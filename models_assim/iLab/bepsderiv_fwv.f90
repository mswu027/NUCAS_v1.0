!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (develop) -  6 Oct 2021 16:40
!
!  Differentiation of cos_plant in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: cos_assim g_b g_sw
!   with respect to varying inputs: g_b cosa g_sw vcmax ffpa f_soilwater
!--iLab::convf no longer required
! subroutine cos_plant(lc,cosa,convf,g_sw,g_b,vcmax,ffpa,f_soilwater,cos_assim)
SUBROUTINE COS_PLANT_FWV(lc, cosa, cosa_fw, g_sw, g_sw_fw, g_b, g_b_fw, &
& vcmax, vcmax_fw, ffpa, ffpa_fw, f_soilwater, f_soilwater_fw, cos_assim&
& , cos_assim_fw, nbdirs)
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
!Input Variables
! real(r8) :: vcmax, g_sw, g_b,convf,f_soilwater,cos_assim
  REAL(r8) :: vcmax, g_sw, g_b, f_soilwater, cos_assim
  REAL(r8), DIMENSION(nbdirsmax) :: vcmax_fw, g_sw_fw, g_b_fw, &
& f_soilwater_fw, cos_assim_fw
  INTEGER :: lc
!Local Variables
  REAL(r8) :: c4flag, ffpa
  REAL(r8), DIMENSION(nbdirsmax) :: ffpa_fw
! CAS COS concentration (pmol COS/mol air)
  REAL(r8) :: cosa
  REAL(r8), DIMENSION(nbdirsmax) :: cosa_fw
  REAL(r8) :: gcosm
  REAL(r8), DIMENSION(nbdirsmax) :: gcosm_fw
  REAL(r8) :: gtcos
  REAL(r8), DIMENSION(nbdirsmax) :: gtcos_fw
  INTRINSIC MAX
  INTEGER :: nd
  REAL(r8) :: temp
  INTEGER :: nbdirs
  c4flag = 0.
  IF (lc .EQ. 40 .OR. lc .EQ. 41) c4flag = 1.0
  IF (1.e-6 .LT. g_sw) THEN
    g_sw = g_sw
  ELSE
    g_sw = 1.e-6
    g_sw_fw(:) = 0.0_8
  END IF
  IF (1.e-6 .LT. g_b) THEN
    g_b = g_b
  ELSE
    g_b = 1.e-6
    g_b_fw(:) = 0.0_8
  END IF
! mol/m2/s
  temp = 1.0e-6*(5.33*c4flag+1.0)*1.40e3
  DO nd=1,nbdirs
    gcosm_fw(nd) = temp*(f_soilwater*(ffpa*vcmax_fw(nd)+vcmax*ffpa_fw(nd&
&     ))+vcmax*ffpa*f_soilwater_fw(nd))
  END DO
  gcosm = temp*(vcmax*ffpa*f_soilwater)
  IF (gcosm .LT. 1.e-6) THEN
    gcosm = 1.e-6
    gcosm_fw(:) = 0.0_8
  ELSE
    gcosm = gcosm
  END IF
!gtcos = 1.0/(1.94/(g_sw*convf) + 1.0/(g_b*convf) + 1.0/(gcosm*convf))  ! m/s
! mol/m2/s
  temp = 1.0/(1.94/g_sw+1.0/g_b+1.0/gcosm)
  gtcos = temp
  DO nd=1,nbdirs
    gtcos_fw(nd) = -(temp*(-(1.94*g_sw_fw(nd)/g_sw**2)-g_b_fw(nd)/g_b**2&
&     -gcosm_fw(nd)/gcosm**2)/(1.94/g_sw+1.0/g_b+1.0/gcosm))
! pmol/m2/s
    cos_assim_fw(nd) = cosa*gtcos_fw(nd) + gtcos*cosa_fw(nd)
  END DO
  cos_assim = gtcos*cosa
END SUBROUTINE COS_PLANT_FWV

MODULE MO_HELPER_DIFFV
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
! PARAMETERS FOR AUXILLIARY FUNCTIONS
  REAL, PARAMETER :: zmin=1.e-18

CONTAINS
!  REAL, PARAMETER :: eta = 0.99999            ! curvature parameter for mins/maxs
!*********************************************************
!* FUNCTION errf
!* the (cumulative) error function
!* numerical recipes in Fortran 77, Chapter 6.2
!*********************************************************
  REAL FUNCTION ERRF(x)
    IMPLICIT NONE
    REAL :: x, z, t
    INTRINSIC ABS
    INTRINSIC EXP
    REAL :: arg1
    IF (x .GE. 0.) THEN
      z = x
    ELSE
      z = -x
    END IF
    t = 1./(1.+0.5*z)
    arg1 = -(z*z) - 1.26551223 + t*(1.00002368+t*(.37409196+t*(.09678418&
&     +t*(-.18628806+t*(.27886807+t*(-1.13520398+t*(1.48851587+t*(-&
&     .82215223+t*.17087277))))))))
    errf = 1. - 0.5*t*EXP(arg1)
    IF (x .LT. 0) errf = 1. - errf
  END FUNCTION ERRF

!*********************************************************
!*  FUNCTION mins
!*  smoothed minimum function
!*********************************************************
!  REAL FUNCTION mins (x, y)
!    REAL :: x, y
!    REAL :: z
!    z = (x+y)**2 - 4.*eta*x*y
!    IF (z.GE.zmin) THEN
!       mins = (x + y - SQRT(z)) / (2.*eta)
!    ELSE
!       mins = 0.
!    ENDIF
!  END FUNCTION mins
  REAL FUNCTION MINS(x, y, eta)
    IMPLICIT NONE
    REAL :: x, y, eta
    REAL :: z
    INTRINSIC MAX
    INTRINSIC SQRT
    REAL :: result1
    z = (x+y)**2 - 4.*eta*x*y
    IF (z .LT. zmin) THEN
      z = zmin
    ELSE
      z = z
    END IF
    result1 = SQRT(z)
    mins = (x+y-result1)/(2.*eta)
  END FUNCTION MINS

!*********************************************************
!*  FUNCTION maxs
!*  smoothed maximum function
!*********************************************************
!  REAL FUNCTION maxs (x, y)
!    REAL :: x, y
!    REAL :: z
!    z = (x+y)**2 - 4.*eta*x*y
!    IF (z.GE.zmin) THEN
!       maxs = (x + y + SQRT(z)) / (2.*eta)
!    ELSE
!       maxs = 0.
!    ENDIF
!  END FUNCTION maxs
  REAL FUNCTION MAXS(x, y, eta)
    IMPLICIT NONE
    REAL :: x, y, eta
    REAL :: z
    INTRINSIC MAX
    INTRINSIC SQRT
    REAL :: result1
    z = (x+y)**2 - 4.*eta*x*y
    IF (z .LT. zmin) THEN
      z = zmin
    ELSE
      z = z
    END IF
    result1 = SQRT(z)
    maxs = (x+y+result1)/(2.*eta)
  END FUNCTION MAXS

!*********************************************************
!*  FUNCTION minx
!*  minimum function with exponential transition
!*********************************************************
  REAL FUNCTION MINX(x, y, x0)
    IMPLICIT NONE
    REAL :: x, y, x0
    INTRINSIC EXP
    REAL :: arg1
    IF (x .LE. y + x0) THEN
      arg1 = (x-y)/x0 - 1.
      minx = x - x0*EXP(arg1)
    ELSE
      minx = y
    END IF
  END FUNCTION MINX

!  Differentiation of fominef_ss in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: fominef_ss
!   with respect to varying inputs: p1
  SUBROUTINE FOMINEF_SS_FWV(p1, p1_fw, p2, tune, fominef_ss, &
&   fominef_ss_fw, nbdirs)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
    REAL :: p1, p2
    REAL, DIMENSION(nbdirsmax) :: p1_fw
! tune/2 >= min(p1,p2) - fominef
    REAL :: tune
    INTRINSIC MIN
    INTRINSIC ABS
    INTRINSIC EXP
    REAL :: min1
    REAL, DIMENSION(nbdirsmax) :: min1_fw
    REAL :: abs0
    REAL, DIMENSION(nbdirsmax) :: abs0_fw
    REAL :: arg1
    REAL, DIMENSION(nbdirsmax) :: arg1_fw
    INTEGER :: nd
    REAL :: fominef_ss_fw(nbdirsmax)
    REAL :: fominef_ss
    INTEGER :: nbdirs
    IF (p1 .GT. p2) THEN
      min1 = p2
      min1_fw(:) = 0.0_8
    ELSE
      DO nd=1,nbdirs
        min1_fw(nd) = p1_fw(nd)
      END DO
      min1 = p1
    END IF
    IF (p1 - p2 .GE. 0.) THEN
      DO nd=1,nbdirs
        abs0_fw(nd) = p1_fw(nd)
      END DO
      abs0 = p1 - p2
    ELSE
      DO nd=1,nbdirs
        abs0_fw(nd) = -p1_fw(nd)
      END DO
      abs0 = -(p1-p2)
    END IF
    arg1 = -(abs0/tune)
    DO nd=1,nbdirs
      arg1_fw(nd) = -(abs0_fw(nd)/tune)
      fominef_ss_fw(nd) = min1_fw(nd) - tune*0.5*EXP(arg1)*arg1_fw(nd)
    END DO
    fominef_ss = min1 - 0.5*tune*EXP(arg1)
  END SUBROUTINE FOMINEF_SS_FWV

  REAL FUNCTION FOMINEF_SS(p1, p2, tune)
    IMPLICIT NONE
    REAL :: p1, p2
! tune/2 >= min(p1,p2) - fominef
    REAL :: tune
    INTRINSIC MIN
    INTRINSIC ABS
    INTRINSIC EXP
    REAL :: min1
    REAL :: abs0
    REAL :: arg1
    IF (p1 .GT. p2) THEN
      min1 = p2
    ELSE
      min1 = p1
    END IF
    IF (p1 - p2 .GE. 0.) THEN
      abs0 = p1 - p2
    ELSE
      abs0 = -(p1-p2)
    END IF
    arg1 = -(abs0/tune)
    fominef_ss = min1 - 0.5*tune*EXP(arg1)
  END FUNCTION FOMINEF_SS

  REAL FUNCTION FOMAXEF_SS(p1, p2, tune)
    IMPLICIT NONE
    REAL :: p1, p2
! tune/2 >= fomaxef - max(p1,p2)
    REAL :: tune
    INTRINSIC MAX
    INTRINSIC ABS
    INTRINSIC EXP
    REAL :: max1
    REAL :: abs0
    REAL :: arg1
    IF (p1 .LT. p2) THEN
      max1 = p2
    ELSE
      max1 = p1
    END IF
    IF (p1 - p2 .GE. 0.) THEN
      abs0 = p1 - p2
    ELSE
      abs0 = -(p1-p2)
    END IF
    arg1 = -(abs0/tune)
    fomaxef_ss = max1 + 0.5*tune*EXP(arg1)
  END FUNCTION FOMAXEF_SS

!  Differentiation of maxx in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: maxx
!   with respect to varying inputs: x
!*********************************************************
!*  FUNCTION maxx
!*  maximum function with exponential transition
!*********************************************************
  SUBROUTINE MAXX_FWV(x, x_fw, y, x0, maxx, maxx_fw, nbdirs)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
! snb: to fix bug in lf95-optimisation (variable in function erroneously inherits intent(out) attribute from calling scope)
    REAL, INTENT(IN) :: x, y, x0
    REAL, DIMENSION(nbdirsmax), INTENT(IN) :: x_fw
    INTRINSIC EXP
    REAL :: arg1
    REAL, DIMENSION(nbdirsmax) :: arg1_fw
    INTEGER :: nd
    REAL :: maxx
    REAL :: maxx_fw(nbdirsmax)
    INTEGER :: nbdirs
    IF (x .GE. y - x0) THEN
      arg1 = -((x-y)/x0) - 1.
      DO nd=1,nbdirs
        arg1_fw(nd) = -(x_fw(nd)/x0)
        maxx_fw(nd) = x_fw(nd) + x0*EXP(arg1)*arg1_fw(nd)
      END DO
      maxx = x + x0*EXP(arg1)
    ELSE
      maxx = y
      maxx_fw(:) = 0.0_8
    END IF
  END SUBROUTINE MAXX_FWV

!*********************************************************
!*  FUNCTION maxx
!*  maximum function with exponential transition
!*********************************************************
  REAL FUNCTION MAXX(x, y, x0)
    IMPLICIT NONE
! snb: to fix bug in lf95-optimisation (variable in function erroneously inherits intent(out) attribute from calling scope)
    REAL, INTENT(IN) :: x, y, x0
    INTRINSIC EXP
    REAL :: arg1
    IF (x .GE. y - x0) THEN
      arg1 = -((x-y)/x0) - 1.
      maxx = x + x0*EXP(arg1)
    ELSE
      maxx = y
    END IF
  END FUNCTION MAXX

!*********************************************************
!*  FUNCTION mmin
!*  maximum function with exponential transition
!*********************************************************
! maximum error is x0/e for x==y-x0
  REAL FUNCTION MMIN(x, y, x0)
    IMPLICIT NONE
! snb: to fix bug in lf95-optimisation (variable in function erroneously inherits intent(out) attribute from calling scope)
    REAL, INTENT(IN) :: x, y, x0
    INTRINSIC EXP
    REAL :: arg1
    IF (x .LT. y) THEN
      arg1 = (x-y)/x0
      mmin = x + (y-x)*EXP(arg1)
    ELSE
! exact for (x.le.y):
      mmin = y
    END IF
  END FUNCTION MMIN

!*********************************************************
!*  FUNCTION mmax
!*  maximum function with exponential transition
!*********************************************************
! maximum error is -x0/e for x==y+x0
  REAL FUNCTION MMAX(x, y, x0)
    IMPLICIT NONE
! snb: to fix bug in lf95-optimisation (variable in function erroneously inherits intent(out) attribute from calling scope)
    REAL, INTENT(IN) :: x, y, x0
    INTRINSIC EXP
    REAL :: arg1
    IF (x .GT. y) THEN
      arg1 = (y-x)/x0
      mmax = x + (y-x)*EXP(arg1)
    ELSE
! exact for (x.le.y):
      mmax = y
    END IF
  END FUNCTION MMAX

END MODULE MO_HELPER_DIFFV

MODULE BEPSTYPE_DIFFV
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
! For restart
!-- iLab::module field should have save attribute
  REAL(r8), ALLOCATABLE, PUBLIC, SAVE :: v2last(:, :, :)
  REAL(r8), ALLOCATABLE, PUBLIC, SAVE :: v2last_fw(:, :, :, :)
!downward solar raditation
!relative humidity(%)
! liquid precipitation
! Snow rate
! SW direct radiation
! SW diffuse radiation
!--iLab::to consistenly handle tempooral settings
!--      expected format yyyy-mm-dd
!*********************Climate Forcing datasets**********************
  TYPE, PUBLIC :: FORC
      REAL(r8), POINTER :: temp(:)
      REAL(r8), POINTER :: tempmx(:)
      REAL(r8), POINTER :: tempmn(:)
      REAL(r8), POINTER :: wind(:)
      REAL(r8), POINTER :: srad(:)
      REAL(r8), POINTER :: rh(:)
      REAL(r8), POINTER :: rain(:)
      REAL(r8), POINTER :: snow(:)
      REAL(r8), POINTER :: swdr(:)
      REAL(r8), POINTER :: swdf(:)
      CHARACTER(len=16) :: meteo_ref_yyyymmdd
  END TYPE FORC
  TYPE(FORC), SAVE, TARGET, PUBLIC :: clim
! PFT types
! soil texture
! PFT fraction
! snowdepth
!
! soil moisture
! for plant resp
! for soil resp
!!! soil carbon pools  units(g C/m2)
!     real(r8),pointer:: p_Vcmax(:)
!     real(r8),pointer:: p_q10(:)
!     real(r8),pointer:: p_drainage(:)
!     real(r8),pointer:: p_beta(:)
!     real(r8),pointer:: p_Ksat(:)
!     real(r8),pointer:: p_b(:)
!     real(r8),pointer:: u_Vcmax(:)
!     real(r8),pointer:: u_q10(:)
!     real(r8),pointer:: u_drainage(:)
!     real(r8),pointer:: u_beta(:)
!     real(r8),pointer:: u_Ksat(:)
!     real(r8),pointer:: u_b(:)
! for photosynthesis
! for data assimilation
!     character,pointer:: name(:)
!***********************for CPL datasets****************************
!******************for boundary/yrdata/lai/cpools/
  TYPE, PUBLIC :: SURF
      INTEGER, POINTER :: lcno(:, :)
      INTEGER, POINTER :: stext(:)
      REAL(r8), POINTER :: pct_pft(:, :)
      REAL(r8), POINTER :: clumping(:)
      REAL(r8), POINTER :: longitude(:)
      REAL(r8), POINTER :: latitude(:)
      REAL(r8), POINTER :: sdp(:)
      REAL(r8), POINTER :: st(:)
      REAL(r8), POINTER :: sw(:)
      REAL(r8), POINTER :: laiyr(:, :)
      REAL(r8), POINTER :: nppyr(:, :)
      REAL(r8), POINTER :: ccd(:, :)
      REAL(r8), POINTER :: cfmd(:, :)
      REAL(r8), POINTER :: cfsd(:, :)
      REAL(r8), POINTER :: cm(:, :)
      REAL(r8), POINTER :: cp(:, :)
      REAL(r8), POINTER :: cs(:, :)
      REAL(r8), POINTER :: csm(:, :)
      REAL(r8), POINTER :: csmd(:, :)
      REAL(r8), POINTER :: cssd(:, :)
      REAL(r8), POINTER :: lai(:, :)
      REAL(r8), POINTER :: vcmax(:, :)
  END TYPE SURF
! boundary conditions
  TYPE(SURF), SAVE, TARGET, PUBLIC :: bound
!    real(r8),pointer:: p_f_lr
!     real(r8),pointer:: u_f_lr
!******************for assimilation and parameter optimization/
  TYPE, PUBLIC :: PARA
      REAL(r8), POINTER :: p_vcmax(:)
      REAL(r8), POINTER :: p_vj_slope(:)
      REAL(r8), POINTER :: p_q10(:)
      REAL(r8), POINTER :: p_sif_alpha(:)
      REAL(r8), POINTER :: p_sif_beta(:)
      REAL(r8), POINTER :: p_taweff(:)
      REAL(r8), POINTER :: p_d0(:)
      REAL(r8), POINTER :: p_ksat_scalar(:)
      REAL(r8), POINTER :: p_b_scalar(:)
      REAL(r8), POINTER :: p_f_leaf
      REAL(r8), POINTER :: p_kc25
      REAL(r8), POINTER :: p_ko25
      REAL(r8), POINTER :: p_tau25
      REAL(r8), POINTER :: p_agb2vod
      REAL(r8), POINTER :: u_vcmax(:)
      REAL(r8), POINTER :: u_vj_slope(:)
      REAL(r8), POINTER :: u_q10(:)
      REAL(r8), POINTER :: u_sif_alpha(:)
      REAL(r8), POINTER :: u_sif_beta(:)
      REAL(r8), POINTER :: u_taweff(:)
      REAL(r8), POINTER :: u_d0(:)
      REAL(r8), POINTER :: u_ksat_scalar(:)
      REAL(r8), POINTER :: u_b_scalar(:)
      REAL(r8), POINTER :: u_f_leaf
      REAL(r8), POINTER :: u_kc25
      REAL(r8), POINTER :: u_ko25
      REAL(r8), POINTER :: u_tau25
      REAL(r8), POINTER :: u_agb2vod
  END TYPE PARA
  TYPE, PUBLIC :: PARA_DIFFV
      REAL(r8), DIMENSION(:, :), POINTER :: p_vcmax
      REAL(r8), DIMENSION(:, :), POINTER :: p_vj_slope
      REAL(r8), DIMENSION(:, :), POINTER :: p_sif_alpha
      REAL(r8), DIMENSION(:, :), POINTER :: p_sif_beta
      REAL(r8), DIMENSION(:, :), POINTER :: p_ksat_scalar
      REAL(r8), DIMENSION(:, :), POINTER :: p_b_scalar
      REAL(r8), DIMENSION(:), POINTER :: p_f_leaf
  END TYPE PARA_DIFFV
! optimization of parameters
  TYPE(PARA), SAVE, TARGET, PUBLIC :: assim
  TYPE(PARA_DIFFV), SAVE, TARGET, PUBLIC :: assim_fw
!!(npoints,0:Max_LayerS-1)
!*******************************************************************
!------------------Soil Status----------
!*******************************************************************
  TYPE, PUBLIC :: SOILS
      INTEGER, POINTER :: n_layer(:)
      REAL(r8), POINTER :: zp(:, :)
      REAL(r8), POINTER :: zsp(:, :)
      REAL(r8), POINTER :: r_rain_g(:, :)
      REAL(r8), POINTER :: r_drainage(:, :)
      REAL(r8), POINTER :: r_root_decay(:, :)
      REAL(r8), POINTER :: psi_min(:, :)
      REAL(r8), POINTER :: alpha(:, :)
      REAL(r8), POINTER :: f_soilwater(:, :)
      REAL(r8), POINTER :: d_soil(:, :)
      REAL(r8), POINTER :: f_root(:, :, :)
      REAL(r8), POINTER :: dt(:, :, :)
      REAL(r8), POINTER :: thermal_cond(:, :, :)
      REAL(r8), POINTER :: theta_vfc(:, :, :)
      REAL(r8), POINTER :: theta_vwp(:, :, :)
      REAL(r8), POINTER :: fei(:, :, :)
      REAL(r8), POINTER :: ksat(:, :, :)
      REAL(r8), POINTER :: psi_sat(:, :, :)
      REAL(r8), POINTER :: b(:, :, :)
      REAL(r8), POINTER :: density_soil(:, :)
      REAL(r8), POINTER :: f_org(:, :, :)
      REAL(r8), POINTER :: ice_ratio(:, :, :)
      REAL(r8), POINTER :: thetam(:, :, :)
      REAL(r8), POINTER :: thetam_prev(:, :, :)
      REAL(r8), POINTER :: temp_soil_p(:, :, :)
      REAL(r8), POINTER :: temp_soil_c(:, :, :)
      REAL(r8), POINTER :: f_ice(:, :, :)
      REAL(r8), POINTER :: psim(:, :, :)
      REAL(r8), POINTER :: thetab(:, :, :)
      REAL(r8), POINTER :: psib(:, :, :)
      REAL(r8), POINTER :: r_waterflow(:, :, :)
      REAL(r8), POINTER :: km(:, :, :)
      REAL(r8), POINTER :: kb(:, :, :)
      REAL(r8), POINTER :: kk(:, :, :)
      REAL(r8), POINTER :: cs(:, :, :)
      REAL(r8), POINTER :: lambda(:, :, :)
      REAL(r8), POINTER :: ett(:, :, :)
      REAL(r8), POINTER :: g(:, :, :)
  END TYPE SOILS
  TYPE, PUBLIC :: SOILS_DIFFV
      INTEGER, DIMENSION(:, :), POINTER :: n_layer
      REAL(r8), DIMENSION(:, :, :), POINTER :: zp
      REAL(r8), DIMENSION(:, :, :), POINTER :: zsp
      REAL(r8), DIMENSION(:, :, :), POINTER :: r_rain_g
      REAL(r8), DIMENSION(:, :, :), POINTER :: r_drainage
      REAL(r8), DIMENSION(:, :, :), POINTER :: r_root_decay
      REAL(r8), DIMENSION(:, :, :), POINTER :: psi_min
      REAL(r8), DIMENSION(:, :, :), POINTER :: alpha
      REAL(r8), DIMENSION(:, :, :), POINTER :: f_soilwater
      REAL(r8), DIMENSION(:, :, :), POINTER :: d_soil
      REAL(r8), DIMENSION(:, :, :, :), POINTER :: f_root
      REAL(r8), DIMENSION(:, :, :, :), POINTER :: dt
      REAL(r8), DIMENSION(:, :, :, :), POINTER :: thermal_cond
      REAL(r8), DIMENSION(:, :, :, :), POINTER :: theta_vfc
      REAL(r8), DIMENSION(:, :, :, :), POINTER :: theta_vwp
      REAL(r8), DIMENSION(:, :, :, :), POINTER :: fei
      REAL(r8), DIMENSION(:, :, :, :), POINTER :: ksat
      REAL(r8), DIMENSION(:, :, :, :), POINTER :: psi_sat
      REAL(r8), DIMENSION(:, :, :, :), POINTER :: b
      REAL(r8), DIMENSION(:, :, :), POINTER :: density_soil
      REAL(r8), DIMENSION(:, :, :, :), POINTER :: f_org
      REAL(r8), DIMENSION(:, :, :, :), POINTER :: ice_ratio
      REAL(r8), DIMENSION(:, :, :, :), POINTER :: thetam
      REAL(r8), DIMENSION(:, :, :, :), POINTER :: thetam_prev
      REAL(r8), DIMENSION(:, :, :, :), POINTER :: temp_soil_p
      REAL(r8), DIMENSION(:, :, :, :), POINTER :: temp_soil_c
      REAL(r8), DIMENSION(:, :, :, :), POINTER :: f_ice
      REAL(r8), DIMENSION(:, :, :, :), POINTER :: psim
      REAL(r8), DIMENSION(:, :, :, :), POINTER :: thetab
      REAL(r8), DIMENSION(:, :, :, :), POINTER :: psib
      REAL(r8), DIMENSION(:, :, :, :), POINTER :: r_waterflow
      REAL(r8), DIMENSION(:, :, :, :), POINTER :: km
      REAL(r8), DIMENSION(:, :, :, :), POINTER :: kb
      REAL(r8), DIMENSION(:, :, :, :), POINTER :: kk
      REAL(r8), DIMENSION(:, :, :, :), POINTER :: cs
      REAL(r8), DIMENSION(:, :, :, :), POINTER :: lambda
      REAL(r8), DIMENSION(:, :, :, :), POINTER :: ett
      REAL(r8), DIMENSION(:, :, :, :), POINTER :: g
  END TYPE SOILS_DIFFV
  TYPE(SOILS), TARGET, SAVE, PUBLIC :: soilstat
  TYPE(SOILS_DIFFV), TARGET, SAVE, PUBLIC :: soilstat_fw
!accord with the satellite data
!*********************************************************
!-----------Interest Variables For output-----------------
!*********************************************************
  TYPE, PUBLIC :: RES
      REAL(r8), POINTER :: gpppft(:, :)
      REAL(r8), POINTER :: sifpft(:, :)
      REAL(r8), POINTER :: sifpft_sat(:, :)
      REAL(r8), POINTER :: npppft(:, :)
      REAL(r8), POINTER :: neppft(:, :)
      REAL(r8), POINTER :: shpft(:, :)
      REAL(r8), POINTER :: lhpft(:, :)
      REAL(r8), POINTER :: transpft(:, :)
      REAL(r8), POINTER :: evappft(:, :)
      REAL(r8), POINTER :: net_radpft(:, :)
      REAL(r8), POINTER :: gpp(:)
      REAL(r8), POINTER :: sif(:)
      REAL(r8), POINTER :: sif_sat(:)
      REAL(r8), POINTER :: npp(:)
      REAL(r8), POINTER :: nep(:)
      REAL(r8), POINTER :: laipft(:, :)
      REAL(r8), POINTER :: lai(:)
      REAL(r8), POINTER :: sh(:)
      REAL(r8), POINTER :: lh(:)
      REAL(r8), POINTER :: trans(:)
      REAL(r8), POINTER :: evap(:)
      REAL(r8), POINTER :: net_rad(:)
      REAL(r8), POINTER :: thetampft(:, :)
      REAL(r8), POINTER :: thetam(:)
      REAL(r8), POINTER :: faparpft(:, :)
      REAL(r8), POINTER :: fapar(:)
      REAL(r8), POINTER :: vodpft(:, :)
      REAL(r8), POINTER :: vod(:)
      REAL(r8), POINTER :: cos_fluxpft(:, :)
      REAL(r8), POINTER :: cos_flux(:)
      REAL(r8), POINTER :: npp_yr_acc(:, :)
  END TYPE RES
  TYPE, PUBLIC :: RES_DIFFV
      REAL(r8), DIMENSION(:, :, :), POINTER :: gpppft
      REAL(r8), DIMENSION(:, :, :), POINTER :: sifpft
      REAL(r8), DIMENSION(:, :, :), POINTER :: sifpft_sat
      REAL(r8), DIMENSION(:, :, :), POINTER :: npppft
      REAL(r8), DIMENSION(:, :, :), POINTER :: neppft
      REAL(r8), DIMENSION(:, :, :), POINTER :: shpft
      REAL(r8), DIMENSION(:, :, :), POINTER :: lhpft
      REAL(r8), DIMENSION(:, :, :), POINTER :: transpft
      REAL(r8), DIMENSION(:, :, :), POINTER :: evappft
      REAL(r8), DIMENSION(:, :, :), POINTER :: net_radpft
      REAL(r8), DIMENSION(:, :), POINTER :: sif
      REAL(r8), DIMENSION(:, :, :), POINTER :: laipft
      REAL(r8), DIMENSION(:, :, :), POINTER :: thetampft
      REAL(r8), DIMENSION(:, :), POINTER :: thetam
      REAL(r8), DIMENSION(:, :, :), POINTER :: faparpft
      REAL(r8), DIMENSION(:, :, :), POINTER :: vodpft
      REAL(r8), DIMENSION(:, :, :), POINTER :: cos_fluxpft
      REAL(r8), DIMENSION(:, :), POINTER :: cos_flux
  END TYPE RES_DIFFV
  TYPE(RES), SAVE, TARGET, PUBLIC :: output
  TYPE(RES_DIFFV), SAVE, TARGET, PUBLIC :: output_fw
END MODULE BEPSTYPE_DIFFV

! This module is used to initialize bepstype variables
! Editted by J.Wang
! Date: 10May2017
MODULE BEPSTYPEINIT_DIFFV
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
!--iLab::added further entities (as module bepstype does no longer use beps_par)
  USE BEPS_PAR, ONLY : npoints, pft, max_layers, texture
  USE BEPSTYPE_DIFFV
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
!--iLab::can avoid 'save' here since no variables are declared,
!        use-associated entities should already have the attribute
! save
  PUBLIC :: initbepstype
  PUBLIC :: initbepstype_fwv
  PRIVATE :: initatm2lnd
  PRIVATE :: initsurf
  PRIVATE :: initouput
  PRIVATE :: initouput_fwv
  PRIVATE :: initassim
  PRIVATE :: initassim_fwv

CONTAINS
!  Differentiation of initbepstype in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   Plus diff mem management of: output.gpppft:out output.sifpft:out
!                output.sifpft_sat:out output.npppft:out output.neppft:out
!                output.shpft:out output.lhpft:out output.transpft:out
!                output.evappft:out output.net_radpft:out output.sif:out
!                output.laipft:out output.thetampft:out output.thetam:out
!                output.faparpft:out output.vodpft:out output.cos_fluxpft:out
!                output.cos_flux:out assim.p_vcmax:out assim.p_vj_slope:out
!                assim.p_sif_alpha:out assim.p_sif_beta:out assim.p_ksat_scalar:out
!                assim.p_b_scalar:out assim.p_f_leaf:out soilstat.zp:out
!                soilstat.zsp:out soilstat.r_rain_g:out soilstat.r_drainage:out
!                soilstat.r_root_decay:out soilstat.psi_min:out
!                soilstat.alpha:out soilstat.f_soilwater:out soilstat.d_soil:out
!                soilstat.f_root:out soilstat.dt:out soilstat.thermal_cond:out
!                soilstat.theta_vfc:out soilstat.theta_vwp:out
!                soilstat.fei:out soilstat.ksat:out soilstat.psi_sat:out
!                soilstat.b:out soilstat.density_soil:out soilstat.f_org:out
!                soilstat.ice_ratio:out soilstat.thetam:out soilstat.thetam_prev:out
!                soilstat.temp_soil_p:out soilstat.temp_soil_c:out
!                soilstat.f_ice:out soilstat.psim:out soilstat.thetab:out
!                soilstat.psib:out soilstat.r_waterflow:out soilstat.km:out
!                soilstat.kb:out soilstat.kk:out soilstat.cs:out
!                soilstat.lambda:out soilstat.ett:out soilstat.g:out
!                v2last:out
  SUBROUTINE INITBEPSTYPE_FWV(nbdirs)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
    INTEGER :: nbdirs
    ALLOCATE(v2last_fw(nbdirsmax, npoints, 0:40, pft))
    ALLOCATE(v2last(npoints, 0:40, pft))
    v2last = 0.
    CALL INITATM2LND()
    CALL INITSURF()
    CALL INITSOILSTAT_FWV(nbdirs)
    CALL INITOUPUT_FWV(nbdirs)
    CALL INITASSIM_FWV(nbdirs)
    RETURN
  END SUBROUTINE INITBEPSTYPE_FWV

  SUBROUTINE INITBEPSTYPE()
    IMPLICIT NONE
    ALLOCATE(v2last(npoints, 0:40, pft))
    v2last = 0.
    CALL INITATM2LND()
    CALL INITSURF()
    CALL INITSOILSTAT()
    CALL INITOUPUT()
    CALL INITASSIM()
    RETURN
  END SUBROUTINE INITBEPSTYPE

  SUBROUTINE INITATM2LND()
    IMPLICIT NONE
!--iLab::avoid pointer
! type(forc),pointer ::p
! p=>clim
    ALLOCATE(clim%temp(npoints))
    ALLOCATE(clim%tempmx(npoints))
    ALLOCATE(clim%tempmn(npoints))
    ALLOCATE(clim%wind(npoints))
    ALLOCATE(clim%srad(npoints))
    ALLOCATE(clim%rh(npoints))
    ALLOCATE(clim%rain(npoints))
    ALLOCATE(clim%snow(npoints))
    ALLOCATE(clim%swdr(npoints))
    ALLOCATE(clim%swdf(npoints))
    clim%temp(:) = 0.
    clim%tempmx(:) = 0.
    clim%tempmn(:) = 0.
    clim%wind(:) = 0.
    clim%srad(:) = 0.
    clim%rh(:) = 0.
    clim%rain(:) = 0.
    clim%snow(:) = 0.
    clim%swdr(:) = 0.
    clim%swdf(:) = 0.
    RETURN
  END SUBROUTINE INITATM2LND

  SUBROUTINE INITSURF()
    IMPLICIT NONE
!bound%p_Vcmax   = 0.
!bound%p_q10     = 0.
!bound%p_drainage   = 0.
!bound%p_beta   = 0.
!bound%p_Ksat   = 0.
!bound%p_b   = 0.
!bound%u_Vcmax   = 0.
!bound%u_q10   = 0.
!bound%u_drainage   = 0.
!bound%u_beta   = 0.
!bound%u_Ksat   = 0.
!bound%u_b   = 0.
!--iLab::avoid pointer
! type(surf),pointer::p
! p=>bound
    ALLOCATE(bound%lcno(npoints, pft))
    ALLOCATE(bound%stext(npoints))
    ALLOCATE(bound%pct_pft(npoints, pft))
    ALLOCATE(bound%clumping(npoints))
    ALLOCATE(bound%longitude(npoints))
    ALLOCATE(bound%latitude(npoints))
    ALLOCATE(bound%sdp(npoints))
    ALLOCATE(bound%st(npoints))
    ALLOCATE(bound%sw(npoints))
    ALLOCATE(bound%laiyr(npoints, pft))
    ALLOCATE(bound%nppyr(npoints, pft))
    ALLOCATE(bound%ccd(npoints, pft))
    ALLOCATE(bound%cfmd(npoints, pft))
    ALLOCATE(bound%cfsd(npoints, pft))
    ALLOCATE(bound%cm(npoints, pft))
    ALLOCATE(bound%cp(npoints, pft))
    ALLOCATE(bound%cs(npoints, pft))
    ALLOCATE(bound%csm(npoints, pft))
    ALLOCATE(bound%csmd(npoints, pft))
    ALLOCATE(bound%cssd(npoints, pft))
    ALLOCATE(bound%lai(npoints, pft))
    ALLOCATE(bound%vcmax(npoints, pft))
!allocate(bound%p_Vcmax(PFT))
!allocate(bound%p_q10(PFT))
!allocate(bound%p_drainage(PFT))
!allocate(bound%p_beta(PFT))
!allocate(bound%p_Ksat(texture))
!allocate(bound%p_b(texture))
!allocate(bound%u_Vcmax(PFT))
!allocate(bound%u_q10(PFT))
!allocate(bound%u_drainage(PFT))
!allocate(bound%u_beta(PFT))
!allocate(bound%u_Ksat(texture))
!allocate(bound%u_b(texture))
    bound%lcno = 0
    bound%stext = 0
    bound%pct_pft = 0
    bound%clumping = 0.
    bound%longitude = 0.
    bound%latitude = 0.
    bound%sdp = 0.
    bound%st = 0.
    bound%sw = 0.
    bound%laiyr = 0.
    bound%nppyr = 0.
    bound%ccd = 0.
    bound%cfmd = 0.
    bound%cfsd = 0.
    bound%cm = 0.
    bound%cp = 0.
    bound%cs = 0.
    bound%csm = 0.
    bound%csmd = 0.
    bound%cssd = 0.
    bound%lai = 0.
    bound%vcmax = 0.
  END SUBROUTINE INITSURF

!  Differentiation of initassim in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   Plus diff mem management of: assim.p_vcmax:out assim.p_vj_slope:out
!                assim.p_sif_alpha:out assim.p_sif_beta:out assim.p_ksat_scalar:out
!                assim.p_b_scalar:out assim.p_f_leaf:out
  SUBROUTINE INITASSIM_FWV(nbdirs)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
    INTEGER :: nbdirs
!--iLab::avoid pointer
! type(para),pointer  ::p
! p => assim
    ALLOCATE(assim_fw%p_vcmax(nbdirsmax, pft))
    ALLOCATE(assim%p_vcmax(pft))
    ALLOCATE(assim%p_q10(pft))
    ALLOCATE(assim_fw%p_vj_slope(nbdirsmax, pft))
    ALLOCATE(assim%p_vj_slope(pft))
    ALLOCATE(assim_fw%p_sif_alpha(nbdirsmax, pft))
    ALLOCATE(assim%p_sif_alpha(pft))
    ALLOCATE(assim_fw%p_sif_beta(nbdirsmax, pft))
    ALLOCATE(assim%p_sif_beta(pft))
    ALLOCATE(assim%p_taweff(pft))
    ALLOCATE(assim%p_d0(pft))
    ALLOCATE(assim_fw%p_ksat_scalar(nbdirsmax, texture))
    ALLOCATE(assim%p_ksat_scalar(texture))
    ALLOCATE(assim_fw%p_b_scalar(nbdirsmax, texture))
    ALLOCATE(assim%p_b_scalar(texture))
    ALLOCATE(assim_fw%p_f_leaf(nbdirsmax))
    ALLOCATE(assim%p_f_leaf)
    ALLOCATE(assim%p_kc25)
    ALLOCATE(assim%p_ko25)
    ALLOCATE(assim%p_tau25)
!allocate(assim%p_f_lr)
    ALLOCATE(assim%p_agb2vod)
    ALLOCATE(assim%u_vcmax(pft))
    ALLOCATE(assim%u_q10(pft))
    ALLOCATE(assim%u_vj_slope(pft))
    ALLOCATE(assim%u_sif_alpha(pft))
    ALLOCATE(assim%u_sif_beta(pft))
    ALLOCATE(assim%u_taweff(pft))
    ALLOCATE(assim%u_d0(pft))
    ALLOCATE(assim%u_ksat_scalar(texture))
    ALLOCATE(assim%u_b_scalar(texture))
    ALLOCATE(assim%u_f_leaf)
    ALLOCATE(assim%u_kc25)
    ALLOCATE(assim%u_ko25)
    ALLOCATE(assim%u_tau25)
!allocate(assim%u_f_lr)
    ALLOCATE(assim%u_agb2vod)
    assim%p_vcmax = 0.
    assim%p_q10 = 0.
    assim%p_vj_slope = 0.
    assim%p_sif_alpha = 0.
    assim%p_sif_beta = 0.
    assim%p_taweff = 0.
    assim%p_d0 = 0.
    assim%p_ksat_scalar = 0.
    assim%p_b_scalar = 0.
    assim%p_f_leaf = 0.
    assim%p_kc25 = 0.
    assim%p_ko25 = 0.
    assim%p_tau25 = 0.
!assim%p_f_lr   = 0.
    assim%p_agb2vod = 0.
    assim%u_vcmax = 0.
    assim%u_q10 = 0.
    assim%u_vj_slope = 0.
    assim%u_sif_alpha = 0.
    assim%u_sif_beta = 0.
    assim%u_taweff = 0.
    assim%u_d0 = 0.
    assim%u_ksat_scalar = 0.
    assim%u_b_scalar = 0.
    assim%u_f_leaf = 0.
    assim%u_kc25 = 0.
    assim%u_ko25 = 0.
    assim%u_tau25 = 0.
!assim%u_f_lr   = 0.
    assim%u_agb2vod = 0.
  END SUBROUTINE INITASSIM_FWV

  SUBROUTINE INITASSIM()
    IMPLICIT NONE
!--iLab::avoid pointer
! type(para),pointer  ::p
! p => assim
    ALLOCATE(assim%p_vcmax(pft))
    ALLOCATE(assim%p_q10(pft))
    ALLOCATE(assim%p_vj_slope(pft))
    ALLOCATE(assim%p_sif_alpha(pft))
    ALLOCATE(assim%p_sif_beta(pft))
    ALLOCATE(assim%p_taweff(pft))
    ALLOCATE(assim%p_d0(pft))
    ALLOCATE(assim%p_ksat_scalar(texture))
    ALLOCATE(assim%p_b_scalar(texture))
    ALLOCATE(assim%p_f_leaf)
    ALLOCATE(assim%p_kc25)
    ALLOCATE(assim%p_ko25)
    ALLOCATE(assim%p_tau25)
!allocate(assim%p_f_lr)
    ALLOCATE(assim%p_agb2vod)
    ALLOCATE(assim%u_vcmax(pft))
    ALLOCATE(assim%u_q10(pft))
    ALLOCATE(assim%u_vj_slope(pft))
    ALLOCATE(assim%u_sif_alpha(pft))
    ALLOCATE(assim%u_sif_beta(pft))
    ALLOCATE(assim%u_taweff(pft))
    ALLOCATE(assim%u_d0(pft))
    ALLOCATE(assim%u_ksat_scalar(texture))
    ALLOCATE(assim%u_b_scalar(texture))
    ALLOCATE(assim%u_f_leaf)
    ALLOCATE(assim%u_kc25)
    ALLOCATE(assim%u_ko25)
    ALLOCATE(assim%u_tau25)
!allocate(assim%u_f_lr)
    ALLOCATE(assim%u_agb2vod)
    assim%p_vcmax = 0.
    assim%p_q10 = 0.
    assim%p_vj_slope = 0.
    assim%p_sif_alpha = 0.
    assim%p_sif_beta = 0.
    assim%p_taweff = 0.
    assim%p_d0 = 0.
    assim%p_ksat_scalar = 0.
    assim%p_b_scalar = 0.
    assim%p_f_leaf = 0.
    assim%p_kc25 = 0.
    assim%p_ko25 = 0.
    assim%p_tau25 = 0.
!assim%p_f_lr   = 0.
    assim%p_agb2vod = 0.
    assim%u_vcmax = 0.
    assim%u_q10 = 0.
    assim%u_vj_slope = 0.
    assim%u_sif_alpha = 0.
    assim%u_sif_beta = 0.
    assim%u_taweff = 0.
    assim%u_d0 = 0.
    assim%u_ksat_scalar = 0.
    assim%u_b_scalar = 0.
    assim%u_f_leaf = 0.
    assim%u_kc25 = 0.
    assim%u_ko25 = 0.
    assim%u_tau25 = 0.
!assim%u_f_lr   = 0.
    assim%u_agb2vod = 0.
  END SUBROUTINE INITASSIM

!  Differentiation of initsoilstat in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   Plus diff mem management of: soilstat.zp:out soilstat.zsp:out
!                soilstat.r_rain_g:out soilstat.r_drainage:out
!                soilstat.r_root_decay:out soilstat.psi_min:out
!                soilstat.alpha:out soilstat.f_soilwater:out soilstat.d_soil:out
!                soilstat.f_root:out soilstat.dt:out soilstat.thermal_cond:out
!                soilstat.theta_vfc:out soilstat.theta_vwp:out
!                soilstat.fei:out soilstat.ksat:out soilstat.psi_sat:out
!                soilstat.b:out soilstat.density_soil:out soilstat.f_org:out
!                soilstat.ice_ratio:out soilstat.thetam:out soilstat.thetam_prev:out
!                soilstat.temp_soil_p:out soilstat.temp_soil_c:out
!                soilstat.f_ice:out soilstat.psim:out soilstat.thetab:out
!                soilstat.psib:out soilstat.r_waterflow:out soilstat.km:out
!                soilstat.kb:out soilstat.kk:out soilstat.cs:out
!                soilstat.lambda:out soilstat.ett:out soilstat.g:out
  SUBROUTINE INITSOILSTAT_FWV(nbdirs)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
    INTEGER :: nbdirs
!--iLab::avoid pointer
! type(soils),pointer  :: p
! p => soilstat
    ALLOCATE(soilstat_fw%n_layer(nbdirsmax, npoints))
    ALLOCATE(soilstat%n_layer(npoints))
    ALLOCATE(soilstat_fw%zp(nbdirsmax, npoints, pft))
    ALLOCATE(soilstat%zp(npoints, pft))
    ALLOCATE(soilstat_fw%zsp(nbdirsmax, npoints, pft))
    ALLOCATE(soilstat%zsp(npoints, pft))
    ALLOCATE(soilstat_fw%r_rain_g(nbdirsmax, npoints, pft))
    ALLOCATE(soilstat%r_rain_g(npoints, pft))
    ALLOCATE(soilstat_fw%r_drainage(nbdirsmax, npoints, pft))
    ALLOCATE(soilstat%r_drainage(npoints, pft))
    ALLOCATE(soilstat_fw%r_root_decay(nbdirsmax, npoints, pft))
    ALLOCATE(soilstat%r_root_decay(npoints, pft))
    ALLOCATE(soilstat_fw%psi_min(nbdirsmax, npoints, pft))
    ALLOCATE(soilstat%psi_min(npoints, pft))
    ALLOCATE(soilstat_fw%alpha(nbdirsmax, npoints, pft))
    ALLOCATE(soilstat%alpha(npoints, pft))
    ALLOCATE(soilstat_fw%f_soilwater(nbdirsmax, npoints, pft))
    ALLOCATE(soilstat%f_soilwater(npoints, pft))
    ALLOCATE(soilstat_fw%d_soil(nbdirsmax, npoints, 0:max_layers-1))
    ALLOCATE(soilstat%d_soil(npoints, 0:max_layers-1))
    ALLOCATE(soilstat_fw%f_root(nbdirsmax, npoints, 0:max_layers-1, pft)&
&   )
    ALLOCATE(soilstat%f_root(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_fw%dt(nbdirsmax, npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%dt(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_fw%thermal_cond(nbdirsmax, npoints, 0:max_layers-1&
&   , pft))
    ALLOCATE(soilstat%thermal_cond(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_fw%theta_vfc(nbdirsmax, npoints, 0:max_layers-1, &
&   pft))
    ALLOCATE(soilstat%theta_vfc(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_fw%theta_vwp(nbdirsmax, npoints, 0:max_layers-1, &
&   pft))
    ALLOCATE(soilstat%theta_vwp(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_fw%fei(nbdirsmax, npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%fei(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_fw%ksat(nbdirsmax, npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%ksat(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_fw%psi_sat(nbdirsmax, npoints, 0:max_layers-1, pft&
&   ))
    ALLOCATE(soilstat%psi_sat(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_fw%b(nbdirsmax, npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%b(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_fw%density_soil(nbdirsmax, npoints, 0:max_layers-1&
&   ))
    ALLOCATE(soilstat%density_soil(npoints, 0:max_layers-1))
    ALLOCATE(soilstat_fw%f_org(nbdirsmax, npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%f_org(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_fw%ice_ratio(nbdirsmax, npoints, 0:max_layers-1, &
&   pft))
    ALLOCATE(soilstat%ice_ratio(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_fw%thetam(nbdirsmax, npoints, 0:max_layers-1, pft)&
&   )
    ALLOCATE(soilstat%thetam(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_fw%thetam_prev(nbdirsmax, npoints, 0:max_layers-1&
&   , pft))
    ALLOCATE(soilstat%thetam_prev(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_fw%temp_soil_p(nbdirsmax, npoints, 0:max_layers-1&
&   , pft))
    ALLOCATE(soilstat%temp_soil_p(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_fw%temp_soil_c(nbdirsmax, npoints, 0:max_layers-1&
&   , pft))
    ALLOCATE(soilstat%temp_soil_c(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_fw%f_ice(nbdirsmax, npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%f_ice(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_fw%psim(nbdirsmax, npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%psim(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_fw%thetab(nbdirsmax, npoints, 0:max_layers-1, pft)&
&   )
    ALLOCATE(soilstat%thetab(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_fw%psib(nbdirsmax, npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%psib(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_fw%r_waterflow(nbdirsmax, npoints, 0:max_layers-1&
&   , pft))
    ALLOCATE(soilstat%r_waterflow(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_fw%km(nbdirsmax, npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%km(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_fw%kb(nbdirsmax, npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%kb(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_fw%kk(nbdirsmax, npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%kk(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_fw%cs(nbdirsmax, npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%cs(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_fw%lambda(nbdirsmax, npoints, 0:max_layers-1, pft)&
&   )
    ALLOCATE(soilstat%lambda(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_fw%ett(nbdirsmax, npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%ett(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_fw%g(nbdirsmax, npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%g(npoints, 0:max_layers-1, pft))
    soilstat%n_layer(:) = 0
    soilstat%zp(:, :) = 0.
    soilstat%zsp(:, :) = 0.
    soilstat%r_rain_g(:, :) = 0.
    soilstat%r_drainage(:, :) = 0.
    soilstat%r_root_decay(:, :) = 0.
    soilstat%psi_min(:, :) = 0.
    soilstat%alpha(:, :) = 0.
    soilstat%f_soilwater(:, :) = 0.
    soilstat%d_soil(:, :) = 0.
    soilstat%f_root(:, :, :) = 0.
    soilstat%dt(:, :, :) = 0.
    soilstat%thermal_cond(:, :, :) = 0.
    soilstat%theta_vfc(:, :, :) = 0.
    soilstat%theta_vwp(:, :, :) = 0.
    soilstat%fei(:, :, :) = 0.
    soilstat%ksat(:, :, :) = 0.
    soilstat%psi_sat(:, :, :) = 0.
    soilstat%b(:, :, :) = 0.
    soilstat%density_soil(:, :) = 0.
    soilstat%f_org(:, :, :) = 0.
    soilstat%ice_ratio(:, :, :) = 0.
    soilstat%thetam(:, :, :) = 0.
    soilstat%thetam_prev(:, :, :) = 0.
    soilstat%temp_soil_p(:, :, :) = 0.
    soilstat%temp_soil_c(:, :, :) = 0.
    soilstat%f_ice(:, :, :) = 0.
    soilstat%psim(:, :, :) = 0.
    soilstat%thetab(:, :, :) = 0.
    soilstat%psib(:, :, :) = 0.
    soilstat%r_waterflow(:, :, :) = 0.
    soilstat%km(:, :, :) = 0.
    soilstat%kb(:, :, :) = 0.
    soilstat%kk(:, :, :) = 0.
    soilstat%cs(:, :, :) = 0.
    soilstat%lambda(:, :, :) = 0.
    soilstat%ett(:, :, :) = 0.
    soilstat%g(:, :, :) = 0.
  END SUBROUTINE INITSOILSTAT_FWV

  SUBROUTINE INITSOILSTAT()
    IMPLICIT NONE
!--iLab::avoid pointer
! type(soils),pointer  :: p
! p => soilstat
    ALLOCATE(soilstat%n_layer(npoints))
    ALLOCATE(soilstat%zp(npoints, pft))
    ALLOCATE(soilstat%zsp(npoints, pft))
    ALLOCATE(soilstat%r_rain_g(npoints, pft))
    ALLOCATE(soilstat%r_drainage(npoints, pft))
    ALLOCATE(soilstat%r_root_decay(npoints, pft))
    ALLOCATE(soilstat%psi_min(npoints, pft))
    ALLOCATE(soilstat%alpha(npoints, pft))
    ALLOCATE(soilstat%f_soilwater(npoints, pft))
    ALLOCATE(soilstat%d_soil(npoints, 0:max_layers-1))
    ALLOCATE(soilstat%f_root(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%dt(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%thermal_cond(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%theta_vfc(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%theta_vwp(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%fei(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%ksat(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%psi_sat(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%b(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%density_soil(npoints, 0:max_layers-1))
    ALLOCATE(soilstat%f_org(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%ice_ratio(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%thetam(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%thetam_prev(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%temp_soil_p(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%temp_soil_c(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%f_ice(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%psim(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%thetab(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%psib(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%r_waterflow(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%km(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%kb(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%kk(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%cs(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%lambda(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%ett(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%g(npoints, 0:max_layers-1, pft))
    soilstat%n_layer(:) = 0
    soilstat%zp(:, :) = 0.
    soilstat%zsp(:, :) = 0.
    soilstat%r_rain_g(:, :) = 0.
    soilstat%r_drainage(:, :) = 0.
    soilstat%r_root_decay(:, :) = 0.
    soilstat%psi_min(:, :) = 0.
    soilstat%alpha(:, :) = 0.
    soilstat%f_soilwater(:, :) = 0.
    soilstat%d_soil(:, :) = 0.
    soilstat%f_root(:, :, :) = 0.
    soilstat%dt(:, :, :) = 0.
    soilstat%thermal_cond(:, :, :) = 0.
    soilstat%theta_vfc(:, :, :) = 0.
    soilstat%theta_vwp(:, :, :) = 0.
    soilstat%fei(:, :, :) = 0.
    soilstat%ksat(:, :, :) = 0.
    soilstat%psi_sat(:, :, :) = 0.
    soilstat%b(:, :, :) = 0.
    soilstat%density_soil(:, :) = 0.
    soilstat%f_org(:, :, :) = 0.
    soilstat%ice_ratio(:, :, :) = 0.
    soilstat%thetam(:, :, :) = 0.
    soilstat%thetam_prev(:, :, :) = 0.
    soilstat%temp_soil_p(:, :, :) = 0.
    soilstat%temp_soil_c(:, :, :) = 0.
    soilstat%f_ice(:, :, :) = 0.
    soilstat%psim(:, :, :) = 0.
    soilstat%thetab(:, :, :) = 0.
    soilstat%psib(:, :, :) = 0.
    soilstat%r_waterflow(:, :, :) = 0.
    soilstat%km(:, :, :) = 0.
    soilstat%kb(:, :, :) = 0.
    soilstat%kk(:, :, :) = 0.
    soilstat%cs(:, :, :) = 0.
    soilstat%lambda(:, :, :) = 0.
    soilstat%ett(:, :, :) = 0.
    soilstat%g(:, :, :) = 0.
  END SUBROUTINE INITSOILSTAT

!  Differentiation of initouput in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   Plus diff mem management of: output.gpppft:out output.sifpft:out
!                output.sifpft_sat:out output.npppft:out output.neppft:out
!                output.shpft:out output.lhpft:out output.transpft:out
!                output.evappft:out output.net_radpft:out output.sif:out
!                output.laipft:out output.thetampft:out output.thetam:out
!                output.faparpft:out output.vodpft:out output.cos_fluxpft:out
!                output.cos_flux:out
  SUBROUTINE INITOUPUT_FWV(nbdirs)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
    INTEGER :: nbdirs
!--iLab::avoid pointer
! type(res),pointer::p
! p=>output
    ALLOCATE(output_fw%gpppft(nbdirsmax, npoints, pft))
    ALLOCATE(output%gpppft(npoints, pft))
    ALLOCATE(output_fw%sifpft(nbdirsmax, npoints, pft))
    ALLOCATE(output%sifpft(npoints, pft))
    ALLOCATE(output_fw%sifpft_sat(nbdirsmax, npoints, pft))
    ALLOCATE(output%sifpft_sat(npoints, pft))
    ALLOCATE(output_fw%npppft(nbdirsmax, npoints, pft))
    ALLOCATE(output%npppft(npoints, pft))
    ALLOCATE(output_fw%neppft(nbdirsmax, npoints, pft))
    ALLOCATE(output%neppft(npoints, pft))
    ALLOCATE(output_fw%shpft(nbdirsmax, npoints, pft))
    ALLOCATE(output%shpft(npoints, pft))
    ALLOCATE(output_fw%lhpft(nbdirsmax, npoints, pft))
    ALLOCATE(output%lhpft(npoints, pft))
    ALLOCATE(output_fw%transpft(nbdirsmax, npoints, pft))
    ALLOCATE(output%transpft(npoints, pft))
    ALLOCATE(output_fw%evappft(nbdirsmax, npoints, pft))
    ALLOCATE(output%evappft(npoints, pft))
    ALLOCATE(output_fw%net_radpft(nbdirsmax, npoints, pft))
    ALLOCATE(output%net_radpft(npoints, pft))
    ALLOCATE(output%gpp(npoints))
    ALLOCATE(output_fw%sif(nbdirsmax, npoints))
    ALLOCATE(output%sif(npoints))
    ALLOCATE(output%sif_sat(npoints))
    ALLOCATE(output%npp(npoints))
    ALLOCATE(output%nep(npoints))
    ALLOCATE(output_fw%laipft(nbdirsmax, npoints, pft))
    ALLOCATE(output%laipft(npoints, pft))
    ALLOCATE(output%lai(npoints))
    ALLOCATE(output%sh(npoints))
    ALLOCATE(output%lh(npoints))
    ALLOCATE(output%trans(npoints))
    ALLOCATE(output%evap(npoints))
    ALLOCATE(output%net_rad(npoints))
    ALLOCATE(output_fw%thetampft(nbdirsmax, npoints, pft))
    ALLOCATE(output%thetampft(npoints, pft))
    ALLOCATE(output_fw%thetam(nbdirsmax, npoints))
    ALLOCATE(output%thetam(npoints))
    ALLOCATE(output_fw%faparpft(nbdirsmax, npoints, pft))
    ALLOCATE(output%faparpft(npoints, pft))
    ALLOCATE(output%fapar(npoints))
    ALLOCATE(output_fw%vodpft(nbdirsmax, npoints, pft))
    ALLOCATE(output%vodpft(npoints, pft))
    ALLOCATE(output%vod(npoints))
    ALLOCATE(output_fw%cos_fluxpft(nbdirsmax, npoints, pft))
    ALLOCATE(output%cos_fluxpft(npoints, pft))
    ALLOCATE(output_fw%cos_flux(nbdirsmax, npoints))
    ALLOCATE(output%cos_flux(npoints))
    ALLOCATE(output%npp_yr_acc(npoints, pft))
    output%gpppft(:, :) = 0.
    output%sifpft(:, :) = 0.
    output%sifpft_sat(:, :) = 0.
    output%npppft(:, :) = 0.
    output%neppft(:, :) = 0.
    output%shpft(:, :) = 0.
    output%lhpft(:, :) = 0.
    output%transpft(:, :) = 0.
    output%evappft(:, :) = 0.
    output%net_radpft(:, :) = 0.
    output%laipft(:, :) = 0.
    output%thetampft(:, :) = 0.
    output%faparpft(:, :) = 0.
    output%vodpft(:, :) = 0.
    output%cos_fluxpft(:, :) = 0.
    output%npp_yr_acc(:, :) = 0.
    output%gpp(:) = 0.
    output%sif(:) = 0.
    output%sif_sat(:) = 0.
    output%npp(:) = 0.
    output%nep(:) = 0.
    output%lai(:) = 0.
    output%sh(:) = 0.
    output%lh(:) = 0.
    output%trans(:) = 0.
    output%evap(:) = 0.
    output%net_rad(:) = 0.
    output%thetam(:) = 0.
    output%fapar(:) = 0.
    output%cos_flux(:) = 0.
    output%vod(:) = 0.
  END SUBROUTINE INITOUPUT_FWV

  SUBROUTINE INITOUPUT()
    IMPLICIT NONE
!--iLab::avoid pointer
! type(res),pointer::p
! p=>output
    ALLOCATE(output%gpppft(npoints, pft))
    ALLOCATE(output%sifpft(npoints, pft))
    ALLOCATE(output%sifpft_sat(npoints, pft))
    ALLOCATE(output%npppft(npoints, pft))
    ALLOCATE(output%neppft(npoints, pft))
    ALLOCATE(output%shpft(npoints, pft))
    ALLOCATE(output%lhpft(npoints, pft))
    ALLOCATE(output%transpft(npoints, pft))
    ALLOCATE(output%evappft(npoints, pft))
    ALLOCATE(output%net_radpft(npoints, pft))
    ALLOCATE(output%gpp(npoints))
    ALLOCATE(output%sif(npoints))
    ALLOCATE(output%sif_sat(npoints))
    ALLOCATE(output%npp(npoints))
    ALLOCATE(output%nep(npoints))
    ALLOCATE(output%laipft(npoints, pft))
    ALLOCATE(output%lai(npoints))
    ALLOCATE(output%sh(npoints))
    ALLOCATE(output%lh(npoints))
    ALLOCATE(output%trans(npoints))
    ALLOCATE(output%evap(npoints))
    ALLOCATE(output%net_rad(npoints))
    ALLOCATE(output%thetampft(npoints, pft))
    ALLOCATE(output%thetam(npoints))
    ALLOCATE(output%faparpft(npoints, pft))
    ALLOCATE(output%fapar(npoints))
    ALLOCATE(output%vodpft(npoints, pft))
    ALLOCATE(output%vod(npoints))
    ALLOCATE(output%cos_fluxpft(npoints, pft))
    ALLOCATE(output%cos_flux(npoints))
    ALLOCATE(output%npp_yr_acc(npoints, pft))
    output%gpppft(:, :) = 0.
    output%sifpft(:, :) = 0.
    output%sifpft_sat(:, :) = 0.
    output%npppft(:, :) = 0.
    output%neppft(:, :) = 0.
    output%shpft(:, :) = 0.
    output%lhpft(:, :) = 0.
    output%transpft(:, :) = 0.
    output%evappft(:, :) = 0.
    output%net_radpft(:, :) = 0.
    output%laipft(:, :) = 0.
    output%thetampft(:, :) = 0.
    output%faparpft(:, :) = 0.
    output%vodpft(:, :) = 0.
    output%cos_fluxpft(:, :) = 0.
    output%npp_yr_acc(:, :) = 0.
    output%gpp(:) = 0.
    output%sif(:) = 0.
    output%sif_sat(:) = 0.
    output%npp(:) = 0.
    output%nep(:) = 0.
    output%lai(:) = 0.
    output%sh(:) = 0.
    output%lh(:) = 0.
    output%trans(:) = 0.
    output%evap(:) = 0.
    output%net_rad(:) = 0.
    output%thetam(:) = 0.
    output%fapar(:) = 0.
    output%cos_flux(:) = 0.
    output%vod(:) = 0.
  END SUBROUTINE INITOUPUT

END MODULE BEPSTYPEINIT_DIFFV

!***************************************************************
!! This module will read control parameters,meteo input,boundary conditions,
!! yrdata,cpools etc. for beps
!! Editted by J. Wang
!! 22May 2017
!***************************************************************
MODULE CONTROLINPUT_MOD_DIFFV
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE BEPS_PAR
  USE BEPSTYPE_DIFFV
!--iLab::restricted use(s)
!-- update:with required arguments in routines below, can avoid completely
! use beps_time_manager,only: get_curr_date, get_curr_calday
! use beps_time_manager,only: set_timemgr_init,timemgr_init,get_curr_date,&
!      get_prev_date,get_curr_calday,timemgr_datediff
  USE NETCDF
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
!include 'mpif.h'
!--iLab::no need for include file, since we call 'use netcdf' above
! include 'netcdf.inc'
  SAVE 
  INTEGER :: nlat, nlon
  CHARACTER(len=80) :: calendar
  INTEGER :: sim_type
  INTEGER :: icdate
  INTEGER :: icsec
  INTEGER :: sim_duration
!!nstpd determines when to output
  INTEGER :: nhtfrq, nstpd
  INTEGER :: restart_frq
  INTEGER :: meteo_input
  INTEGER :: nscale, n_site
  INTEGER :: lai_input
  CHARACTER(len=255) :: meteo_path, meteo_flnm_prefix, &
& meteo_site_flnm_prefix
  CHARACTER(len=255) :: surface_data_path
  CHARACTER(len=255) :: beps_yrdata_path
  CHARACTER(len=255) :: beps_site_path, site_bound_prefix, &
& prior_para_prefix
  CHARACTER(len=255) :: beps_lai_path, beps_lai_prefix, &
& beps_lai_site_prefix
  CHARACTER(len=255) :: beps_vcmax_path, beps_vcmax_site_path
  CHARACTER(len=255) :: beps_domain
  CHARACTER(len=255) :: beps_cpools
  CHARACTER(len=255) :: beps_out_dir
  CHARACTER(len=255) :: beps_rst_dir
  PUBLIC :: rdnamelist
  PRIVATE :: read_beps_domain

CONTAINS
  SUBROUTINE RDNAMELIST()
    IMPLICIT NONE
    INTEGER :: ierr
    NAMELIST /nls/ nlat, nlon, nscale, calendar, icdate, icsec, sim_type&
&       , sim_duration, nhtfrq, restart_frq, meteo_input, meteo_path, &
&       meteo_flnm_prefix, meteo_site_flnm_prefix, surface_data_path, &
&       beps_yrdata_path, n_site, beps_site_path, site_bound_prefix, &
&       lai_input, beps_lai_path, beps_lai_prefix, beps_lai_site_prefix&
&       , beps_vcmax_path, beps_vcmax_site_path, beps_domain, &
&       prior_para_prefix, beps_cpools, beps_out_dir, beps_rst_dir
!if(myid ==0) then
    OPEN(5, file='beps.stdin', form='formatted') 
    REWIND(5) 
    READ(5, nml=nls, iostat=ierr) 
    IF (ierr .GT. 0) THEN
      WRITE(6, *) 'RDNAMELIST: Namelist read returns ', ierr
      CALL ENDRUN('Read Namelist Wrong!')
    END IF
    IF (nscale .EQ. 0) CALL READ_BEPS_DOMAIN(beps_domain)
!end if
!call mpi_barrier(mpi_comm_world,ierr)
!call mpi_bcast(nlat,1,mpi_integer,0,mpi_comm_world,ierr)
!call mpi_bcast(nlon,1,mpi_integer,0,mpi_comm_world,ierr)
!call mpi_bcast(nscale,1,mpi_integer,0,mpi_comm_world,ierr)
!call mpi_bcast(calendar,len(calendar),mpi_character,0,mpi_comm_world,ierr)
!call mpi_bcast(icdate,1,mpi_integer,0,mpi_comm_world,ierr)
!call mpi_bcast(icsec,1,mpi_integer,0,mpi_comm_world,ierr)
!call mpi_bcast(sim_type,1,mpi_integer,0,mpi_comm_world,ierr)
!call mpi_bcast(sim_duration,1,mpi_integer,0,mpi_comm_world,ierr)
!call mpi_bcast(nhtfrq,1,mpi_integer,0,mpi_comm_world,ierr)
!call mpi_bcast(restart_frq,1,mpi_integer,0,mpi_comm_world,ierr)
!call mpi_bcast(meteo_input,1,mpi_integer,0,mpi_comm_world,ierr)
!call mpi_bcast(meteo_path,len(meteo_path),mpi_character,0,mpi_comm_world,ierr)
!call mpi_bcast(meteo_flnm_prefix,len(meteo_flnm_prefix),mpi_character,0,mpi_comm_world,ierr)
!call mpi_bcast(meteo_site_flnm_prefix,len(meteo_site_flnm_prefix),mpi_character,0,mpi_comm_world,ierr)
!call mpi_bcast(surface_data_path,len(surface_data_path),mpi_character,0,mpi_comm_world,ierr)
!call mpi_bcast(beps_yrdata_path,len(beps_yrdata_path),mpi_character,0,mpi_comm_world,ierr)
!call mpi_bcast(n_site,1,mpi_integer,0,mpi_comm_world,ierr)
!call mpi_bcast(beps_site_path,len(beps_site_path),mpi_character,0,mpi_comm_world,ierr)
!call mpi_bcast(site_bound_prefix,len(site_bound_prefix),mpi_character,0,mpi_comm_world,ierr)
!call mpi_bcast(lai_input,1,mpi_integer,0,mpi_comm_world,ierr)
!call mpi_bcast(beps_lai_path,len(beps_lai_path),mpi_character,0,mpi_comm_world,ierr)
!call mpi_bcast(beps_lai_prefix,len(beps_lai_prefix),mpi_character,0,mpi_comm_world,ierr)
!call mpi_bcast(beps_lai_site_prefix,len(beps_lai_site_prefix),mpi_character,0,mpi_comm_world,ierr)
!call mpi_bcast(beps_Vcmax_path,len(beps_Vcmax_path),mpi_character,0,mpi_comm_world,ierr)
!call mpi_bcast(beps_Vcmax_site_path,len(beps_Vcmax_site_path),mpi_character,0,mpi_comm_world,ierr)
!call mpi_bcast(beps_domain,len(beps_domain),mpi_character,0,mpi_comm_world,ierr)
!call mpi_bcast(beps_cpools,len(beps_cpools),mpi_character,0,mpi_comm_world,ierr)
!call mpi_bcast(beps_out_dir,len(beps_out_dir),mpi_character,0,mpi_comm_world,ierr)
!call mpi_bcast(beps_rst_dir,len(beps_rst_dir),mpi_character,0,mpi_comm_world,ierr)
!call mpi_barrier(mpi_comm_world,ierr)
!!  store run type
    nsrest = sim_type
!! setting nstpd
    IF (nhtfrq .LT. 0) THEN
! means hours
      nstpd = -(nhtfrq*3600/step)
    END IF
  END SUBROUTINE RDNAMELIST

  SUBROUTINE READ_BEPS_DOMAIN(filname)
    IMPLICIT NONE
!deallocate(stype)
!deallocate(mapping)
    CHARACTER(len=*), INTENT(IN) :: filname
    INTEGER :: ncid, varid(2)
    INTEGER :: domain(nlon, nlat)
    INTEGER :: i, j
    INTRINSIC TRIM
    INTRINSIC RESHAPE
    INTEGER :: result1
    result1 = NF90_OPEN(TRIM(filname), nf90_nowrite, ncid)
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'domain', varid(1))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'nlp', varid(2))
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(1), domain)
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(2), nlp)
    CALL CHECK(result1)
    result1 = NF90_CLOSE(ncid)
    CALL CHECK(result1)
    ALLOCATE(stype(nlon*nlat))
    ALLOCATE(mapping(nlp))
    stype = RESHAPE(domain, (/nlon*nlat/))
    j = 1
    DO i=1,nlon*nlat
      IF (stype(i) .EQ. 1) THEN
        mapping(j) = i
        j = j + 1
      END IF
    END DO
  END SUBROUTINE READ_BEPS_DOMAIN

!***************Reading boundary data*************************
  SUBROUTINE READ_BOUNDARY()
    IMPLICIT NONE
    INTEGER :: i, ncid, varid(9), ierr
    INTEGER :: lcno(nlon, nlat, pft), stext(nlon, nlat)
    REAL(r8) :: pct_pft(nlon, nlat, pft), ci(nlon, nlat), longitude(nlon&
&   , nlat), latitude(nlon, nlat), sdp(nlon, nlat), st(nlon, nlat), sw(&
&   nlon, nlat)
    INTEGER :: lcno2(nlon*nlat, pft), stext2(nlon*nlat)
    REAL(r8) :: pct_pft2(nlon*nlat, pft), ci2(nlon*nlat), longitude2(&
&   nlon*nlat), latitude2(nlon*nlat), sdp2(nlon*nlat), st2(nlon*nlat), &
&   sw2(nlon*nlat)
    INTEGER :: lcno3(nlp, pft), stext3(nlp)
    REAL(r8) :: pct_pft3(nlp, pft), ci3(nlp), longitude3(nlp), latitude3&
&   (nlp), sdp3(nlp), st3(nlp), sw3(nlp)
    TYPE(SURF), POINTER :: p
    INTRINSIC TRIM
    INTRINSIC RESHAPE
    INTEGER :: result1
    p => bound
!if(myid == 0) then
    result1 = NF90_OPEN(TRIM(surface_data_path), nf90_nowrite, ncid)
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'PFT', varid(1))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'PCT_PFT', varid(2))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'ci', varid(3))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'stext', varid(4))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'longitude', varid(5))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'latitude', varid(6))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'sdp', varid(7))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'st', varid(8))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'sw', varid(9))
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(1), lcno)
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(2), pct_pft)
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(3), ci)
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(4), stext)
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(5), longitude)
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(6), latitude)
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(7), sdp)
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(8), st)
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(9), sw)
    CALL CHECK(result1)
    result1 = NF90_CLOSE(ncid)
    CALL CHECK(result1)
    lcno2 = RESHAPE(lcno, (/nlon*nlat, pft/))
    pct_pft2 = RESHAPE(pct_pft, (/nlon*nlat, pft/))
    ci2 = RESHAPE(ci, (/nlon*nlat/))
    stext2 = RESHAPE(stext, (/nlon*nlat/))
    longitude2 = RESHAPE(longitude, (/nlon*nlat/))
    latitude2 = RESHAPE(latitude, (/nlon*nlat/))
    sdp2 = RESHAPE(sdp, (/nlon*nlat/))
    st2 = RESHAPE(st, (/nlon*nlat/))
    sw2 = RESHAPE(sw, (/nlon*nlat/))
    lcno3 = lcno2(mapping, :)
    pct_pft3 = pct_pft2(mapping, :)
    ci3 = ci2(mapping)
    stext3 = stext2(mapping)
    longitude3 = longitude2(mapping)
    latitude3 = latitude2(mapping)
    sdp3 = sdp2(mapping)
    st3 = st2(mapping)
    sw3 = sw2(mapping)
!end if
!call mpi_barrier(mpi_comm_world,ierr)
!call mpi_scatterv(ci3(1),dp,sp,MPI_real8,p%clumping(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(stext3(1),dp,sp,mpi_integer,p%stext(1),npoints,mpi_integer,0,mpi_comm_world,ierr)
!call mpi_scatterv(longitude3(1),dp,sp,mpi_real8,p%longitude(1),npoints,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(latitude3(1),dp,sp,mpi_real8,p%latitude(1),npoints,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(sdp3(1),dp,sp,mpi_real8,p%sdp(1),npoints,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(st3(1),dp,sp,mpi_real8,p%st(1),npoints,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(sw3(1),dp,sp,mpi_real8,p%sw(1),npoints,mpi_real8,0,mpi_comm_world,ierr)
!do i=1,PFT
!   call mpi_scatterv(lcno3(1,i),dp,sp,mpi_integer,p%lcno(1,i),npoints,mpi_integer,0,mpi_comm_world,ierr)
!   call mpi_scatterv(PCT_PFT3(1,i),dp,sp,mpi_real8,p%PCT_PFT(1,i),npoints,mpi_real8,0,mpi_comm_world,ierr)
!end do
!call mpi_barrier(mpi_comm_world,ierr)
    p%clumping = ci3
    p%stext = stext3
    p%longitude = longitude3
    p%latitude = latitude3
    p%sdp = sdp3
    p%st = st3
    p%sw = sw3
    p%lcno = lcno3
    p%pct_pft = pct_pft3
  END SUBROUTINE READ_BOUNDARY

  SUBROUTINE READ_YRDATA()
    IMPLICIT NONE
    INTEGER :: i, ncid, varid(2), ierr
    REAL(r8) :: laiyr1(nlon, nlat, pft), nppyr1(nlon, nlat, pft)
    REAL(r8) :: laiyr2(nlon*nlat, pft), nppyr2(nlon*nlat, pft)
    REAL(r8) :: laiyr3(nlp, pft), nppyr3(nlp, pft)
    TYPE(SURF), POINTER :: p
    INTRINSIC TRIM
    INTRINSIC RESHAPE
    INTEGER :: result1
    p => bound
!if(myid ==0) then
    result1 = NF90_OPEN(TRIM(beps_yrdata_path), nf90_nowrite, ncid)
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'lai', varid(1))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'npp', varid(2))
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(1), laiyr1)
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(2), nppyr1)
    CALL CHECK(result1)
    result1 = NF90_CLOSE(ncid)
    CALL CHECK(result1)
    laiyr2 = RESHAPE(laiyr1, (/nlon*nlat, pft/))
    nppyr2 = RESHAPE(nppyr1, (/nlon*nlat, pft/))
    laiyr3 = laiyr2(mapping, :)
    nppyr3 = nppyr2(mapping, :)
!end if
!call mpi_barrier(mpi_comm_world,ierr)
!do i = 1,PFT
!   call mpi_scatterv(laiyr3(1,i),dp,sp,mpi_real8,p%laiyr(1,i),npoints,mpi_real8,0,mpi_comm_world,ierr)
!   call mpi_scatterv(nppyr3(1,i),dp,sp,mpi_real8,p%nppyr(1,i),npoints,mpi_real8,0,mpi_comm_world,ierr)
!end do
!call mpi_barrier(mpi_comm_world,ierr)
    p%laiyr = laiyr3
    p%nppyr = nppyr3
  END SUBROUTINE READ_YRDATA

  SUBROUTINE READ_BOUNDARY_SITE()
    IMPLICIT NONE
    INTEGER :: i, ncid, varid(20), ierr
    INTEGER :: lcno(nlp, pft), stext(nlp)
    REAL(r8) :: laiyr(nlp, pft), nppyr(nlp, pft)
    REAL(r8) :: pct_pft(nlp, pft)
    REAL(r8) :: longitude(nlp), latitude(nlp), sdp(nlp), st(nlp), sw(nlp&
&   ), ci(nlp)
    REAL(r8) :: ccd(nlp, pft), cfmd(nlp, pft), cfsd(nlp, pft), cm(nlp, &
&   pft), cp(nlp, pft), cs(nlp, pft), csm(nlp, pft), csmd(nlp, pft), &
&   cssd(nlp, pft)
!--iLab::avoid pointer
! type(surf),pointer :: p
! p => bound
    CHARACTER(len=255) :: fname
    CHARACTER(len=*), PARAMETER :: method='read_boundary_site'
    INTRINSIC TRIM
    INTRINSIC LEN
    INTEGER :: result1
    IF (LEN(TRIM(beps_site_path)) + LEN(TRIM(site_bound_prefix)) + LEN(&
&       '.nc') .GT. LEN(fname)) THEN
      WRITE(*, '(a)') 'FATAL::INTERNAL-ERROR::'//method//&
&     ':file name too long!'
      STOP
    ELSE
      fname = TRIM(beps_site_path)//TRIM(site_bound_prefix)//'.nc'
      PRINT*, 'START read_boundary_site with *****'//TRIM(fname)//&
&     '*****'
!if(myid == 0) then
      result1 = NF90_OPEN(fname, nf90_nowrite, ncid)
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'laiyr', varid(1))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'nppyr', varid(2))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'lcno', varid(3))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'PCT_PFT', varid(4))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'ci', varid(5))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'stext', varid(6))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'longitude', varid(7))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'latitude', varid(8))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'sdp', varid(9))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'st', varid(10))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'sw', varid(11))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'ccd', varid(12))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'cfmd', varid(13))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'cfsd', varid(14))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'cm', varid(15))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'cp', varid(16))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'cs', varid(17))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'csm', varid(18))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'csmd', varid(19))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'cssd', varid(20))
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(1), laiyr)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(2), nppyr)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(3), lcno)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(4), pct_pft)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(5), ci)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(6), stext)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(7), longitude)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(8), latitude)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(9), sdp)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(10), st)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(11), sw)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(12), ccd)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(13), cfmd)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(14), cfsd)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(15), cm)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(16), cp)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(17), cs)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(18), csm)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(19), csmd)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(20), cssd)
      CALL CHECK(result1)
      result1 = NF90_CLOSE(ncid)
      CALL CHECK(result1)
!end if
!! convert fraction to %
      pct_pft = pct_pft*1.0
!call mpi_barrier(mpi_comm_world,ierr)
!call mpi_scatterv(ci(1),dp,sp,MPI_real8,bound%clumping(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(stext(1),dp,sp,mpi_integer,bound%stext(1),npoints,mpi_integer,0,mpi_comm_world,ierr)
!call mpi_scatterv(longitude(1),dp,sp,mpi_real8,bound%longitude(1),npoints,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(latitude(1),dp,sp,mpi_real8,bound%latitude(1),npoints,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(sdp(1),dp,sp,mpi_real8,bound%sdp(1),npoints,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(st(1),dp,sp,mpi_real8,bound%st(1),npoints,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(sw(1),dp,sp,mpi_real8,bound%sw(1),npoints,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(name(1),dp,sp,mpi_character,bound%name(1),npoints,mpi_character,0,mpi_comm_world,ierr)
!call mpi_barrier(mpi_comm_world,ierr)
!do i = 1,PFT
!    call mpi_scatterv(lcno(1,i),dp,sp,mpi_integer,bound%lcno(1,i),npoints,mpi_integer,0,mpi_comm_world,ierr)
!    call mpi_scatterv(PCT_PFT(1,i),dp,sp,mpi_real8,bound%PCT_PFT(1,i),npoints,mpi_real8,0,mpi_comm_world,ierr)
!    call mpi_scatterv(laiyr(1,i),dp,sp,mpi_real8,bound%laiyr(1,i),npoints,mpi_real8,0,mpi_comm_world,ierr)
!    call mpi_scatterv(nppyr(1,i),dp,sp,mpi_real8,bound%nppyr(1,i),npoints,mpi_real8,0,mpi_comm_world,ierr)
!    call mpi_scatterv(ccd(1,i),dp,sp,MPI_real8,bound%ccd(1,i),npoints,MPI_real8,0,mpi_comm_world,ierr)
!    call mpi_scatterv(cfmd(1,i),dp,sp,MPI_real8,bound%cfmd(1,i),npoints,MPI_real8,0,mpi_comm_world,ierr)
!    call mpi_scatterv(cfsd(1,i),dp,sp,MPI_real8,bound%cfsd(1,i),npoints,MPI_real8,0,mpi_comm_world,ierr)
!    call mpi_scatterv(cm(1,i),dp,sp,MPI_real8,bound%cm(1,i),npoints,MPI_real8,0,mpi_comm_world,ierr)
!    call mpi_scatterv(cp(1,i),dp,sp,MPI_real8,bound%cp(1,i),npoints,MPI_real8,0,mpi_comm_world,ierr)
!    call mpi_scatterv(cs(1,i),dp,sp,MPI_real8,bound%cs(1,i),npoints,MPI_real8,0,mpi_comm_world,ierr)
!    call mpi_scatterv(csm(1,i),dp,sp,MPI_real8,bound%csm(1,i),npoints,MPI_real8,0,mpi_comm_world,ierr)
!    call mpi_scatterv(csmd(1,i),dp,sp,MPI_real8,bound%csmd(1,i),npoints,MPI_real8,0,mpi_comm_world,ierr)
!    call mpi_scatterv(cssd(1,i),dp,sp,MPI_real8,bound%cssd(1,i),npoints,MPI_real8,0,mpi_comm_world,ierr)
!end do
!call mpi_barrier(mpi_comm_world,ierr)
      bound%clumping = ci
      bound%stext = stext
      bound%longitude = longitude
      bound%latitude = latitude
      bound%sdp = sdp
      bound%st = st
      bound%sw = sw
      bound%lcno = lcno
      bound%pct_pft = pct_pft
      bound%laiyr = laiyr
      bound%nppyr = nppyr
      bound%ccd = ccd
      bound%cfmd = cfmd
      bound%cfsd = cfsd
      bound%cm = cm
      bound%cp = cp
      bound%cs = cs
      bound%csm = csm
      bound%csmd = csmd
      bound%cssd = cssd
    END IF
  END SUBROUTINE READ_BOUNDARY_SITE

  SUBROUTINE READ_METEO_DAILY(yr, mon, day, sec)
    IMPLICIT NONE
!--iLab::made yr/mon/day/sec arguments in order to avoid 'get_curr_date'
    INTEGER, INTENT(IN) :: yr, mon, day, sec
!character(len=*) :: file_path,file_flnm_prefix
    INTEGER :: ncid, ierr, varid(6)
    INTEGER :: nt
    INTEGER :: i
!--iLab::avoid pointer (see also below)
! type(forc),pointer :: p
    REAL(r8) :: t1(nlon, nlat), tmax1(nlon, nlat), tmin1(nlon, nlat), &
&   rh1(nlon, nlat), ws1(nlon, nlat), prcp1(nlon, nlat), ssrd1(nlon, &
&   nlat)
    REAL(r8) :: t2(nlon*nlat), tmax2(nlon*nlat), tmin2(nlon*nlat), rh2(&
&   nlon*nlat), ws2(nlon*nlat), prcp2(nlon*nlat), ssrd2(nlon*nlat)
    REAL(r8) :: t3(nlp), tmax3(nlp), tmin3(nlp), rh3(nlp), ws3(nlp), &
&   prcp3(nlp), ssrd3(nlp)
    REAL(r8) :: rainfall(nlp), snow(nlp)
    CHARACTER(len=6) :: monstr
    CHARACTER(len=8) :: datestr
    CHARACTER(len=4) :: yrstr
    REAL(r8), PARAMETER :: density_water=1025.
    REAL(r8) :: density_new_snow
    CHARACTER(len=255) :: fname
    CHARACTER(len=*), PARAMETER :: method='read_meteo_daily'
    INTRINSIC TRIM
    INTRINSIC LEN
    INTRINSIC RESHAPE
    INTRINSIC MAX
    INTRINSIC EXP
    INTEGER :: result1
    REAL(r8) :: arg1
!if(myid ==0) then
!   day  = get_curr_calday()
! call  get_curr_date(yr,mon,day,sec)
!   call get_prev_date(yr,mon,day,sec)   !!??
!  write(6,*) "Reading met data on ",sec,"of", yr*10000+mon*100+day
!  write(datestr,'(i8)')  yr*10000+mon*100+day
    WRITE(monstr, '(i6)') yr*100 + mon
    WRITE(yrstr, '(i4)') yr
!  call check(nf90_open(trim(meteo_path)//trim(yrstr)//'/'//trim(meteo_flnm_prefix)//trim(datestr)//".nc",nf90_nowrite,ncid))
    IF (LEN(TRIM(meteo_path)) + LEN(TRIM(meteo_flnm_prefix)) + LEN(TRIM(&
&       monstr)) + LEN('.nc') .GT. LEN(fname)) THEN
      WRITE(*, '(a)') 'FATAL::INTERNAL-ERROR::'//method//&
&     ':file name too long!'
      STOP
    ELSE
      fname = TRIM(meteo_path)//'/'//TRIM(meteo_flnm_prefix)//TRIM(&
&       monstr)//'.nc'
      result1 = NF90_OPEN(fname, nf90_nowrite, ncid)
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'TMAX', varid(1))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'TMIN', varid(2))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'RH', varid(3))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'WS', varid(4))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'PRCP', varid(5))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'SSRD', varid(6))
      CALL CHECK(result1)
!  nt    = (day-1)*24+sec/int(step)+1     !! data slide for months
!  nt    = sec/int(step)+1
      WRITE(*, *) 'Reading meteo data on ', day, 'of', monstr
      result1 = NF90_GET_VAR(ncid, varid(1), tmax1, start=(/1, 1, day/)&
&       , count=(/nlon, nlat, 1/))
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(2), tmin1, start=(/1, 1, day/)&
&       , count=(/nlon, nlat, 1/))
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(3), rh1, start=(/1, 1, day/), &
&       count=(/nlon, nlat, 1/))
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(4), ws1, start=(/1, 1, day/), &
&       count=(/nlon, nlat, 1/))
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(5), prcp1, start=(/1, 1, day/)&
&       , count=(/nlon, nlat, 1/))
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(6), ssrd1, start=(/1, 1, day/)&
&       , count=(/nlon, nlat, 1/))
      CALL CHECK(result1)
      result1 = NF90_CLOSE(ncid)
      CALL CHECK(result1)
      tmax2 = RESHAPE(tmax1, (/nlon*nlat/))
      tmin2 = RESHAPE(tmin1, (/nlon*nlat/))
      rh2 = RESHAPE(rh1, (/nlon*nlat/))
      ws2 = RESHAPE(ws1, (/nlon*nlat/))
      prcp2 = RESHAPE(prcp1, (/nlon*nlat/))
      ssrd2 = RESHAPE(ssrd1, (/nlon*nlat/))
!! K
      tmax3 = tmax2(mapping)
!! K
      tmin3 = tmin2(mapping)
!!
      rh3 = rh2(mapping)
!! m/s
      ws3 = ws2(mapping)
!! m/s(consult)
      prcp3 = prcp2(mapping)
!! w/m2
      ssrd3 = ssrd2(mapping)
!! translate into centigrade (oC)
      tmax3 = tmax3 - 273.16
!! translate into centigrade (oC)
      tmin3 = tmin3 - 273.16
!! %
      rh3 = rh3*100
      WHERE (0. .LT. prcp3/3600.) 
        prcp3 = prcp3/3600.
      ELSEWHERE
        prcp3 = 0.
      END WHERE
      t3 = (tmax3+tmin3)/2.
!! seperating total precip into liquid and solid according to temperature
      DO i=1,nlp
        IF (t3(i) .GT. 0.) THEN
          rainfall(i) = prcp3(i)
          snow(i) = 0.
        ELSE
          rainfall(i) = 0.
          arg1 = t3(i)/2.6
          density_new_snow = 67.9 + 51.3*EXP(arg1)
          snow(i) = prcp3(i)*density_water/density_new_snow
        END IF
      END DO
!end if
!--iLab::avoid pointer
! p =>clim
!call mpi_barrier(mpi_comm_world,ierr)
!call mpi_scatterv(TMAX3(1),dp,sp,MPI_real8,clim%Tempmx(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(TMIN3(1),dp,sp,MPI_real8,clim%Tempmn(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(RH3(1),dp,sp,MPI_real8,clim%Rh(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(WS3(1),dp,sp,MPI_real8,clim%Wind(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(SSRD3(1),dp,sp,MPI_real8,clim%Srad(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(rainfall(1),dp,sp,MPI_real8,clim%Rain(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(snow(1),dp,sp,MPI_real8,clim%Snow(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_barrier(mpi_comm_world,ierr)
      clim%tempmx = tmax3
      clim%tempmn = tmin3
      clim%rh = rh3
      clim%wind = ws3
      clim%srad = ssrd3
      clim%rain = rainfall
      clim%snow = snow
    END IF
  END SUBROUTINE READ_METEO_DAILY

  SUBROUTINE READ_METEO_HOURLY(yr, mon, day, sec)
    IMPLICIT NONE
!--iLab::made yr/mon/day/sec arguments in order to avoid 'get_curr_date'
    INTEGER, INTENT(IN) :: yr, mon, day, sec
!character(len=*) :: file_path,file_flnm_prefix
    INTEGER :: ncid, ierr, varid(5)
! integer          :: yr,mon,day,sec
    INTEGER :: nt
    INTEGER :: i
!--iLab::avoid pointer (see also below)
! type(forc),pointer :: p
    REAL(r8) :: t1(nlon, nlat), rh1(nlon, nlat), ws1(nlon, nlat), prcp1(&
&   nlon, nlat), ssrd1(nlon, nlat)
    REAL(r8) :: t2(nlon*nlat), rh2(nlon*nlat), ws2(nlon*nlat), prcp2(&
&   nlon*nlat), ssrd2(nlon*nlat)
    REAL(r8) :: t3(nlp), rh3(nlp), ws3(nlp), prcp3(nlp), ssrd3(nlp)
    REAL(r8) :: rainfall(nlp), snow(nlp)
!character(len=6)   :: monstr
    CHARACTER(len=8) :: datestr
    CHARACTER(len=4) :: yrstr
    REAL(r8), PARAMETER :: density_water=1025.
    REAL(r8) :: density_new_snow
    CHARACTER(len=255) :: fname
    CHARACTER(len=*), PARAMETER :: method='read_meteo_hourly'
    INTRINSIC TRIM
    INTRINSIC LEN
    INTRINSIC INT
    INTRINSIC RESHAPE
    INTRINSIC MAX
    INTRINSIC EXP
    INTEGER :: result1
    REAL(r8) :: arg1
!if(myid ==0) then
! call get_curr_date(yr,mon,day,sec)
    WRITE(datestr, '(i8)') yr*10000 + mon*100 + day
    WRITE(yrstr, '(i4)') yr
!  call check(nf90_open(trim(meteo_path)//trim(yrstr)//'/'//trim(meteo_flnm_prefix)//trim(datestr)//".nc",nf90_nowrite,ncid))
    IF (LEN(TRIM(meteo_path)) + LEN(TRIM(meteo_flnm_prefix)) + LEN(TRIM(&
&       datestr)) + LEN('.nc') .GT. LEN(fname)) THEN
      WRITE(*, '(a)') 'FATAL::INTERNAL-ERROR::'//method//&
&     ':file name too long!'
      STOP
    ELSE
      fname = TRIM(meteo_path)//'/'//TRIM(meteo_flnm_prefix)//TRIM(&
&       datestr)//'.nc'
      result1 = NF90_OPEN(fname, nf90_nowrite, ncid)
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'T', varid(1))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'RH', varid(2))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'WS', varid(3))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'PRCP', varid(4))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'SSRD', varid(5))
      CALL CHECK(result1)
!  nt    = (day-1)*24+sec/int(step)+1     !! data slide for months
      nt = sec/INT(step) + 1
      WRITE(*, *) 'Reading meteo data on ', nt, 'of', datestr
      result1 = NF90_GET_VAR(ncid, varid(1), t1, start=(/1, 1, nt/), &
&       count=(/nlon, nlat, 1/))
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(2), rh1, start=(/1, 1, nt/), &
&       count=(/nlon, nlat, 1/))
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(3), ws1, start=(/1, 1, nt/), &
&       count=(/nlon, nlat, 1/))
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(4), prcp1, start=(/1, 1, nt/), &
&       count=(/nlon, nlat, 1/))
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(5), ssrd1, start=(/1, 1, nt/), &
&       count=(/nlon, nlat, 1/))
      CALL CHECK(result1)
      result1 = NF90_CLOSE(ncid)
      CALL CHECK(result1)
      t2 = RESHAPE(t1, (/nlon*nlat/))
      rh2 = RESHAPE(rh1, (/nlon*nlat/))
      ws2 = RESHAPE(ws1, (/nlon*nlat/))
      prcp2 = RESHAPE(prcp1, (/nlon*nlat/))
      ssrd2 = RESHAPE(ssrd1, (/nlon*nlat/))
!! K
      t3 = t2(mapping)
!!
      rh3 = rh2(mapping)
!! m/s
      ws3 = ws2(mapping)
!! m/s(consult)
      prcp3 = prcp2(mapping)
!! w/m2
      ssrd3 = ssrd2(mapping)
!! translate into centigrade (oC)
      t3 = t3 - 273.16
!! %
      rh3 = rh3*100
      WHERE (0. .LT. prcp3/3600.) 
        prcp3 = prcp3/3600.
      ELSEWHERE
        prcp3 = 0.
      END WHERE
!! seperating total precip into liquid and solid according to temperature
      DO i=1,nlp
        IF (t3(i) .GT. 0.) THEN
          rainfall(i) = prcp3(i)
          snow(i) = 0.
        ELSE
          rainfall(i) = 0.
          arg1 = t3(i)/2.6
          density_new_snow = 67.9 + 51.3*EXP(arg1)
          snow(i) = prcp3(i)*density_water/density_new_snow
        END IF
      END DO
!end if
!--iLab::avoid pointer
! p =>clim
!call mpi_barrier(mpi_comm_world,ierr)
!call mpi_scatterv(T3(1),dp,sp,MPI_real8,clim%Temp(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(RH3(1),dp,sp,MPI_real8,clim%Rh(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(WS3(1),dp,sp,MPI_real8,clim%Wind(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(SSRD3(1),dp,sp,MPI_real8,clim%Srad(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(rainfall(1),dp,sp,MPI_real8,clim%Rain(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(snow(1),dp,sp,MPI_real8,clim%Snow(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_barrier(mpi_comm_world,ierr)
      clim%temp = t3
      clim%rh = rh3
      clim%wind = ws3
      clim%srad = ssrd3
      clim%rain = rainfall
      clim%snow = snow
    END IF
  END SUBROUTINE READ_METEO_HOURLY

  SUBROUTINE READ_METEO_SITE_REFTIME()
    IMPLICIT NONE
    INTEGER :: ncid, timevar_id
    LOGICAL :: ldebug
    CHARACTER(len=255) :: fname
    CHARACTER(len=*), PARAMETER :: method='read_meteo_site_reftime'
    CHARACTER(len=*), PARAMETER :: time_unit_expected=&
&     'hours since YYYY-MM-DD'
    CHARACTER(len=128) :: time_unit
    INTRINSIC TRIM
    INTRINSIC LEN
    INTEGER :: result1
    ldebug = .false.
    IF (LEN(TRIM(beps_site_path)) + LEN(TRIM(meteo_site_flnm_prefix)) + &
&       LEN('.nc') .GT. LEN(fname)) THEN
      WRITE(*, '(a)') 'FATAL::INTERNAL-ERROR::'//method//&
&     ':file name too long!'
      STOP
    ELSE
      fname = TRIM(beps_site_path)//'/'//TRIM(meteo_site_flnm_prefix)//&
&       '.nc'
      IF (ldebug) WRITE(*, '(a)') 'DEBUG::'//method//&
&                 ':reading meteo data ***'//TRIM(fname)//'***'
      result1 = NF90_OPEN(fname, nf90_nowrite, ncid)
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'time', timevar_id)
      CALL CHECK(result1)
      IF (ldebug) WRITE(*, '(a)') 'DEBUG::'//method//&
&                 ':data set identifier determined!'
!-- iLab::get reference time in meteorological forcing
      result1 = NF90_GET_ATT(ncid, timevar_id, 'units', time_unit)
      CALL CHECK(result1)
      IF (LEN(TRIM(time_unit)) .NE. LEN(time_unit_expected)) THEN
        WRITE(*, '(a)') ' FATAL::'//method//&
&       ': unexpected unit of time in met forcing '//'***'//TRIM(&
&       time_unit)//'***'
        STOP
      ELSE
!-- expected: "hours since yyyy-mm-dd"
        clim%meteo_ref_yyyymmdd = time_unit(13:22)
        result1 = NF90_CLOSE(ncid)
        CALL CHECK(result1)
        IF (ldebug) WRITE(*, '(a)') 'DEBUG::'//method//&
&                   ':NetCDF file closed again.'
      END IF
    END IF
  END SUBROUTINE READ_METEO_SITE_REFTIME

  SUBROUTINE READ_METEO_SITE(nd)
    IMPLICIT NONE
!character(len=*) :: file_path,file_flnm_prefix
    INTEGER, INTENT(IN) :: nd
    INTEGER :: ncid, ierr, varid(5)
    INTEGER :: yr, mon, day, sec
    INTEGER :: nt
    INTEGER :: i
!--iLab::avoid pointer (see also below)
! type(forc),pointer :: p
    REAL(r8) :: t(nlp), rh(nlp), ws(nlp), prcp(nlp), ssrd(nlp)
    REAL(r8) :: rainfall(nlp), snow(nlp)
!character(len=6)   :: monstr
    CHARACTER(len=8) :: datestr
    CHARACTER(len=4) :: yrstr
    REAL(r8), PARAMETER :: density_water=1025.
    REAL(r8) :: density_new_snow
    LOGICAL :: ldebug
    CHARACTER(len=255) :: fname
    CHARACTER(len=*), PARAMETER :: method='read_meteo_site'
    LOGICAL :: exist
    INTRINSIC TRIM
    INTRINSIC LEN
    INTRINSIC MAX
    INTRINSIC EXP
    INTEGER :: result1
    REAL(r8) :: arg1
!--iLab::added missing initialisation
    ldebug = .false.
!if(myid ==0) then
!  call check(nf90_open(trim(meteo_path)//trim(yrstr)//'/'//trim(meteo_flnm_prefix)//trim(datestr)//".nc",nf90_nowrite,ncid))
    IF (LEN(TRIM(beps_site_path)) + LEN(TRIM(meteo_site_flnm_prefix)) + &
&       LEN('.nc') .GT. LEN(fname)) THEN
      WRITE(*, '(a)') 'FATAL::INTERNAL-ERROR::'//method//&
&     ':file name too long!'
      STOP
    ELSE
      fname = TRIM(beps_site_path)//'/'//TRIM(meteo_site_flnm_prefix)//&
&       '.nc'
!-- iLab::added: stop in case meteo file is not present
      INQUIRE(file=fname, exist=exist) 
      IF (.NOT.exist) THEN
        WRITE(*, '(a)') ' FATAL::'//method//': file ***'//TRIM(fname)//&
&       '*** does NOT exist'
        STOP
      ELSE
        IF (ldebug) WRITE(*, '(a)') 'DEBUG::'//method//&
&                   ':reading meteo data ***'//TRIM(fname)//'***'
        result1 = NF90_OPEN(fname, nf90_nowrite, ncid)
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'T', varid(1))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'RH', varid(2))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'WS', varid(3))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'PRCP', varid(4))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'SSRD', varid(5))
        CALL CHECK(result1)
        IF (ldebug) WRITE(*, '(a)') 'DEBUG::'//method//&
&                   ':data set identifier determined!'
!  nt    = (day-1)*24+sec/int(step)+1     !! data slide for months
        IF (ldebug) WRITE(*, '(a,2(a,i5,1x))') 'DEBUG::'//method//&
&                   ':reading meteo data on ', 'nd=', nd, 'nlp=', nlp
        result1 = NF90_GET_VAR(ncid, varid(1), t, start=(/1, nd/), count&
&         =(/nlp, 1/))
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(2), rh, start=(/1, nd/), &
&         count=(/nlp, 1/))
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(3), ws, start=(/1, nd/), &
&         count=(/nlp, 1/))
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(4), prcp, start=(/1, nd/), &
&         count=(/nlp, 1/))
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(5), ssrd, start=(/1, nd/), &
&         count=(/nlp, 1/))
        CALL CHECK(result1)
        result1 = NF90_CLOSE(ncid)
        CALL CHECK(result1)
        IF (ldebug) WRITE(*, '(a)') 'DEBUG::'//method//&
&                   ':NetCDF file closed again.'
!! translate into centigrade (oC), input is oC for site.@MOUSONG.WU
        t = t
!! %
        rh = rh*100
        WHERE (0. .LT. prcp/3600.) 
          prcp = prcp/3600.
        ELSEWHERE
          prcp = 0.
        END WHERE
        WHERE (0. .LT. ssrd) 
          ssrd = ssrd
        ELSEWHERE
          ssrd = 0.
        END WHERE
!! seperating total precip into liquid and solid according to temperature
        DO i=1,nlp
          IF (t(i) .GT. 0.) THEN
            rainfall(i) = prcp(i)
            snow(i) = 0.
          ELSE
            rainfall(i) = 0.
            arg1 = t(i)/2.6
            density_new_snow = 67.9 + 51.3*EXP(arg1)
            snow(i) = prcp(i)*density_water/density_new_snow
          END IF
        END DO
!end if
!--iLab::avoid pointer
! p =>clim
!call mpi_barrier(mpi_comm_world,ierr)
!call mpi_scatterv(T(1),dp,sp,MPI_real8,clim%Temp(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(RH(1),dp,sp,MPI_real8,clim%Rh(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(WS(1),dp,sp,MPI_real8,clim%Wind(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(SSRD(1),dp,sp,MPI_real8,clim%Srad(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(rainfall(1),dp,sp,MPI_real8,clim%Rain(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(snow(1),dp,sp,MPI_real8,clim%Snow(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_barrier(mpi_comm_world,ierr)
        clim%temp = t
        clim%rh = rh
        clim%wind = ws
        clim%srad = ssrd
        clim%rain = rainfall
        clim%snow = snow
      END IF
    END IF
  END SUBROUTINE READ_METEO_SITE

  SUBROUTINE READ_LAI(yr, mn, dd, tod, day)
    IMPLICIT NONE
!--iLab::made yr/mon/day/sec arguments in order to avoid 'get_curr_date'/'get_cal_day'
    INTEGER, INTENT(IN) :: yr, mn, dd, tod, day
    REAL(r8) :: lai1(nlon, nlat, pft), lai2(nlon*nlat, pft), lai3(nlp, &
&   pft)
    CHARACTER(len=4) :: datestr
    INTEGER :: ncid, varid, ierr, i
!--iLab::avoid pointer (see also below)
! type(surf),pointer:: p
    CHARACTER(len=255) :: fname
    CHARACTER(len=*), PARAMETER :: method='read_lai'
    INTRINSIC TRIM
    INTRINSIC LEN
    INTRINSIC RESHAPE
    INTEGER :: result1
!if(myid ==0) then
! day  = get_curr_calday()
! call get_curr_date(yr,mn,dd,tod)
    WRITE(datestr, '(i4)') yr
    WRITE(*, *) 'Reading LAI On ', yr*10000 + mn*100 + dd
    IF (LEN(TRIM(beps_lai_path)) + LEN(TRIM(beps_lai_prefix)) + LEN(TRIM&
&       (datestr)) + LEN('.nc') .GT. LEN(fname)) THEN
      WRITE(*, '(a)') 'FATAL::INTERNAL-ERROR::'//method//&
&     ':file name too long!'
      STOP
    ELSE
      fname = TRIM(beps_lai_path)//TRIM(beps_lai_prefix)//TRIM(datestr)&
&       //'.nc'
      result1 = NF90_OPEN(fname, nf90_nowrite, ncid)
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'lai', varid)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid, lai1, start=(/1, 1, 1, day/), &
&       count=(/nlon, nlat, pft, 1/))
      CALL CHECK(result1)
      result1 = NF90_CLOSE(ncid)
      CALL CHECK(result1)
      lai2 = RESHAPE(lai1, (/nlon*nlat, pft/))
      lai3 = lai2(mapping, :)
!end if
!--iLab::avoid pointer
! p => bound
!call mpi_barrier(mpi_comm_world,ierr)
!do i = 1,PFT
!    call mpi_scatterv(lai3(1,i),dp,sp,mpi_real8,p%lai(1,i),npoints,mpi_real8,0,mpi_comm_world,ierr)
!end do
!call mpi_barrier(mpi_comm_world,ierr)
      bound%lai = lai3
    END IF
  END SUBROUTINE READ_LAI

  SUBROUTINE READ_LAI_SITE(day)
    IMPLICIT NONE
!--iLab::no need for actual day, calendar day as input
    INTEGER, INTENT(IN) :: day
! integer          :: yr,mn,dd,tod,day
    REAL(r8) :: lai1(nlp, pft)
    INTEGER :: ncid, varid, ierr, i
!--iLab::avoid pointer (see also below)
! type(surf),pointer:: p
!--iLab::added to limit terminal output
    LOGICAL :: ldebug
    CHARACTER(len=255) :: fname
    CHARACTER(len=*), PARAMETER :: method='read_lai_site'
    LOGICAL :: exist
    INTRINSIC TRIM
    INTRINSIC LEN
    INTEGER :: result1
!if(myid ==0) then
! day  = get_curr_calday()
! call get_curr_date(yr,mn,dd,tod)
    ldebug = .false.
    IF (ldebug) WRITE(*, *) 'INFO::'//method//':Reading LAI day=', day
    IF (LEN(TRIM(beps_site_path)) + LEN(TRIM(beps_lai_site_prefix)) + &
&       LEN('.nc') .GT. LEN(fname)) THEN
      WRITE(*, '(a)') 'FATAL::INTERNAL-ERROR::'//method//&
&     ':file name too long!'
      STOP
    ELSE
      fname = TRIM(beps_site_path)//TRIM(beps_lai_site_prefix)//'.nc'
      IF (ldebug) WRITE(*, *) 'INFO::'//method//':Reading from file ***'&
&                 //TRIM(fname)//'***'
!-- iLab::added: stop in case LAI file is not present
      INQUIRE(file=fname, exist=exist) 
      IF (.NOT.exist) THEN
        WRITE(*, '(a)') ' FATAL::'//method//': file ***'//TRIM(fname)//&
&       '*** does NOT exist'
        STOP
      ELSE
        result1 = NF90_OPEN(fname, nf90_nowrite, ncid)
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'lai', varid)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid, lai1, start=(/1, 1, day/), &
&         count=(/nlp, pft, 1/))
        CALL CHECK(result1)
        result1 = NF90_CLOSE(ncid)
        CALL CHECK(result1)
!end if
!--iLab::avoid pointer (see below)
! p => bound
!call mpi_barrier(mpi_comm_world,ierr)
!do i = 1,PFT
!    call mpi_scatterv(lai1(1,i),dp,sp,mpi_real8,p%lai(1,i),npoints,mpi_real8,0,mpi_comm_world,ierr)
!end do
!call mpi_barrier(mpi_comm_world,ierr)
        bound%lai = lai1
      END IF
    END IF
  END SUBROUTINE READ_LAI_SITE

!! Reading Vcmax for data assimilation use
  SUBROUTINE READ_VCMAX(yr, mn, dd, tod)
    IMPLICIT NONE
!--iLab::made yr/mon/day/sec arguments in order to avoid 'get_curr_date'
    INTEGER, INTENT(IN) :: yr, mn, dd, tod
! integer          :: yr,mn,dd,tod,day
    REAL(r8) :: vcmax1(nlon, nlat, pft), vcmax2(nlon*nlat, pft), vcmax3(&
&   nlp, pft)
    CHARACTER(len=6) :: datestr
    INTEGER :: ncid, varid, ierr, i
!--iLab::avoid pointer (see also below)
! type(surf),pointer:: p
    CHARACTER(len=255) :: fname
    CHARACTER(len=*), PARAMETER :: method='read_Vcmax'
    INTRINSIC TRIM
    INTRINSIC LEN
    INTRINSIC RESHAPE
    INTEGER :: result1
!if(myid ==0) then
!   day  = get_curr_calday()
! call get_curr_date(yr,mn,dd,tod)
    WRITE(datestr, '(i6)') yr*100 + mn
    WRITE(*, *) 'Reading Vcmax on '//datestr
    IF (LEN(TRIM(beps_vcmax_path)) + LEN('Vcmax_') + LEN(TRIM(datestr)) &
&       + LEN('.nc') .GT. LEN(fname)) THEN
      WRITE(*, '(a)') 'FATAL::INTERNAL-ERROR::'//method//&
&     ':file name too long!'
      STOP
    ELSE
      fname = TRIM(beps_vcmax_path)//'Vcmax_'//TRIM(datestr)//'.nc'
      result1 = NF90_OPEN(fname, nf90_nowrite, ncid)
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'Vcmax', varid)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid, vcmax1)
      CALL CHECK(result1)
      result1 = NF90_CLOSE(ncid)
      CALL CHECK(result1)
      vcmax2 = RESHAPE(vcmax1, (/nlon*nlat, pft/))
      vcmax3 = vcmax2(mapping, :)
!end if
!--iLab::avoid pointer (see also below)
! p => bound
!call mpi_barrier(mpi_comm_world,ierr)
!do i = 1,PFT
!    call mpi_scatterv(vcmax3(1,i),dp,sp,mpi_real8,bound%Vcmax(1,i),npoints,mpi_real8,0,mpi_comm_world,ierr)
!end do
!call mpi_barrier(mpi_comm_world,ierr)
      bound%vcmax = vcmax3
    END IF
  END SUBROUTINE READ_VCMAX

  SUBROUTINE READ_VCMAX_SITE(yr, mn, dd, tod)
    IMPLICIT NONE
!--iLab::made yr/mon/day/sec arguments in order to avoid 'get_curr_date'
    INTEGER, INTENT(IN) :: yr, mn, dd, tod
! integer          :: yr,mn,dd,tod,day
    REAL(r8) :: vcmax(nlp, pft)
    CHARACTER(len=6) :: datestr
    INTEGER :: ncid, varid, ierr, i
!--iLab::avoid pointer (see also below)
! type(surf),pointer:: p
    CHARACTER(len=255) :: fname
    CHARACTER(len=*), PARAMETER :: method='read_Vcmax_site'
    INTRINSIC TRIM
    INTRINSIC LEN
    INTEGER :: result1
!if(myid ==0) then
!   day  = get_curr_calday()
! call get_curr_date(yr,mn,dd,tod)
    WRITE(datestr, '(i6)') yr*100 + mn
    WRITE(*, *) 'Reading Vcmax on '//datestr
    IF (LEN(TRIM(beps_vcmax_site_path)) + LEN('Site_Vcmax_') + LEN(TRIM(&
&       datestr)) + LEN('.nc') .GT. LEN(fname)) THEN
      WRITE(*, '(a)') 'FATAL::INTERNAL-ERROR::'//method//&
&     ':file name too long!'
      STOP
    ELSE
      fname = TRIM(beps_vcmax_site_path)//'Site_Vcmax_'//TRIM(datestr)//&
&       '.nc'
      result1 = NF90_OPEN(fname, nf90_nowrite, ncid)
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'Vcmax', varid)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid, vcmax)
      CALL CHECK(result1)
      result1 = NF90_CLOSE(ncid)
      CALL CHECK(result1)
!end if
!--iLab::avoid pointer (see also below)
! p => bound
!call mpi_barrier(mpi_comm_world,ierr)
!do i = 1,PFT
!    call mpi_scatterv(vcmax(1,i),dp,sp,mpi_real8,bound%Vcmax(1,i),npoints,mpi_real8,0,mpi_comm_world,ierr)
!end do
!call mpi_barrier(mpi_comm_world,ierr)
      bound%vcmax = vcmax
    END IF
  END SUBROUTINE READ_VCMAX_SITE

  SUBROUTINE READ_CPOOLS()
    IMPLICIT NONE
    INTEGER :: ncid, varid(9), ierr, i
    REAL(r8) :: ccd(nlon, nlat, pft), cfmd(nlon, nlat, pft), cfsd(nlon, &
&   nlat, pft), cm(nlon, nlat, pft), cp(nlon, nlat, pft), cs(nlon, nlat&
&   , pft), csm(nlon, nlat, pft), csmd(nlon, nlat, pft), cssd(nlon, nlat&
&   , pft)
    REAL(r8) :: ccd2(nlon*nlat, pft), cfmd2(nlon*nlat, pft), cfsd2(nlon*&
&   nlat, pft), cm2(nlon*nlat, pft), cp2(nlon*nlat, pft), cs2(nlon*nlat&
&   , pft), csm2(nlon*nlat, pft), csmd2(nlon*nlat, pft), cssd2(nlon*nlat&
&   , pft)
    REAL(r8) :: ccd3(nlp, pft), cfmd3(nlp, pft), cfsd3(nlp, pft), cm3(&
&   nlp, pft), cp3(nlp, pft), cs3(nlp, pft), csm3(nlp, pft), csmd3(nlp, &
&   pft), cssd3(nlp, pft)
    INTRINSIC TRIM
    INTRINSIC RESHAPE
    INTEGER :: result1
!--iLab::avoid pointer (see also below)
! type(surf),pointer :: p
!--iLab::avoid pointer (see also below)
! p => bound
!if( myid ==0 ) then
    result1 = NF90_OPEN(TRIM(beps_cpools), nf90_nowrite, ncid)
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'ccd', varid(1))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'cfmd', varid(2))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'cfsd', varid(3))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'cm', varid(4))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'cp', varid(5))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'cs', varid(6))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'csm', varid(7))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'csmd', varid(8))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'cssd', varid(9))
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(1), ccd)
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(2), cfmd)
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(3), cfsd)
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(4), cm)
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(5), cp)
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(6), cs)
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(7), csm)
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(8), csmd)
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(9), cssd)
    CALL CHECK(result1)
    result1 = NF90_CLOSE(ncid)
    CALL CHECK(result1)
    ccd2 = RESHAPE(ccd, (/nlon*nlat, pft/))
    cfmd2 = RESHAPE(cfmd, (/nlon*nlat, pft/))
    cfsd2 = RESHAPE(cfsd, (/nlon*nlat, pft/))
    cm2 = RESHAPE(cm, (/nlon*nlat, pft/))
    cp2 = RESHAPE(cp, (/nlon*nlat, pft/))
    cs2 = RESHAPE(cs, (/nlon*nlat, pft/))
    csm2 = RESHAPE(csm, (/nlon*nlat, pft/))
    csmd2 = RESHAPE(csmd, (/nlon*nlat, pft/))
    cssd2 = RESHAPE(cssd, (/nlon*nlat, pft/))
!! kg->g
    ccd3 = ccd2(mapping, :)*1e3
    cfmd3 = cfmd2(mapping, :)*1e3
    cfsd3 = cfsd2(mapping, :)*1e3
    cm3 = cm2(mapping, :)*1e3
    cp3 = cp2(mapping, :)*1e3
    cs3 = cs2(mapping, :)*1e3
    csm3 = csm2(mapping, :)*1e3
    csmd3 = csmd2(mapping, :)*1e3
    cssd3 = cssd2(mapping, :)*1e3
!end if
!call mpi_barrier(mpi_comm_world,ierr)
!do i = 1,PFT
! call mpi_scatterv(ccd3(1,i),dp,sp,MPI_real8,bound%ccd(1,i),npoints,MPI_real8,0,mpi_comm_world,ierr)
! call mpi_scatterv(cfmd3(1,i),dp,sp,MPI_real8,bound%cfmd(1,i),npoints,MPI_real8,0,mpi_comm_world,ierr)
! call mpi_scatterv(cfsd3(1,i),dp,sp,MPI_real8,bound%cfsd(1,i),npoints,MPI_real8,0,mpi_comm_world,ierr)
! call mpi_scatterv(cm3(1,i),dp,sp,MPI_real8,bound%cm(1,i),npoints,MPI_real8,0,mpi_comm_world,ierr)
! call mpi_scatterv(cp3(1,i),dp,sp,MPI_real8,bound%cp(1,i),npoints,MPI_real8,0,mpi_comm_world,ierr)
! call mpi_scatterv(cs3(1,i),dp,sp,MPI_real8,bound%cs(1,i),npoints,MPI_real8,0,mpi_comm_world,ierr)
! call mpi_scatterv(csm3(1,i),dp,sp,MPI_real8,bound%csm(1,i),npoints,MPI_real8,0,mpi_comm_world,ierr)
! call mpi_scatterv(csmd3(1,i),dp,sp,MPI_real8,bound%csmd(1,i),npoints,MPI_real8,0,mpi_comm_world,ierr)
! call mpi_scatterv(cssd3(1,i),dp,sp,MPI_real8,bound%cssd(1,i),npoints,MPI_real8,0,mpi_comm_world,ierr)
!end do
!call mpi_barrier(mpi_comm_world,ierr)
    bound%ccd = ccd3
    bound%cfmd = cfmd3
    bound%cfsd = cfsd3
    bound%cm = cm3
    bound%cp = cp3
    bound%cs = cs3
    bound%csm = csm3
    bound%csmd = csmd3
    bound%cssd = cssd3
  END SUBROUTINE READ_CPOOLS

  SUBROUTINE READ_PRIOR_PARA()
    IMPLICIT NONE
    INTEGER :: i, ncid, varid(28), ierr
    REAL(r8) :: p_vcmax(pft), p_q10(pft), p_vj_slope(pft), p_sif_alpha(&
&   pft), p_sif_beta(pft), p_taweff(pft), p_d0(pft)
    REAL(r8) :: p_ksat_scalar(texture), p_b_scalar(texture)
    REAL(r8) :: p_f_leaf, p_kc25, p_ko25, p_tau25, p_agb2vod
    REAL(r8) :: u_vcmax(pft), u_q10(pft), u_vj_slope(pft), u_sif_alpha(&
&   pft), u_sif_beta(pft), u_taweff(pft), u_d0(pft)
    REAL(r8) :: u_ksat_scalar(texture), u_b_scalar(texture)
    REAL(r8) :: u_f_leaf, u_kc25, u_ko25, u_tau25, u_f_lr, u_agb2vod
!--iLab::avoid pointer (see also below)
! type(para),pointer :: p
    CHARACTER(len=255) :: fname
    CHARACTER(len=*), PARAMETER :: method='read_prior_para'
    LOGICAL :: exist
    INTRINSIC TRIM
    INTRINSIC LEN
    INTEGER :: result1
!--iLab::avoid pointer (see also below)
! p => assim
    IF (LEN(TRIM(beps_site_path)) + LEN(TRIM(prior_para_prefix)) + LEN(&
&       '.nc') .GT. LEN(fname)) THEN
      WRITE(*, '(a)') 'FATAL::INTERNAL-ERROR::'//method//&
&     ':file name too long!'
      STOP
    ELSE
      fname = TRIM(beps_site_path)//TRIM(prior_para_prefix)//'.nc'
!-- iLab::added: stop in case boundary file is not present
      INQUIRE(file=fname, exist=exist) 
      IF (.NOT.exist) THEN
        WRITE(*, '(a)') ' FATAL::'//method//': file ***'//TRIM(fname)//&
&       '*** does NOT exist'
        STOP
      ELSE
        result1 = NF90_OPEN(fname, nf90_nowrite, ncid)
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'p_Vcmax', varid(1))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'p_q10', varid(2))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'p_VJ_slope', varid(3))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'p_sif_alpha', varid(4))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'p_sif_beta', varid(5))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'p_taweff', varid(6))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'p_D0', varid(7))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'p_Ksat_scalar', varid(8))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'p_b_scalar', varid(9))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'p_f_leaf', varid(10))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'p_kc25', varid(11))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'p_ko25', varid(12))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'p_tau25', varid(13))
        CALL CHECK(result1)
!call check(nf90_inq_varid(ncid,"p_f_lr",varid(14)))
        result1 = NF90_INQ_VARID(ncid, 'p_agb2vod', varid(14))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'u_Vcmax', varid(15))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'u_q10', varid(16))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'u_VJ_slope', varid(17))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'u_sif_alpha', varid(18))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'u_sif_beta', varid(19))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'u_taweff', varid(20))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'u_D0', varid(21))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'u_Ksat_scalar', varid(22))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'u_b_scalar', varid(23))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'u_f_leaf', varid(24))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'u_kc25', varid(25))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'u_ko25', varid(26))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'u_tau25', varid(27))
        CALL CHECK(result1)
!call check(nf90_inq_varid(ncid,"u_f_lr",varid(28)))
        result1 = NF90_INQ_VARID(ncid, 'u_agb2vod', varid(28))
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(1), p_vcmax)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(2), p_q10)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(3), p_vj_slope)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(4), p_sif_alpha)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(5), p_sif_beta)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(6), p_taweff)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(7), p_d0)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(8), p_ksat_scalar)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(9), p_b_scalar)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(10), p_f_leaf)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(11), p_kc25)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(12), p_ko25)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(13), p_tau25)
        CALL CHECK(result1)
! call check(nf90_get_var(ncid,varid(14),p_f_lr))
        result1 = NF90_GET_VAR(ncid, varid(14), p_agb2vod)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(15), u_vcmax)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(16), u_q10)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(17), u_vj_slope)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(18), u_sif_alpha)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(19), u_sif_beta)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(20), u_taweff)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(21), u_d0)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(22), u_ksat_scalar)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(23), u_b_scalar)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(24), u_f_leaf)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(25), u_kc25)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(26), u_ko25)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(27), u_tau25)
        CALL CHECK(result1)
!call check(nf90_get_var(ncid,varid(29),u_f_lr))
        result1 = NF90_GET_VAR(ncid, varid(28), u_agb2vod)
        CALL CHECK(result1)
        result1 = NF90_CLOSE(ncid)
        CALL CHECK(result1)
        assim%p_vcmax = p_vcmax
        assim%p_q10 = p_q10
        assim%p_vj_slope = p_vj_slope
        assim%p_sif_alpha = p_sif_alpha
        assim%p_sif_beta = p_sif_beta
        assim%p_taweff = p_taweff
        assim%p_d0 = p_d0
        assim%p_ksat_scalar = p_ksat_scalar
        assim%p_b_scalar = p_b_scalar
        assim%p_f_leaf = p_f_leaf
        assim%p_kc25 = p_kc25
        assim%p_ko25 = p_ko25
        assim%p_tau25 = p_tau25
! assim%p_f_lr = p_f_lr
        assim%p_agb2vod = p_agb2vod
        assim%u_vcmax = u_vcmax
        assim%u_q10 = u_q10
        assim%u_vj_slope = u_vj_slope
        assim%u_sif_alpha = u_sif_alpha
        assim%u_sif_beta = u_sif_beta
        assim%u_taweff = u_taweff
        assim%u_d0 = u_d0
        assim%u_ksat_scalar = u_ksat_scalar
        assim%u_b_scalar = u_b_scalar
        assim%u_f_leaf = u_f_leaf
        assim%u_kc25 = u_kc25
        assim%u_ko25 = u_ko25
        assim%u_tau25 = u_tau25
!assim%u_f_lr = u_f_lr
        assim%u_agb2vod = u_agb2vod
      END IF
    END IF
  END SUBROUTINE READ_PRIOR_PARA

  SUBROUTINE CHECK(status)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: status
!write(*,*) 'get rid of check status'
    IF (status .NE. nf90_noerr) CALL ENDRUN('Reading nc file is wrong!!'&
&                                    )
  END SUBROUTINE CHECK

END MODULE CONTROLINPUT_MOD_DIFFV

MODULE METEOMOD_DIFFV
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE BEPS_CON, ONLY : rho_a
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
! kg/m3
  REAL(r8), PUBLIC :: density_air
! specific heat of air  J/kg/C
  REAL(r8), PUBLIC :: cp_air
  REAL(r8), DIMENSION(nbdirsmax), PUBLIC :: cp_air_fw
! kPa
  REAL(r8), PUBLIC :: vpd
  REAL(r8), DIMENSION(nbdirsmax), PUBLIC :: vpd_fw
! slope  of vapor presure to temperature kPa/C
  REAL(r8), PUBLIC :: slope_vapor
  REAL(r8), DIMENSION(nbdirsmax), PUBLIC :: slope_vapor_fw
! psychrometer constant  kPa/C
  REAL(r8), PUBLIC :: psy
! saturate water vapor   kPa
  REAL(r8), PUBLIC :: e_saturate
  REAL(r8), DIMENSION(nbdirsmax), PUBLIC :: e_saturate_fw
! actual water vapor     kPa
  REAL(r8), PUBLIC :: e_actual
  REAL(r8), DIMENSION(nbdirsmax), PUBLIC :: e_actual_fw
! specific humidity g/g
  REAL(r8), PUBLIC :: sp_humidity
  REAL(r8), DIMENSION(nbdirsmax), PUBLIC :: sp_humidity_fw
! condensation    J/kg
  REAL(r8), PUBLIC :: latent_water
! sublimation/deposition    J/kg
  REAL(r8), PUBLIC :: latent_snow

CONTAINS
!  Differentiation of meteo_pack in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: cp_air vpd slope_vapor
!   with respect to varying inputs: temp
  SUBROUTINE METEO_PACK_FWV(temp, temp_fw, rh, nbdirs)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
    REAL(r8), INTENT(IN) :: temp
    REAL(r8), DIMENSION(nbdirsmax), INTENT(IN) :: temp_fw
    REAL(r8), INTENT(IN) :: rh
    INTRINSIC EXP
    REAL(r8) :: arg1
    REAL(r8), DIMENSION(nbdirsmax) :: arg1_fw
    INTEGER :: nd
    REAL(r8) :: temp0
    INTEGER :: nbdirs
! 0C 1.292
    density_air = rho_a
    temp0 = temp/(temp+237.3)
    arg1 = 17.3*temp0
    DO nd=1,nbdirs
      arg1_fw(nd) = 17.3*(1.0-temp0)*temp_fw(nd)/(temp+237.3)
      e_saturate_fw(nd) = 0.61078*EXP(arg1)*arg1_fw(nd)
      e_actual_fw(nd) = rh*e_saturate_fw(nd)/100.
      vpd_fw(nd) = e_saturate_fw(nd) - e_actual_fw(nd)
    END DO
    e_saturate = 0.61078*EXP(arg1)
    e_actual = e_saturate*rh/100.
    vpd = e_saturate - e_actual
    temp0 = e_actual/(-(0.378*e_actual)+101.35)
    DO nd=1,nbdirs
      sp_humidity_fw(nd) = 0.622*(temp0*0.378+1.0)*e_actual_fw(nd)/(&
&       101.35-0.378*e_actual)
      cp_air_fw(nd) = 1004.65*0.84*sp_humidity_fw(nd)
    END DO
    sp_humidity = 0.622*temp0
    cp_air = 1004.65*(1.+0.84*sp_humidity)
    temp0 = temp/(temp+237.3)
    DO nd=1,nbdirs
      arg1_fw(nd) = 17.27*(1.0-temp0)*temp_fw(nd)/(temp+237.3)
    END DO
    arg1 = 17.27*temp0
    temp0 = EXP(arg1)/((temp+237.3)*(temp+237.3))
    DO nd=1,nbdirs
      slope_vapor_fw(nd) = 2503.*(EXP(arg1)*arg1_fw(nd)-temp0*2*(temp+&
&       237.3)*temp_fw(nd))/(temp+237.3)**2
    END DO
    slope_vapor = 2503.*temp0
    psy = 0.066
    latent_water = (2.501-0.00237*temp)*1e6
    latent_snow = 2.83*1e6
  END SUBROUTINE METEO_PACK_FWV

  SUBROUTINE METEO_PACK(temp, rh)
    IMPLICIT NONE
    REAL(r8), INTENT(IN) :: temp
    REAL(r8), INTENT(IN) :: rh
    INTRINSIC EXP
    REAL(r8) :: arg1
! 0C 1.292
    density_air = rho_a
    arg1 = 17.3*temp/(237.3+temp)
    e_saturate = 0.61078*EXP(arg1)
    e_actual = e_saturate*rh/100.
    vpd = e_saturate - e_actual
    sp_humidity = 0.622*e_actual/(101.35-0.378*e_actual)
    cp_air = 1004.65*(1.+0.84*sp_humidity)
    arg1 = 17.27*temp/(temp+237.3)
    slope_vapor = 2503./(temp+237.3)**2*EXP(arg1)
    psy = 0.066
    latent_water = (2.501-0.00237*temp)*1e6
    latent_snow = 2.83*1e6
  END SUBROUTINE METEO_PACK

END MODULE METEOMOD_DIFFV

MODULE MID_RESULTS_DIFFV
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
!   real(r8)  :: COS_grnd2
  TYPE RESULTS
      REAL(r8) :: gpp_o_sunlit
      REAL(r8) :: gpp_u_sunlit
      REAL(r8) :: gpp_o_shaded
      REAL(r8) :: gpp_u_shaded
      REAL(r8) :: plant_resp
      REAL(r8) :: npp_o
      REAL(r8) :: npp_u
      REAL(r8) :: gpp
      REAL(r8) :: sif
      REAL(r8) :: npp
      REAL(r8) :: nep
      REAL(r8) :: soil_resp
      REAL(r8) :: net_rad
      REAL(r8) :: sh
      REAL(r8) :: lh
      REAL(r8) :: trans
      REAL(r8) :: evap
      REAL(r8) :: thetam_surf
      REAL(r8) :: cos_flux
      REAL(r8) :: lai
      REAL(r8) :: lai_old
      REAL(r8) :: lai_new
      REAL(r8) :: cos_plant
      REAL(r8) :: cos_grnd
      REAL(r8) :: fapar
  END TYPE RESULTS
  TYPE RESULTS_DIFFV
      REAL(r8), DIMENSION(nbdirsmax) :: sif
      REAL(r8), DIMENSION(nbdirsmax) :: trans
      REAL(r8), DIMENSION(nbdirsmax) :: thetam_surf
      REAL(r8), DIMENSION(nbdirsmax) :: lai_old
      REAL(r8), DIMENSION(nbdirsmax) :: lai_new
      REAL(r8), DIMENSION(nbdirsmax) :: cos_plant
      REAL(r8), DIMENSION(nbdirsmax) :: cos_grnd
  END TYPE RESULTS_DIFFV
! temperatre  (oC)
!solar radiation
!downward longwave radiation
!liquid water rainfall
!snow
!diffuse solar radiation
!direct solar radiation
  TYPE CLIMATEDATA
      REAL(r8) :: temp
      REAL(r8) :: srad
      REAL(r8) :: lr
      REAL(r8) :: rainfall
      REAL(r8) :: snow
      REAL(r8) :: s_dff
      REAL(r8) :: s_dir
      REAL(r8) :: rh
      REAL(r8) :: wind
      REAL(r8) :: tempmx
      REAL(r8) :: tempmn
  END TYPE CLIMATEDATA
!friction velocity, m s-1
!updated friction velocity with new H, m s-1
!absolute humidity, g m-3
!absolute humidity, kg m-3
!sensible heat flux, W M-2
!old sensible heat flux, W m-2
!air density, kg m-3
!absolute air temperature, K
!station pressure, kPa
!station pressure, bars
!pressure, Pa
!gas constant computations
!air density, mole m-3
!relative humidity, ea/es(T)
!vapor pressure deficit
!infrared flux density
!! These types are adapted from DB.h, but many variables are not used @J.Wang
!! Importantly, these three types are only used by photosynthesis module.
  TYPE METEOROLOGY
      REAL(r8) :: ustar
      REAL(r8) :: ustarnew
      REAL(r8) :: rhova_g
      REAL(r8) :: rhova_kg
      REAL(r8) :: sensible_heat_flux
      REAL(r8) :: h_old
      REAL(r8) :: air_density
      REAL(r8) :: t_kelvin
      REAL(r8) :: press_kpa
      REAL(r8) :: press_bars
      REAL(r8) :: press_pa
      REAL(r8) :: pstat273
      REAL(r8) :: air_density_mole
      REAL(r8) :: relative_humidity
      REAL(r8) :: vpd
      REAL(r8) :: ir_in
  END TYPE METEOROLOGY
!latent heat of vaporization, J kg-1
!latent heat of vaporization times molecular mass of vapor, 18 g mol-1
!factor for sensible heat flux density
!filter coefficients
!filter coefficients
!CO2 factor, ma/mc * rhoa (mole m-3)
  TYPE FACTORS
      REAL(r8) :: latent
      REAL(r8) :: latent18
      REAL(r8) :: heatcoef
      REAL(r8) :: a_filt
      REAL(r8) :: b_filt
      REAL(r8) :: co2
  END TYPE FACTORS
  TYPE FACTORS_DIFFV
      REAL(r8), DIMENSION(nbdirsmax) :: latent
  END TYPE FACTORS_DIFFV
!resistance for water vapor, s/m
!resistance for heat, s/m
!resistance for CO2, s/m
  TYPE BOUNDARY_LAYER_RESISTANCES
      REAL(r8) :: vapor
      REAL(r8) :: heat
      REAL(r8) :: co2
  END TYPE BOUNDARY_LAYER_RESISTANCES
  TYPE BOUNDARY_LAYER_RESISTANCES_DIFFV
      REAL(r8), DIMENSION(nbdirsmax) :: vapor
  END TYPE BOUNDARY_LAYER_RESISTANCES_DIFFV

CONTAINS
!-- iLab::added for debugging purpose
  SUBROUTINE MIDRES_DUMP(midres, fmt)
    IMPLICIT NONE
    TYPE(RESULTS), INTENT(IN) :: midres
    CHARACTER(len=*), INTENT(IN), OPTIONAL :: fmt
!-- local
    CHARACTER(len=16) :: r8_fmt
    INTRINSIC PRESENT
    INTRINSIC TRIM
    IF (PRESENT(fmt)) THEN
      r8_fmt = '(a15,'//TRIM(fmt)//')'
    ELSE
      r8_fmt = '(a15,e25.16)'
    END IF
    WRITE(*, r8_fmt) 'gpp_o_sunlit=', midres%gpp_o_sunlit
    WRITE(*, r8_fmt) 'gpp_u_sunlit=', midres%gpp_u_sunlit
    WRITE(*, r8_fmt) 'gpp_o_shaded=', midres%gpp_o_shaded
    WRITE(*, r8_fmt) 'gpp_u_shaded=', midres%gpp_u_shaded
    WRITE(*, r8_fmt) 'plant_resp=', midres%plant_resp
    WRITE(*, r8_fmt) 'npp_o=', midres%npp_o
    WRITE(*, r8_fmt) 'npp_u=', midres%npp_u
    WRITE(*, r8_fmt) 'GPP=', midres%gpp
    WRITE(*, r8_fmt) 'SIF=', midres%sif
    WRITE(*, r8_fmt) 'NPP=', midres%npp
    WRITE(*, r8_fmt) 'NEP=', midres%nep
    WRITE(*, r8_fmt) 'soil_resp=', midres%soil_resp
    WRITE(*, r8_fmt) 'Net_Rad=', midres%net_rad
    WRITE(*, r8_fmt) 'SH=', midres%sh
    WRITE(*, r8_fmt) 'LH=', midres%lh
    WRITE(*, r8_fmt) 'Trans=', midres%trans
    WRITE(*, r8_fmt) 'Evap=', midres%evap
    WRITE(*, r8_fmt) 'thetam_surf=', midres%thetam_surf
    WRITE(*, r8_fmt) 'COS_flux=', midres%cos_flux
    WRITE(*, r8_fmt) 'lai=', midres%lai
    WRITE(*, r8_fmt) 'lai_old=', midres%lai_old
    WRITE(*, r8_fmt) 'lai_new=', midres%lai_new
    WRITE(*, r8_fmt) 'COS_plant=', midres%cos_plant
    WRITE(*, r8_fmt) 'COS_grnd=', midres%cos_grnd
!write(*, r8_fmt) 'COS_grnd2=',midres%COS_grnd2
    WRITE(*, r8_fmt) 'fapar=', midres%fapar
  END SUBROUTINE MIDRES_DUMP

END MODULE MID_RESULTS_DIFFV

!***************************************************
! Function : calculate the photosyntheis,leaf temp,
!            and the evapotraspiration
! created  : Jun Wang
! Date     : 2016/12/5
!***************************************************
MODULE ANGSMOD_DIFFV
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE BEPS_CON
  USE BEPS_PAR
  USE MID_RESULTS_DIFFV
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
  TYPE(METEOROLOGY) :: met
  TYPE(FACTORS) :: fact
  TYPE(FACTORS_DIFFV) :: fact_fw
  TYPE(BOUNDARY_LAYER_RESISTANCES) :: bound_layer_res
  TYPE(BOUNDARY_LAYER_RESISTANCES_DIFFV) :: bound_layer_res_fw
  PUBLIC :: lai_cal, vcmax_jmax, photosynthesis, transpiration, &
& evaporation_canopy
  PUBLIC :: lai_cal_fwv, vcmax_jmax_fwv, photosynthesis_fwv, &
& transpiration_fwv, evaporation_canopy_fwv

CONTAINS
!  Differentiation of lai_cal in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: pai_o_shaded pai_u_sunlit lai_o_sunlit
!                pai_u_shaded lai_o_shaded lai_u_sunlit lai_u_shaded
!                pai_o_sunlit
!   with respect to varying inputs: lai_o lai_u
  SUBROUTINE LAI_CAL_FWV(stem_o, stem_u, lc, coszs, lai_o, lai_o_fw, &
&   clumping, lai_u, lai_u_fw, lai_o_sunlit, lai_o_sunlit_fw, &
&   lai_o_shaded, lai_o_shaded_fw, lai_u_sunlit, lai_u_sunlit_fw, &
&   lai_u_shaded, lai_u_shaded_fw, pai_o_sunlit, pai_o_sunlit_fw, &
&   pai_o_shaded, pai_o_shaded_fw, pai_u_sunlit, pai_u_sunlit_fw, &
&   pai_u_shaded, pai_u_shaded_fw, nbdirs)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
!overstory woody area
    REAL(r8) :: stem_o
!understory woody area
    REAL(r8) :: stem_u
!landcover type
    INTEGER :: lc
!cosine solar zenith angle
    REAL(r8) :: coszs
!overstory lai
    REAL(r8) :: lai_o
    REAL(r8), DIMENSION(nbdirsmax) :: lai_o_fw
!clumping index
    REAL(r8) :: clumping
!understory lai
    REAL(r8) :: lai_u
    REAL(r8), DIMENSION(nbdirsmax) :: lai_u_fw
!overstory sunlit lai
    REAL(r8) :: lai_o_sunlit
    REAL(r8), DIMENSION(nbdirsmax) :: lai_o_sunlit_fw
!overstory shaded lai
    REAL(r8) :: lai_o_shaded
    REAL(r8), DIMENSION(nbdirsmax) :: lai_o_shaded_fw
! understory sunlit lai
    REAL(r8) :: lai_u_sunlit
    REAL(r8), DIMENSION(nbdirsmax) :: lai_u_sunlit_fw
!understory shaded lai
    REAL(r8) :: lai_u_shaded
    REAL(r8), DIMENSION(nbdirsmax) :: lai_u_shaded_fw
!overstory sunlit lai
    REAL(r8) :: pai_o_sunlit
    REAL(r8), DIMENSION(nbdirsmax) :: pai_o_sunlit_fw
!overstory shaded lai
    REAL(r8) :: pai_o_shaded
    REAL(r8), DIMENSION(nbdirsmax) :: pai_o_shaded_fw
!understory sunlit lai
    REAL(r8) :: pai_u_sunlit
    REAL(r8), DIMENSION(nbdirsmax) :: pai_u_sunlit_fw
!understory shaded lai
    REAL(r8) :: pai_u_shaded
    REAL(r8), DIMENSION(nbdirsmax) :: pai_u_shaded_fw
    REAL(r8) :: temp
    INTRINSIC EXP
    INTRINSIC MAX
    REAL(r8) :: arg1
    REAL(r8), DIMENSION(nbdirsmax) :: arg1_fw
    INTEGER :: nd
    INTEGER :: nbdirs
    IF (coszs .GT. 0) THEN
      temp = -(0.5*clumping*(lai_o+stem_o)/coszs)
      IF (temp .LT. -10) THEN
        pai_o_sunlit = 2*coszs
        pai_o_sunlit_fw(:) = 0.0_8
      ELSE
        arg1 = -(0.5*clumping*(lai_o+stem_o)/coszs)
        DO nd=1,nbdirs
          arg1_fw(nd) = -(clumping*0.5*lai_o_fw(nd)/coszs)
          pai_o_sunlit_fw(nd) = -(coszs*2*EXP(arg1)*arg1_fw(nd))
        END DO
        pai_o_sunlit = 2*coszs*(1-EXP(arg1))
      END IF
    ELSE
      pai_o_sunlit = 0
      pai_o_sunlit_fw(:) = 0.0_8
    END IF
    DO nd=1,nbdirs
      pai_o_shaded_fw(nd) = lai_o_fw(nd) - pai_o_sunlit_fw(nd)
    END DO
    pai_o_shaded = lai_o + stem_o - pai_o_sunlit
    IF (coszs .GT. 0) THEN
      temp = -(0.5*clumping*(lai_o+stem_o+lai_u+stem_u)/coszs)
      IF (temp .LT. -10) THEN
        DO nd=1,nbdirs
          pai_u_sunlit_fw(nd) = -pai_o_sunlit_fw(nd)
        END DO
        pai_u_sunlit = 2*coszs - pai_o_sunlit
      ELSE
        arg1 = -(0.5*clumping*(lai_o+stem_o+lai_u+stem_u)/coszs)
        DO nd=1,nbdirs
          arg1_fw(nd) = -(clumping*0.5*(lai_o_fw(nd)+lai_u_fw(nd))/coszs&
&           )
          pai_u_sunlit_fw(nd) = -(coszs*2*EXP(arg1)*arg1_fw(nd)) - &
&           pai_o_sunlit_fw(nd)
        END DO
        pai_u_sunlit = 2*coszs*(1-EXP(arg1)) - pai_o_sunlit
      END IF
    ELSE
      pai_u_sunlit = 0
      pai_u_sunlit_fw(:) = 0.0_8
    END IF
    DO nd=1,nbdirs
      pai_u_shaded_fw(nd) = lai_u_fw(nd) - pai_u_sunlit_fw(nd)
    END DO
    pai_u_shaded = lai_u + stem_u - pai_u_sunlit
    IF (coszs .GT. 0) THEN
      temp = -(0.5*clumping*lai_o/coszs)
      IF (temp .LT. -10) THEN
        lai_o_sunlit = 2*coszs
        lai_o_sunlit_fw(:) = 0.0_8
      ELSE
        arg1 = -(0.5*clumping*lai_o/coszs)
        DO nd=1,nbdirs
          arg1_fw(nd) = -(clumping*0.5*lai_o_fw(nd)/coszs)
          lai_o_sunlit_fw(nd) = -(coszs*2*EXP(arg1)*arg1_fw(nd))
        END DO
        lai_o_sunlit = 2*coszs*(1-EXP(arg1))
      END IF
    ELSE
      lai_o_sunlit = 0
      lai_o_sunlit_fw(:) = 0.0_8
    END IF
    IF (0. .LT. lai_o - pai_o_sunlit) THEN
      DO nd=1,nbdirs
        lai_o_shaded_fw(nd) = lai_o_fw(nd) - pai_o_sunlit_fw(nd)
      END DO
      lai_o_shaded = lai_o - pai_o_sunlit
    ELSE
      lai_o_shaded = 0.
      lai_o_shaded_fw(:) = 0.0_8
    END IF
    IF (coszs .GT. 0) THEN
      temp = -(0.5*clumping*(lai_o+lai_u)/coszs)
      IF (temp .LT. -10) THEN
        DO nd=1,nbdirs
          lai_u_sunlit_fw(nd) = -lai_o_sunlit_fw(nd)
        END DO
        lai_u_sunlit = 2*coszs - lai_o_sunlit
      ELSE
        arg1 = -(0.5*clumping*(lai_o+lai_u)/coszs)
        DO nd=1,nbdirs
          arg1_fw(nd) = -(clumping*0.5*(lai_o_fw(nd)+lai_u_fw(nd))/coszs&
&           )
          lai_u_sunlit_fw(nd) = -(coszs*2*EXP(arg1)*arg1_fw(nd)) - &
&           lai_o_sunlit_fw(nd)
        END DO
        lai_u_sunlit = 2*coszs*(1-EXP(arg1)) - lai_o_sunlit
      END IF
    ELSE
      lai_u_sunlit = 0
      lai_u_sunlit_fw(:) = 0.0_8
    END IF
    IF (0. .LT. lai_u - pai_u_sunlit) THEN
      DO nd=1,nbdirs
        lai_u_shaded_fw(nd) = lai_u_fw(nd) - pai_u_sunlit_fw(nd)
      END DO
      lai_u_shaded = lai_u - pai_u_sunlit
    ELSE
      lai_u_shaded = 0.
      lai_u_shaded_fw(:) = 0.0_8
    END IF
  END SUBROUTINE LAI_CAL_FWV

  SUBROUTINE LAI_CAL(stem_o, stem_u, lc, coszs, lai_o, clumping, lai_u, &
&   lai_o_sunlit, lai_o_shaded, lai_u_sunlit, lai_u_shaded, pai_o_sunlit&
&   , pai_o_shaded, pai_u_sunlit, pai_u_shaded)
    IMPLICIT NONE
!overstory woody area
    REAL(r8) :: stem_o
!understory woody area
    REAL(r8) :: stem_u
!landcover type
    INTEGER :: lc
!cosine solar zenith angle
    REAL(r8) :: coszs
!overstory lai
    REAL(r8) :: lai_o
!clumping index
    REAL(r8) :: clumping
!understory lai
    REAL(r8) :: lai_u
!overstory sunlit lai
    REAL(r8) :: lai_o_sunlit
!overstory shaded lai
    REAL(r8) :: lai_o_shaded
! understory sunlit lai
    REAL(r8) :: lai_u_sunlit
!understory shaded lai
    REAL(r8) :: lai_u_shaded
!overstory sunlit lai
    REAL(r8) :: pai_o_sunlit
!overstory shaded lai
    REAL(r8) :: pai_o_shaded
!understory sunlit lai
    REAL(r8) :: pai_u_sunlit
!understory shaded lai
    REAL(r8) :: pai_u_shaded
    REAL(r8) :: temp
    INTRINSIC EXP
    INTRINSIC MAX
    REAL(r8) :: arg1
    IF (coszs .GT. 0) THEN
      temp = -(0.5*clumping*(lai_o+stem_o)/coszs)
      IF (temp .LT. -10) THEN
        pai_o_sunlit = 2*coszs
      ELSE
        arg1 = -(0.5*clumping*(lai_o+stem_o)/coszs)
        pai_o_sunlit = 2*coszs*(1-EXP(arg1))
      END IF
    ELSE
      pai_o_sunlit = 0
    END IF
    pai_o_shaded = lai_o + stem_o - pai_o_sunlit
    IF (coszs .GT. 0) THEN
      temp = -(0.5*clumping*(lai_o+stem_o+lai_u+stem_u)/coszs)
      IF (temp .LT. -10) THEN
        pai_u_sunlit = 2*coszs - pai_o_sunlit
      ELSE
        arg1 = -(0.5*clumping*(lai_o+stem_o+lai_u+stem_u)/coszs)
        pai_u_sunlit = 2*coszs*(1-EXP(arg1)) - pai_o_sunlit
      END IF
    ELSE
      pai_u_sunlit = 0
    END IF
    pai_u_shaded = lai_u + stem_u - pai_u_sunlit
    IF (coszs .GT. 0) THEN
      temp = -(0.5*clumping*lai_o/coszs)
      IF (temp .LT. -10) THEN
        lai_o_sunlit = 2*coszs
      ELSE
        arg1 = -(0.5*clumping*lai_o/coszs)
        lai_o_sunlit = 2*coszs*(1-EXP(arg1))
      END IF
    ELSE
      lai_o_sunlit = 0
    END IF
    IF (0. .LT. lai_o - pai_o_sunlit) THEN
      lai_o_shaded = lai_o - pai_o_sunlit
    ELSE
      lai_o_shaded = 0.
    END IF
    IF (coszs .GT. 0) THEN
      temp = -(0.5*clumping*(lai_o+lai_u)/coszs)
      IF (temp .LT. -10) THEN
        lai_u_sunlit = 2*coszs - lai_o_sunlit
      ELSE
        arg1 = -(0.5*clumping*(lai_o+lai_u)/coszs)
        lai_u_sunlit = 2*coszs*(1-EXP(arg1)) - lai_o_sunlit
      END IF
    ELSE
      lai_u_sunlit = 0
    END IF
    IF (0. .LT. lai_u - pai_u_sunlit) THEN
      lai_u_shaded = lai_u - pai_u_sunlit
    ELSE
      lai_u_shaded = 0.
    END IF
  END SUBROUTINE LAI_CAL

!  Differentiation of vcmax_jmax in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: lai_o vcmax_sunlit vcmax_shaded
!   with respect to varying inputs: vcmax0 lai_o
!*************************************************************************************************
! Subroutine to calculate the Vcmax and Jmax for sunlit and shaded big-leaf
! Reference:
!       (1) Chen, J. M., G. Mo, J. Pisek, F. Deng, M. Ishozawa, D. Chan, 2012.
!       Effects of foliage clumping on global terrestrial gross primary
!       productivity. Global Biogeochemical Cycles, VOL. 26, GB1019, 18,
!       doi:10.1029/2010GB003996
!       (2) Medlyn, B.E. et al., 1999. Effects of elevated [CO2] on photosynthesis
!   in European forest species: a meta-analysis of model parameters.
!   Plant, Cell & Environment, 22(12): 1475-1495.
!*************************************************************************************************
  SUBROUTINE VCMAX_JMAX_FWV(lai_o, lai_o_fw, clumping, vcmax0, vcmax0_fw&
&   , vj_slope, slope_vcmax_n, leaf_n, coszs, vcmax_sunlit, &
&   vcmax_sunlit_fw, vcmax_shaded, vcmax_shaded_fw, jmax_sunlit, &
&   jmax_shaded, nbdirs)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
    REAL(r8) :: lai_o, clumping, vcmax0, slope_vcmax_n
    REAL(r8), DIMENSION(nbdirsmax) :: lai_o_fw, vcmax0_fw
    REAL(r8) :: leaf_n, coszs
    REAL(r8) :: vcmax_sunlit, vcmax_shaded
    REAL(r8), DIMENSION(nbdirsmax) :: vcmax_sunlit_fw, vcmax_shaded_fw
    REAL(r8) :: jmax_sunlit, jmax_shaded
    REAL(r8) :: vj_slope
    REAL(r8) :: k, expr1, expr2, expr3
    REAL(r8), DIMENSION(nbdirsmax) :: expr1_fw, expr2_fw, expr3_fw
    REAL(r8), PARAMETER :: kn=0.3
    REAL(r8), PARAMETER :: g_theta=0.5
    INTRINSIC EXP
    REAL(r8) :: arg1
    REAL(r8), DIMENSION(nbdirsmax) :: arg1_fw
    INTEGER :: nd
    REAL(r8) :: temp
    REAL(r8) :: temp0
    REAL(r8) :: temp1
    INTEGER :: nbdirs
    IF (lai_o .LT. 0.001) THEN
      lai_o = 0.001
      lai_o_fw(:) = 0.0_8
    END IF
    IF (coszs .GT. 0) THEN
      k = g_theta*clumping/coszs
      IF (k .GT. 10) THEN
        expr1 = 1.
        expr2 = 1.
        expr1_fw(:) = 0.0_8
        expr2_fw(:) = 0.0_8
      ELSE
        arg1 = -(k*lai_o)
        DO nd=1,nbdirs
          arg1_fw(nd) = -(k*lai_o_fw(nd))
          expr1_fw(nd) = -(EXP(arg1)*arg1_fw(nd))
          arg1_fw(nd) = -((kn+k)*lai_o_fw(nd))
        END DO
        expr1 = 1 - EXP(arg1)
        arg1 = -((kn+k)*lai_o)
        DO nd=1,nbdirs
          expr2_fw(nd) = -(EXP(arg1)*arg1_fw(nd))
        END DO
        expr2 = 1 - EXP(arg1)
      END IF
      arg1 = -(kn*lai_o)
      DO nd=1,nbdirs
        arg1_fw(nd) = -(kn*lai_o_fw(nd))
        expr3_fw(nd) = -(EXP(arg1)*arg1_fw(nd))
      END DO
      expr3 = 1 - EXP(arg1)
      IF (expr1 .GT. 0) THEN
        temp = slope_vcmax_n*leaf_n*k
        temp0 = vcmax0*expr2/((kn+k)*expr1)
        DO nd=1,nbdirs
          vcmax_sunlit_fw(nd) = temp*(expr2*vcmax0_fw(nd)+vcmax0*&
&           expr2_fw(nd)-temp0*(kn+k)*expr1_fw(nd))/((kn+k)*expr1)
        END DO
        vcmax_sunlit = temp*temp0
      ELSE
        DO nd=1,nbdirs
          vcmax_sunlit_fw(nd) = vcmax0_fw(nd)
        END DO
        vcmax_sunlit = vcmax0
      END IF
      IF (k .GT. 0 .AND. lai_o .GT. expr1/k) THEN
        temp0 = lai_o - expr1/k
        temp = vcmax0/temp0
        temp1 = expr3/kn - expr2/(kn+k)
        DO nd=1,nbdirs
          vcmax_shaded_fw(nd) = slope_vcmax_n*leaf_n*(temp*(expr3_fw(nd)&
&           /kn-expr2_fw(nd)/(kn+k))+temp1*(vcmax0_fw(nd)-temp*(lai_o_fw&
&           (nd)-expr1_fw(nd)/k))/temp0)
        END DO
        vcmax_shaded = slope_vcmax_n*leaf_n*(temp1*temp)
      ELSE
        DO nd=1,nbdirs
          vcmax_shaded_fw(nd) = vcmax0_fw(nd)
        END DO
        vcmax_shaded = vcmax0
      END IF
    ELSE
      DO nd=1,nbdirs
        vcmax_sunlit_fw(nd) = vcmax0_fw(nd)
        vcmax_shaded_fw(nd) = vcmax0_fw(nd)
      END DO
      vcmax_sunlit = vcmax0
      vcmax_shaded = vcmax0
    END IF
    jmax_sunlit = vcmax_sunlit*2.39 - 14.2
    jmax_shaded = vcmax_shaded*2.39 - 14.2
  END SUBROUTINE VCMAX_JMAX_FWV

!*************************************************************************************************
! Subroutine to calculate the Vcmax and Jmax for sunlit and shaded big-leaf
! Reference:
!       (1) Chen, J. M., G. Mo, J. Pisek, F. Deng, M. Ishozawa, D. Chan, 2012.
!       Effects of foliage clumping on global terrestrial gross primary
!       productivity. Global Biogeochemical Cycles, VOL. 26, GB1019, 18,
!       doi:10.1029/2010GB003996
!       (2) Medlyn, B.E. et al., 1999. Effects of elevated [CO2] on photosynthesis
!   in European forest species: a meta-analysis of model parameters.
!   Plant, Cell & Environment, 22(12): 1475-1495.
!*************************************************************************************************
  SUBROUTINE VCMAX_JMAX(lai_o, clumping, vcmax0, vj_slope, slope_vcmax_n&
&   , leaf_n, coszs, vcmax_sunlit, vcmax_shaded, jmax_sunlit, &
&   jmax_shaded)
    IMPLICIT NONE
    REAL(r8) :: lai_o, clumping, vcmax0, slope_vcmax_n
    REAL(r8) :: leaf_n, coszs
    REAL(r8) :: vcmax_sunlit, vcmax_shaded
    REAL(r8) :: jmax_sunlit, jmax_shaded
    REAL(r8) :: vj_slope
    REAL(r8) :: k, expr1, expr2, expr3
    REAL(r8), PARAMETER :: kn=0.3
    REAL(r8), PARAMETER :: g_theta=0.5
    INTRINSIC EXP
    REAL(r8) :: arg1
    IF (lai_o .LT. 0.001) lai_o = 0.001
    IF (coszs .GT. 0) THEN
      k = g_theta*clumping/coszs
      IF (k .GT. 10) THEN
        expr1 = 1.
        expr2 = 1.
      ELSE
        arg1 = -(k*lai_o)
        expr1 = 1 - EXP(arg1)
        arg1 = -((kn+k)*lai_o)
        expr2 = 1 - EXP(arg1)
      END IF
      arg1 = -(kn*lai_o)
      expr3 = 1 - EXP(arg1)
      IF (expr1 .GT. 0) THEN
        vcmax_sunlit = vcmax0*slope_vcmax_n*leaf_n*k*expr2/(kn+k)/expr1
      ELSE
        vcmax_sunlit = vcmax0
      END IF
      IF (k .GT. 0 .AND. lai_o .GT. expr1/k) THEN
        vcmax_shaded = vcmax0*slope_vcmax_n*leaf_n*(expr3/kn-expr2/(kn+k&
&         ))/(lai_o-expr1/k)
      ELSE
        vcmax_shaded = vcmax0
      END IF
    ELSE
      vcmax_sunlit = vcmax0
      vcmax_shaded = vcmax0
    END IF
    jmax_sunlit = vcmax_sunlit*2.39 - 14.2
    jmax_shaded = vcmax_shaded*2.39 - 14.2
  END SUBROUTINE VCMAX_JMAX

!  Differentiation of leaf_temperatures in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: tc_o_sunlit tc_o_shaded tc_u_sunlit
!                tc_u_shaded
!   with respect to varying inputs: xcs_o gh_o_sunlit xcs_u gh_o_shaded
!                gh_u_sunlit gww_o_sunlit radiation_o_shaded gw_o_sunlit
!                gh_u_shaded gww_o_shaded gw_o_shaded radiation_u_shaded
!                gw_u_sunlit gww_u_sunlit gw_u_shaded gww_u_shaded
!                radiation_o_sun xcl_o xcl_u radiation_u_sun
  SUBROUTINE LEAF_TEMPERATURES_FWV(tair, slope, psychrometer, vpd_air, &
&   cp_ca, gw_o_sunlit, gw_o_sunlit_fw, gw_o_shaded, gw_o_shaded_fw, &
&   gw_u_sunlit, gw_u_sunlit_fw, gw_u_shaded, gw_u_shaded_fw, &
&   gww_o_sunlit, gww_o_sunlit_fw, gww_o_shaded, gww_o_shaded_fw, &
&   gww_u_sunlit, gww_u_sunlit_fw, gww_u_shaded, gww_u_shaded_fw, &
&   gh_o_sunlit, gh_o_sunlit_fw, gh_o_shaded, gh_o_shaded_fw, &
&   gh_u_sunlit, gh_u_sunlit_fw, gh_u_shaded, gh_u_shaded_fw, xcs_o, &
&   xcs_o_fw, xcl_o, xcl_o_fw, xcs_u, xcs_u_fw, xcl_u, xcl_u_fw, &
&   radiation_o_sun, radiation_o_sun_fw, radiation_o_shaded, &
&   radiation_o_shaded_fw, radiation_u_sun, radiation_u_sun_fw, &
&   radiation_u_shaded, radiation_u_shaded_fw, tc_o_sunlit, &
&   tc_o_sunlit_fw, tc_o_shaded, tc_o_shaded_fw, tc_u_sunlit, &
&   tc_u_sunlit_fw, tc_u_shaded, tc_u_shaded_fw, nbdirs)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
!*************************************************************************
! Subroutine to calculate the sunlit and shaded leaf temperatures for
! overstory and understory leave.
!*************************************************************************
    REAL(r8) :: tair, slope, psychrometer, vpd_air, cp_ca
    REAL(r8) :: gw_o_sunlit, gw_o_shaded, gw_u_sunlit, gw_u_shaded
    REAL(r8), DIMENSION(nbdirsmax) :: gw_o_sunlit_fw, gw_o_shaded_fw, &
&   gw_u_sunlit_fw, gw_u_shaded_fw
    REAL(r8) :: gww_o_sunlit, gww_o_shaded, gww_u_sunlit, gww_u_shaded
    REAL(r8), DIMENSION(nbdirsmax) :: gww_o_sunlit_fw, gww_o_shaded_fw, &
&   gww_u_sunlit_fw, gww_u_shaded_fw
    REAL(r8) :: gh_o_sunlit, gh_o_shaded, gh_u_sunlit, gh_u_shaded
    REAL(r8), DIMENSION(nbdirsmax) :: gh_o_sunlit_fw, gh_o_shaded_fw, &
&   gh_u_sunlit_fw, gh_u_shaded_fw
    REAL(r8) :: xcs_o, xcl_o, xcs_u, xcl_u
    REAL(r8), DIMENSION(nbdirsmax) :: xcs_o_fw, xcl_o_fw, xcs_u_fw, &
&   xcl_u_fw
    REAL(r8) :: radiation_o_sun, radiation_o_shaded, radiation_u_sun, &
&   radiation_u_shaded
    REAL(r8), DIMENSION(nbdirsmax) :: radiation_o_sun_fw, &
&   radiation_o_shaded_fw, radiation_u_sun_fw, radiation_u_shaded_fw
    REAL(r8) :: tc_o_sunlit, tc_o_shaded, tc_u_sunlit, tc_u_shaded
    REAL(r8), DIMENSION(nbdirsmax) :: tc_o_sunlit_fw, tc_o_shaded_fw, &
&   tc_u_sunlit_fw, tc_u_shaded_fw
    INTEGER :: nbdirs
    CALL LEAF_TEMPERATURE_FWV(tair, slope, psychrometer, vpd_air, cp_ca&
&                       , gw_o_sunlit, gw_o_sunlit_fw, gww_o_sunlit, &
&                       gww_o_sunlit_fw, gh_o_sunlit, gh_o_sunlit_fw, &
&                       xcs_o, xcs_o_fw, xcl_o, xcl_o_fw, &
&                       radiation_o_sun, radiation_o_sun_fw, tc_o_sunlit&
&                       , tc_o_sunlit_fw, nbdirs)
    CALL LEAF_TEMPERATURE_FWV(tair, slope, psychrometer, vpd_air, cp_ca&
&                       , gw_o_shaded, gw_o_shaded_fw, gww_o_shaded, &
&                       gww_o_shaded_fw, gh_o_shaded, gh_o_shaded_fw, &
&                       xcs_o, xcs_o_fw, xcl_o, xcl_o_fw, &
&                       radiation_o_shaded, radiation_o_shaded_fw, &
&                       tc_o_shaded, tc_o_shaded_fw, nbdirs)
    CALL LEAF_TEMPERATURE_FWV(tair, slope, psychrometer, vpd_air, cp_ca&
&                       , gw_u_sunlit, gw_u_sunlit_fw, gww_u_sunlit, &
&                       gww_u_sunlit_fw, gh_u_sunlit, gh_u_sunlit_fw, &
&                       xcs_u, xcs_u_fw, xcl_u, xcl_u_fw, &
&                       radiation_u_sun, radiation_u_sun_fw, tc_u_sunlit&
&                       , tc_u_sunlit_fw, nbdirs)
    CALL LEAF_TEMPERATURE_FWV(tair, slope, psychrometer, vpd_air, cp_ca&
&                       , gw_u_shaded, gw_u_shaded_fw, gww_u_shaded, &
&                       gww_u_shaded_fw, gh_u_shaded, gh_u_shaded_fw, &
&                       xcs_u, xcs_u_fw, xcl_u, xcl_u_fw, &
&                       radiation_u_shaded, radiation_u_shaded_fw, &
&                       tc_u_shaded, tc_u_shaded_fw, nbdirs)
  END SUBROUTINE LEAF_TEMPERATURES_FWV

  SUBROUTINE LEAF_TEMPERATURES(tair, slope, psychrometer, vpd_air, cp_ca&
&   , gw_o_sunlit, gw_o_shaded, gw_u_sunlit, gw_u_shaded, gww_o_sunlit, &
&   gww_o_shaded, gww_u_sunlit, gww_u_shaded, gh_o_sunlit, gh_o_shaded, &
&   gh_u_sunlit, gh_u_shaded, xcs_o, xcl_o, xcs_u, xcl_u, &
&   radiation_o_sun, radiation_o_shaded, radiation_u_sun, &
&   radiation_u_shaded, tc_o_sunlit, tc_o_shaded, tc_u_sunlit, &
&   tc_u_shaded)
    IMPLICIT NONE
!*************************************************************************
! Subroutine to calculate the sunlit and shaded leaf temperatures for
! overstory and understory leave.
!*************************************************************************
    REAL(r8) :: tair, slope, psychrometer, vpd_air, cp_ca
    REAL(r8) :: gw_o_sunlit, gw_o_shaded, gw_u_sunlit, gw_u_shaded
    REAL(r8) :: gww_o_sunlit, gww_o_shaded, gww_u_sunlit, gww_u_shaded
    REAL(r8) :: gh_o_sunlit, gh_o_shaded, gh_u_sunlit, gh_u_shaded
    REAL(r8) :: xcs_o, xcl_o, xcs_u, xcl_u
    REAL(r8) :: radiation_o_sun, radiation_o_shaded, radiation_u_sun, &
&   radiation_u_shaded
    REAL(r8) :: tc_o_sunlit, tc_o_shaded, tc_u_sunlit, tc_u_shaded
    CALL LEAF_TEMPERATURE(tair, slope, psychrometer, vpd_air, cp_ca, &
&                   gw_o_sunlit, gww_o_sunlit, gh_o_sunlit, xcs_o, xcl_o&
&                   , radiation_o_sun, tc_o_sunlit)
    CALL LEAF_TEMPERATURE(tair, slope, psychrometer, vpd_air, cp_ca, &
&                   gw_o_shaded, gww_o_shaded, gh_o_shaded, xcs_o, xcl_o&
&                   , radiation_o_shaded, tc_o_shaded)
    CALL LEAF_TEMPERATURE(tair, slope, psychrometer, vpd_air, cp_ca, &
&                   gw_u_sunlit, gww_u_sunlit, gh_u_sunlit, xcs_u, xcl_u&
&                   , radiation_u_sun, tc_u_sunlit)
    CALL LEAF_TEMPERATURE(tair, slope, psychrometer, vpd_air, cp_ca, &
&                   gw_u_shaded, gww_u_shaded, gh_u_shaded, xcs_u, xcl_u&
&                   , radiation_u_shaded, tc_u_shaded)
  END SUBROUTINE LEAF_TEMPERATURES

!  Differentiation of leaf_temperature in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: tc
!   with respect to varying inputs: xcs gw radiation gww xcl gh
  SUBROUTINE LEAF_TEMPERATURE_FWV(tair, slope, psychrometer, vpd_air, &
&   cp_ca, gw, gw_fw, gww, gww_fw, gh, gh_fw, xcs, xcs_fw, xcl, xcl_fw, &
&   radiation, radiation_fw, tc, tc_fw, nbdirs)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
    REAL(r8) :: tair, slope, psychrometer, vpd_air, cp_ca
    REAL(r8) :: gw, gww, gh, xcs, xcl, radiation
    REAL(r8), DIMENSION(nbdirsmax) :: gw_fw, gww_fw, gh_fw, xcs_fw, &
&   xcl_fw, radiation_fw
    REAL(r8) :: p_star, tc, r
    REAL(r8), DIMENSION(nbdirsmax) :: p_star_fw, tc_fw
    INTRINSIC MAX
    INTRINSIC MIN
    INTEGER :: nd
    REAL(r8) :: temp
    REAL(r8) :: temp0
    INTEGER :: nbdirs
    p_star = (gw+gww*(xcs+xcl))/psychrometer
    temp = rho_a*cp_ca*(gh+slope*p_star)
    temp0 = (radiation-vpd_air*rho_a*cp_ca*p_star)/temp
    DO nd=1,nbdirs
!    R = 1. / Gw + 1. / (Gww* (Xcs + Xcl))
      p_star_fw(nd) = (gw_fw(nd)+(xcs+xcl)*gww_fw(nd)+gww*(xcs_fw(nd)+&
&       xcl_fw(nd)))/psychrometer
      tc_fw(nd) = (radiation_fw(nd)-vpd_air*rho_a*cp_ca*p_star_fw(nd)-&
&       temp0*rho_a*cp_ca*(gh_fw(nd)+slope*p_star_fw(nd)))/temp
    END DO
    tc = tair + temp0
    IF (tair - 3.0 .LT. tc) THEN
      tc = tc
    ELSE
      tc = tair - 3.0
      tc_fw(:) = 0.0_8
    END IF
    IF (tair + 5.0 .GT. tc) THEN
      tc = tc
    ELSE
      tc = tair + 5.0
      tc_fw(:) = 0.0_8
    END IF
  END SUBROUTINE LEAF_TEMPERATURE_FWV

  SUBROUTINE LEAF_TEMPERATURE(tair, slope, psychrometer, vpd_air, cp_ca&
&   , gw, gww, gh, xcs, xcl, radiation, tc)
    IMPLICIT NONE
    REAL(r8) :: tair, slope, psychrometer, vpd_air, cp_ca
    REAL(r8) :: gw, gww, gh, xcs, xcl, radiation
    REAL(r8) :: p_star, tc, r
    INTRINSIC MAX
    INTRINSIC MIN
!    R = 1. / Gw + 1. / (Gww* (Xcs + Xcl))
    p_star = (gw+gww*(xcs+xcl))/psychrometer
    tc = tair + (radiation-vpd_air*rho_a*cp_ca*p_star)/(rho_a*cp_ca*(gh+&
&     slope*p_star))
    IF (tair - 3.0 .LT. tc) THEN
      tc = tc
    ELSE
      tc = tair - 3.0
    END IF
    IF (tair + 5.0 .GT. tc) THEN
      tc = tc
    ELSE
      tc = tair + 5.0
    END IF
  END SUBROUTINE LEAF_TEMPERATURE

!  Differentiation of transpiration in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: trans_o trans_u
!   with respect to varying inputs: lai_o_sunlit templ_o_sunlit
!                lai_o_shaded templ_o_shaded lai_u_sunlit templ_u_sunlit
!                lai_u_shaded gtrans_o_sunlit templ_u_shaded gtrans_o_shaded
!                gtrans_u_sunlit gtrans_u_shaded
  SUBROUTINE TRANSPIRATION_FWV(templ_o_sunlit, templ_o_sunlit_fw, &
&   templ_o_shaded, templ_o_shaded_fw, templ_u_sunlit, templ_u_sunlit_fw&
&   , templ_u_shaded, templ_u_shaded_fw, temp_air, rh_air, &
&   gtrans_o_sunlit, gtrans_o_sunlit_fw, gtrans_o_shaded, &
&   gtrans_o_shaded_fw, gtrans_u_sunlit, gtrans_u_sunlit_fw, &
&   gtrans_u_shaded, gtrans_u_shaded_fw, lai_o_sunlit, lai_o_sunlit_fw, &
&   lai_o_shaded, lai_o_shaded_fw, lai_u_sunlit, lai_u_sunlit_fw, &
&   lai_u_shaded, lai_u_shaded_fw, trans_o, trans_o_fw, trans_u, &
&   trans_u_fw, nbdirs)
    USE METEOMOD_DIFFV
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
    REAL(r8) :: templ_o_sunlit, templ_o_shaded, templ_u_sunlit, &
&   templ_u_shaded
    REAL(r8), DIMENSION(nbdirsmax) :: templ_o_sunlit_fw, &
&   templ_o_shaded_fw, templ_u_sunlit_fw, templ_u_shaded_fw
    REAL(r8) :: temp_air, rh_air
    REAL(r8) :: gtrans_o_sunlit, gtrans_o_shaded, gtrans_u_sunlit, &
&   gtrans_u_shaded
    REAL(r8), DIMENSION(nbdirsmax) :: gtrans_o_sunlit_fw, &
&   gtrans_o_shaded_fw, gtrans_u_sunlit_fw, gtrans_u_shaded_fw
    REAL(r8) :: lai_o_sunlit, lai_o_shaded, lai_u_sunlit, lai_u_shaded
    REAL(r8), DIMENSION(nbdirsmax) :: lai_o_sunlit_fw, lai_o_shaded_fw, &
&   lai_u_sunlit_fw, lai_u_shaded_fw
    REAL(r8) :: trans_o, trans_u
    REAL(r8), DIMENSION(nbdirsmax) :: trans_o_fw, trans_u_fw
!latent heat from leaves W/m2
    REAL(r8) :: lht_o_sunlit, lht_o_shaded, lht_u_sunlit, lht_u_shaded
    REAL(r8), DIMENSION(nbdirsmax) :: lht_o_sunlit_fw, lht_o_shaded_fw, &
&   lht_u_sunlit_fw, lht_u_shaded_fw
    INTEGER :: nd
    REAL(r8) :: temp
    INTEGER :: nbdirs
    CALL METEO_PACK(temp_air, rh_air)
    temp = vpd + slope_vapor*(templ_o_sunlit-temp_air)
    DO nd=1,nbdirs
      lht_o_sunlit_fw(nd) = density_air*cp_air*(gtrans_o_sunlit*&
&       slope_vapor*templ_o_sunlit_fw(nd)/psy+temp*gtrans_o_sunlit_fw(nd&
&       )/psy)
    END DO
    lht_o_sunlit = density_air*cp_air*(temp*(gtrans_o_sunlit/psy))
    temp = vpd + slope_vapor*(templ_o_shaded-temp_air)
    lht_o_shaded = density_air*cp_air*(temp*(gtrans_o_shaded/psy))
    DO nd=1,nbdirs
      lht_o_shaded_fw(nd) = density_air*cp_air*(gtrans_o_shaded*&
&       slope_vapor*templ_o_shaded_fw(nd)/psy+temp*gtrans_o_shaded_fw(nd&
&       )/psy)
      trans_o_fw(nd) = (lai_o_sunlit*lht_o_sunlit_fw(nd)+lht_o_sunlit*&
&       lai_o_sunlit_fw(nd)+lai_o_shaded*lht_o_shaded_fw(nd)+&
&       lht_o_shaded*lai_o_shaded_fw(nd))/latent_water
    END DO
    temp = vpd + slope_vapor*(templ_u_sunlit-temp_air)
    DO nd=1,nbdirs
      lht_u_sunlit_fw(nd) = density_air*cp_air*(gtrans_u_sunlit*&
&       slope_vapor*templ_u_sunlit_fw(nd)/psy+temp*gtrans_u_sunlit_fw(nd&
&       )/psy)
    END DO
    lht_u_sunlit = density_air*cp_air*(temp*(gtrans_u_sunlit/psy))
    temp = vpd + slope_vapor*(templ_u_shaded-temp_air)
    lht_u_shaded = density_air*cp_air*(temp*(gtrans_u_shaded/psy))
    DO nd=1,nbdirs
      lht_u_shaded_fw(nd) = density_air*cp_air*(gtrans_u_shaded*&
&       slope_vapor*templ_u_shaded_fw(nd)/psy+temp*gtrans_u_shaded_fw(nd&
&       )/psy)
      trans_u_fw(nd) = (lai_u_sunlit*lht_u_sunlit_fw(nd)+lht_u_sunlit*&
&       lai_u_sunlit_fw(nd)+lai_u_shaded*lht_u_shaded_fw(nd)+&
&       lht_u_shaded*lai_u_shaded_fw(nd))/latent_water
    END DO
    trans_o = 1/latent_water*(lht_o_sunlit*lai_o_sunlit+lht_o_shaded*&
&     lai_o_shaded)
    trans_u = 1/latent_water*(lht_u_sunlit*lai_u_sunlit+lht_u_shaded*&
&     lai_u_shaded)
  END SUBROUTINE TRANSPIRATION_FWV

  SUBROUTINE TRANSPIRATION(templ_o_sunlit, templ_o_shaded, &
&   templ_u_sunlit, templ_u_shaded, temp_air, rh_air, gtrans_o_sunlit, &
&   gtrans_o_shaded, gtrans_u_sunlit, gtrans_u_shaded, lai_o_sunlit, &
&   lai_o_shaded, lai_u_sunlit, lai_u_shaded, trans_o, trans_u)
    USE METEOMOD_DIFFV
    IMPLICIT NONE
    REAL(r8) :: templ_o_sunlit, templ_o_shaded, templ_u_sunlit, &
&   templ_u_shaded
    REAL(r8) :: temp_air, rh_air
    REAL(r8) :: gtrans_o_sunlit, gtrans_o_shaded, gtrans_u_sunlit, &
&   gtrans_u_shaded
    REAL(r8) :: lai_o_sunlit, lai_o_shaded, lai_u_sunlit, lai_u_shaded
    REAL(r8) :: trans_o, trans_u
!latent heat from leaves W/m2
    REAL(r8) :: lht_o_sunlit, lht_o_shaded, lht_u_sunlit, lht_u_shaded
    CALL METEO_PACK(temp_air, rh_air)
    lht_o_sunlit = (vpd+slope_vapor*(templ_o_sunlit-temp_air))*&
&     density_air*cp_air*gtrans_o_sunlit/psy
    lht_o_shaded = (vpd+slope_vapor*(templ_o_shaded-temp_air))*&
&     density_air*cp_air*gtrans_o_shaded/psy
    lht_u_sunlit = (vpd+slope_vapor*(templ_u_sunlit-temp_air))*&
&     density_air*cp_air*gtrans_u_sunlit/psy
    lht_u_shaded = (vpd+slope_vapor*(templ_u_shaded-temp_air))*&
&     density_air*cp_air*gtrans_u_shaded/psy
    trans_o = 1/latent_water*(lht_o_sunlit*lai_o_sunlit+lht_o_shaded*&
&     lai_o_shaded)
    trans_u = 1/latent_water*(lht_u_sunlit*lai_u_sunlit+lht_u_shaded*&
&     lai_u_shaded)
  END SUBROUTINE TRANSPIRATION

!  Differentiation of evaporation_canopy in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: evapo_snow_o evapo_snow_u evapo_water_o
!                evapo_water_u
!   with respect to varying inputs: lai_o_sunlit gwater_o_sunlit
!                templ_o_sunlit lai_o_shaded gwater_o_shaded gwater_u_sunlit
!                templ_o_shaded lai_u_sunlit templ_u_sunlit gwater_u_shaded
!                percent_water_o lai_u_shaded percent_water_u templ_u_shaded
!                percent_snow_o percent_snow_u
  SUBROUTINE EVAPORATION_CANOPY_FWV(templ_o_sunlit, templ_o_sunlit_fw, &
&   templ_o_shaded, templ_o_shaded_fw, templ_u_sunlit, templ_u_sunlit_fw&
&   , templ_u_shaded, templ_u_shaded_fw, temp_air, rh_air, &
&   gwater_o_sunlit, gwater_o_sunlit_fw, gwater_o_shaded, &
&   gwater_o_shaded_fw, gwater_u_sunlit, gwater_u_sunlit_fw, &
&   gwater_u_shaded, gwater_u_shaded_fw, lai_o_sunlit, lai_o_sunlit_fw, &
&   lai_o_shaded, lai_o_shaded_fw, lai_u_sunlit, lai_u_sunlit_fw, &
&   lai_u_shaded, lai_u_shaded_fw, percent_water_o, percent_water_o_fw, &
&   percent_water_u, percent_water_u_fw, percent_snow_o, &
&   percent_snow_o_fw, percent_snow_u, percent_snow_u_fw, evapo_water_o&
&   , evapo_water_o_fw, evapo_water_u, evapo_water_u_fw, evapo_snow_o, &
&   evapo_snow_o_fw, evapo_snow_u, evapo_snow_u_fw, nbdirs)
    USE METEOMOD_DIFFV
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
!*************************************************************************
! this module calculates evaporation and sublimation from canopy, from
!overstorey understorey sunlit and shaded
! input includes:
!temperature of sunlit and shaded leaves from other storey (leaf temperature module).
!temperature of air, relative humidity,
!aerodynamic conductance of water (snow) for sunlit shaded leaves from overstorey
!and understorey;
!percentage of overstorey or understorey covered by water or snow;
!leaf area index, sunlit and shaded, overstorey and understorey
!(from leaf area index module);
! output:
!evaporation of water and snow from overstorey and understorey
!*************************************************************************
    REAL(r8) :: templ_o_sunlit, templ_o_shaded, templ_u_sunlit, &
&   templ_u_shaded
    REAL(r8), DIMENSION(nbdirsmax) :: templ_o_sunlit_fw, &
&   templ_o_shaded_fw, templ_u_sunlit_fw, templ_u_shaded_fw
    REAL(r8) :: temp_air, rh_air
    REAL(r8) :: gwater_o_sunlit, gwater_o_shaded, gwater_u_sunlit, &
&   gwater_u_shaded
    REAL(r8), DIMENSION(nbdirsmax) :: gwater_o_sunlit_fw, &
&   gwater_o_shaded_fw, gwater_u_sunlit_fw, gwater_u_shaded_fw
    REAL(r8) :: lai_o_sunlit, lai_o_shaded, lai_u_sunlit, lai_u_shaded
    REAL(r8), DIMENSION(nbdirsmax) :: lai_o_sunlit_fw, lai_o_shaded_fw, &
&   lai_u_sunlit_fw, lai_u_shaded_fw
    REAL(r8) :: percent_water_o, percent_water_u, percent_snow_o, &
&   percent_snow_u
    REAL(r8), DIMENSION(nbdirsmax) :: percent_water_o_fw, &
&   percent_water_u_fw, percent_snow_o_fw, percent_snow_u_fw
    REAL(r8) :: evapo_water_o, evapo_water_u, evapo_snow_o, evapo_snow_u
    REAL(r8), DIMENSION(nbdirsmax) :: evapo_water_o_fw, evapo_water_u_fw&
&   , evapo_snow_o_fw, evapo_snow_u_fw
    REAL(r8) :: lhw_o_sunlit, lhw_o_shaded, lhw_u_sunlit, lhw_u_shaded
    REAL(r8), DIMENSION(nbdirsmax) :: lhw_o_sunlit_fw, lhw_o_shaded_fw, &
&   lhw_u_sunlit_fw, lhw_u_shaded_fw
    REAL(r8) :: lhs_o_sunlit, lhs_o_shaded, lhs_u_sunlit, lhs_u_shaded
    REAL(r8), DIMENSION(nbdirsmax) :: lhs_o_sunlit_fw, lhs_o_shaded_fw, &
&   lhs_u_sunlit_fw, lhs_u_shaded_fw
    INTRINSIC MAX
    REAL(r8) :: max1
    REAL(r8), DIMENSION(nbdirsmax) :: max1_fw
    REAL(r8) :: max2
    REAL(r8), DIMENSION(nbdirsmax) :: max2_fw
    REAL(r8) :: max3
    REAL(r8), DIMENSION(nbdirsmax) :: max3_fw
    REAL(r8) :: max4
    REAL(r8), DIMENSION(nbdirsmax) :: max4_fw
    REAL(r8) :: max5
    REAL(r8), DIMENSION(nbdirsmax) :: max5_fw
    REAL(r8) :: max6
    REAL(r8), DIMENSION(nbdirsmax) :: max6_fw
    REAL(r8) :: max7
    REAL(r8), DIMENSION(nbdirsmax) :: max7_fw
    REAL(r8) :: max8
    REAL(r8), DIMENSION(nbdirsmax) :: max8_fw
    INTEGER :: nd
    REAL(r8) :: temp
    REAL(r8) :: temp0
    INTEGER :: nbdirs
    CALL METEO_PACK(temp_air, rh_air)
    temp = percent_water_o*gwater_o_sunlit/psy
    temp0 = vpd + slope_vapor*(templ_o_sunlit-temp_air)
    DO nd=1,nbdirs
      lhw_o_sunlit_fw(nd) = density_air*cp_air*(temp*slope_vapor*&
&       templ_o_sunlit_fw(nd)+temp0*(gwater_o_sunlit*percent_water_o_fw(&
&       nd)+percent_water_o*gwater_o_sunlit_fw(nd))/psy)
    END DO
    lhw_o_sunlit = density_air*cp_air*(temp0*temp)
    temp0 = percent_water_o*gwater_o_shaded/psy
    temp = vpd + slope_vapor*(templ_o_shaded-temp_air)
    DO nd=1,nbdirs
      lhw_o_shaded_fw(nd) = density_air*cp_air*(temp0*slope_vapor*&
&       templ_o_shaded_fw(nd)+temp*(gwater_o_shaded*percent_water_o_fw(&
&       nd)+percent_water_o*gwater_o_shaded_fw(nd))/psy)
    END DO
    lhw_o_shaded = density_air*cp_air*(temp*temp0)
    temp0 = percent_water_u*gwater_u_sunlit/psy
    temp = vpd + slope_vapor*(templ_u_sunlit-temp_air)
    DO nd=1,nbdirs
      lhw_u_sunlit_fw(nd) = density_air*cp_air*(temp0*slope_vapor*&
&       templ_u_sunlit_fw(nd)+temp*(gwater_u_sunlit*percent_water_u_fw(&
&       nd)+percent_water_u*gwater_u_sunlit_fw(nd))/psy)
    END DO
    lhw_u_sunlit = density_air*cp_air*(temp*temp0)
    temp0 = percent_water_u*gwater_u_shaded/psy
    temp = vpd + slope_vapor*(templ_u_shaded-temp_air)
    DO nd=1,nbdirs
      lhw_u_shaded_fw(nd) = density_air*cp_air*(temp0*slope_vapor*&
&       templ_u_shaded_fw(nd)+temp*(gwater_u_shaded*percent_water_u_fw(&
&       nd)+percent_water_u*gwater_u_shaded_fw(nd))/psy)
    END DO
    lhw_u_shaded = density_air*cp_air*(temp*temp0)
    temp0 = percent_snow_o*gwater_o_sunlit/psy
    temp = vpd + slope_vapor*(templ_o_sunlit-temp_air)
    DO nd=1,nbdirs
      lhs_o_sunlit_fw(nd) = density_air*cp_air*(temp0*slope_vapor*&
&       templ_o_sunlit_fw(nd)+temp*(gwater_o_sunlit*percent_snow_o_fw(nd&
&       )+percent_snow_o*gwater_o_sunlit_fw(nd))/psy)
    END DO
    lhs_o_sunlit = density_air*cp_air*(temp*temp0)
    temp0 = percent_snow_o*gwater_o_shaded/psy
    temp = vpd + slope_vapor*(templ_o_shaded-temp_air)
    DO nd=1,nbdirs
      lhs_o_shaded_fw(nd) = density_air*cp_air*(temp0*slope_vapor*&
&       templ_o_shaded_fw(nd)+temp*(gwater_o_shaded*percent_snow_o_fw(nd&
&       )+percent_snow_o*gwater_o_shaded_fw(nd))/psy)
    END DO
    lhs_o_shaded = density_air*cp_air*(temp*temp0)
    temp0 = percent_snow_u*gwater_u_sunlit/psy
    temp = vpd + slope_vapor*(templ_u_sunlit-temp_air)
    DO nd=1,nbdirs
      lhs_u_sunlit_fw(nd) = density_air*cp_air*(temp0*slope_vapor*&
&       templ_u_sunlit_fw(nd)+temp*(gwater_u_sunlit*percent_snow_u_fw(nd&
&       )+percent_snow_u*gwater_u_sunlit_fw(nd))/psy)
    END DO
    lhs_u_sunlit = density_air*cp_air*(temp*temp0)
    temp0 = percent_snow_u*gwater_u_shaded/psy
    temp = vpd + slope_vapor*(templ_u_shaded-temp_air)
    DO nd=1,nbdirs
      lhs_u_shaded_fw(nd) = density_air*cp_air*(temp0*slope_vapor*&
&       templ_u_shaded_fw(nd)+temp*(gwater_u_shaded*percent_snow_u_fw(nd&
&       )+percent_snow_u*gwater_u_shaded_fw(nd))/psy)
    END DO
    lhs_u_shaded = density_air*cp_air*(temp*temp0)
    IF (lhw_o_sunlit .LT. 1.e-6) THEN
      max1 = 1.e-6
      max1_fw(:) = 0.0_8
    ELSE
      DO nd=1,nbdirs
        max1_fw(nd) = lhw_o_sunlit_fw(nd)
      END DO
      max1 = lhw_o_sunlit
    END IF
    IF (lhw_o_shaded .LT. 1.e-6) THEN
      max5 = 1.e-6
      max5_fw(:) = 0.0_8
    ELSE
      DO nd=1,nbdirs
        max5_fw(nd) = lhw_o_shaded_fw(nd)
      END DO
      max5 = lhw_o_shaded
    END IF
    DO nd=1,nbdirs
      evapo_water_o_fw(nd) = (lai_o_sunlit*max1_fw(nd)+max1*&
&       lai_o_sunlit_fw(nd)+lai_o_shaded*max5_fw(nd)+max5*&
&       lai_o_shaded_fw(nd))/latent_water
    END DO
    evapo_water_o = 1./latent_water*(max1*lai_o_sunlit+max5*lai_o_shaded&
&     )
    IF (lhw_u_sunlit .LT. 1.e-6) THEN
      max2 = 1.e-6
      max2_fw(:) = 0.0_8
    ELSE
      DO nd=1,nbdirs
        max2_fw(nd) = lhw_u_sunlit_fw(nd)
      END DO
      max2 = lhw_u_sunlit
    END IF
    IF (lhw_u_shaded .LT. 1.e-6) THEN
      max6 = 1.e-6
      max6_fw(:) = 0.0_8
    ELSE
      DO nd=1,nbdirs
        max6_fw(nd) = lhw_u_shaded_fw(nd)
      END DO
      max6 = lhw_u_shaded
    END IF
!    write(*,*) LHw_u_sunlit,lai_u_sunlit,LHw_u_shaded,lai_u_shaded
    DO nd=1,nbdirs
      evapo_water_u_fw(nd) = (lai_u_sunlit*max2_fw(nd)+max2*&
&       lai_u_sunlit_fw(nd)+lai_u_shaded*max6_fw(nd)+max6*&
&       lai_u_shaded_fw(nd))/latent_water
    END DO
    evapo_water_u = 1./latent_water*(max2*lai_u_sunlit+max6*lai_u_shaded&
&     )
    IF (lhs_o_sunlit .LT. 1.e-6) THEN
      max3 = 1.e-6
      max3_fw(:) = 0.0_8
    ELSE
      DO nd=1,nbdirs
        max3_fw(nd) = lhs_o_sunlit_fw(nd)
      END DO
      max3 = lhs_o_sunlit
    END IF
    IF (lhs_o_shaded .LT. 1.e-6) THEN
      max7 = 1.e-6
      max7_fw(:) = 0.0_8
    ELSE
      DO nd=1,nbdirs
        max7_fw(nd) = lhs_o_shaded_fw(nd)
      END DO
      max7 = lhs_o_shaded
    END IF
    DO nd=1,nbdirs
      evapo_snow_o_fw(nd) = (lai_o_sunlit*max3_fw(nd)+max3*&
&       lai_o_sunlit_fw(nd)+lai_o_shaded*max7_fw(nd)+max7*&
&       lai_o_shaded_fw(nd))/latent_snow
    END DO
    evapo_snow_o = 1/latent_snow*(max3*lai_o_sunlit+max7*lai_o_shaded)
    IF (lhs_u_sunlit .LT. 1.e-6) THEN
      max4 = 1.e-6
      max4_fw(:) = 0.0_8
    ELSE
      DO nd=1,nbdirs
        max4_fw(nd) = lhs_u_sunlit_fw(nd)
      END DO
      max4 = lhs_u_sunlit
    END IF
    IF (lhs_u_shaded .LT. 1.e-6) THEN
      max8 = 1.e-6
      max8_fw(:) = 0.0_8
    ELSE
      DO nd=1,nbdirs
        max8_fw(nd) = lhs_u_shaded_fw(nd)
      END DO
      max8 = lhs_u_shaded
    END IF
    DO nd=1,nbdirs
      evapo_snow_u_fw(nd) = (lai_u_sunlit*max4_fw(nd)+max4*&
&       lai_u_sunlit_fw(nd)+lai_u_shaded*max8_fw(nd)+max8*&
&       lai_u_shaded_fw(nd))/latent_snow
    END DO
    evapo_snow_u = 1/latent_snow*(max4*lai_u_sunlit+max8*lai_u_shaded)
    IF (0. .LT. evapo_water_o) THEN
      evapo_water_o = evapo_water_o
    ELSE
      evapo_water_o = 0.
      evapo_water_o_fw(:) = 0.0_8
    END IF
    IF (0. .LT. evapo_water_u) THEN
      evapo_water_u = evapo_water_u
    ELSE
      evapo_water_u = 0.
      evapo_water_u_fw(:) = 0.0_8
    END IF
    IF (0. .LT. evapo_snow_o) THEN
      evapo_snow_o = evapo_snow_o
    ELSE
      evapo_snow_o = 0.
      evapo_snow_o_fw(:) = 0.0_8
    END IF
    IF (0. .LT. evapo_snow_u) THEN
      evapo_snow_u = evapo_snow_u
    ELSE
      evapo_snow_u = 0.
      evapo_snow_u_fw(:) = 0.0_8
    END IF
  END SUBROUTINE EVAPORATION_CANOPY_FWV

  SUBROUTINE EVAPORATION_CANOPY(templ_o_sunlit, templ_o_shaded, &
&   templ_u_sunlit, templ_u_shaded, temp_air, rh_air, gwater_o_sunlit, &
&   gwater_o_shaded, gwater_u_sunlit, gwater_u_shaded, lai_o_sunlit, &
&   lai_o_shaded, lai_u_sunlit, lai_u_shaded, percent_water_o, &
&   percent_water_u, percent_snow_o, percent_snow_u, evapo_water_o, &
&   evapo_water_u, evapo_snow_o, evapo_snow_u)
    USE METEOMOD_DIFFV
    IMPLICIT NONE
!*************************************************************************
! this module calculates evaporation and sublimation from canopy, from
!overstorey understorey sunlit and shaded
! input includes:
!temperature of sunlit and shaded leaves from other storey (leaf temperature module).
!temperature of air, relative humidity,
!aerodynamic conductance of water (snow) for sunlit shaded leaves from overstorey
!and understorey;
!percentage of overstorey or understorey covered by water or snow;
!leaf area index, sunlit and shaded, overstorey and understorey
!(from leaf area index module);
! output:
!evaporation of water and snow from overstorey and understorey
!*************************************************************************
    REAL(r8) :: templ_o_sunlit, templ_o_shaded, templ_u_sunlit, &
&   templ_u_shaded
    REAL(r8) :: temp_air, rh_air
    REAL(r8) :: gwater_o_sunlit, gwater_o_shaded, gwater_u_sunlit, &
&   gwater_u_shaded
    REAL(r8) :: lai_o_sunlit, lai_o_shaded, lai_u_sunlit, lai_u_shaded
    REAL(r8) :: percent_water_o, percent_water_u, percent_snow_o, &
&   percent_snow_u
    REAL(r8) :: evapo_water_o, evapo_water_u, evapo_snow_o, evapo_snow_u
    REAL(r8) :: lhw_o_sunlit, lhw_o_shaded, lhw_u_sunlit, lhw_u_shaded
    REAL(r8) :: lhs_o_sunlit, lhs_o_shaded, lhs_u_sunlit, lhs_u_shaded
    INTRINSIC MAX
    REAL(r8) :: max1
    REAL(r8) :: max2
    REAL(r8) :: max3
    REAL(r8) :: max4
    REAL(r8) :: max5
    REAL(r8) :: max6
    REAL(r8) :: max7
    REAL(r8) :: max8
    CALL METEO_PACK(temp_air, rh_air)
    lhw_o_sunlit = percent_water_o*(vpd+slope_vapor*(templ_o_sunlit-&
&     temp_air))*density_air*cp_air*gwater_o_sunlit/psy
    lhw_o_shaded = percent_water_o*(vpd+slope_vapor*(templ_o_shaded-&
&     temp_air))*density_air*cp_air*gwater_o_shaded/psy
    lhw_u_sunlit = percent_water_u*(vpd+slope_vapor*(templ_u_sunlit-&
&     temp_air))*density_air*cp_air*gwater_u_sunlit/psy
    lhw_u_shaded = percent_water_u*(vpd+slope_vapor*(templ_u_shaded-&
&     temp_air))*density_air*cp_air*gwater_u_shaded/psy
    lhs_o_sunlit = percent_snow_o*(vpd+slope_vapor*(templ_o_sunlit-&
&     temp_air))*density_air*cp_air*gwater_o_sunlit/psy
    lhs_o_shaded = percent_snow_o*(vpd+slope_vapor*(templ_o_shaded-&
&     temp_air))*density_air*cp_air*gwater_o_shaded/psy
    lhs_u_sunlit = percent_snow_u*(vpd+slope_vapor*(templ_u_sunlit-&
&     temp_air))*density_air*cp_air*gwater_u_sunlit/psy
    lhs_u_shaded = percent_snow_u*(vpd+slope_vapor*(templ_u_shaded-&
&     temp_air))*density_air*cp_air*gwater_u_shaded/psy
    IF (lhw_o_sunlit .LT. 1.e-6) THEN
      max1 = 1.e-6
    ELSE
      max1 = lhw_o_sunlit
    END IF
    IF (lhw_o_shaded .LT. 1.e-6) THEN
      max5 = 1.e-6
    ELSE
      max5 = lhw_o_shaded
    END IF
    evapo_water_o = 1./latent_water*(max1*lai_o_sunlit+max5*lai_o_shaded&
&     )
    IF (lhw_u_sunlit .LT. 1.e-6) THEN
      max2 = 1.e-6
    ELSE
      max2 = lhw_u_sunlit
    END IF
    IF (lhw_u_shaded .LT. 1.e-6) THEN
      max6 = 1.e-6
    ELSE
      max6 = lhw_u_shaded
    END IF
!    write(*,*) LHw_u_sunlit,lai_u_sunlit,LHw_u_shaded,lai_u_shaded
    evapo_water_u = 1./latent_water*(max2*lai_u_sunlit+max6*lai_u_shaded&
&     )
    IF (lhs_o_sunlit .LT. 1.e-6) THEN
      max3 = 1.e-6
    ELSE
      max3 = lhs_o_sunlit
    END IF
    IF (lhs_o_shaded .LT. 1.e-6) THEN
      max7 = 1.e-6
    ELSE
      max7 = lhs_o_shaded
    END IF
    evapo_snow_o = 1/latent_snow*(max3*lai_o_sunlit+max7*lai_o_shaded)
    IF (lhs_u_sunlit .LT. 1.e-6) THEN
      max4 = 1.e-6
    ELSE
      max4 = lhs_u_sunlit
    END IF
    IF (lhs_u_shaded .LT. 1.e-6) THEN
      max8 = 1.e-6
    ELSE
      max8 = lhs_u_shaded
    END IF
    evapo_snow_u = 1/latent_snow*(max4*lai_u_sunlit+max8*lai_u_shaded)
    IF (0. .LT. evapo_water_o) THEN
      evapo_water_o = evapo_water_o
    ELSE
      evapo_water_o = 0.
    END IF
    IF (0. .LT. evapo_water_u) THEN
      evapo_water_u = evapo_water_u
    ELSE
      evapo_water_u = 0.
    END IF
    IF (0. .LT. evapo_snow_o) THEN
      evapo_snow_o = evapo_snow_o
    ELSE
      evapo_snow_o = 0.
    END IF
    IF (0. .LT. evapo_snow_u) THEN
      evapo_snow_u = evapo_snow_u
    ELSE
      evapo_snow_u = 0.
    END IF
  END SUBROUTINE EVAPORATION_CANOPY

!  Differentiation of photosynthesis in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: cos_assim aphoto cosi gs_w
!                xsif
!   with respect to varying inputs: temp_leaf_p vc_opt rad_leaf
!                sif_alpha g_lb_w vj_slope lh_leaf aphoto cosii
!                ffpa sif_beta f_soilwater f_leaf
  SUBROUTINE PHOTOSYNTHESIS_FWV(lc, temp_leaf_p, temp_leaf_p_fw, f_leaf&
&   , f_leaf_fw, p_kc25, p_ko25, p_tau25, rad_leaf, rad_leaf_fw, e_air, &
&   g_lb_w, g_lb_w_fw, vc_opt, vc_opt_fw, vj_slope, vj_slope_fw, &
&   f_soilwater, f_soilwater_fw, b_h2o, m_h2o, cii, temp_leaf_c, lh_leaf&
&   , lh_leaf_fw, gs_w, gs_w_fw, gs_h2o_mole, aphoto, aphoto_fw, ci, &
&   ffpa, ffpa_fw, sif_alpha, sif_alpha_fw, sif_beta, sif_beta_fw, xsif&
&   , xsif_fw, cosii, cosii_fw, cosi, cosi_fw, cos_assim, cos_assim_fw, &
&   nbdirs)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
!*************************************************************************
! This program solves a cubic equation to calculate
! leaf photosynthesis.  This cubic expression is derived from solving
! five simultaneous equations for A, PG, cs, CI and GS.
! Stomatal conductance is computed with the Ball-Berry model.
! The cubic derivation assumes that b', the intercept of the Ball-Berry
! stomatal conductance model, is non-zero.
! Gs = k A rh/cs + b'
! We also found that the solution for A can be obtained by a quadratic equation
! when Gs is constant or b' is zero.
! The derivation is published in:
! Baldocchi, D.D. 1994. An analytical solution for coupled leaf photosynthesis
! and stomatal conductance models. Tree Physiology 14: 1069-1079.
!-----------------------------------------------------------------------
! A Biochemical Model of C3 Photosynthesis
! After Farquhar, von Caemmerer and Berry (1980) Planta.
! 149: 78-90.
! The original program was modified to incorporate functions and parameters
! derived from gas exchange experiments of Harley, who paramertized Vc and J in
! terms of optimal temperature, rather than some reference temperature, eg 25C.
! Program calculates leaf photosynthesis from biochemical parameters
! rd25 - Dark respiration at 25 degrees C (umol m-2 s-1)
! tlk - leaf temperature, Kelvin
! jmax - optimal rate of electron transport
! vcopt - maximum rate of RuBP Carboxylase/oxygenase
! iphoton - incident photosynthetically active photon flux (umols m-2 s-1)
! note: Harley parameterized the model on the basis of incident PAR
! gs - stomatal conductance (mols m-2 s-1), typically 0.01-0.20
! pstat-station pressure, bars
! aphoto - net photosynthesis  (umol m-2 s-1)
! ps - gross photosynthesis (umol m-2 s-1)
! aps - net photosynthesis (mg m-2 s-1)
! aphoto (umol m-2 s-1)
!-----------------------------------------------------------------------
! iphoton is radiation incident on leaves
! The temperature dependency of the kinetic properties of
! RUBISCO are compensated for using the Arrhenius and
! Boltzmann equations.  From biochemistry, one observes that
! at moderate temperatures enzyme kinetic rates increase
! with temperature.  At extreme temperatures enzyme
! denaturization occurs and rates must decrease.
! Arrhenius Eq.
! f(T)=f(tk_25) exp(tk -298)eact/(298 R tk)), where eact is the
! activation energy.
! Boltzmann distribution
! F(T)=tboltz)
! Define terms for calculation of gross photosynthesis, PG
! PG is a function of the minimum of RuBP saturated rate of
! carboxylation, Wc, and the RuBP limited rate of carboxylation, Wj.
! Wj is limiting when light is low and electron transport, which
! re-generates RuBP, is limiting.  Wc is limiting when plenty of RuBP is
! available compared to the CO2 that is needed for carboxylation.
! Both equations take the form:
! PG-photorespiration= (a CI-a d)/(e CI + b)
! PG-photorespiration=min[Wj,Wc] (1-gamma_ps/Ci)
! Wc=Vcmax Ci/(Ci + Kc(1+O2/Ko))
! Wj=J Ci/(4 Ci + 8 gamma_ps)
! Ps kinetic coefficients from Harley at WBW.
! gamma_ps is the CO2 compensation point
! Jan 14, 1999 Updated the cubic solutions for photosynthesis.  There are
! times when the restriction that R^2 < Q^3 is violated.  I therefore need
! alternative algorithms to solve for the correct root.
!*************************************************************************
! It is temporay, will be removed later
    REAL(r8) :: temp_leaf_p
    REAL(r8), DIMENSION(nbdirsmax) :: temp_leaf_p_fw
! Leaf respiration ratio, default value of 0.5
    REAL(r8) :: f_leaf
    REAL(r8), DIMENSION(nbdirsmax) :: f_leaf_fw
! net shortwave radiation (W/m2)
    REAL(r8) :: rad_leaf
    REAL(r8), DIMENSION(nbdirsmax) :: rad_leaf_fw
! water vapor pressure above canopy (kPa)
    REAL(r8) :: e_air
! leaf laminar boundary layer condunctance to H2O (m/s)
    REAL(r8) :: g_lb_w
    REAL(r8), DIMENSION(nbdirsmax) :: g_lb_w_fw
! the maximum velocities of carboxylation of Rubisco at 25 deg C (umol m-2 s-1)
    REAL(r8) :: vc_opt
    REAL(r8), DIMENSION(nbdirsmax) :: vc_opt_fw
! the ratio of Vmax/Jmax, default value of 2.39
    REAL(r8) :: vj_slope
    REAL(r8), DIMENSION(nbdirsmax) :: vj_slope_fw
! an empirical scalar of soil water stress on stomatal conductance, dimensionless
    REAL(r8) :: f_soilwater
    REAL(r8), DIMENSION(nbdirsmax) :: f_soilwater_fw
! the intercept term in BWB model (mol H2O m-2 s-1)
    REAL(r8) :: b_h2o
! the slope in BWB model
    REAL(r8) :: m_h2o
!landcover type
    INTEGER :: lc
! replace, kc25,ko25,tau25 with three pramters, default values are 274.6,419.8,2904.12, respectively
    REAL(r8) :: p_kc25, p_ko25, p_tau25
! initial intercellular co2 concentration (ppm)
    REAL(r8) :: cii
! leaf temperature (deg C)
    REAL(r8) :: temp_leaf_c
! leaf latent heat flux (W m-2)
    REAL(r8) :: lh_leaf
    REAL(r8), DIMENSION(nbdirsmax) :: lh_leaf_fw
! stomatal conductance to water vapor (m s-1)
    REAL(r8) :: gs_w
    REAL(r8), DIMENSION(nbdirsmax) :: gs_w_fw
! net photosynthesis rate (umol CO2 m-2 s-1)
    REAL(r8) :: aphoto
    REAL(r8), DIMENSION(nbdirsmax) :: aphoto_fw
! intercellular co2 concentration (ppm)
    REAL(r8) :: ci
    REAL(r8), DIMENSION(nbdirsmax) :: ci_fw
!    real(r8)  :: xSIF           ! SIF
! SIF
    REAL(r8) :: sif_alpha, sif_beta, xsif
    REAL(r8), DIMENSION(nbdirsmax) :: sif_alpha_fw, sif_beta_fw, xsif_fw
!  air pressure (kPa)
    REAL(r8), PARAMETER :: air_pres=101.325
! atmospheric co2 concentration (ppm)
    REAL(r8) :: ca
! incident photosynthetic photon flux density (PPFD) umol m-2 s-1
    REAL(r8) :: iphoton
    REAL(r8), DIMENSION(nbdirsmax) :: iphoton_fw
!    real(r8)  :: g_lb_c          ! leaf laminar boundary layer condunctance to CO2 (mol m-2 s-1)
! leaf laminar boundary layer condunctance to CO2,COS (mol m-2 s-1)
    REAL(r8) :: g_lb_c, g_lb_cos
    REAL(r8), DIMENSION(nbdirsmax) :: g_lb_c_fw, g_lb_cos_fw
! relative humidity at leaf surface (0-1)
    REAL(r8) :: rh_leaf
    REAL(r8), DIMENSION(nbdirsmax) :: rh_leaf_fw
! leaf temperature (K)
    REAL(r8) :: temp_leaf_k
! stomatal conductance to CO2 (mol m-2 s-1)
    REAL(r8) :: gs_co2_mole
    REAL(r8), DIMENSION(nbdirsmax) :: gs_co2_mole_fw
! stomatal conductance to h2o (mol m-2 s-1)
    REAL(r8) :: gs_h2o_mole
    REAL(r8), DIMENSION(nbdirsmax) :: gs_h2o_mole_fw
! temporary variable
    REAL(r8) :: bc
! CO2 concentration at leaf surface (ppm)
    REAL(r8) :: cs
    REAL(r8), DIMENSION(nbdirsmax) :: cs_fw
! the intercept term in BWB model (mol CO2 m-2 s-1): b_h2o/1.6
    REAL(r8) :: b_co2
! the slope in BWB model: m_h2o/1.6
    REAL(r8) :: m_co2
! CO2 compensation point (ppm)
    REAL(r8) :: gammac
! the maximum potential electron transport rate at 25 deg C (umol m-2 s-1)
    REAL(r8) :: jmopt
    REAL(r8), DIMENSION(nbdirsmax) :: jmopt_fw
! the maximum potential electron transport rate (umol m-2 s-1)
    REAL(r8) :: jmax
    REAL(r8), DIMENSION(nbdirsmax) :: jmax_fw
! the maximum velocities of carboxylation of Rubisco (umol m-2 s-1)
    REAL(r8) :: vcmax
    REAL(r8), DIMENSION(nbdirsmax) :: vcmax_fw
! Michaelis-Menten constant for CO2 (?ol mol-1)
    REAL(r8) :: km_co2
! Michaelis-Menten constant for O2 (mmol mol-1)
    REAL(r8) :: km_o2
! the specifity of Rubisco for CO2 compared with O2
    REAL(r8) :: tau
! leaf dark respiration (umol m-2 s-1)
    REAL(r8) :: resp_ld
    REAL(r8), DIMENSION(nbdirsmax) :: resp_ld_fw
! leaf dark respiration at 25 deg C (umol m-2 s-1)
    REAL(r8) :: resp_ld25
    REAL(r8), DIMENSION(nbdirsmax) :: resp_ld25_fw
! the flux of electrons through the thylakoid membrane (umol m-2 s-1)
    REAL(r8) :: j_photon
    REAL(r8), DIMENSION(nbdirsmax) :: j_photon_fw
    REAL(r8) :: alpha_ps
    REAL(r8), DIMENSION(nbdirsmax) :: alpha_ps_fw
    REAL(r8) :: beta_ps
    REAL(r8), DIMENSION(nbdirsmax) :: beta_ps_fw
    REAL(r8) :: gamma_ps
    REAL(r8), DIMENSION(nbdirsmax) :: gamma_ps_fw
    REAL(r8) :: theta_ps
    REAL(r8), DIMENSION(nbdirsmax) :: theta_ps_fw
    REAL(r8) :: denom
    REAL(r8), DIMENSION(nbdirsmax) :: denom_fw
    REAL(r8) :: p_cubic
    REAL(r8), DIMENSION(nbdirsmax) :: p_cubic_fw
    REAL(r8) :: q_cubic
    REAL(r8), DIMENSION(nbdirsmax) :: q_cubic_fw
    REAL(r8) :: r_cubic
    REAL(r8), DIMENSION(nbdirsmax) :: r_cubic_fw
    REAL(r8) :: qroot
    REAL(r8), DIMENSION(nbdirsmax) :: qroot_fw
    REAL(r8) :: rroot
    REAL(r8), DIMENSION(nbdirsmax) :: rroot_fw
    REAL(r8) :: root1, root2, root3
    REAL(r8), DIMENSION(nbdirsmax) :: root1_fw, root2_fw, root3_fw
    REAL(r8) :: ang_l
    REAL(r8), DIMENSION(nbdirsmax) :: ang_l_fw
! net photosynthesis rate limited by sucrose synthesis (umol m-2 s-1)
    REAL(r8) :: j_sucrose
    REAL(r8), DIMENSION(nbdirsmax) :: j_sucrose_fw
! gross photosynthesis rate limited by light (umol m-2 s-1)
    REAL(r8) :: wc, wj, psguess
    REAL(r8), DIMENSION(nbdirsmax) :: wc_fw, wj_fw
!-- iLab::convf no longer required
! real(r8)  :: cosa,convf,cosi,cosii,coss  ! parameters used for COS calculations
! parameters used for COS calculations
    REAL(r8) :: cosa, cosi, cosii, coss
    REAL(r8), DIMENSION(nbdirsmax) :: cosi_fw, cosii_fw, coss_fw
    REAL(r8) :: cos_assim
    REAL(r8), DIMENSION(nbdirsmax) :: cos_assim_fw
    REAL(r8) :: kn, kf, kd, kp, ps_sif, fm
    REAL(r8), DIMENSION(nbdirsmax) :: kn_fw, ps_sif_fw, fm_fw
    REAL(r8) :: je, xxn, fs, ffpa
    REAL(r8), DIMENSION(nbdirsmax) :: je_fw, xxn_fw, fs_fw, ffpa_fw
    REAL(r8) :: aquad, bquad, cquad
    REAL(r8), DIMENSION(nbdirsmax) :: aquad_fw, bquad_fw, cquad_fw
    REAL(r8) :: b_ps, a_ps, e_ps, d_ps
    REAL(r8), DIMENSION(nbdirsmax) :: a_ps_fw
    REAL(r8) :: product1
    REAL(r8), DIMENSION(nbdirsmax) :: product1_fw
    REAL(r8) :: ps_1
    REAL(r8), DIMENSION(nbdirsmax) :: ps_1_fw
    REAL(r8) :: delta_1
    REAL(r8), DIMENSION(nbdirsmax) :: delta_1_fw
    REAL(r8) :: r3q
    REAL(r8), DIMENSION(nbdirsmax) :: r3q_fw
    REAL(r8) :: minroot, maxroot, midroot
    REAL(r8), DIMENSION(nbdirsmax) :: minroot_fw, maxroot_fw, midroot_fw
    REAL(r8) :: tprime25
    REAL(r8) :: k_t_opt, k_t, theta, beta, m1, m2, m
    REAL(r8), DIMENSION(nbdirsmax) :: k_t_opt_fw, k_t_fw, m1_fw, m2_fw, &
&   m_fw
    INTRINSIC SQRT
    INTRINSIC MAX
    INTRINSIC ACOS
    INTRINSIC COS
    REAL(r8) :: x1
    REAL(r8), DIMENSION(nbdirsmax) :: x1_fw
    REAL(r8) :: arg1
    REAL(r8), DIMENSION(nbdirsmax) :: arg1_fw
    REAL(r8) :: result1
    REAL(r8), DIMENSION(nbdirsmax) :: result1_fw
    INTEGER :: nd
    REAL(r8) :: temp
    REAL(r8) :: temp0
    REAL(r8) :: temp1
    REAL(r8) :: temp2
    INTEGER :: nbdirs
    minroot = 0.0
    maxroot = 0.0
    midroot = 0.0
    ca = co2_air
    cosa = cos_air
!    iphoton = 4.55*0.5*rad_leaf
! replace 0.5 to a coefficient, f_leaf, leaf respiration rate, for optimization purpose, @MOUSONG WU, 2020-09-14
    DO nd=1,nbdirs
      iphoton_fw(nd) = 4.55*(rad_leaf*f_leaf_fw(nd)+f_leaf*rad_leaf_fw(&
&       nd))
    END DO
    iphoton = 4.55*f_leaf*rad_leaf
    IF (2*iphoton .LT. 1) THEN
      iphoton = 0
      iphoton_fw(:) = 0.0_8
    END IF
    temp_leaf_k = temp_leaf_c + 273.13
    CALL LAMBDA_FWV(temp_leaf_p, temp_leaf_p_fw, fact%latent, fact_fw%&
&             latent, nbdirs)
    met%press_bars = 1.013
    met%pstat273 = 0.022624/(273.16*met%press_bars)
    met%t_kelvin = temp_leaf_c + 273.13
! absolute humidity, g m-3
    met%rhova_g = e_air*2165/met%t_kelvin
! absolute humidity, kg m-3
    met%rhova_kg = met%rhova_g/1000.0
    temp = 1.6*temp_leaf_k*met%pstat273
    DO nd=1,nbdirs
      bound_layer_res_fw%vapor(nd) = -(g_lb_w_fw(nd)/g_lb_w**2)
      g_lb_c_fw(nd) = g_lb_w_fw(nd)/temp
      resp_ld25_fw(nd) = 0.004657*vc_opt_fw(nd)
    END DO
    bound_layer_res%vapor = 1.0/g_lb_w
    g_lb_c = g_lb_w/temp
    m_co2 = m_h2o/1.6
    b_co2 = b_h2o/1.6
    temp = 1.56*temp_leaf_k*met%pstat273
    DO nd=1,nbdirs
      g_lb_cos_fw(nd) = g_lb_w_fw(nd)/temp
    END DO
    g_lb_cos = g_lb_w/temp
!-- iLab::convf no longer required
! convf = temp_leaf_K * (met%pstat273)
    CALL SFC_VPD_FWV(temp_leaf_k, lh_leaf, lh_leaf_fw, rh_leaf, &
&              rh_leaf_fw, nbdirs)
! temperature difference
    tprime25 = temp_leaf_k - tk_25
!   
    CALL TEMP_FUNC(kc25, ekc, tprime25, tk_25, temp_leaf_k, km_co2)
    CALL TEMP_FUNC(ko25, eko, tprime25, tk_25, temp_leaf_k, km_o2)
    CALL TEMP_FUNC(tau25, ektau, tprime25, tk_25, temp_leaf_k, tau)
    bc = km_co2*(1.0+o2/km_o2)
! umol mol-1
    gammac = 0.5*o2/tau*1000.0
    resp_ld25 = vc_opt*0.004657
    IF (2.0*iphoton .GT. 10) THEN
! Bin Chen: check this later.
! reduce respiration by 40% in light according to Amthor
      DO nd=1,nbdirs
        resp_ld25_fw(nd) = 0.4*resp_ld25_fw(nd)
      END DO
      resp_ld25 = resp_ld25*0.4
    END IF
    CALL TEMP_FUNC_FWV(resp_ld25, resp_ld25_fw, erd, tprime25, tk_25, &
&                temp_leaf_k, resp_ld, resp_ld_fw, nbdirs)
!    jmopt   = 2.39*vc_opt - 14.2
    DO nd=1,nbdirs
      jmopt_fw(nd) = vc_opt*vj_slope_fw(nd) + vj_slope*vc_opt_fw(nd)
    END DO
    jmopt = vj_slope*vc_opt - 14.2
! Apply temperature correction to JMAX
    CALL TBOLTZ_FWV(jmopt, jmopt_fw, ejm, toptjm, temp_leaf_k, jmax, &
&             jmax_fw, nbdirs)
    IF (lc .EQ. 40 .OR. lc .EQ. 41) THEN
! Apply temperature correction to vcmax
      CALL TBOLTZC4_FWV(vc_opt, vc_opt_fw, toptvc, temp_leaf_k, vcmax, &
&                 vcmax_fw, nbdirs)
    ELSE
! Apply temperature correction to vcmax
      CALL TBOLTZ_FWV(vc_opt, vc_opt_fw, evc, toptvc, temp_leaf_k, vcmax&
&               , vcmax_fw, nbdirs)
    END IF
!***************************************
!        APHOTO = PG - resp_ld, net photosynthesis is the difference
!        between gross photosynthesis and dark respiration. Note
!        photorespiration is already factored into PG.
!        Gs from Ball-Berry is for water vapor.  It must be divided
!        by the ratio of the molecular diffusivities to be valid
!        for A
!****************************************
    IF (lc .EQ. 40 .OR. lc .EQ. 41) THEN
      temp = 2.**((temp_leaf_k-298.15)/10.)
      j_photon = iphoton*0.05
      wj = j_photon
      wc = vcmax
      theta = 0.80
      DO nd=1,nbdirs
! analytical solution for C4 photosynthesis, added by MOUSONG.WU@201907, refer to Chen et al.2019 AFM
        k_t_opt_fw(nd) = 1.e4*2.*vc_opt_fw(nd)
        k_t_fw(nd) = temp*k_t_opt_fw(nd)
        j_photon_fw(nd) = 0.05*iphoton_fw(nd)
        wj_fw(nd) = j_photon_fw(nd)
        wc_fw(nd) = vcmax_fw(nd)
        arg1_fw(nd) = 2*(wj+wc)*(wj_fw(nd)+wc_fw(nd)) - theta*4*(wc*&
&         wj_fw(nd)+wj*wc_fw(nd))
      END DO
      k_t_opt = 2.*1.e4*vc_opt
      k_t = temp*k_t_opt
      beta = 0.95
      arg1 = (wj+wc)*(wj+wc) - 4*theta*wj*wc
      temp = SQRT(arg1)
      DO nd=1,nbdirs
        IF (arg1 .EQ. 0.0_8) THEN
          result1_fw(nd) = 0.0_8
        ELSE
          result1_fw(nd) = arg1_fw(nd)/(2.0*temp)
        END IF
        m1_fw(nd) = (wj_fw(nd)+wc_fw(nd)+result1_fw(nd))/(2*theta)
        arg1_fw(nd) = 2*(wj+wc)*(wj_fw(nd)+wc_fw(nd)) + theta*4*(wc*&
&         wj_fw(nd)+wj*wc_fw(nd))
      END DO
      result1 = temp
      m1 = (wj+wc+result1)/(2*theta)
      arg1 = (wj+wc)*(wj+wc) + 4*theta*wj*wc
      temp = SQRT(arg1)
      DO nd=1,nbdirs
        IF (arg1 .EQ. 0.0_8) THEN
          result1_fw(nd) = 0.0_8
        ELSE
          result1_fw(nd) = arg1_fw(nd)/(2.0*temp)
        END IF
        m2_fw(nd) = (wj_fw(nd)+wc_fw(nd)+result1_fw(nd))/(2*theta)
      END DO
      result1 = temp
      m2 = (wj+wc+result1)/(2*theta)
      IF (m1 .LT. m2) THEN
        DO nd=1,nbdirs
          m_fw(nd) = m1_fw(nd)
        END DO
        m = m1
      ELSE
        DO nd=1,nbdirs
          m_fw(nd) = m2_fw(nd)
        END DO
        m = m2
      END IF
      temp = beta*b_co2/g_lb_c
      temp0 = rh_leaf/g_lb_c
      temp1 = k_t/(g_lb_c*g_lb_c)
      DO nd=1,nbdirs
        alpha_ps_fw(nd) = beta*m_co2*(rh_leaf*f_soilwater_fw(nd)+&
&         f_soilwater*rh_leaf_fw(nd)) + temp*g_lb_c_fw(nd)/g_lb_c - 1.6*&
&         (k_t_fw(nd)-k_t*g_lb_c_fw(nd)/g_lb_c)/g_lb_c + m_co2*(temp0*(&
&         f_soilwater*k_t_fw(nd)+k_t*f_soilwater_fw(nd))+k_t*f_soilwater&
&         *(rh_leaf_fw(nd)-temp0*g_lb_c_fw(nd))/g_lb_c) - b_co2*(k_t_fw(&
&         nd)-temp1*2*g_lb_c*g_lb_c_fw(nd))/g_lb_c**2
      END DO
      alpha_ps = beta*m_co2*(f_soilwater*rh_leaf) - temp - 1.6*(k_t/&
&       g_lb_c) + m_co2*(k_t*f_soilwater*temp0) - b_co2*temp1
      temp1 = 2*b_co2*ca
      temp0 = resp_ld*k_t/g_lb_c
      temp = (1.6*k_t*resp_ld+1.6*k_t*m-m_co2*m*k_t*f_soilwater*rh_leaf)&
&       /g_lb_c
      temp2 = m*k_t/(g_lb_c*g_lb_c)
      DO nd=1,nbdirs
        beta_ps_fw(nd) = ca*1.6*k_t_fw(nd) - beta*m_co2*(resp_ld*(&
&         rh_leaf*f_soilwater_fw(nd)+f_soilwater*rh_leaf_fw(nd))+&
&         f_soilwater*rh_leaf*resp_ld_fw(nd)) - m_co2*(rh_leaf*(&
&         f_soilwater*m_fw(nd)+m*f_soilwater_fw(nd))+m*f_soilwater*&
&         rh_leaf_fw(nd)) + b_co2*(m_fw(nd)-m*g_lb_c_fw(nd)/g_lb_c)/&
&         g_lb_c - m_co2*ca*(rh_leaf*(f_soilwater*k_t_fw(nd)+k_t*&
&         f_soilwater_fw(nd))+k_t*f_soilwater*rh_leaf_fw(nd)) + temp1*(&
&         k_t_fw(nd)-k_t*g_lb_c_fw(nd)/g_lb_c)/g_lb_c - m_co2*(&
&         f_soilwater*rh_leaf*(k_t*resp_ld_fw(nd)+resp_ld*k_t_fw(nd)-&
&         temp0*g_lb_c_fw(nd))/g_lb_c+temp0*(rh_leaf*f_soilwater_fw(nd)+&
&         f_soilwater*rh_leaf_fw(nd))) + (1.6*(resp_ld*k_t_fw(nd)+k_t*&
&         resp_ld_fw(nd))+1.6*(m*k_t_fw(nd)+k_t*m_fw(nd))-m_co2*(&
&         f_soilwater*rh_leaf*(k_t*m_fw(nd)+m*k_t_fw(nd))+m*k_t*(rh_leaf&
&         *f_soilwater_fw(nd)+f_soilwater*rh_leaf_fw(nd)))-temp*&
&         g_lb_c_fw(nd))/g_lb_c + b_co2*(k_t*m_fw(nd)+m*k_t_fw(nd)-temp2&
&         *2*g_lb_c*g_lb_c_fw(nd))/g_lb_c**2
      END DO
      beta_ps = beta*b_co2*ca + ca*1.6*k_t - beta*m_co2*(f_soilwater*&
&       rh_leaf*resp_ld) - m_co2*(m*f_soilwater*rh_leaf) + b_co2*(m/&
&       g_lb_c) - m_co2*ca*(k_t*f_soilwater*rh_leaf) + temp1*(k_t/g_lb_c&
&       ) - m_co2*(temp0*(f_soilwater*rh_leaf)) + temp + b_co2*temp2
      temp2 = 2*b_co2*ca
      temp1 = m*k_t/g_lb_c
      temp0 = m*k_t*resp_ld
      temp = (1.6*m*resp_ld*k_t-m_co2*temp0*f_soilwater*rh_leaf)/g_lb_c
      DO nd=1,nbdirs
        gamma_ps_fw(nd) = m_co2*(f_soilwater*rh_leaf*(m*resp_ld_fw(nd)+&
&         resp_ld*m_fw(nd))+resp_ld*m*(rh_leaf*f_soilwater_fw(nd)+&
&         f_soilwater*rh_leaf_fw(nd))) - b_co2*ca*m_fw(nd) + m_co2*ca*(&
&         f_soilwater*rh_leaf*(k_t*resp_ld_fw(nd)+resp_ld*k_t_fw(nd))+&
&         resp_ld*k_t*(rh_leaf*f_soilwater_fw(nd)+f_soilwater*rh_leaf_fw&
&         (nd))) - ca**2*b_co2*k_t_fw(nd) + ca*(m_co2*(f_soilwater*&
&         rh_leaf*(k_t*m_fw(nd)+m*k_t_fw(nd))+m*k_t*(rh_leaf*&
&         f_soilwater_fw(nd)+f_soilwater*rh_leaf_fw(nd)))-1.6*(k_t*&
&         resp_ld_fw(nd)+resp_ld*k_t_fw(nd))-1.6*(m*k_t_fw(nd)+k_t*m_fw(&
&         nd))) - temp2*(k_t*m_fw(nd)+m*k_t_fw(nd)-temp1*g_lb_c_fw(nd))/&
&         g_lb_c - (1.6*(k_t*(resp_ld*m_fw(nd)+m*resp_ld_fw(nd))+m*&
&         resp_ld*k_t_fw(nd))-m_co2*(f_soilwater*rh_leaf*(resp_ld*(k_t*&
&         m_fw(nd)+m*k_t_fw(nd))+m*k_t*resp_ld_fw(nd))+temp0*(rh_leaf*&
&         f_soilwater_fw(nd)+f_soilwater*rh_leaf_fw(nd)))-temp*g_lb_c_fw&
&         (nd))/g_lb_c
      END DO
      gamma_ps = m_co2*(resp_ld*m*(f_soilwater*rh_leaf)) - b_co2*ca*m + &
&       m_co2*ca*(resp_ld*k_t*(f_soilwater*rh_leaf)) - ca*ca*(b_co2*k_t)&
&       + ca*(m_co2*(m*k_t*(f_soilwater*rh_leaf))-1.6*(resp_ld*k_t)-1.6*&
&       (k_t*m)) - temp2*temp1 - temp
      temp2 = b_co2*(ca*ca)
      temp1 = m*resp_ld*rh_leaf
      DO nd=1,nbdirs
        theta_ps_fw(nd) = temp2*(k_t*m_fw(nd)+m*k_t_fw(nd)) + ca*1.6*(&
&         k_t*(resp_ld*m_fw(nd)+m*resp_ld_fw(nd))+m*resp_ld*k_t_fw(nd)) &
&         - m_co2*ca*(k_t*f_soilwater*(rh_leaf*(resp_ld*m_fw(nd)+m*&
&         resp_ld_fw(nd))+m*resp_ld*rh_leaf_fw(nd))+temp1*(f_soilwater*&
&         k_t_fw(nd)+k_t*f_soilwater_fw(nd)))
      END DO
      theta_ps = temp2*(m*k_t) + ca*1.6*(m*resp_ld*k_t) - m_co2*ca*(&
&       temp1*(k_t*f_soilwater))
      IF (.NOT.(wj .LE. resp_ld .OR. wc .LE. resp_ld)) THEN
        denom = alpha_ps
        p_cubic = beta_ps/denom
        q_cubic = gamma_ps/denom
        DO nd=1,nbdirs
!        //cubic solution:
!        // A^3 + p A^2 + q A + r = 0
          denom_fw(nd) = alpha_ps_fw(nd)
          p_cubic_fw(nd) = (beta_ps_fw(nd)-beta_ps*denom_fw(nd)/denom)/&
&           denom
          q_cubic_fw(nd) = (gamma_ps_fw(nd)-gamma_ps*denom_fw(nd)/denom)&
&           /denom
          r_cubic_fw(nd) = (theta_ps_fw(nd)-theta_ps*denom_fw(nd)/denom)&
&           /denom
!        // Use solution from Numerical Recipes from Press
          qroot_fw(nd) = (2*p_cubic*p_cubic_fw(nd)-3.0*q_cubic_fw(nd))/&
&           9.0
          rroot_fw(nd) = (2.0*3*p_cubic**2*p_cubic_fw(nd)-9.0*(q_cubic*&
&           p_cubic_fw(nd)+p_cubic*q_cubic_fw(nd))+27.0*r_cubic_fw(nd))/&
&           54.0
        END DO
        r_cubic = theta_ps/denom
        qroot = (p_cubic*p_cubic-3.0*q_cubic)/9.0
        rroot = (2.0*p_cubic*p_cubic*p_cubic-9.0*p_cubic*q_cubic+27.0*&
&         r_cubic)/54.0
        IF (qroot .LT. 1.e-6) THEN
          qroot = 1.e-6
          qroot_fw(:) = 0.0_8
        ELSE
          qroot = qroot
        END IF
        arg1 = qroot*qroot*qroot
        temp2 = SQRT(arg1)
        result1 = temp2
        DO nd=1,nbdirs
          arg1_fw(nd) = 3*qroot**2*qroot_fw(nd)
          IF (arg1 .EQ. 0.0_8) THEN
            result1_fw(nd) = 0.0_8
          ELSE
            result1_fw(nd) = arg1_fw(nd)/(2.0*temp2)
          END IF
          r3q_fw(nd) = (rroot_fw(nd)-rroot*result1_fw(nd)/result1)/&
&           result1
        END DO
        r3q = rroot/result1
        IF (r3q .GT. 1) THEN
          r3q = 1
          r3q_fw(:) = 0.0_8
        END IF
        IF (r3q .LT. -1) THEN
          r3q = -1
          r3q_fw(:) = 0.0_8
        END IF
        temp2 = SQRT(qroot)
        DO nd=1,nbdirs
          IF (r3q .EQ. 1.0 .OR. r3q .EQ. (-1.0)) THEN
            ang_l_fw(nd) = 0.0_8
          ELSE
            ang_l_fw(nd) = -(r3q_fw(nd)/SQRT(1.0-r3q**2))
          END IF
          IF (qroot .EQ. 0.0_8) THEN
            result1_fw(nd) = 0.0_8
          ELSE
            result1_fw(nd) = qroot_fw(nd)/(2.0*temp2)
          END IF
          arg1_fw(nd) = ang_l_fw(nd)/3.0
        END DO
        ang_l = ACOS(r3q)
        result1 = temp2
        arg1 = ang_l/3.0
        temp2 = COS(arg1)
        DO nd=1,nbdirs
          root1_fw(nd) = -(2.0*(temp2*result1_fw(nd)-result1*SIN(arg1)*&
&           arg1_fw(nd))) - p_cubic_fw(nd)/3.0
          arg1_fw(nd) = ang_l_fw(nd)/3.0
        END DO
        root1 = -(2.0*(result1*temp2)) - p_cubic/3.0
        temp2 = SQRT(qroot)
        DO nd=1,nbdirs
          IF (qroot .EQ. 0.0_8) THEN
            result1_fw(nd) = 0.0_8
          ELSE
            result1_fw(nd) = qroot_fw(nd)/(2.0*temp2)
          END IF
        END DO
        result1 = temp2
        arg1 = (ang_l+pi2)/3.0
        temp2 = COS(arg1)
        DO nd=1,nbdirs
          root2_fw(nd) = -(2.0*(temp2*result1_fw(nd)-result1*SIN(arg1)*&
&           arg1_fw(nd))) - p_cubic_fw(nd)/3.0
          arg1_fw(nd) = ang_l_fw(nd)/3.0
        END DO
        root2 = -(2.0*(result1*temp2)) - p_cubic/3.0
        temp2 = SQRT(qroot)
        DO nd=1,nbdirs
          IF (qroot .EQ. 0.0_8) THEN
            result1_fw(nd) = 0.0_8
          ELSE
            result1_fw(nd) = qroot_fw(nd)/(2.0*temp2)
          END IF
        END DO
        result1 = temp2
        arg1 = (ang_l-pi2)/3.0
        temp2 = COS(arg1)
        DO nd=1,nbdirs
          root3_fw(nd) = -(2.0*(temp2*result1_fw(nd)-result1*SIN(arg1)*&
&           arg1_fw(nd))) - p_cubic_fw(nd)/3.0
        END DO
        root3 = -(2.0*(result1*temp2)) - p_cubic/3.0
!   Here A = x - p / 3, allowing the cubic expression to be expressed
!   as: x^3 + ax + b = 0
!   rank roots #1,#2 and #3 according to the minimum, intermediate and maximum value
        IF (root1 .LE. root2 .AND. root1 .LE. root3) THEN
          DO nd=1,nbdirs
            minroot_fw(nd) = root1_fw(nd)
          END DO
          minroot = root1
          IF (root2 .LE. root3) THEN
            DO nd=1,nbdirs
              midroot_fw(nd) = root2_fw(nd)
              maxroot_fw(nd) = root3_fw(nd)
            END DO
            midroot = root2
            maxroot = root3
          ELSE
            DO nd=1,nbdirs
              midroot_fw(nd) = root3_fw(nd)
              maxroot_fw(nd) = root2_fw(nd)
            END DO
            midroot = root3
            maxroot = root2
          END IF
        ELSE
          midroot_fw(:) = 0.0_8
          minroot_fw(:) = 0.0_8
          maxroot_fw(:) = 0.0_8
        END IF
        IF (root2 .LE. root1 .AND. root2 .LE. root3) THEN
          DO nd=1,nbdirs
            minroot_fw(nd) = root2_fw(nd)
          END DO
          minroot = root2
          IF (root1 .LE. root3) THEN
            DO nd=1,nbdirs
              midroot_fw(nd) = root1_fw(nd)
              maxroot_fw(nd) = root3_fw(nd)
            END DO
            midroot = root1
            maxroot = root3
          ELSE
            DO nd=1,nbdirs
              midroot_fw(nd) = root3_fw(nd)
              maxroot_fw(nd) = root1_fw(nd)
            END DO
            midroot = root3
            maxroot = root1
          END IF
        END IF
        IF (root3 .LE. root1 .AND. root3 .LE. root2) THEN
          DO nd=1,nbdirs
            minroot_fw(nd) = root3_fw(nd)
          END DO
          minroot = root3
          IF (root1 .LT. root2) THEN
            DO nd=1,nbdirs
              midroot_fw(nd) = root1_fw(nd)
              maxroot_fw(nd) = root2_fw(nd)
            END DO
            midroot = root1
            maxroot = root2
          ELSE
            DO nd=1,nbdirs
              midroot_fw(nd) = root2_fw(nd)
              maxroot_fw(nd) = root1_fw(nd)
            END DO
            midroot = root2
            maxroot = root1
          END IF
        END IF
        aphoto = 0
!     find out where roots plop down relative to the x-y axis
        IF (minroot .GT. 0 .AND. midroot .GT. 0 .AND. maxroot .GT. 0) &
&       THEN
          DO nd=1,nbdirs
            aphoto_fw(nd) = minroot_fw(nd)
          END DO
          aphoto = minroot
        ELSE
          aphoto_fw(:) = 0.0_8
        END IF
        IF (minroot .LT. 0 .AND. midroot .LT. 0 .AND. maxroot .GT. 0) &
&       THEN
          DO nd=1,nbdirs
            aphoto_fw(nd) = maxroot_fw(nd)
          END DO
          aphoto = maxroot
        END IF
        IF (minroot .LT. 0 .AND. midroot .GT. 0 .AND. maxroot .GT. 0) &
&       THEN
          DO nd=1,nbdirs
            aphoto_fw(nd) = midroot_fw(nd)
          END DO
          aphoto = midroot
        END IF
        cs = ca - aphoto/g_lb_c
!mol m-2 s-1
        temp2 = aphoto/cs
        gs_h2o_mole = b_h2o + m_h2o*(f_soilwater*rh_leaf*temp2)
        gs_co2_mole = gs_h2o_mole/1.6
        ci = cs - aphoto/gs_co2_mole
        DO nd=1,nbdirs
!        //also test for sucrose limitation of photosynthesis, as suggested by
!        //Collatz.  Js=Vmax/2
          cs_fw(nd) = -((aphoto_fw(nd)-aphoto*g_lb_c_fw(nd)/g_lb_c)/&
&           g_lb_c)
          gs_h2o_mole_fw(nd) = m_h2o*(temp2*(rh_leaf*f_soilwater_fw(nd)+&
&           f_soilwater*rh_leaf_fw(nd))+f_soilwater*rh_leaf*(aphoto_fw(&
&           nd)-temp2*cs_fw(nd))/cs)
          gs_co2_mole_fw(nd) = gs_h2o_mole_fw(nd)/1.6
          ci_fw(nd) = cs_fw(nd) - (aphoto_fw(nd)-aphoto*gs_co2_mole_fw(&
&           nd)/gs_co2_mole)/gs_co2_mole
          j_sucrose_fw(nd) = ci*k_t_fw(nd) + k_t*ci_fw(nd) - resp_ld_fw(&
&           nd)
        END DO
        j_sucrose = k_t*ci - resp_ld
        IF (j_sucrose .LT. aphoto) THEN
          DO nd=1,nbdirs
            aphoto_fw(nd) = j_sucrose_fw(nd)
          END DO
          aphoto = j_sucrose
        END IF
!         //Stomatal conductance for water vapor
!        //forest are hypostomatous.
!        //Hence we don't divide the total resistance
!        //by 2 since transfer is going on only one side of a leaf.
!        // if A < 0 then gs should go to cuticular value and recalculate A
!         //using quadratic solution
        IF (aphoto .GT. 0.0) GOTO 400
      END IF
      aquad = beta + k_t/g_lb_c + 1.6*k_t/b_co2
      temp2 = k_t/g_lb_c + 1.6*k_t/b_co2
      bquad = beta*2*resp_ld - m - ca*k_t - temp2*(m-resp_ld)
      cquad = beta*resp_ld*resp_ld - m*resp_ld + ca*k_t*(m-resp_ld)
      DO nd=1,nbdirs
!        // if aphoto < 0  set stomatal conductance to cuticle value
!        //a quadratic solution of A is derived if gs=b, but a cubic form occurs
!        //if gs =ax + b.  Use quadratic case when A <=0
!  // Bin Chen:
!         r_tot = 1.0/b_co2 + 1.0/g_lb_c; // total resistance to CO2 (m2 s mol-1)
!         denom = g_lb_c * b_co2;
!         Aquad = r_tot * e_ps;
!         Bquad = (e_ps*resp_ld + a_ps)*r_tot - b_ps - e_ps*ca;
!         Cquad = a_ps*(ca-d_ps) - resp_ld*(e_ps*ca+b_ps);
        aquad_fw(nd) = (k_t_fw(nd)-k_t*g_lb_c_fw(nd)/g_lb_c)/g_lb_c + &
&         1.6*k_t_fw(nd)/b_co2
        bquad_fw(nd) = beta*2*resp_ld_fw(nd) - m_fw(nd) - ca*k_t_fw(nd) &
&         - (m-resp_ld)*((k_t_fw(nd)-k_t*g_lb_c_fw(nd)/g_lb_c)/g_lb_c+&
&         1.6*k_t_fw(nd)/b_co2) - temp2*(m_fw(nd)-resp_ld_fw(nd))
        cquad_fw(nd) = (beta*2*resp_ld-m)*resp_ld_fw(nd) - resp_ld*m_fw(&
&         nd) + ca*((m-resp_ld)*k_t_fw(nd)+k_t*(m_fw(nd)-resp_ld_fw(nd))&
&         )
        product1_fw(nd) = 2*bquad*bquad_fw(nd) - 4.0*(cquad*aquad_fw(nd)&
&         +aquad*cquad_fw(nd))
      END DO
      product1 = bquad*bquad - 4.0*aquad*cquad
      IF (product1 .GE. 0) THEN
        temp2 = SQRT(product1)
        DO nd=1,nbdirs
          IF (product1 .EQ. 0.0_8) THEN
            result1_fw(nd) = 0.0_8
          ELSE
            result1_fw(nd) = product1_fw(nd)/(2.0*temp2)
          END IF
        END DO
        result1 = temp2
        temp2 = (-bquad-result1)/(2.0*aquad)
        DO nd=1,nbdirs
          aphoto_fw(nd) = (-bquad_fw(nd)-result1_fw(nd)-temp2*2.0*&
&           aquad_fw(nd))/(2.0*aquad)
        END DO
        aphoto = temp2
      END IF
 400  IF (0. .LT. aphoto) THEN
        aphoto = aphoto
      ELSE
        aphoto = 0.
        aphoto_fw(:) = 0.0_8
      END IF
      cs = ca - aphoto/g_lb_c
!mol m-2 s-1
      temp2 = aphoto/cs
      gs_h2o_mole = b_h2o + m_h2o*(f_soilwater*rh_leaf*temp2)
      gs_co2_mole = gs_h2o_mole/1.6
      DO nd=1,nbdirs
        cs_fw(nd) = -((aphoto_fw(nd)-aphoto*g_lb_c_fw(nd)/g_lb_c)/g_lb_c&
&         )
        gs_h2o_mole_fw(nd) = m_h2o*(temp2*(rh_leaf*f_soilwater_fw(nd)+&
&         f_soilwater*rh_leaf_fw(nd))+f_soilwater*rh_leaf*(aphoto_fw(nd)&
&         -temp2*cs_fw(nd))/cs)
        gs_co2_mole_fw(nd) = gs_h2o_mole_fw(nd)/1.6
        ci_fw(nd) = cs_fw(nd) - (aphoto_fw(nd)-aphoto*gs_co2_mole_fw(nd)&
&         /gs_co2_mole)/gs_co2_mole
!m s-1
        gs_w_fw(nd) = temp_leaf_k*met%pstat273*gs_h2o_mole_fw(nd)
      END DO
      ci = cs - aphoto/gs_co2_mole
      gs_w = gs_h2o_mole*temp_leaf_k*met%pstat273
    ELSE
!***************************************
!        Test for the minimum of Wc and Wj.  Both have the form:
!        W = (a ci - ad)/(e ci + b)
!        after the minimum is chosen set a, b, e and d for the cubic solution.
!        estimate of J according to Farquhar and von Cammerer (1981)
!***************************************
      temp2 = jmax*iphoton/(iphoton+2.1*jmax)
      DO nd=1,nbdirs
        alpha_ps_fw(nd) = -(b_co2*g_lb_c_fw(nd)/g_lb_c**2) - m_co2*(&
&         f_soilwater*rh_leaf_fw(nd)+rh_leaf*f_soilwater_fw(nd))
        beta_ps_fw(nd) = ca*(m_co2*(f_soilwater*(rh_leaf*g_lb_c_fw(nd)+&
&         g_lb_c*rh_leaf_fw(nd))+g_lb_c*rh_leaf*f_soilwater_fw(nd))-&
&         g_lb_c_fw(nd))
        gamma_ps_fw(nd) = ca**2*b_co2*g_lb_c_fw(nd)
        theta_ps_fw(nd) = m_co2*(f_soilwater*(rh_leaf*g_lb_c_fw(nd)+&
&         g_lb_c*rh_leaf_fw(nd))+g_lb_c*rh_leaf*f_soilwater_fw(nd))
        j_photon_fw(nd) = (iphoton*jmax_fw(nd)+jmax*iphoton_fw(nd)-temp2&
&         *(iphoton_fw(nd)+2.1*jmax_fw(nd)))/(iphoton+2.1*jmax)
      END DO
      alpha_ps = 1.0 + b_co2/g_lb_c - m_co2*rh_leaf*f_soilwater
      beta_ps = ca*(g_lb_c*m_co2*rh_leaf*f_soilwater-2.0*b_co2-g_lb_c)
      gamma_ps = ca*ca*g_lb_c*b_co2
      theta_ps = g_lb_c*m_co2*rh_leaf*f_soilwater - b_co2
      j_photon = temp2
!    if(LC == 40) then
!        j_photon = jmax
!    else
!      j_photon =jmax * iphoton/ (iphoton+ 2.1*jmax)
!    end if
!  initial guess of intercellular CO2 concentration to estimate Wc and Wj:
      wj = j_photon*(cii-gammac)/(4.*cii+8.0*gammac)
      wc = vcmax*(cii-gammac)/(cii+bc)
!    if(LC == 40) then
!        wc = vcmax
!    else
!      wc = vcmax * (cii - gammac) / (cii + bc)
!    end if
      IF (wj .LT. wc) THEN
!        // for Harley and Farquhar type model for Wj
        psguess = wj
        DO nd=1,nbdirs
          a_ps_fw(nd) = j_photon_fw(nd)
        END DO
        a_ps = j_photon
        b_ps = 8.0*gammac
        e_ps = 4.0
        d_ps = gammac
      ELSE
        psguess = wc
        DO nd=1,nbdirs
          a_ps_fw(nd) = vcmax_fw(nd)
        END DO
        a_ps = vcmax
        b_ps = bc
        e_ps = 1.0
        d_ps = gammac
      END IF
!***************************************
! if wj or wc are less than resp_ld then A would probably be less than
! zero.  This would yield a
! negative stomatal conductance.  In this case, assume gs equals the
! cuticular value. This
! assumptions yields a quadratic rather than cubic solution for A
!***************************************
      IF (.NOT.(wj .LE. resp_ld .OR. wc .LE. resp_ld)) THEN
        denom = e_ps*alpha_ps
        p_cubic = e_ps*beta_ps + b_ps*theta_ps - a_ps*alpha_ps + e_ps*&
&         resp_ld*alpha_ps
        q_cubic = e_ps*gamma_ps + b_ps*gamma_ps/ca - a_ps*beta_ps + a_ps&
&         *d_ps*theta_ps + e_ps*resp_ld*beta_ps + resp_ld*b_ps*theta_ps
        r_cubic = -(a_ps*gamma_ps) + a_ps*d_ps*gamma_ps/ca + e_ps*&
&         resp_ld*gamma_ps + resp_ld*b_ps*gamma_ps/ca
        DO nd=1,nbdirs
!        //cubic solution:
!        // A^3 + p A^2 + q A + r = 0
          denom_fw(nd) = e_ps*alpha_ps_fw(nd)
          p_cubic_fw(nd) = e_ps*beta_ps_fw(nd) + b_ps*theta_ps_fw(nd) + &
&           e_ps*(alpha_ps*resp_ld_fw(nd)+resp_ld*alpha_ps_fw(nd)) - &
&           alpha_ps*a_ps_fw(nd) - a_ps*alpha_ps_fw(nd)
          p_cubic_fw(nd) = (p_cubic_fw(nd)-p_cubic*denom_fw(nd)/denom)/&
&           denom
          q_cubic_fw(nd) = (e_ps+b_ps/ca)*gamma_ps_fw(nd) - beta_ps*&
&           a_ps_fw(nd) - a_ps*beta_ps_fw(nd) + d_ps*(theta_ps*a_ps_fw(&
&           nd)+a_ps*theta_ps_fw(nd)) + e_ps*(beta_ps*resp_ld_fw(nd)+&
&           resp_ld*beta_ps_fw(nd)) + b_ps*(theta_ps*resp_ld_fw(nd)+&
&           resp_ld*theta_ps_fw(nd))
          q_cubic_fw(nd) = (q_cubic_fw(nd)-q_cubic*denom_fw(nd)/denom)/&
&           denom
          r_cubic_fw(nd) = d_ps*(gamma_ps*a_ps_fw(nd)+a_ps*gamma_ps_fw(&
&           nd))/ca - gamma_ps*a_ps_fw(nd) - a_ps*gamma_ps_fw(nd) + e_ps&
&           *(gamma_ps*resp_ld_fw(nd)+resp_ld*gamma_ps_fw(nd)) + b_ps*(&
&           gamma_ps*resp_ld_fw(nd)+resp_ld*gamma_ps_fw(nd))/ca
          r_cubic_fw(nd) = (r_cubic_fw(nd)-r_cubic*denom_fw(nd)/denom)/&
&           denom
        END DO
        p_cubic = p_cubic/denom
        q_cubic = q_cubic/denom
        r_cubic = r_cubic/denom
        DO nd=1,nbdirs
!        // Use solution from Numerical Recipes from Press
          qroot_fw(nd) = (2*p_cubic*p_cubic_fw(nd)-3.0*q_cubic_fw(nd))/&
&           9.0
          rroot_fw(nd) = (2.0*3*p_cubic**2*p_cubic_fw(nd)-9.0*(q_cubic*&
&           p_cubic_fw(nd)+p_cubic*q_cubic_fw(nd))+27.0*r_cubic_fw(nd))/&
&           54.0
        END DO
        qroot = (p_cubic*p_cubic-3.0*q_cubic)/9.0
        rroot = (2.0*p_cubic*p_cubic*p_cubic-9.0*p_cubic*q_cubic+27.0*&
&         r_cubic)/54.0
        IF (qroot .LT. 1.e-6) THEN
          qroot = 1.e-6
          qroot_fw(:) = 0.0_8
        ELSE
          qroot = qroot
        END IF
        arg1 = qroot*qroot*qroot
        temp2 = SQRT(arg1)
        result1 = temp2
        DO nd=1,nbdirs
          arg1_fw(nd) = 3*qroot**2*qroot_fw(nd)
          IF (arg1 .EQ. 0.0_8) THEN
            result1_fw(nd) = 0.0_8
          ELSE
            result1_fw(nd) = arg1_fw(nd)/(2.0*temp2)
          END IF
          r3q_fw(nd) = (rroot_fw(nd)-rroot*result1_fw(nd)/result1)/&
&           result1
        END DO
        r3q = rroot/result1
        IF (r3q .GT. 1) THEN
          r3q = 1
          r3q_fw(:) = 0.0_8
        END IF
        IF (r3q .LT. -1) THEN
          r3q = -1
          r3q_fw(:) = 0.0_8
        END IF
        temp2 = SQRT(qroot)
        DO nd=1,nbdirs
          IF (r3q .EQ. 1.0 .OR. r3q .EQ. (-1.0)) THEN
            ang_l_fw(nd) = 0.0_8
          ELSE
            ang_l_fw(nd) = -(r3q_fw(nd)/SQRT(1.0-r3q**2))
          END IF
          IF (qroot .EQ. 0.0_8) THEN
            result1_fw(nd) = 0.0_8
          ELSE
            result1_fw(nd) = qroot_fw(nd)/(2.0*temp2)
          END IF
          arg1_fw(nd) = ang_l_fw(nd)/3.0
        END DO
        ang_l = ACOS(r3q)
        result1 = temp2
        arg1 = ang_l/3.0
        temp2 = COS(arg1)
        DO nd=1,nbdirs
          root1_fw(nd) = -(2.0*(temp2*result1_fw(nd)-result1*SIN(arg1)*&
&           arg1_fw(nd))) - p_cubic_fw(nd)/3.0
          arg1_fw(nd) = ang_l_fw(nd)/3.0
        END DO
        root1 = -(2.0*(result1*temp2)) - p_cubic/3.0
        temp2 = SQRT(qroot)
        DO nd=1,nbdirs
          IF (qroot .EQ. 0.0_8) THEN
            result1_fw(nd) = 0.0_8
          ELSE
            result1_fw(nd) = qroot_fw(nd)/(2.0*temp2)
          END IF
        END DO
        result1 = temp2
        arg1 = (ang_l+pi2)/3.0
        temp2 = COS(arg1)
        DO nd=1,nbdirs
          root2_fw(nd) = -(2.0*(temp2*result1_fw(nd)-result1*SIN(arg1)*&
&           arg1_fw(nd))) - p_cubic_fw(nd)/3.0
          arg1_fw(nd) = ang_l_fw(nd)/3.0
        END DO
        root2 = -(2.0*(result1*temp2)) - p_cubic/3.0
        temp2 = SQRT(qroot)
        DO nd=1,nbdirs
          IF (qroot .EQ. 0.0_8) THEN
            result1_fw(nd) = 0.0_8
          ELSE
            result1_fw(nd) = qroot_fw(nd)/(2.0*temp2)
          END IF
        END DO
        result1 = temp2
        arg1 = (ang_l-pi2)/3.0
        temp2 = COS(arg1)
        DO nd=1,nbdirs
          root3_fw(nd) = -(2.0*(temp2*result1_fw(nd)-result1*SIN(arg1)*&
&           arg1_fw(nd))) - p_cubic_fw(nd)/3.0
        END DO
        root3 = -(2.0*(result1*temp2)) - p_cubic/3.0
!   Here A = x - p / 3, allowing the cubic expression to be expressed
!   as: x^3 + ax + b = 0
!   rank roots #1,#2 and #3 according to the minimum, intermediate and maximum value
        IF (root1 .LE. root2 .AND. root1 .LE. root3) THEN
          DO nd=1,nbdirs
            minroot_fw(nd) = root1_fw(nd)
          END DO
          minroot = root1
          IF (root2 .LE. root3) THEN
            DO nd=1,nbdirs
              midroot_fw(nd) = root2_fw(nd)
              maxroot_fw(nd) = root3_fw(nd)
            END DO
            midroot = root2
            maxroot = root3
          ELSE
            DO nd=1,nbdirs
              midroot_fw(nd) = root3_fw(nd)
              maxroot_fw(nd) = root2_fw(nd)
            END DO
            midroot = root3
            maxroot = root2
          END IF
        ELSE
          midroot_fw(:) = 0.0_8
          minroot_fw(:) = 0.0_8
          maxroot_fw(:) = 0.0_8
        END IF
        IF (root2 .LE. root1 .AND. root2 .LE. root3) THEN
          DO nd=1,nbdirs
            minroot_fw(nd) = root2_fw(nd)
          END DO
          minroot = root2
          IF (root1 .LE. root3) THEN
            DO nd=1,nbdirs
              midroot_fw(nd) = root1_fw(nd)
              maxroot_fw(nd) = root3_fw(nd)
            END DO
            midroot = root1
            maxroot = root3
          ELSE
            DO nd=1,nbdirs
              midroot_fw(nd) = root3_fw(nd)
              maxroot_fw(nd) = root1_fw(nd)
            END DO
            midroot = root3
            maxroot = root1
          END IF
        END IF
        IF (root3 .LE. root1 .AND. root3 .LE. root2) THEN
          DO nd=1,nbdirs
            minroot_fw(nd) = root3_fw(nd)
          END DO
          minroot = root3
          IF (root1 .LT. root2) THEN
            DO nd=1,nbdirs
              midroot_fw(nd) = root1_fw(nd)
              maxroot_fw(nd) = root2_fw(nd)
            END DO
            midroot = root1
            maxroot = root2
          ELSE
            DO nd=1,nbdirs
              midroot_fw(nd) = root2_fw(nd)
              maxroot_fw(nd) = root1_fw(nd)
            END DO
            midroot = root2
            maxroot = root1
          END IF
        END IF
        aphoto = 0
!     find out where roots plop down relative to the x-y axis
        IF (minroot .GT. 0 .AND. midroot .GT. 0 .AND. maxroot .GT. 0) &
&       THEN
          DO nd=1,nbdirs
            aphoto_fw(nd) = minroot_fw(nd)
          END DO
          aphoto = minroot
        ELSE
          aphoto_fw(:) = 0.0_8
        END IF
        IF (minroot .LT. 0 .AND. midroot .LT. 0 .AND. maxroot .GT. 0) &
&       THEN
          DO nd=1,nbdirs
            aphoto_fw(nd) = maxroot_fw(nd)
          END DO
          aphoto = maxroot
        END IF
        IF (minroot .LT. 0 .AND. midroot .GT. 0 .AND. maxroot .GT. 0) &
&       THEN
          DO nd=1,nbdirs
            aphoto_fw(nd) = midroot_fw(nd)
          END DO
          aphoto = midroot
        END IF
!        //also test for sucrose limitation of photosynthesis, as suggested by
!        //Collatz.  Js=Vmax/2
        DO nd=1,nbdirs
          j_sucrose_fw(nd) = vcmax_fw(nd)/2. - resp_ld_fw(nd)
        END DO
        j_sucrose = vcmax/2. - resp_ld
!    if(LC == 40) then
!      j_sucrose = 2.*1.e4*vcmax*cii/air_pres/1000. - resp_ld
!    else
!      j_sucrose = vcmax / 2. - resp_ld
!    end if
        IF (j_sucrose .LT. aphoto) THEN
          DO nd=1,nbdirs
            aphoto_fw(nd) = j_sucrose_fw(nd)
          END DO
          aphoto = j_sucrose
        END IF
!         //Stomatal conductance for water vapor
!        //forest are hypostomatous.
!        //Hence we don't divide the total resistance
!        //by 2 since transfer is going on only one side of a leaf.
!        // if A < 0 then gs should go to cuticular value and recalculate A
!         //using quadratic solution
        IF (aphoto .GT. 0.0) GOTO 200
      END IF
      ps_1 = ca*g_lb_c*b_co2
      delta_1 = b_co2 + g_lb_c
      denom = g_lb_c*b_co2
      aquad = delta_1*e_ps
      bquad = -(ps_1*e_ps) - a_ps*delta_1 + e_ps*resp_ld*delta_1 - b_ps*&
&       denom
      cquad = a_ps*ps_1 - a_ps*d_ps*denom - e_ps*resp_ld*ps_1 - resp_ld*&
&       b_ps*denom
      DO nd=1,nbdirs
!        // if aphoto < 0  set stomatal conductance to cuticle value
!        //a quadratic solution of A is derived if gs=b, but a cubic form occurs
!        //if gs =ax + b.  Use quadratic case when A <=0
!  // Bin Chen:
!         r_tot = 1.0/b_co2 + 1.0/g_lb_c; // total resistance to CO2 (m2 s mol-1)
!         denom = g_lb_c * b_co2;
!         Aquad = r_tot * e_ps;
!         Bquad = (e_ps*resp_ld + a_ps)*r_tot - b_ps - e_ps*ca;
!         Cquad = a_ps*(ca-d_ps) - resp_ld*(e_ps*ca+b_ps);
        ps_1_fw(nd) = ca*b_co2*g_lb_c_fw(nd)
        delta_1_fw(nd) = g_lb_c_fw(nd)
        denom_fw(nd) = b_co2*g_lb_c_fw(nd)
        aquad_fw(nd) = e_ps*delta_1_fw(nd)
        bquad_fw(nd) = e_ps*(delta_1*resp_ld_fw(nd)+resp_ld*delta_1_fw(&
&         nd)) - delta_1*a_ps_fw(nd) - a_ps*delta_1_fw(nd) - e_ps*&
&         ps_1_fw(nd) - b_ps*denom_fw(nd)
        cquad_fw(nd) = ps_1*a_ps_fw(nd) + a_ps*ps_1_fw(nd) - d_ps*(denom&
&         *a_ps_fw(nd)+a_ps*denom_fw(nd)) - e_ps*(ps_1*resp_ld_fw(nd)+&
&         resp_ld*ps_1_fw(nd)) - b_ps*(denom*resp_ld_fw(nd)+resp_ld*&
&         denom_fw(nd))
        product1_fw(nd) = 2*bquad*bquad_fw(nd) - 4.0*(cquad*aquad_fw(nd)&
&         +aquad*cquad_fw(nd))
      END DO
      product1 = bquad*bquad - 4.0*aquad*cquad
      IF (product1 .GE. 0) THEN
        temp2 = SQRT(product1)
        DO nd=1,nbdirs
          IF (product1 .EQ. 0.0_8) THEN
            result1_fw(nd) = 0.0_8
          ELSE
            result1_fw(nd) = product1_fw(nd)/(2.0*temp2)
          END IF
        END DO
        result1 = temp2
        temp2 = (-bquad-result1)/(2.0*aquad)
        DO nd=1,nbdirs
          aphoto_fw(nd) = (-bquad_fw(nd)-result1_fw(nd)-temp2*2.0*&
&           aquad_fw(nd))/(2.0*aquad)
        END DO
        aphoto = temp2
      END IF
 200  IF (0. .LT. aphoto) THEN
        aphoto = aphoto
      ELSE
        aphoto = 0.
        aphoto_fw(:) = 0.0_8
      END IF
      cs = ca - aphoto/g_lb_c
!mol m-2 s-1
      temp2 = aphoto/cs
      gs_h2o_mole = b_h2o + m_h2o*(f_soilwater*rh_leaf*temp2)
      gs_co2_mole = gs_h2o_mole/1.6
      DO nd=1,nbdirs
        cs_fw(nd) = -((aphoto_fw(nd)-aphoto*g_lb_c_fw(nd)/g_lb_c)/g_lb_c&
&         )
        gs_h2o_mole_fw(nd) = m_h2o*(temp2*(rh_leaf*f_soilwater_fw(nd)+&
&         f_soilwater*rh_leaf_fw(nd))+f_soilwater*rh_leaf*(aphoto_fw(nd)&
&         -temp2*cs_fw(nd))/cs)
        gs_co2_mole_fw(nd) = gs_h2o_mole_fw(nd)/1.6
        ci_fw(nd) = cs_fw(nd) - (aphoto_fw(nd)-aphoto*gs_co2_mole_fw(nd)&
&         /gs_co2_mole)/gs_co2_mole
!m s-1
        gs_w_fw(nd) = temp_leaf_k*met%pstat273*gs_h2o_mole_fw(nd)
      END DO
      ci = cs - aphoto/gs_co2_mole
      gs_w = gs_h2o_mole*temp_leaf_k*met%pstat273
    END IF
!! QBO
!   ffpa = 0.8;   ! 0.6~0.9
    IF (iphoton .LE. 0.) THEN
      xsif = 0.
      xsif_fw(:) = 0.0_8
    ELSE
! C4 je is added, @MOUSONG WU, 2020-09-10
      IF (lc .EQ. 40 .OR. lc .EQ. 41) THEN
        DO nd=1,nbdirs
          je_fw(nd) = aphoto_fw(nd)
        END DO
        je = aphoto
      ELSE
        temp2 = aphoto/(ci-gammac)
        DO nd=1,nbdirs
          x1_fw(nd) = temp2*ci_fw(nd) + (gammac*2.0+ci)*(aphoto_fw(nd)-&
&           temp2*ci_fw(nd))/(ci-gammac)
        END DO
        x1 = (gammac*2.0+ci)*temp2
        IF (x1 .LT. 0.0) THEN
          je = 0.0
          je_fw(:) = 0.0_8
        ELSE
          DO nd=1,nbdirs
            je_fw(nd) = x1_fw(nd)
          END DO
          je = x1
        END IF
      END IF
      temp2 = 0.05*iphoton*ffpa
      DO nd=1,nbdirs
        xxn_fw(nd) = -((je_fw(nd)-je*(ffpa*0.05*iphoton_fw(nd)+0.05*&
&         iphoton*ffpa_fw(nd))/temp2)/temp2)
      END DO
      xxn = 1.0 - je/temp2
      IF (xxn .LT. 0) THEN
        xxn = 0.
        xxn_fw(:) = 0.0_8
      END IF
      kf = 0.05
      kd = 0.95
      kp = 4.0
      ps_sif = kp/(kf+kp+kd)*(1.-xxn)
      kn = (sif_alpha*xxn+sif_beta)*xxn
! kn     = (6.2473*xxn - 0.5994)*xxn
      temp2 = kf/(kf+kd+kn)
      fm = temp2
      DO nd=1,nbdirs
        ps_sif_fw(nd) = -(kp*xxn_fw(nd)/(kf+kp+kd))
        kn_fw(nd) = xxn*(xxn*sif_alpha_fw(nd)+sif_alpha*xxn_fw(nd)+&
&         sif_beta_fw(nd)) + (sif_alpha*xxn+sif_beta)*xxn_fw(nd)
        fm_fw(nd) = -(temp2*kn_fw(nd)/(kf+kd+kn))
        fs_fw(nd) = (1.0-ps_sif)*fm_fw(nd) - fm*ps_sif_fw(nd)
      END DO
      fs = fm*(1.0-ps_sif)
      IF (xxn .LT. 0.26) THEN
        DO nd=1,nbdirs
          fs_fw(nd) = -(0.0075*xxn_fw(nd))
        END DO
        fs = -(0.0075*xxn) + 0.0181
      END IF
      DO nd=1,nbdirs
        xsif_fw(nd) = ffpa*(iphoton*fs_fw(nd)+fs*iphoton_fw(nd)) + fs*&
&         iphoton*ffpa_fw(nd)
      END DO
      xsif = fs*iphoton*ffpa
!    xSIF = iphoton
    END IF
! add the module for calculating COS uptake by plants, @MOUSONG.WU 2020-09-17
!-- iLab::convf no longer required
! call cos_plant(LC,cosii,convf,gs_h2o_mole,g_lb_cos,vcmax,ffpa,f_soilwater,cos_assim)
    CALL COS_PLANT_FWV(lc, cosii, cosii_fw, gs_h2o_mole, gs_h2o_mole_fw&
&                , g_lb_cos, g_lb_cos_fw, vcmax, vcmax_fw, ffpa, ffpa_fw&
&                , f_soilwater, f_soilwater_fw, cos_assim, cos_assim_fw&
&                , nbdirs)
    DO nd=1,nbdirs
! ppb
      coss_fw(nd) = -((cos_assim_fw(nd)-cos_assim*g_lb_cos_fw(nd)/&
&       g_lb_cos)/g_lb_cos)
! ppb
      cosi_fw(nd) = coss_fw(nd) - 1.56*(cos_assim_fw(nd)-cos_assim*&
&       gs_h2o_mole_fw(nd)/gs_h2o_mole)/gs_h2o_mole
    END DO
    coss = cosa - cos_assim/g_lb_cos
    cosi = coss - cos_assim/(gs_h2o_mole/1.56)
  END SUBROUTINE PHOTOSYNTHESIS_FWV

  SUBROUTINE PHOTOSYNTHESIS(lc, temp_leaf_p, f_leaf, p_kc25, p_ko25, &
&   p_tau25, rad_leaf, e_air, g_lb_w, vc_opt, vj_slope, f_soilwater, &
&   b_h2o, m_h2o, cii, temp_leaf_c, lh_leaf, gs_w, gs_h2o_mole, aphoto, &
&   ci, ffpa, sif_alpha, sif_beta, xsif, cosii, cosi, cos_assim)
    IMPLICIT NONE
!*************************************************************************
! This program solves a cubic equation to calculate
! leaf photosynthesis.  This cubic expression is derived from solving
! five simultaneous equations for A, PG, cs, CI and GS.
! Stomatal conductance is computed with the Ball-Berry model.
! The cubic derivation assumes that b', the intercept of the Ball-Berry
! stomatal conductance model, is non-zero.
! Gs = k A rh/cs + b'
! We also found that the solution for A can be obtained by a quadratic equation
! when Gs is constant or b' is zero.
! The derivation is published in:
! Baldocchi, D.D. 1994. An analytical solution for coupled leaf photosynthesis
! and stomatal conductance models. Tree Physiology 14: 1069-1079.
!-----------------------------------------------------------------------
! A Biochemical Model of C3 Photosynthesis
! After Farquhar, von Caemmerer and Berry (1980) Planta.
! 149: 78-90.
! The original program was modified to incorporate functions and parameters
! derived from gas exchange experiments of Harley, who paramertized Vc and J in
! terms of optimal temperature, rather than some reference temperature, eg 25C.
! Program calculates leaf photosynthesis from biochemical parameters
! rd25 - Dark respiration at 25 degrees C (umol m-2 s-1)
! tlk - leaf temperature, Kelvin
! jmax - optimal rate of electron transport
! vcopt - maximum rate of RuBP Carboxylase/oxygenase
! iphoton - incident photosynthetically active photon flux (umols m-2 s-1)
! note: Harley parameterized the model on the basis of incident PAR
! gs - stomatal conductance (mols m-2 s-1), typically 0.01-0.20
! pstat-station pressure, bars
! aphoto - net photosynthesis  (umol m-2 s-1)
! ps - gross photosynthesis (umol m-2 s-1)
! aps - net photosynthesis (mg m-2 s-1)
! aphoto (umol m-2 s-1)
!-----------------------------------------------------------------------
! iphoton is radiation incident on leaves
! The temperature dependency of the kinetic properties of
! RUBISCO are compensated for using the Arrhenius and
! Boltzmann equations.  From biochemistry, one observes that
! at moderate temperatures enzyme kinetic rates increase
! with temperature.  At extreme temperatures enzyme
! denaturization occurs and rates must decrease.
! Arrhenius Eq.
! f(T)=f(tk_25) exp(tk -298)eact/(298 R tk)), where eact is the
! activation energy.
! Boltzmann distribution
! F(T)=tboltz)
! Define terms for calculation of gross photosynthesis, PG
! PG is a function of the minimum of RuBP saturated rate of
! carboxylation, Wc, and the RuBP limited rate of carboxylation, Wj.
! Wj is limiting when light is low and electron transport, which
! re-generates RuBP, is limiting.  Wc is limiting when plenty of RuBP is
! available compared to the CO2 that is needed for carboxylation.
! Both equations take the form:
! PG-photorespiration= (a CI-a d)/(e CI + b)
! PG-photorespiration=min[Wj,Wc] (1-gamma_ps/Ci)
! Wc=Vcmax Ci/(Ci + Kc(1+O2/Ko))
! Wj=J Ci/(4 Ci + 8 gamma_ps)
! Ps kinetic coefficients from Harley at WBW.
! gamma_ps is the CO2 compensation point
! Jan 14, 1999 Updated the cubic solutions for photosynthesis.  There are
! times when the restriction that R^2 < Q^3 is violated.  I therefore need
! alternative algorithms to solve for the correct root.
!*************************************************************************
! It is temporay, will be removed later
    REAL(r8) :: temp_leaf_p
! Leaf respiration ratio, default value of 0.5
    REAL(r8) :: f_leaf
! net shortwave radiation (W/m2)
    REAL(r8) :: rad_leaf
! water vapor pressure above canopy (kPa)
    REAL(r8) :: e_air
! leaf laminar boundary layer condunctance to H2O (m/s)
    REAL(r8) :: g_lb_w
! the maximum velocities of carboxylation of Rubisco at 25 deg C (umol m-2 s-1)
    REAL(r8) :: vc_opt
! the ratio of Vmax/Jmax, default value of 2.39
    REAL(r8) :: vj_slope
! an empirical scalar of soil water stress on stomatal conductance, dimensionless
    REAL(r8) :: f_soilwater
! the intercept term in BWB model (mol H2O m-2 s-1)
    REAL(r8) :: b_h2o
! the slope in BWB model
    REAL(r8) :: m_h2o
!landcover type
    INTEGER :: lc
! replace, kc25,ko25,tau25 with three pramters, default values are 274.6,419.8,2904.12, respectively
    REAL(r8) :: p_kc25, p_ko25, p_tau25
! initial intercellular co2 concentration (ppm)
    REAL(r8) :: cii
! leaf temperature (deg C)
    REAL(r8) :: temp_leaf_c
! leaf latent heat flux (W m-2)
    REAL(r8) :: lh_leaf
! stomatal conductance to water vapor (m s-1)
    REAL(r8) :: gs_w
! net photosynthesis rate (umol CO2 m-2 s-1)
    REAL(r8) :: aphoto
! intercellular co2 concentration (ppm)
    REAL(r8) :: ci
!    real(r8)  :: xSIF           ! SIF
! SIF
    REAL(r8) :: sif_alpha, sif_beta, xsif
!  air pressure (kPa)
    REAL(r8), PARAMETER :: air_pres=101.325
! atmospheric co2 concentration (ppm)
    REAL(r8) :: ca
! incident photosynthetic photon flux density (PPFD) umol m-2 s-1
    REAL(r8) :: iphoton
!    real(r8)  :: g_lb_c          ! leaf laminar boundary layer condunctance to CO2 (mol m-2 s-1)
! leaf laminar boundary layer condunctance to CO2,COS (mol m-2 s-1)
    REAL(r8) :: g_lb_c, g_lb_cos
! relative humidity at leaf surface (0-1)
    REAL(r8) :: rh_leaf
! leaf temperature (K)
    REAL(r8) :: temp_leaf_k
! stomatal conductance to CO2 (mol m-2 s-1)
    REAL(r8) :: gs_co2_mole
! stomatal conductance to h2o (mol m-2 s-1)
    REAL(r8) :: gs_h2o_mole
! temporary variable
    REAL(r8) :: bc
! CO2 concentration at leaf surface (ppm)
    REAL(r8) :: cs
! the intercept term in BWB model (mol CO2 m-2 s-1): b_h2o/1.6
    REAL(r8) :: b_co2
! the slope in BWB model: m_h2o/1.6
    REAL(r8) :: m_co2
! CO2 compensation point (ppm)
    REAL(r8) :: gammac
! the maximum potential electron transport rate at 25 deg C (umol m-2 s-1)
    REAL(r8) :: jmopt
! the maximum potential electron transport rate (umol m-2 s-1)
    REAL(r8) :: jmax
! the maximum velocities of carboxylation of Rubisco (umol m-2 s-1)
    REAL(r8) :: vcmax
! Michaelis-Menten constant for CO2 (?ol mol-1)
    REAL(r8) :: km_co2
! Michaelis-Menten constant for O2 (mmol mol-1)
    REAL(r8) :: km_o2
! the specifity of Rubisco for CO2 compared with O2
    REAL(r8) :: tau
! leaf dark respiration (umol m-2 s-1)
    REAL(r8) :: resp_ld
! leaf dark respiration at 25 deg C (umol m-2 s-1)
    REAL(r8) :: resp_ld25
! the flux of electrons through the thylakoid membrane (umol m-2 s-1)
    REAL(r8) :: j_photon
    REAL(r8) :: alpha_ps
    REAL(r8) :: beta_ps
    REAL(r8) :: gamma_ps
    REAL(r8) :: theta_ps
    REAL(r8) :: denom
    REAL(r8) :: p_cubic
    REAL(r8) :: q_cubic
    REAL(r8) :: r_cubic
    REAL(r8) :: qroot
    REAL(r8) :: rroot
    REAL(r8) :: root1, root2, root3
    REAL(r8) :: ang_l
! net photosynthesis rate limited by sucrose synthesis (umol m-2 s-1)
    REAL(r8) :: j_sucrose
! gross photosynthesis rate limited by light (umol m-2 s-1)
    REAL(r8) :: wc, wj, psguess
!-- iLab::convf no longer required
! real(r8)  :: cosa,convf,cosi,cosii,coss  ! parameters used for COS calculations
! parameters used for COS calculations
    REAL(r8) :: cosa, cosi, cosii, coss
    REAL(r8) :: cos_assim
    REAL(r8) :: kn, kf, kd, kp, ps_sif, fm
    REAL(r8) :: je, xxn, fs, ffpa
    REAL(r8) :: aquad, bquad, cquad
    REAL(r8) :: b_ps, a_ps, e_ps, d_ps
    REAL(r8) :: product1
    REAL(r8) :: ps_1
    REAL(r8) :: delta_1
    REAL(r8) :: r3q
    REAL(r8) :: minroot, maxroot, midroot
    REAL(r8) :: tprime25
    REAL(r8) :: k_t_opt, k_t, theta, beta, m1, m2, m
    INTRINSIC SQRT
    INTRINSIC MAX
    INTRINSIC ACOS
    INTRINSIC COS
    REAL(r8) :: x1
    REAL(r8) :: arg1
    REAL(r8) :: result1
    minroot = 0.0
    maxroot = 0.0
    midroot = 0.0
    ca = co2_air
    cosa = cos_air
!    iphoton = 4.55*0.5*rad_leaf
! replace 0.5 to a coefficient, f_leaf, leaf respiration rate, for optimization purpose, @MOUSONG WU, 2020-09-14
    iphoton = 4.55*f_leaf*rad_leaf
    IF (2*iphoton .LT. 1) iphoton = 0
    temp_leaf_k = temp_leaf_c + 273.13
    CALL LAMBDA(temp_leaf_p, fact%latent)
    bound_layer_res%vapor = 1.0/g_lb_w
    met%press_bars = 1.013
    met%pstat273 = 0.022624/(273.16*met%press_bars)
    met%t_kelvin = temp_leaf_c + 273.13
! absolute humidity, g m-3
    met%rhova_g = e_air*2165/met%t_kelvin
! absolute humidity, kg m-3
    met%rhova_kg = met%rhova_g/1000.0
    g_lb_c = 1./(1.0/g_lb_w*1.6*temp_leaf_k*met%pstat273)
    m_co2 = m_h2o/1.6
    b_co2 = b_h2o/1.6
    g_lb_cos = 1./(1.0/g_lb_w*1.56*temp_leaf_k*met%pstat273)
!-- iLab::convf no longer required
! convf = temp_leaf_K * (met%pstat273)
    CALL SFC_VPD(temp_leaf_k, lh_leaf, rh_leaf)
! temperature difference
    tprime25 = temp_leaf_k - tk_25
!   
    CALL TEMP_FUNC(kc25, ekc, tprime25, tk_25, temp_leaf_k, km_co2)
    CALL TEMP_FUNC(ko25, eko, tprime25, tk_25, temp_leaf_k, km_o2)
    CALL TEMP_FUNC(tau25, ektau, tprime25, tk_25, temp_leaf_k, tau)
    bc = km_co2*(1.0+o2/km_o2)
! umol mol-1
    gammac = 0.5*o2/tau*1000.0
    resp_ld25 = vc_opt*0.004657
    IF (2.0*iphoton .GT. 10) THEN
! Bin Chen: check this later.
! reduce respiration by 40% in light according to Amthor
      resp_ld25 = resp_ld25*0.4
    END IF
    CALL TEMP_FUNC(resp_ld25, erd, tprime25, tk_25, temp_leaf_k, resp_ld&
&           )
!    jmopt   = 2.39*vc_opt - 14.2
    jmopt = vj_slope*vc_opt - 14.2
! Apply temperature correction to JMAX
    CALL TBOLTZ(jmopt, ejm, toptjm, temp_leaf_k, jmax)
    IF (lc .EQ. 40 .OR. lc .EQ. 41) THEN
! Apply temperature correction to vcmax
      CALL TBOLTZC4(vc_opt, toptvc, temp_leaf_k, vcmax)
    ELSE
! Apply temperature correction to vcmax
      CALL TBOLTZ(vc_opt, evc, toptvc, temp_leaf_k, vcmax)
    END IF
!***************************************
!        APHOTO = PG - resp_ld, net photosynthesis is the difference
!        between gross photosynthesis and dark respiration. Note
!        photorespiration is already factored into PG.
!        Gs from Ball-Berry is for water vapor.  It must be divided
!        by the ratio of the molecular diffusivities to be valid
!        for A
!****************************************
    IF (lc .EQ. 40 .OR. lc .EQ. 41) THEN
! analytical solution for C4 photosynthesis, added by MOUSONG.WU@201907, refer to Chen et al.2019 AFM
      k_t_opt = 2.*1.e4*vc_opt
      k_t = k_t_opt*2.**((temp_leaf_k-298.15)/10.)
      j_photon = iphoton*0.05
      wj = j_photon
      wc = vcmax
      theta = 0.80
      beta = 0.95
      arg1 = (wj+wc)*(wj+wc) - 4*theta*wj*wc
      result1 = SQRT(arg1)
      m1 = (wj+wc+result1)/(2*theta)
      arg1 = (wj+wc)*(wj+wc) + 4*theta*wj*wc
      result1 = SQRT(arg1)
      m2 = (wj+wc+result1)/(2*theta)
      IF (m1 .LT. m2) THEN
        m = m1
      ELSE
        m = m2
      END IF
      alpha_ps = beta*m_co2*f_soilwater*rh_leaf - beta*b_co2/g_lb_c - &
&       1.6*k_t/g_lb_c + k_t*m_co2*f_soilwater*rh_leaf/g_lb_c - k_t*&
&       b_co2/g_lb_c/g_lb_c
      beta_ps = beta*b_co2*ca - beta*m_co2*f_soilwater*rh_leaf*resp_ld +&
&       1.6*k_t*ca - m*m_co2*f_soilwater*rh_leaf - k_t*m_co2*f_soilwater&
&       *rh_leaf*ca + m*b_co2/g_lb_c - resp_ld*k_t*m_co2*f_soilwater*&
&       rh_leaf/g_lb_c + 2*k_t*b_co2*ca/g_lb_c + (1.6*k_t*resp_ld+1.6*&
&       k_t*m-m*k_t*m_co2*f_soilwater*rh_leaf)/g_lb_c + m*k_t*b_co2/&
&       g_lb_c/g_lb_c
      gamma_ps = resp_ld*m*m_co2*f_soilwater*rh_leaf - m*b_co2*ca + &
&       resp_ld*k_t*m_co2*f_soilwater*rh_leaf*ca - k_t*b_co2*ca*ca + (m*&
&       k_t*m_co2*f_soilwater*rh_leaf-1.6*resp_ld*k_t-1.6*k_t*m)*ca - 2*&
&       m*k_t*b_co2*ca/g_lb_c - (1.6*m*resp_ld*k_t-m*k_t*m_co2*&
&       f_soilwater*rh_leaf*resp_ld)/g_lb_c
      theta_ps = m*k_t*b_co2*ca*ca + 1.6*m*resp_ld*k_t*ca - m*resp_ld*&
&       k_t*m_co2*f_soilwater*rh_leaf*ca
      IF (.NOT.(wj .LE. resp_ld .OR. wc .LE. resp_ld)) THEN
!        //cubic solution:
!        // A^3 + p A^2 + q A + r = 0
        denom = alpha_ps
        p_cubic = beta_ps/denom
        q_cubic = gamma_ps/denom
        r_cubic = theta_ps/denom
!        // Use solution from Numerical Recipes from Press
        qroot = (p_cubic*p_cubic-3.0*q_cubic)/9.0
        rroot = (2.0*p_cubic*p_cubic*p_cubic-9.0*p_cubic*q_cubic+27.0*&
&         r_cubic)/54.0
        IF (qroot .LT. 1.e-6) THEN
          qroot = 1.e-6
        ELSE
          qroot = qroot
        END IF
        arg1 = qroot*qroot*qroot
        result1 = SQRT(arg1)
        r3q = rroot/result1
        IF (r3q .GT. 1) r3q = 1
        IF (r3q .LT. -1) r3q = -1
        ang_l = ACOS(r3q)
        result1 = SQRT(qroot)
        arg1 = ang_l/3.0
        root1 = -(2.0*result1*COS(arg1)) - p_cubic/3.0
        result1 = SQRT(qroot)
        arg1 = (ang_l+pi2)/3.0
        root2 = -(2.0*result1*COS(arg1)) - p_cubic/3.0
        result1 = SQRT(qroot)
        arg1 = (ang_l-pi2)/3.0
        root3 = -(2.0*result1*COS(arg1)) - p_cubic/3.0
!   Here A = x - p / 3, allowing the cubic expression to be expressed
!   as: x^3 + ax + b = 0
!   rank roots #1,#2 and #3 according to the minimum, intermediate and maximum value
        IF (root1 .LE. root2 .AND. root1 .LE. root3) THEN
          minroot = root1
          IF (root2 .LE. root3) THEN
            midroot = root2
            maxroot = root3
          ELSE
            midroot = root3
            maxroot = root2
          END IF
        END IF
        IF (root2 .LE. root1 .AND. root2 .LE. root3) THEN
          minroot = root2
          IF (root1 .LE. root3) THEN
            midroot = root1
            maxroot = root3
          ELSE
            midroot = root3
            maxroot = root1
          END IF
        END IF
        IF (root3 .LE. root1 .AND. root3 .LE. root2) THEN
          minroot = root3
          IF (root1 .LT. root2) THEN
            midroot = root1
            maxroot = root2
          ELSE
            midroot = root2
            maxroot = root1
          END IF
        END IF
        aphoto = 0
!     find out where roots plop down relative to the x-y axis
        IF (minroot .GT. 0 .AND. midroot .GT. 0 .AND. maxroot .GT. 0) &
&         aphoto = minroot
        IF (minroot .LT. 0 .AND. midroot .LT. 0 .AND. maxroot .GT. 0) &
&         aphoto = maxroot
        IF (minroot .LT. 0 .AND. midroot .GT. 0 .AND. maxroot .GT. 0) &
&         aphoto = midroot
!        //also test for sucrose limitation of photosynthesis, as suggested by
!        //Collatz.  Js=Vmax/2
        cs = ca - aphoto/g_lb_c
!mol m-2 s-1
        gs_h2o_mole = f_soilwater*m_h2o*rh_leaf*aphoto/cs + b_h2o
        gs_co2_mole = gs_h2o_mole/1.6
        ci = cs - aphoto/gs_co2_mole
        j_sucrose = k_t*ci - resp_ld
        IF (j_sucrose .LT. aphoto) aphoto = j_sucrose
!         //Stomatal conductance for water vapor
!        //forest are hypostomatous.
!        //Hence we don't divide the total resistance
!        //by 2 since transfer is going on only one side of a leaf.
!        // if A < 0 then gs should go to cuticular value and recalculate A
!         //using quadratic solution
        IF (aphoto .GT. 0.0) GOTO 400
      END IF
!        // if aphoto < 0  set stomatal conductance to cuticle value
!        //a quadratic solution of A is derived if gs=b, but a cubic form occurs
!        //if gs =ax + b.  Use quadratic case when A <=0
!  // Bin Chen:
!         r_tot = 1.0/b_co2 + 1.0/g_lb_c; // total resistance to CO2 (m2 s mol-1)
!         denom = g_lb_c * b_co2;
!         Aquad = r_tot * e_ps;
!         Bquad = (e_ps*resp_ld + a_ps)*r_tot - b_ps - e_ps*ca;
!         Cquad = a_ps*(ca-d_ps) - resp_ld*(e_ps*ca+b_ps);
      aquad = beta + k_t/g_lb_c + 1.6*k_t/b_co2
      bquad = 2*beta*resp_ld - m - ca*k_t - (k_t/g_lb_c+1.6*k_t/b_co2)*(&
&       m-resp_ld)
      cquad = beta*resp_ld*resp_ld - m*resp_ld + ca*k_t*(m-resp_ld)
      product1 = bquad*bquad - 4.0*aquad*cquad
      IF (product1 .GE. 0) THEN
        result1 = SQRT(product1)
        aphoto = (-bquad-result1)/(2.0*aquad)
      END IF
 400  IF (0. .LT. aphoto) THEN
        aphoto = aphoto
      ELSE
        aphoto = 0.
      END IF
      cs = ca - aphoto/g_lb_c
!mol m-2 s-1
      gs_h2o_mole = f_soilwater*m_h2o*rh_leaf*aphoto/cs + b_h2o
      gs_co2_mole = gs_h2o_mole/1.6
      ci = cs - aphoto/gs_co2_mole
!m s-1
      gs_w = gs_h2o_mole*temp_leaf_k*met%pstat273
    ELSE
      alpha_ps = 1.0 + b_co2/g_lb_c - m_co2*rh_leaf*f_soilwater
      beta_ps = ca*(g_lb_c*m_co2*rh_leaf*f_soilwater-2.0*b_co2-g_lb_c)
      gamma_ps = ca*ca*g_lb_c*b_co2
      theta_ps = g_lb_c*m_co2*rh_leaf*f_soilwater - b_co2
!***************************************
!        Test for the minimum of Wc and Wj.  Both have the form:
!        W = (a ci - ad)/(e ci + b)
!        after the minimum is chosen set a, b, e and d for the cubic solution.
!        estimate of J according to Farquhar and von Cammerer (1981)
!***************************************
      j_photon = jmax*iphoton/(iphoton+2.1*jmax)
!    if(LC == 40) then
!        j_photon = jmax
!    else
!      j_photon =jmax * iphoton/ (iphoton+ 2.1*jmax)
!    end if
!  initial guess of intercellular CO2 concentration to estimate Wc and Wj:
      wj = j_photon*(cii-gammac)/(4.*cii+8.0*gammac)
      wc = vcmax*(cii-gammac)/(cii+bc)
!    if(LC == 40) then
!        wc = vcmax
!    else
!      wc = vcmax * (cii - gammac) / (cii + bc)
!    end if
      IF (wj .LT. wc) THEN
!        // for Harley and Farquhar type model for Wj
        psguess = wj
        a_ps = j_photon
        b_ps = 8.0*gammac
        e_ps = 4.0
        d_ps = gammac
      ELSE
        psguess = wc
        a_ps = vcmax
        b_ps = bc
        e_ps = 1.0
        d_ps = gammac
      END IF
!***************************************
! if wj or wc are less than resp_ld then A would probably be less than
! zero.  This would yield a
! negative stomatal conductance.  In this case, assume gs equals the
! cuticular value. This
! assumptions yields a quadratic rather than cubic solution for A
!***************************************
      IF (.NOT.(wj .LE. resp_ld .OR. wc .LE. resp_ld)) THEN
!        //cubic solution:
!        // A^3 + p A^2 + q A + r = 0
        denom = e_ps*alpha_ps
        p_cubic = e_ps*beta_ps + b_ps*theta_ps - a_ps*alpha_ps + e_ps*&
&         resp_ld*alpha_ps
        p_cubic = p_cubic/denom
        q_cubic = e_ps*gamma_ps + b_ps*gamma_ps/ca - a_ps*beta_ps + a_ps&
&         *d_ps*theta_ps + e_ps*resp_ld*beta_ps + resp_ld*b_ps*theta_ps
        q_cubic = q_cubic/denom
        r_cubic = -(a_ps*gamma_ps) + a_ps*d_ps*gamma_ps/ca + e_ps*&
&         resp_ld*gamma_ps + resp_ld*b_ps*gamma_ps/ca
        r_cubic = r_cubic/denom
!        // Use solution from Numerical Recipes from Press
        qroot = (p_cubic*p_cubic-3.0*q_cubic)/9.0
        rroot = (2.0*p_cubic*p_cubic*p_cubic-9.0*p_cubic*q_cubic+27.0*&
&         r_cubic)/54.0
        IF (qroot .LT. 1.e-6) THEN
          qroot = 1.e-6
        ELSE
          qroot = qroot
        END IF
        arg1 = qroot*qroot*qroot
        result1 = SQRT(arg1)
        r3q = rroot/result1
        IF (r3q .GT. 1) r3q = 1
        IF (r3q .LT. -1) r3q = -1
        ang_l = ACOS(r3q)
        result1 = SQRT(qroot)
        arg1 = ang_l/3.0
        root1 = -(2.0*result1*COS(arg1)) - p_cubic/3.0
        result1 = SQRT(qroot)
        arg1 = (ang_l+pi2)/3.0
        root2 = -(2.0*result1*COS(arg1)) - p_cubic/3.0
        result1 = SQRT(qroot)
        arg1 = (ang_l-pi2)/3.0
        root3 = -(2.0*result1*COS(arg1)) - p_cubic/3.0
!   Here A = x - p / 3, allowing the cubic expression to be expressed
!   as: x^3 + ax + b = 0
!   rank roots #1,#2 and #3 according to the minimum, intermediate and maximum value
        IF (root1 .LE. root2 .AND. root1 .LE. root3) THEN
          minroot = root1
          IF (root2 .LE. root3) THEN
            midroot = root2
            maxroot = root3
          ELSE
            midroot = root3
            maxroot = root2
          END IF
        END IF
        IF (root2 .LE. root1 .AND. root2 .LE. root3) THEN
          minroot = root2
          IF (root1 .LE. root3) THEN
            midroot = root1
            maxroot = root3
          ELSE
            midroot = root3
            maxroot = root1
          END IF
        END IF
        IF (root3 .LE. root1 .AND. root3 .LE. root2) THEN
          minroot = root3
          IF (root1 .LT. root2) THEN
            midroot = root1
            maxroot = root2
          ELSE
            midroot = root2
            maxroot = root1
          END IF
        END IF
        aphoto = 0
!     find out where roots plop down relative to the x-y axis
        IF (minroot .GT. 0 .AND. midroot .GT. 0 .AND. maxroot .GT. 0) &
&         aphoto = minroot
        IF (minroot .LT. 0 .AND. midroot .LT. 0 .AND. maxroot .GT. 0) &
&         aphoto = maxroot
        IF (minroot .LT. 0 .AND. midroot .GT. 0 .AND. maxroot .GT. 0) &
&         aphoto = midroot
!        //also test for sucrose limitation of photosynthesis, as suggested by
!        //Collatz.  Js=Vmax/2
        j_sucrose = vcmax/2. - resp_ld
!    if(LC == 40) then
!      j_sucrose = 2.*1.e4*vcmax*cii/air_pres/1000. - resp_ld
!    else
!      j_sucrose = vcmax / 2. - resp_ld
!    end if
        IF (j_sucrose .LT. aphoto) aphoto = j_sucrose
!         //Stomatal conductance for water vapor
!        //forest are hypostomatous.
!        //Hence we don't divide the total resistance
!        //by 2 since transfer is going on only one side of a leaf.
!        // if A < 0 then gs should go to cuticular value and recalculate A
!         //using quadratic solution
        IF (aphoto .GT. 0.0) GOTO 200
      END IF
!        // if aphoto < 0  set stomatal conductance to cuticle value
!        //a quadratic solution of A is derived if gs=b, but a cubic form occurs
!        //if gs =ax + b.  Use quadratic case when A <=0
!  // Bin Chen:
!         r_tot = 1.0/b_co2 + 1.0/g_lb_c; // total resistance to CO2 (m2 s mol-1)
!         denom = g_lb_c * b_co2;
!         Aquad = r_tot * e_ps;
!         Bquad = (e_ps*resp_ld + a_ps)*r_tot - b_ps - e_ps*ca;
!         Cquad = a_ps*(ca-d_ps) - resp_ld*(e_ps*ca+b_ps);
      ps_1 = ca*g_lb_c*b_co2
      delta_1 = b_co2 + g_lb_c
      denom = g_lb_c*b_co2
      aquad = delta_1*e_ps
      bquad = -(ps_1*e_ps) - a_ps*delta_1 + e_ps*resp_ld*delta_1 - b_ps*&
&       denom
      cquad = a_ps*ps_1 - a_ps*d_ps*denom - e_ps*resp_ld*ps_1 - resp_ld*&
&       b_ps*denom
      product1 = bquad*bquad - 4.0*aquad*cquad
      IF (product1 .GE. 0) THEN
        result1 = SQRT(product1)
        aphoto = (-bquad-result1)/(2.0*aquad)
      END IF
 200  IF (0. .LT. aphoto) THEN
        aphoto = aphoto
      ELSE
        aphoto = 0.
      END IF
      cs = ca - aphoto/g_lb_c
!mol m-2 s-1
      gs_h2o_mole = f_soilwater*m_h2o*rh_leaf*aphoto/cs + b_h2o
      gs_co2_mole = gs_h2o_mole/1.6
      ci = cs - aphoto/gs_co2_mole
!m s-1
      gs_w = gs_h2o_mole*temp_leaf_k*met%pstat273
    END IF
!! QBO
!   ffpa = 0.8;   ! 0.6~0.9
    IF (iphoton .LE. 0.) THEN
      xsif = 0.
    ELSE
! C4 je is added, @MOUSONG WU, 2020-09-10
      IF (lc .EQ. 40 .OR. lc .EQ. 41) THEN
        je = aphoto
      ELSE
        x1 = aphoto*(ci+2.0*gammac)/(ci-gammac)
        IF (x1 .LT. 0.0) THEN
          je = 0.0
        ELSE
          je = x1
        END IF
      END IF
      xxn = 1.0 - je/(iphoton*ffpa*0.05)
      IF (xxn .LT. 0) xxn = 0.
      kf = 0.05
      kd = 0.95
      kp = 4.0
      ps_sif = kp/(kf+kp+kd)*(1.-xxn)
      kn = (sif_alpha*xxn+sif_beta)*xxn
! kn     = (6.2473*xxn - 0.5994)*xxn
      fm = kf/(kf+kd+kn)
      fs = fm*(1.0-ps_sif)
      IF (xxn .LT. 0.26) fs = -(0.0075*xxn) + 0.0181
      xsif = fs*iphoton*ffpa
!    xSIF = iphoton
    END IF
! add the module for calculating COS uptake by plants, @MOUSONG.WU 2020-09-17
!-- iLab::convf no longer required
! call cos_plant(LC,cosii,convf,gs_h2o_mole,g_lb_cos,vcmax,ffpa,f_soilwater,cos_assim)
    CALL COS_PLANT(lc, cosii, gs_h2o_mole, g_lb_cos, vcmax, ffpa, &
&            f_soilwater, cos_assim)
! ppb
    coss = cosa - cos_assim/g_lb_cos
! ppb
    cosi = coss - cos_assim/(gs_h2o_mole/1.56)
  END SUBROUTINE PHOTOSYNTHESIS

!  Differentiation of sfc_vpd in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: y
!   with respect to varying inputs: bound_layer_res.vapor fact.latent
!                leleafpt
  SUBROUTINE SFC_VPD_FWV(temp_leaf_k, leleafpt, leleafpt_fw, y, y_fw, &
&   nbdirs)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
!****************************************************
! this function computes the relative humidity at the leaf surface for
! application in the Ball Berry Equation
! latent heat flux, LE, is passed through the function, mol m-2 s-1
! and it solves for the humidity at leaf surface
! es_leaf : saturation vapor pressure at leaf temperature.
!****************************************************
    REAL(r8) :: temp_leaf_k, leleafpt
    REAL(r8), DIMENSION(nbdirsmax) :: leleafpt_fw
    REAL(r8) :: y, rhov_sfc, e_sfc, vpd_sfc, rhum_leaf
    REAL(r8), DIMENSION(nbdirsmax) :: y_fw, rhov_sfc_fw, e_sfc_fw, &
&   vpd_sfc_fw, rhum_leaf_fw
    REAL(r8) :: es_leaf
    INTEGER :: nd
    REAL(r8) :: temp
    INTEGER :: nbdirs
    CALL ES(temp_leaf_k, es_leaf)
!  kg m-3
    temp = leleafpt*bound_layer_res%vapor/fact%latent
    DO nd=1,nbdirs
      rhov_sfc_fw(nd) = (bound_layer_res%vapor*leleafpt_fw(nd)+leleafpt*&
&       bound_layer_res_fw%vapor(nd)-temp*fact_fw%latent(nd))/fact%&
&       latent
! mb
      e_sfc_fw(nd) = temp_leaf_k*rhov_sfc_fw(nd)/0.2165
! mb
      vpd_sfc_fw(nd) = -e_sfc_fw(nd)
! 0 to 1.0
      rhum_leaf_fw(nd) = -(vpd_sfc_fw(nd)/es_leaf)
      y_fw(nd) = rhum_leaf_fw(nd)
    END DO
    rhov_sfc = met%rhova_kg + temp
    e_sfc = rhov_sfc*temp_leaf_k/0.2165
    vpd_sfc = es_leaf - e_sfc
    rhum_leaf = 1.0 - vpd_sfc/es_leaf
    y = rhum_leaf
  END SUBROUTINE SFC_VPD_FWV

  SUBROUTINE SFC_VPD(temp_leaf_k, leleafpt, y)
    IMPLICIT NONE
!****************************************************
! this function computes the relative humidity at the leaf surface for
! application in the Ball Berry Equation
! latent heat flux, LE, is passed through the function, mol m-2 s-1
! and it solves for the humidity at leaf surface
! es_leaf : saturation vapor pressure at leaf temperature.
!****************************************************
    REAL(r8) :: temp_leaf_k, leleafpt
    REAL(r8) :: y, rhov_sfc, e_sfc, vpd_sfc, rhum_leaf
    REAL(r8) :: es_leaf
    CALL ES(temp_leaf_k, es_leaf)
!  kg m-3
    rhov_sfc = leleafpt/fact%latent*bound_layer_res%vapor + met%rhova_kg
! mb
    e_sfc = rhov_sfc*temp_leaf_k/0.2165
! mb
    vpd_sfc = es_leaf - e_sfc
! 0 to 1.0
    rhum_leaf = 1.0 - vpd_sfc/es_leaf
    y = rhum_leaf
  END SUBROUTINE SFC_VPD

!  Differentiation of temp_func in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: y
!   with respect to varying inputs: rate
  SUBROUTINE TEMP_FUNC_FWV(rate, rate_fw, eact, tprime, tref, t_lk, y, &
&   y_fw, nbdirs)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
    REAL(r8) :: rate, eact, tprime, tref, t_lk, y
    REAL(r8), DIMENSION(nbdirsmax) :: rate_fw, y_fw
    INTRINSIC EXP
    REAL(r8) :: arg1
    INTEGER :: nd
    REAL(r8) :: temp
    INTEGER :: nbdirs
!   Arhennius temperature function
    arg1 = tprime*eact/(tref*rugc*t_lk)
    temp = EXP(arg1)
    DO nd=1,nbdirs
      y_fw(nd) = temp*rate_fw(nd)
    END DO
    y = temp*rate
  END SUBROUTINE TEMP_FUNC_FWV

  SUBROUTINE TEMP_FUNC(rate, eact, tprime, tref, t_lk, y)
    IMPLICIT NONE
    REAL(r8) :: rate, eact, tprime, tref, t_lk, y
    INTRINSIC EXP
    REAL(r8) :: arg1
!   Arhennius temperature function
    arg1 = tprime*eact/(tref*rugc*t_lk)
    y = rate*EXP(arg1)
  END SUBROUTINE TEMP_FUNC

!  Differentiation of lambda in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: y
!   with respect to varying inputs: tak
  SUBROUTINE LAMBDA_FWV(tak, tak_fw, y, y_fw, nbdirs)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
!   Latent heat of Vaporiation, J kg-1
    REAL(r8) :: tak, y
    REAL(r8), DIMENSION(nbdirsmax) :: tak_fw, y_fw
    INTEGER :: nd
    INTEGER :: nbdirs
    DO nd=1,nbdirs
      y_fw(nd) = -(2370.0*tak_fw(nd))
    END DO
    y = 3149000.0 - 2370.0*tak
!   add heat of fusion for melting ice
    IF (tak .LT. 273.0) y = y + 333
  END SUBROUTINE LAMBDA_FWV

  SUBROUTINE LAMBDA(tak, y)
    IMPLICIT NONE
!   Latent heat of Vaporiation, J kg-1
    REAL(r8) :: tak, y
    y = 3149000.0 - 2370.0*tak
!   add heat of fusion for melting ice
    IF (tak .LT. 273.0) y = y + 333
  END SUBROUTINE LAMBDA

  SUBROUTINE ES(t, y)
    IMPLICIT NONE
! saturation vapor pressure function (mb)
! T is temperature in Kelvin
    REAL(r8) :: t, y, y1
    INTRINSIC LOG
    INTRINSIC EXP
    IF (t .GT. 0) THEN
      y1 = 54.8781919 - 6790.4985/t - 5.02808*LOG(t)
      y = EXP(y1)
    ELSE
      WRITE(*, *) 'bad es calc'
    END IF
  END SUBROUTINE ES

!  Differentiation of tboltz in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: y
!   with respect to varying inputs: rate
  SUBROUTINE TBOLTZ_FWV(rate, rate_fw, eakin, topt, tl, y, y_fw, nbdirs)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
!   Boltzmann temperature distribution for photosynthesis
    REAL(r8) :: rate, eakin, topt, tl
    REAL(r8), DIMENSION(nbdirsmax) :: rate_fw
    REAL(r8) :: y, dtlopt, prodt, numm, denom
    REAL(r8), DIMENSION(nbdirsmax) :: y_fw
    INTRINSIC EXP
    REAL(r8) :: arg1
    INTEGER :: nd
    INTEGER :: nbdirs
    dtlopt = tl - topt
    prodt = rugc*topt*tl
    arg1 = eakin*dtlopt/prodt
    numm = hkin*EXP(arg1)
    arg1 = hkin*dtlopt/prodt
    denom = hkin - eakin*(1.0-EXP(arg1))
    DO nd=1,nbdirs
      y_fw(nd) = numm*rate_fw(nd)/denom
    END DO
    y = rate*numm/denom
  END SUBROUTINE TBOLTZ_FWV

  SUBROUTINE TBOLTZ(rate, eakin, topt, tl, y)
    IMPLICIT NONE
!   Boltzmann temperature distribution for photosynthesis
    REAL(r8) :: rate, eakin, topt, tl
    REAL(r8) :: y, dtlopt, prodt, numm, denom
    INTRINSIC EXP
    REAL(r8) :: arg1
    dtlopt = tl - topt
    prodt = rugc*topt*tl
    arg1 = eakin*dtlopt/prodt
    numm = hkin*EXP(arg1)
    arg1 = hkin*dtlopt/prodt
    denom = hkin - eakin*(1.0-EXP(arg1))
    y = rate*numm/denom
  END SUBROUTINE TBOLTZ

!  Differentiation of tboltzc4 in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: y
!   with respect to varying inputs: rate
  SUBROUTINE TBOLTZC4_FWV(rate, rate_fw, topt, tl, y, y_fw, nbdirs)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
! temperature correction for C4 plants
    REAL(r8) :: rate, topt, tl
    REAL(r8), DIMENSION(nbdirsmax) :: rate_fw
    REAL(r8) :: y, dtlopt, q
    REAL(r8), DIMENSION(nbdirsmax) :: y_fw
    REAL(r8) :: s1, s2, s3, s4, fh, fl
    INTRINSIC EXP
    REAL(r8) :: arg1
    INTEGER :: nd
    REAL(r8) :: temp
    INTEGER :: nbdirs
    dtlopt = tl - topt
    q = 2.
    s1 = 0.3
    s2 = 313.15
    s3 = 0.2
    s4 = 288.15
    arg1 = s1*(tl-s2)
    fh = 1 + EXP(arg1)
    arg1 = s3*(s4-tl)
    fl = 1 + EXP(arg1)
    temp = q**dtlopt
    DO nd=1,nbdirs
      y_fw(nd) = temp*rate_fw(nd)/(fh*fl)
    END DO
    y = temp*(rate/(fh*fl))
  END SUBROUTINE TBOLTZC4_FWV

  SUBROUTINE TBOLTZC4(rate, topt, tl, y)
    IMPLICIT NONE
! temperature correction for C4 plants
    REAL(r8) :: rate, topt, tl
    REAL(r8) :: y, dtlopt, q
    REAL(r8) :: s1, s2, s3, s4, fh, fl
    INTRINSIC EXP
    REAL(r8) :: arg1
    dtlopt = tl - topt
    q = 2.
    s1 = 0.3
    s2 = 313.15
    s3 = 0.2
    s4 = 288.15
    arg1 = s1*(tl-s2)
    fh = 1 + EXP(arg1)
    arg1 = s3*(s4-tl)
    fl = 1 + EXP(arg1)
    y = rate*q**dtlopt/fh/fl
  END SUBROUTINE TBOLTZC4

  SUBROUTINE FLUORESCENCE(x, fs)
    IMPLICIT NONE
    REAL, INTENT(IN) :: x
    REAL, INTENT(OUT) :: fs
    REAL :: kn
    REAL :: kf
    REAL :: kd
    REAL :: kp
    REAL :: po0
    REAL :: ps
    REAL :: fo0
    REAL :: fo
    REAL :: fm
    REAL :: fm0
    REAL :: eta
    REAL :: qq
    REAL :: qe
    kf = 0.05
    kd = 0.95
    kp = 4.0
    po0 = kp/(kf+kd+kp)
    ps = po0*(1.0-x)
    kn = (6.2473*x-0.5944)*x
    fo0 = kf/(kf+kp+kd)
    fo = kf/(kf+kp+kd+kn)
    fm = kf/(kf+kd+kn)
    fm0 = kf/(kf+kd)
    fs = fm*(1.0-ps)
    eta = fs/fo0
    qq = 1.0 - (fs-fo)/(fm-fo)
    qe = 1.0 - (fm-fo)/(fm0-fo0)
  END SUBROUTINE FLUORESCENCE

END MODULE ANGSMOD_DIFFV

!*******************************************************
! Function: Soil module( Initialize/Update soil status,soil
!           water, soil thermal etc.)
! Created : Jun Wang
! Date    : 2016/12/5
!*******************************************************
MODULE BEPS_SOILMOD_DIFFV
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE BEPS_PAR
  USE METEOMOD_DIFFV
  USE BEPS_CON
  USE MID_RESULTS_DIFFV
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
! generic index
  INTEGER, PRIVATE :: i
!the number layers used in model
! depth of ponded water on the ground surface
! snow depth
! the rainfall rate on ground m/s
!    real(r8)  :: soil_r     ! not used
! units:??
! decay_rate_of_root_distribution
! for fw
! for fw
!!! Properties belong to each soil horizon
!root weight
! the weight calculated from soil_water_factor
! read from patameters
! thermal conductivity
!  field capacity
!  wiltng point
! porosity
! saturated hydraulic conductivity
! water potential in sat
! Cambell parameter b
! soil bulk density of layer
! volume fraction of organic matter in layer (%)
! needed to save
! The ratio of ice of soil layer
! soil water content in the layer
! soil temperature in this layer
!?
!!   ! derived variables
! soil water suction in this layer
! soil water content at the bottom of each layer
! soil water suction at the bottom this layer
! the liquid water flow rates at the soil layer interfaces
! the hydraulic conducitivity
! the averaged conductivity of two soil layer
!
! thermal conductivity of each soil layer
! ET in each layer
! energy fluxes
  TYPE, PUBLIC :: SOIL
      INTEGER :: n_layer
      REAL(r8) :: zp
      REAL(r8) :: zsp
      REAL(r8) :: r_rain_g
      REAL(r8) :: r_drainage
      REAL(r8) :: r_root_decay
      REAL(r8) :: psi_min
      REAL(r8) :: alpha
      REAL(r8) :: f_soilwater
      REAL(r8) :: d_soil(0:max_layers-1)
      REAL(r8) :: f_root(0:max_layers-1)
      REAL(r8) :: dt(0:max_layers-1)
      REAL(r8) :: thermal_cond(0:max_layers-1)
      REAL(r8) :: theta_vfc(0:max_layers-1)
      REAL(r8) :: theta_vwp(0:max_layers-1)
      REAL(r8) :: fei(0:max_layers-1)
      REAL(r8) :: ksat(0:max_layers-1)
      REAL(r8) :: psi_sat(0:max_layers-1)
      REAL(r8) :: b(0:max_layers-1)
      REAL(r8) :: density_soil(0:max_layers-1)
      REAL(r8) :: f_org(0:max_layers-1)
      REAL(r8) :: ice_ratio(0:max_layers-1)
      REAL(r8) :: thetam(0:max_layers-1)
      REAL(r8) :: thetam_prev(0:max_layers-1)
      REAL(r8) :: temp_soil_p(0:max_layers-1)
      REAL(r8) :: temp_soil_c(0:max_layers-1)
      REAL(r8) :: f_ice(0:max_layers-1)
      REAL(r8) :: psim(0:max_layers-1)
      REAL(r8) :: psim_prev(0:max_layers-1)
      REAL(r8) :: thetab(0:max_layers-1)
      REAL(r8) :: psib(0:max_layers-1)
      REAL(r8) :: r_waterflow(0:max_layers-1)
      REAL(r8) :: km(0:max_layers-1)
      REAL(r8) :: kb(0:max_layers-1)
      REAL(r8) :: kk(0:max_layers-1)
      REAL(r8) :: cs(0:max_layers-1)
      REAL(r8) :: lambda(0:max_layers-1)
      REAL(r8) :: ett(0:max_layers-1)
      REAL(r8) :: g(0:max_layers-1)
  END TYPE SOIL
  TYPE, PUBLIC :: SOIL_DIFFV
      REAL(r8), DIMENSION(nbdirsmax) :: zp
      REAL(r8), DIMENSION(nbdirsmax) :: zsp
      REAL(r8), DIMENSION(nbdirsmax) :: r_rain_g
      REAL(r8), DIMENSION(nbdirsmax) :: f_soilwater
      REAL(r8), DIMENSION(nbdirsmax, 0:max_layers-1) :: dt
      REAL(r8), DIMENSION(nbdirsmax, 0:max_layers-1) :: ksat
      REAL(r8), DIMENSION(nbdirsmax, 0:max_layers-1) :: b
      REAL(r8), DIMENSION(nbdirsmax, 0:max_layers-1) :: ice_ratio
      REAL(r8), DIMENSION(nbdirsmax, 0:max_layers-1) :: thetam
      REAL(r8), DIMENSION(nbdirsmax, 0:max_layers-1) :: thetam_prev
      REAL(r8), DIMENSION(nbdirsmax, 0:max_layers-1) :: temp_soil_p
      REAL(r8), DIMENSION(nbdirsmax, 0:max_layers-1) :: temp_soil_c
      REAL(r8), DIMENSION(nbdirsmax, 0:max_layers-1) :: f_ice
      REAL(r8), DIMENSION(nbdirsmax, 0:max_layers-1) :: psim
      REAL(r8), DIMENSION(nbdirsmax, 0:max_layers-1) :: psim_prev
      REAL(r8), DIMENSION(nbdirsmax, 0:max_layers-1) :: thetab
      REAL(r8), DIMENSION(nbdirsmax, 0:max_layers-1) :: psib
      REAL(r8), DIMENSION(nbdirsmax, 0:max_layers-1) :: r_waterflow
      REAL(r8), DIMENSION(nbdirsmax, 0:max_layers-1) :: km
      REAL(r8), DIMENSION(nbdirsmax, 0:max_layers-1) :: kb
      REAL(r8), DIMENSION(nbdirsmax, 0:max_layers-1) :: kk
      REAL(r8), DIMENSION(nbdirsmax, 0:max_layers-1) :: cs
      REAL(r8), DIMENSION(nbdirsmax, 0:max_layers-1) :: lambda
      REAL(r8), DIMENSION(nbdirsmax, 0:max_layers-1) :: ett
      REAL(r8), DIMENSION(nbdirsmax, 0:max_layers-1) :: g
  END TYPE SOIL_DIFFV
! initial
!Soil thermal
! soil water
  PUBLIC :: init_soil_parameters, init_soil_status, updateheatflux, &
& update_cs, updatesoilthermalconductivity, surfacetemperature, &
& updatesoilmoisture, soil_water_uptake, soil_water_factor_v2, &
& soil_evaporation
  PUBLIC :: init_soil_parameters_fwv, init_soil_status_fwv, &
& updateheatflux_fwv, update_cs_fwv, updatesoilthermalconductivity_fwv, &
& surfacetemperature_fwv, updatesoilmoisture_fwv, soil_water_uptake_fwv&
& , soil_water_factor_v2_fwv, soil_evaporation_fwv
  PRIVATE :: init_soil_rootfraction, update_ice_ratio
  PRIVATE :: update_ice_ratio_fwv

CONTAINS
!  Differentiation of init_soil_parameters in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: p.ksat p.b
!   with respect to varying inputs: p.ksat p.b
! Initialization process
  SUBROUTINE INIT_SOIL_PARAMETERS_FWV(lc, stxt, r_root_decay, p, p_fw, &
&   nbdirs)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: lc
    INTEGER, INTENT(IN) :: stxt
    REAL(r8), INTENT(IN) :: r_root_decay
    TYPE(SOIL) :: p
    TYPE(SOIL_DIFFV) :: p_fw
    INTEGER :: nd
    INTEGER :: nbdirs
    p%n_layer = 5
    IF (lc .EQ. 3 .OR. lc .EQ. 4) THEN
! for fw
      p%psi_min = 10.0
      p%alpha = 1.5
    ELSE
      p%psi_min = 33.0
      p%alpha = 0.4
    END IF
! depth_layer
    p%d_soil(0:4) = (/0.05, 0.10, 0.20, 0.40, 1.25/)
    p%r_root_decay = r_root_decay
    CALL INIT_SOIL_ROOTFRACTION(p)
    p%density_soil(0:4) = (/1300.0, 1500.0, 1517.0, 1517.0, 1517.0/)
    p%f_org(0:4) = (/5., 2., 1., 1., 0.3/)
    SELECT CASE  (stxt) 
    CASE (1) 
      DO nd=1,nbdirs
! sand
        p_fw%b(nd, 0:4) = 0.0_8
! saturated hydraulic conductivity
        p_fw%ksat(nd, 0:4) = 0.0_8
      END DO
      p%b(0:4) = (/1.7, 1.9, 2.1, 2.3, 2.5/)
      p%ksat(0:4) = (/58., 52., 46., 35., 10./)*1e-6
      p%fei(0:4) = 0.437
!field capacity
      p%theta_vfc(0:4) = 0.09
!wilting point
      p%theta_vwp(0:4) = 0.03
! thermal conductivity
      p%thermal_cond(0:4) = 8.6
      p%psi_sat(0:4) = (/0.07, 0.08, 0.09, 0.10, 0.12/)
    CASE (2) 
      DO nd=1,nbdirs
!loamy sand
        p_fw%b(nd, 0:4) = 0.0_8
        p_fw%ksat(nd, 0:4) = 0.0_8
      END DO
      p%b(0:4) = (/2.1, 2.3, 2.5, 2.7, 2.9/)
      p%ksat(0:4) = (/17., 15., 14., 10., 3./)*1e-6
      p%fei(0:4) = 0.437
      p%theta_vfc(0:4) = 0.21
      p%theta_vwp(0:4) = 0.06
      p%thermal_cond(0:4) = 8.3
      p%psi_sat(0:4) = (/0.09, 0.10, 0.11, 0.12, 0.14/)
    CASE (3) 
      DO nd=1,nbdirs
! sandy loam
        p_fw%b(nd, 0:4) = 0.0_8
        p_fw%ksat(nd, 0:4) = 0.0_8
      END DO
      p%b(0:4) = (/3.1, 3.3, 3.5, 3.7, 3.9/)
      p%ksat(0:4) = (/720., 648., 576., 432., 144./)*1e-8
      p%fei(0:4) = 0.453
      p%theta_vfc(0:4) = 0.21
      p%theta_vwp(0:4) = 0.10
      p%thermal_cond(0:4) = 8.0
      p%psi_sat(0:4) = (/0.15, 0.16, 0.17, 0.18, 0.20/)
    CASE (4) 
      DO nd=1,nbdirs
!loam
        p_fw%b(nd, 0:4) = 0.0_8
        p_fw%ksat(nd, 0:4) = 0.0_8
      END DO
      p%b(0:4) = (/4.5, 4.7, 4.9, 5.1, 5.3/)
      p%ksat(0:4) = (/370., 330., 296., 222., 74./)*1e-8
      p%fei(0:4) = 0.463
      p%theta_vfc(0:4) = 0.27
      p%theta_vwp(0:4) = 0.12
      p%thermal_cond(0:4) = 7.0
      p%psi_sat(0:4) = (/0.11, 0.12, 0.13, 0.14, 0.16/)
    CASE (5) 
      DO nd=1,nbdirs
!silty loam
        p_fw%b(nd, 0:4) = 0.0_8
        p_fw%ksat(nd, 0:4) = 0.0_8
      END DO
      p%b(0:4) = (/4.7, 4.9, 5.1, 5.3, 5.5/)
      p%ksat(0:4) = (/190., 170., 152., 114., 38./)*1e-8
      p%fei(0:4) = 0.501
      p%theta_vfc(0:4) = 0.33
      p%theta_vwp(0:4) = 0.13
      p%thermal_cond(0:4) = 6.3
      p%psi_sat(0:4) = (/0.21, 0.22, 0.23, 0.24, 0.26/)
    CASE (6) 
      DO nd=1,nbdirs
! sandy caly loam
        p_fw%b(nd, 0:4) = 0.0_8
        p_fw%ksat(nd, 0:4) = 0.0_8
      END DO
      p%b(0:4) = (/4.0, 4.2, 4.4, 4.6, 4.8/)
      p%ksat(0:4) = (/12., 10.8, 96., 72., 24./)*1e-7
      p%fei(0:4) = 0.398
      p%theta_vfc(0:4) = 0.26
      p%theta_vwp(0:4) = 0.15
      p%thermal_cond(0:4) = 7.0
      p%psi_sat(0:4) = (/0.28, 0.29, 0.30, 0.31, 0.33/)
    CASE (7) 
      DO nd=1,nbdirs
!clay loam
        p_fw%b(nd, 0:4) = 0.0_8
        p_fw%ksat(nd, 0:4) = 0.0_8
      END DO
      p%b(0:4) = (/5.2, 5.4, 5.6, 5.8, 6.0/)
      p%ksat(0:4) = (/64., 58., 51., 38., 13./)*1e-8
      p%fei(0:4) = 0.464
      p%theta_vfc(0:4) = 0.32
      p%theta_vwp(0:4) = 0.20
      p%thermal_cond(0:4) = (/5.8, 5.8, 5.7, 5.8, 5.8/)
      p%psi_sat(0:4) = (/0.26, 0.27, 0.28, 0.29, 0.31/)
    CASE (8) 
      DO nd=1,nbdirs
!silty clay loam
        p_fw%b(nd, 0:4) = 0.0_8
        p_fw%ksat(nd, 0:4) = 0.0_8
      END DO
      p%b(0:4) = (/6.6, 6.8, 7.0, 7.2, 7.4/)
      p%ksat(0:4) = (/42., 38., 34., 25.2, 8.4/)*1e-8
      p%fei(0:4) = 0.471
      p%theta_vfc(0:4) = 0.37
      p%theta_vwp(0:4) = 0.32
      p%thermal_cond(0:4) = 4.2
      p%psi_sat(0:4) = (/0.33, 0.34, 0.35, 0.36, 0.38/)
    CASE (9) 
      DO nd=1,nbdirs
! sandy clay
        p_fw%b(nd, 0:4) = 0.0_8
        p_fw%ksat(nd, 0:4) = 0.0_8
      END DO
      p%b(0:4) = (/6., 6.2, 6.4, 6.6, 6.8/)
      p%ksat(0:4) = (/33., 30., 26.4, 19.8, 6.6/)*1e-8
      p%fei(0:4) = 0.43
      p%theta_vfc(0:4) = 0.34
      p%theta_vwp(0:4) = 0.24
      p%thermal_cond(0:4) = 6.3
      p%psi_sat(0:4) = (/0.29, 0.30, 0.31, 0.32, 0.34/)
    CASE (10) 
      DO nd=1,nbdirs
!silty clay
        p_fw%b(nd, 0:4) = 0.0_8
        p_fw%ksat(nd, 0:4) = 0.0_8
      END DO
      p%b(0:4) = (/7.9, 8.1, 8.3, 8.5, 8.7/)
      p%ksat(0:4) = (/25., 22.5, 20., 15., 5./)*1e-8
      p%fei(0:4) = 0.479
      p%theta_vfc(0:4) = 0.39
      p%theta_vwp(0:4) = 0.25
      p%thermal_cond(0:4) = 4.0
      p%psi_sat(0:4) = (/0.34, 0.35, 0.36, 0.37, 0.39/)
    CASE (11) 
      DO nd=1,nbdirs
! clay
        p_fw%b(nd, 0:4) = 0.0_8
        p_fw%ksat(nd, 0:4) = 0.0_8
      END DO
      p%b(0:4) = (/7.6, 7.8, 8.0, 8.2, 8.4/)
      p%ksat(0:4) = (/17., 15.3, 13.6, 10.2, 3.4/)*1e-8
      p%fei(0:4) = 0.475
      p%theta_vfc(0:4) = 0.40
      p%theta_vwp(0:4) = 0.27
      p%thermal_cond(0:4) = 4.4
      p%psi_sat(0:4) = (/0.37, 0.38, 0.39, 0.40, 0.42/)
    CASE DEFAULT
      DO nd=1,nbdirs
        p_fw%b(nd, 0:4) = 0.0_8
        p_fw%ksat(nd, 0:4) = 0.0_8
      END DO
      p%b(0:4) = (/7.6, 7.8, 8.0, 8.2, 8.4/)
      p%ksat(0:4) = (/17., 15.3, 13.6, 10.2, 3.4/)*1e-8
      p%fei(0:4) = 0.475
      p%theta_vfc(0:4) = 0.40
      p%theta_vwp(0:4) = 0.27
      p%psi_sat(0:4) = (/0.37, 0.38, 0.39, 0.40, 0.42/)
    END SELECT
    RETURN
  END SUBROUTINE INIT_SOIL_PARAMETERS_FWV

! Initialization process
  SUBROUTINE INIT_SOIL_PARAMETERS(lc, stxt, r_root_decay, p)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: lc
    INTEGER, INTENT(IN) :: stxt
    REAL(r8), INTENT(IN) :: r_root_decay
    TYPE(SOIL) :: p
    p%n_layer = 5
    IF (lc .EQ. 3 .OR. lc .EQ. 4) THEN
! for fw
      p%psi_min = 10.0
      p%alpha = 1.5
    ELSE
      p%psi_min = 33.0
      p%alpha = 0.4
    END IF
! depth_layer
    p%d_soil(0:4) = (/0.05, 0.10, 0.20, 0.40, 1.25/)
    p%r_root_decay = r_root_decay
    CALL INIT_SOIL_ROOTFRACTION(p)
    p%density_soil(0:4) = (/1300.0, 1500.0, 1517.0, 1517.0, 1517.0/)
    p%f_org(0:4) = (/5., 2., 1., 1., 0.3/)
    SELECT CASE  (stxt) 
    CASE (1) 
! sand
      p%b(0:4) = (/1.7, 1.9, 2.1, 2.3, 2.5/)
! saturated hydraulic conductivity
      p%ksat(0:4) = (/58., 52., 46., 35., 10./)*1e-6
      p%fei(0:4) = 0.437
!field capacity
      p%theta_vfc(0:4) = 0.09
!wilting point
      p%theta_vwp(0:4) = 0.03
! thermal conductivity
      p%thermal_cond(0:4) = 8.6
      p%psi_sat(0:4) = (/0.07, 0.08, 0.09, 0.10, 0.12/)
    CASE (2) 
!loamy sand
      p%b(0:4) = (/2.1, 2.3, 2.5, 2.7, 2.9/)
      p%ksat(0:4) = (/17., 15., 14., 10., 3./)*1e-6
      p%fei(0:4) = 0.437
      p%theta_vfc(0:4) = 0.21
      p%theta_vwp(0:4) = 0.06
      p%thermal_cond(0:4) = 8.3
      p%psi_sat(0:4) = (/0.09, 0.10, 0.11, 0.12, 0.14/)
    CASE (3) 
! sandy loam
      p%b(0:4) = (/3.1, 3.3, 3.5, 3.7, 3.9/)
      p%ksat(0:4) = (/720., 648., 576., 432., 144./)*1e-8
      p%fei(0:4) = 0.453
      p%theta_vfc(0:4) = 0.21
      p%theta_vwp(0:4) = 0.10
      p%thermal_cond(0:4) = 8.0
      p%psi_sat(0:4) = (/0.15, 0.16, 0.17, 0.18, 0.20/)
    CASE (4) 
!loam
      p%b(0:4) = (/4.5, 4.7, 4.9, 5.1, 5.3/)
      p%ksat(0:4) = (/370., 330., 296., 222., 74./)*1e-8
      p%fei(0:4) = 0.463
      p%theta_vfc(0:4) = 0.27
      p%theta_vwp(0:4) = 0.12
      p%thermal_cond(0:4) = 7.0
      p%psi_sat(0:4) = (/0.11, 0.12, 0.13, 0.14, 0.16/)
    CASE (5) 
!silty loam
      p%b(0:4) = (/4.7, 4.9, 5.1, 5.3, 5.5/)
      p%ksat(0:4) = (/190., 170., 152., 114., 38./)*1e-8
      p%fei(0:4) = 0.501
      p%theta_vfc(0:4) = 0.33
      p%theta_vwp(0:4) = 0.13
      p%thermal_cond(0:4) = 6.3
      p%psi_sat(0:4) = (/0.21, 0.22, 0.23, 0.24, 0.26/)
    CASE (6) 
! sandy caly loam
      p%b(0:4) = (/4.0, 4.2, 4.4, 4.6, 4.8/)
      p%ksat(0:4) = (/12., 10.8, 96., 72., 24./)*1e-7
      p%fei(0:4) = 0.398
      p%theta_vfc(0:4) = 0.26
      p%theta_vwp(0:4) = 0.15
      p%thermal_cond(0:4) = 7.0
      p%psi_sat(0:4) = (/0.28, 0.29, 0.30, 0.31, 0.33/)
    CASE (7) 
!clay loam
      p%b(0:4) = (/5.2, 5.4, 5.6, 5.8, 6.0/)
      p%ksat(0:4) = (/64., 58., 51., 38., 13./)*1e-8
      p%fei(0:4) = 0.464
      p%theta_vfc(0:4) = 0.32
      p%theta_vwp(0:4) = 0.20
      p%thermal_cond(0:4) = (/5.8, 5.8, 5.7, 5.8, 5.8/)
      p%psi_sat(0:4) = (/0.26, 0.27, 0.28, 0.29, 0.31/)
    CASE (8) 
!silty clay loam
      p%b(0:4) = (/6.6, 6.8, 7.0, 7.2, 7.4/)
      p%ksat(0:4) = (/42., 38., 34., 25.2, 8.4/)*1e-8
      p%fei(0:4) = 0.471
      p%theta_vfc(0:4) = 0.37
      p%theta_vwp(0:4) = 0.32
      p%thermal_cond(0:4) = 4.2
      p%psi_sat(0:4) = (/0.33, 0.34, 0.35, 0.36, 0.38/)
    CASE (9) 
! sandy clay
      p%b(0:4) = (/6., 6.2, 6.4, 6.6, 6.8/)
      p%ksat(0:4) = (/33., 30., 26.4, 19.8, 6.6/)*1e-8
      p%fei(0:4) = 0.43
      p%theta_vfc(0:4) = 0.34
      p%theta_vwp(0:4) = 0.24
      p%thermal_cond(0:4) = 6.3
      p%psi_sat(0:4) = (/0.29, 0.30, 0.31, 0.32, 0.34/)
    CASE (10) 
!silty clay
      p%b(0:4) = (/7.9, 8.1, 8.3, 8.5, 8.7/)
      p%ksat(0:4) = (/25., 22.5, 20., 15., 5./)*1e-8
      p%fei(0:4) = 0.479
      p%theta_vfc(0:4) = 0.39
      p%theta_vwp(0:4) = 0.25
      p%thermal_cond(0:4) = 4.0
      p%psi_sat(0:4) = (/0.34, 0.35, 0.36, 0.37, 0.39/)
    CASE (11) 
! clay
      p%b(0:4) = (/7.6, 7.8, 8.0, 8.2, 8.4/)
      p%ksat(0:4) = (/17., 15.3, 13.6, 10.2, 3.4/)*1e-8
      p%fei(0:4) = 0.475
      p%theta_vfc(0:4) = 0.40
      p%theta_vwp(0:4) = 0.27
      p%thermal_cond(0:4) = 4.4
      p%psi_sat(0:4) = (/0.37, 0.38, 0.39, 0.40, 0.42/)
    CASE DEFAULT
      p%b(0:4) = (/7.6, 7.8, 8.0, 8.2, 8.4/)
      p%ksat(0:4) = (/17., 15.3, 13.6, 10.2, 3.4/)*1e-8
      p%fei(0:4) = 0.475
      p%theta_vfc(0:4) = 0.40
      p%theta_vwp(0:4) = 0.27
      p%psi_sat(0:4) = (/0.37, 0.38, 0.39, 0.40, 0.42/)
    END SELECT
    RETURN
  END SUBROUTINE INIT_SOIL_PARAMETERS

!  Differentiation of init_soil_status in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: p.ice_ratio p.thetam p.thetam_prev
!                p.temp_soil_p p.temp_soil_c
!   with respect to varying inputs: p.ice_ratio p.thetam p.thetam_prev
!                p.temp_soil_p p.temp_soil_c
  SUBROUTINE INIT_SOIL_STATUS_FWV(p, p_fw, tsoil, tair, ms, snowdepth, &
&   nbdirs)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
! soil temperatures and moisutre for each layer
! ponded water,snow depth
    TYPE(SOIL) :: p
    TYPE(SOIL_DIFFV) :: p_fw
    REAL(r8), INTENT(IN) :: tsoil
    REAL(r8), INTENT(IN) :: tair
! soil moisture
    REAL(r8), INTENT(IN) :: ms
    REAL(r8), INTENT(IN) :: snowdepth
    REAL(r8) :: d_t
    INTEGER :: nd
    INTEGER :: nbdirs
    d_t = tsoil - tair
! depth of ponded water on the surface
    p%zp = 0.0
    p%zsp = snowdepth
    p%r_rain_g = 0.0
    IF (d_t .GT. 5.0) d_t = 5.0
    IF (d_t .LT. -5.0) d_t = -5.0
    DO nd=1,nbdirs
      p_fw%temp_soil_c(nd, 0) = 0.0_8
      p_fw%temp_soil_c(nd, 1) = 0.0_8
      p_fw%temp_soil_c(nd, 2) = 0.0_8
      p_fw%temp_soil_c(nd, 3) = 0.0_8
      p_fw%temp_soil_c(nd, 4) = 0.0_8
      p_fw%temp_soil_c(nd, 5) = 0.0_8
      p_fw%temp_soil_p(nd, 0:5) = p_fw%temp_soil_c(nd, 0:5)
      p_fw%thetam(nd, 0) = 0.0_8
      p_fw%thetam(nd, 1) = 0.0_8
      p_fw%thetam(nd, 2) = 0.0_8
      p_fw%thetam(nd, 3) = 0.0_8
      p_fw%thetam(nd, 4) = 0.0_8
      p_fw%thetam(nd, 5) = 0.0_8
      p_fw%thetam_prev(nd, 0:5) = p_fw%thetam(nd, 0:5)
    END DO
    p%temp_soil_c(0) = tair + 0.4*d_t
    p%temp_soil_c(1) = tair + 0.5*d_t
    p%temp_soil_c(2) = tair + d_t
    p%temp_soil_c(3) = tair + 1.2*d_t
    p%temp_soil_c(4) = tair + 1.4*d_t
    p%temp_soil_c(5) = tair + 1.4*d_t
    p%temp_soil_p(0:5) = p%temp_soil_c(0:5)
    p%thetam(0) = 0.8*ms
    p%thetam(1) = ms
    p%thetam(2) = 1.05*ms
    p%thetam(3) = 1.10*ms
    p%thetam(4) = 1.15*ms
    p%thetam(5) = 1.25*ms
    p%thetam_prev(0:5) = p%thetam(0:5)
    p%psim(0:5) = (/0.1,0.1,0.1,0.1,0.1,0.1/)
    p%psim_prev(0:5) = p%psim(0:5)
!-1
    DO i=0,p%n_layer
      IF (p%temp_soil_c(i) .LT. -1.0) THEN
        DO nd=1,nbdirs
          p_fw%ice_ratio(nd, i) = 0.0_8
        END DO
        p%ice_ratio(i) = 1.0
      ELSE IF (p%temp_soil_c(i) .GT. 0) THEN
        DO nd=1,nbdirs
          p_fw%ice_ratio(nd, i) = 0.0_8
        END DO
        p%ice_ratio(i) = 0.
      ELSE
        DO nd=1,nbdirs
          p_fw%ice_ratio(nd, i) = -p_fw%temp_soil_c(nd, i)
        END DO
        p%ice_ratio(i) = (0-p%temp_soil_c(i))/1.0
      END IF
    END DO
    RETURN
  END SUBROUTINE INIT_SOIL_STATUS_FWV

  SUBROUTINE INIT_SOIL_STATUS(p, tsoil, tair, ms, snowdepth)
    IMPLICIT NONE
! soil temperatures and moisutre for each layer
! ponded water,snow depth
    TYPE(SOIL) :: p
    REAL(r8), INTENT(IN) :: tsoil
    REAL(r8), INTENT(IN) :: tair
! soil moisture
    REAL(r8), INTENT(IN) :: ms
    REAL(r8), INTENT(IN) :: snowdepth
    REAL(r8) :: d_t
    d_t = tsoil - tair
! depth of ponded water on the surface
    p%zp = 0.0
    p%zsp = snowdepth
    p%r_rain_g = 0.0
    IF (d_t .GT. 5.0) d_t = 5.0
    IF (d_t .LT. -5.0) d_t = -5.0
    p%temp_soil_c(0) = tair + 0.4*d_t
    p%temp_soil_c(1) = tair + 0.5*d_t
    p%temp_soil_c(2) = tair + d_t
    p%temp_soil_c(3) = tair + 1.2*d_t
    p%temp_soil_c(4) = tair + 1.4*d_t
    p%temp_soil_c(5) = tair + 1.4*d_t
    p%temp_soil_p(0:5) = p%temp_soil_c(0:5)
    p%thetam(0) = 0.8*ms
    p%thetam(1) = ms
    p%thetam(2) = 1.05*ms
    p%thetam(3) = 1.10*ms
    p%thetam(4) = 1.15*ms
    p%thetam(5) = 1.25*ms
    p%thetam_prev(0:5) = p%thetam(0:5)
    p%psim(0:5) = (/0.1,0.1,0.1,0.1,0.1,0.1/)
    p%psim_prev(0:5) = p%psim(0:5)
!-1
    DO i=0,p%n_layer
      IF (p%temp_soil_c(i) .LT. -1.0) THEN
        p%ice_ratio(i) = 1.0
      ELSE IF (p%temp_soil_c(i) .GT. 0) THEN
        p%ice_ratio(i) = 0.
      ELSE
        p%ice_ratio(i) = (0-p%temp_soil_c(i))/1.0
      END IF
    END DO
    RETURN
  END SUBROUTINE INIT_SOIL_STATUS

  SUBROUTINE INIT_SOIL_ROOTFRACTION(p)
    IMPLICIT NONE
    TYPE(SOIL) :: p
    REAL(r8) :: cum_depth(0:max_layers-1)
    cum_depth(0) = p%d_soil(0)
    p%f_root(0) = 1 - p%r_root_decay**(cum_depth(0)*100)
    DO i=1,p%n_layer-2
      cum_depth(i) = cum_depth(i-1) + p%d_soil(i)
      p%f_root(i) = p%r_root_decay**(cum_depth(i-1)*100) - p%&
&       r_root_decay**(cum_depth(i)*100)
    END DO
    p%f_root(p%n_layer-1) = p%r_root_decay**(cum_depth(p%n_layer-2)*100)
    RETURN
  END SUBROUTINE INIT_SOIL_ROOTFRACTION

!  Differentiation of surfacetemperature in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: temp_snow1 temp_snow2 heat_flux
!                temp_snow temp_any0 temp_ground temp_soil0
!   with respect to varying inputs: temp_snow1 temp_snow2 gheat_g
!                heat_flux_soil1 density_snow evapo_soil temp_snow1_last
!                temp_any0_last heat_flux lambda_soil1 temp_soil1_last
!                evapo_snow_g capacity_heat_soil0 capacity_heat_soil1
!                percent_snow_g temp_snow temp_any0 temp_ground
!                evapo_water_g temp_snow_last templ_u temp_ground_last
!                depth_snow netrad_g temp_snow2_last temp_soil0
!                temp_soil0_last
!****************************************************
!  soil thermal regime
! update the soil temperatures for each soil layer
!****************************************************
  SUBROUTINE SURFACETEMPERATURE_FWV(temp_air, rh_air, depth_snow, &
&   depth_snow_fw, depth_water, capacity_heat_soil1, &
&   capacity_heat_soil1_fw, capacity_heat_soil0, capacity_heat_soil0_fw&
&   , gheat_g, gheat_g_fw, depth_soil1, density_snow, density_snow_fw, &
&   templ_u, templ_u_fw, netrad_g, netrad_g_fw, evapo_soil, &
&   evapo_soil_fw, evapo_water_g, evapo_water_g_fw, evapo_snow_g, &
&   evapo_snow_g_fw, lambda_soil1, lambda_soil1_fw, percent_snow_g, &
&   percent_snow_g_fw, heat_flux_soil1, heat_flux_soil1_fw, &
&   temp_ground_last, temp_ground_last_fw, temp_soil1_last, &
&   temp_soil1_last_fw, temp_any0_last, temp_any0_last_fw, &
&   temp_snow_last, temp_snow_last_fw, temp_soil0_last, &
&   temp_soil0_last_fw, temp_snow1_last, temp_snow1_last_fw, &
&   temp_snow2_last, temp_snow2_last_fw, temp_ground, temp_ground_fw, &
&   temp_any0, temp_any0_fw, temp_snow, temp_snow_fw, temp_soil0, &
&   temp_soil0_fw, temp_snow1, temp_snow1_fw, temp_snow2, temp_snow2_fw&
&   , heat_flux, heat_flux_fw, nbdirs)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
    REAL(r8), INTENT(IN) :: temp_air, rh_air, depth_snow, depth_water, &
&   capacity_heat_soil1, capacity_heat_soil0
    REAL(r8), DIMENSION(nbdirsmax), INTENT(IN) :: depth_snow_fw, &
&   capacity_heat_soil1_fw, capacity_heat_soil0_fw
! aerodynamic conductance of heat at ground Gheat = 1/ra_g
    REAL(r8), INTENT(IN) :: gheat_g
    REAL(r8), DIMENSION(nbdirsmax), INTENT(IN) :: gheat_g_fw
    REAL(r8), INTENT(IN) :: depth_soil1, density_snow, templ_u, netrad_g
    REAL(r8), DIMENSION(nbdirsmax), INTENT(IN) :: density_snow_fw, &
&   templ_u_fw, netrad_g_fw
    REAL(r8), INTENT(IN) :: evapo_soil, evapo_water_g, evapo_snow_g
    REAL(r8), DIMENSION(nbdirsmax), INTENT(IN) :: evapo_soil_fw, &
&   evapo_water_g_fw, evapo_snow_g_fw
! thermal conductivity of first layer soil
    REAL(r8), INTENT(IN) :: lambda_soil1
    REAL(r8), DIMENSION(nbdirsmax), INTENT(IN) :: lambda_soil1_fw
    REAL(r8), INTENT(IN) :: percent_snow_g, heat_flux_soil1
    REAL(r8), DIMENSION(nbdirsmax), INTENT(IN) :: percent_snow_g_fw, &
&   heat_flux_soil1_fw
    REAL(r8), INTENT(IN) :: temp_ground_last, temp_soil1_last, &
&   temp_any0_last, temp_snow_last, temp_soil0_last, temp_snow1_last, &
&   temp_snow2_last
    REAL(r8), DIMENSION(nbdirsmax), INTENT(IN) :: temp_ground_last_fw, &
&   temp_soil1_last_fw, temp_any0_last_fw, temp_snow_last_fw, &
&   temp_soil0_last_fw, temp_snow1_last_fw, temp_snow2_last_fw
! ground => ground surface; soil0=>temperature of soil surface right above the soil in last step,the part is not covered by snow;
! soil1=>temperature of first layer soil in last step
! ground surface tem in current
    REAL(r8), INTENT(OUT) :: temp_ground
    REAL(r8), DIMENSION(nbdirsmax), INTENT(OUT) :: temp_ground_fw
! temperature of any layer right abover the soil,could be a mixture of snow temperature and soil surface temperature
    REAL(r8), INTENT(OUT) :: temp_any0
    REAL(r8), DIMENSION(nbdirsmax), INTENT(OUT) :: temp_any0_fw
    REAL(r8), INTENT(OUT) :: temp_snow
    REAL(r8), DIMENSION(nbdirsmax), INTENT(OUT) :: temp_snow_fw
! temperature of soil surface right above the soil, the part not covered by snow
    REAL(r8), INTENT(OUT) :: temp_soil0
    REAL(r8), DIMENSION(nbdirsmax), INTENT(OUT) :: temp_soil0_fw
! temperature of snow layer 2 and 3, used when depth_snow > 0.05m
    REAL(r8), INTENT(OUT) :: temp_snow1, temp_snow2
    REAL(r8), DIMENSION(nbdirsmax), INTENT(OUT) :: temp_snow1_fw, &
&   temp_snow2_fw
! heat_flux from ground to soil
    REAL(r8), INTENT(OUT) :: heat_flux
    REAL(r8), DIMENSION(nbdirsmax), INTENT(OUT) :: heat_flux_fw
! radiation available for heating the ground
    REAL(r8) :: gg
    REAL(r8), DIMENSION(nbdirsmax) :: gg_fw
! thermal conductivity
    REAL(r8) :: lambda_snow
    REAL(r8), DIMENSION(nbdirsmax) :: lambda_snow_fw
! heat flux through the soil and snow fraction on ground, separatively
    REAL(r8) :: heat_flux_soil, heat_flux_snow
    REAL(r8), DIMENSION(nbdirsmax) :: heat_flux_soil_fw, &
&   heat_flux_snow_fw
    REAL(r8) :: heat_flux_snow1, heat_flux_snow2
    REAL(r8), DIMENSION(nbdirsmax) :: heat_flux_snow1_fw, &
&   heat_flux_snow2_fw
! aerodynamic resistence of heat
    REAL(r8) :: ra_g
    REAL(r8), DIMENSION(nbdirsmax) :: ra_g_fw
! temporary vars
    REAL(r8) :: ttt
    REAL(r8), DIMENSION(nbdirsmax) :: ttt_fw
    INTRINSIC MAX
    INTRINSIC MIN
    INTEGER :: nd
    REAL(r8) :: temp
    REAL(r8) :: temp0
    REAL(r8) :: temp1
    INTEGER :: nbdirs
    CALL METEO_PACK(temp_air, rh_air)
    DO nd=1,nbdirs
      ra_g_fw(nd) = -(gheat_g_fw(nd)/gheat_g**2)
      lambda_snow_fw(nd) = (4.2/10000.+1e-9*2.2*3*density_snow**2)*&
&       density_snow_fw(nd)
! available energy on ground
      gg_fw(nd) = netrad_g_fw(nd) - latent_snow*evapo_snow_g_fw(nd) - &
&       latent_water*(evapo_water_g_fw(nd)+evapo_soil_fw(nd))
    END DO
    ra_g = 1./gheat_g
    lambda_snow = 0.021 + 4.2*density_snow/10000. + 2.2*density_snow**3*&
&     1e-9
    gg = netrad_g - evapo_snow_g*latent_snow - (evapo_water_g+evapo_soil&
&     )*latent_water
!!case 1 snow depth < 2cm, snow temperature ,ground temperature, soil surface temperature are the same
    IF (depth_snow .LE. 0.02) THEN
      ttt = capacity_heat_soil1*0.02/kstep
      temp_ground = temp_ground_last*ttt*ra_g*depth_soil1 + gg*ra_g*&
&       depth_soil1 + density_air*cp_air*temp_air*depth_soil1 + ra_g*&
&       lambda_soil1*temp_soil1_last
      temp = density_air*cp_air*depth_soil1 + ra_g*lambda_soil1 + &
&       depth_soil1*ttt*ra_g
      DO nd=1,nbdirs
        ttt_fw(nd) = 0.02*capacity_heat_soil1_fw(nd)/kstep
        temp_ground_fw(nd) = depth_soil1*(ra_g*(ttt*temp_ground_last_fw(&
&         nd)+temp_ground_last*ttt_fw(nd))+temp_ground_last*ttt*ra_g_fw(&
&         nd)) + depth_soil1*(ra_g*gg_fw(nd)+gg*ra_g_fw(nd)) + &
&         temp_soil1_last*(lambda_soil1*ra_g_fw(nd)+ra_g*lambda_soil1_fw&
&         (nd)) + ra_g*lambda_soil1*temp_soil1_last_fw(nd)
        temp_ground_fw(nd) = (temp_ground_fw(nd)-temp_ground*(&
&         lambda_soil1*ra_g_fw(nd)+ra_g*lambda_soil1_fw(nd)+depth_soil1*&
&         (ra_g*ttt_fw(nd)+ttt*ra_g_fw(nd)))/temp)/temp
      END DO
      temp_ground = temp_ground/temp
      IF (temp_ground_last - 25 .LT. temp_ground) THEN
        temp_ground = temp_ground
      ELSE
        DO nd=1,nbdirs
          temp_ground_fw(nd) = temp_ground_last_fw(nd)
        END DO
        temp_ground = temp_ground_last - 25
      END IF
      IF (temp_ground_last + 25 .GT. temp_ground) THEN
        temp_ground = temp_ground
      ELSE
        DO nd=1,nbdirs
          temp_ground_fw(nd) = temp_ground_last_fw(nd)
        END DO
        temp_ground = temp_ground_last + 25
      END IF
      temp_any0 = temp_ground
      DO nd=1,nbdirs
        temp_any0_fw(nd) = temp_ground_fw(nd)
        temp_snow_fw(nd) = temp_any0_fw(nd)
        temp_soil0_fw(nd) = temp_any0_fw(nd)
        temp_snow1_fw(nd) = temp_any0_fw(nd)
        temp_snow2_fw(nd) = temp_any0_fw(nd)
        heat_flux_fw(nd) = 2*(lambda_soil1*(temp_any0_fw(nd)-&
&         temp_soil1_last_fw(nd))/depth_soil1+(temp_any0-temp_soil1_last&
&         )*lambda_soil1_fw(nd)/depth_soil1)
      END DO
      temp_snow = temp_any0
      temp_soil0 = temp_any0
      temp_snow1 = temp_any0
      temp_snow2 = temp_any0
      heat_flux = 2*lambda_soil1*(temp_any0-temp_soil1_last)/depth_soil1
      IF (100. .GT. heat_flux) THEN
        heat_flux = heat_flux
      ELSE
        heat_flux = 100.
        heat_flux_fw(:) = 0.0_8
      END IF
      IF (-100. .LT. heat_flux) THEN
        heat_flux = heat_flux
      ELSE
        heat_flux = -100.
        heat_flux_fw(:) = 0.0_8
      END IF
    ELSE IF (depth_snow .GT. 0.02 .AND. depth_snow .LE. 0.05) THEN
      ttt = capacity_heat_soil1*0.02/kstep
      temp = density_air*cp_air*depth_soil1 + 2*ra_g*lambda_soil1 + &
&       depth_soil1*ttt*ra_g
      temp0 = 2*ra_g*lambda_soil1
      temp1 = (density_air*cp_air*temp_air*depth_soil1+depth_soil1*&
&       temp_soil0_last*ttt*ra_g+depth_soil1*gg*ra_g+temp0*&
&       temp_soil1_last)/temp
      DO nd=1,nbdirs
!! snow fraction on ground decide the snow temperature based on energy balance
!! soil fraction on ground decide the soil surface temperature based on energy balance
!! snow and soil fraction works in parallel to determine the ground surface temperature
! for soil
        ttt_fw(nd) = 0.02*capacity_heat_soil1_fw(nd)/kstep
        temp_soil0_fw(nd) = (depth_soil1*(ra_g*(ttt*temp_soil0_last_fw(&
&         nd)+temp_soil0_last*ttt_fw(nd))+temp_soil0_last*ttt*ra_g_fw(nd&
&         ))+depth_soil1*(ra_g*gg_fw(nd)+gg*ra_g_fw(nd))+temp_soil1_last&
&         *(lambda_soil1*2*ra_g_fw(nd)+2*ra_g*lambda_soil1_fw(nd))+temp0&
&         *temp_soil1_last_fw(nd)-temp1*(lambda_soil1*2*ra_g_fw(nd)+2*&
&         ra_g*lambda_soil1_fw(nd)+depth_soil1*(ra_g*ttt_fw(nd)+ttt*&
&         ra_g_fw(nd))))/temp
      END DO
      temp_soil0 = temp1
      IF (temp_air - 25 .LT. temp_soil0) THEN
        temp_soil0 = temp_soil0
      ELSE
        temp_soil0 = temp_air - 25
        temp_soil0_fw(:) = 0.0_8
      END IF
      IF (temp_air + 25 .GT. temp_soil0) THEN
        temp_soil0 = temp_soil0
      ELSE
        temp_soil0 = temp_air + 25
        temp_soil0_fw(:) = 0.0_8
      END IF
      ttt = cp_ice*density_snow*depth_snow/kstep
      temp1 = density_air*cp_air*depth_snow + ra_g*lambda_snow + ttt*&
&       ra_g*depth_snow
      temp0 = (temp_snow_last*ttt*ra_g*depth_snow+gg*ra_g*depth_snow+&
&       density_air*cp_air*templ_u*depth_snow+ra_g*lambda_snow*&
&       temp_any0_last)/temp1
      DO nd=1,nbdirs
        ttt_fw(nd) = cp_ice*(depth_snow*density_snow_fw(nd)+density_snow&
&         *depth_snow_fw(nd))/kstep
        temp_snow_fw(nd) = (ra_g*depth_snow*(ttt*temp_snow_last_fw(nd)+&
&         temp_snow_last*ttt_fw(nd))+temp_snow_last*ttt*(depth_snow*&
&         ra_g_fw(nd)+ra_g*depth_snow_fw(nd))+depth_snow*(ra_g*gg_fw(nd)&
&         +gg*ra_g_fw(nd))+gg*ra_g*depth_snow_fw(nd)+density_air*cp_air*&
&         (depth_snow*templ_u_fw(nd)+templ_u*depth_snow_fw(nd))+&
&         temp_any0_last*(lambda_snow*ra_g_fw(nd)+ra_g*lambda_snow_fw(nd&
&         ))+ra_g*lambda_snow*temp_any0_last_fw(nd)-temp0*((density_air*&
&         cp_air+ttt*ra_g)*depth_snow_fw(nd)+lambda_snow*ra_g_fw(nd)+&
&         ra_g*lambda_snow_fw(nd)+depth_snow*(ra_g*ttt_fw(nd)+ttt*&
&         ra_g_fw(nd))))/temp1
      END DO
      temp_snow = temp0
      IF (temp_air - 25 .LT. temp_snow) THEN
        temp_snow = temp_snow
      ELSE
        temp_snow = temp_air - 25
        temp_snow_fw(:) = 0.0_8
      END IF
      IF (temp_air + 25 .GT. temp_snow) THEN
        temp_snow = temp_snow
      ELSE
        temp_snow = temp_air + 25
        temp_snow_fw(:) = 0.0_8
      END IF
      temp1 = lambda_soil1/depth_soil1 + lambda_snow/depth_snow + 0.02*&
&       capacity_heat_soil1/kstep
      temp0 = (lambda_soil1*temp_soil1_last/depth_soil1+temp_snow*&
&       lambda_snow+0.02*capacity_heat_soil1*temp_any0_last/kstep)/temp1
      ttt = temp0
      DO nd=1,nbdirs
        ttt_fw(nd) = ((temp_soil1_last*lambda_soil1_fw(nd)+lambda_soil1*&
&         temp_soil1_last_fw(nd))/depth_soil1+lambda_snow*temp_snow_fw(&
&         nd)+temp_snow*lambda_snow_fw(nd)+0.02*(temp_any0_last*&
&         capacity_heat_soil1_fw(nd)+capacity_heat_soil1*&
&         temp_any0_last_fw(nd))/kstep-temp0*(lambda_soil1_fw(nd)/&
&         depth_soil1+(lambda_snow_fw(nd)-lambda_snow*depth_snow_fw(nd)/&
&         depth_snow)/depth_snow+0.02*capacity_heat_soil1_fw(nd)/kstep))&
&         /temp1
        temp_any0_fw(nd) = (1-percent_snow_g)*temp_soil0_fw(nd) - (&
&         temp_soil0-ttt)*percent_snow_g_fw(nd) + percent_snow_g*ttt_fw(&
&         nd)
      END DO
      temp_any0 = temp_soil0*(1-percent_snow_g) + ttt*percent_snow_g
      temp1 = lambda_snow*(temp_snow-temp_soil1_last)/(0.5*depth_soil1+&
&       depth_snow)
      heat_flux_snow = temp1
      heat_flux_soil = heat_flux_snow*(temp_any0-temp_soil1_last)/&
&       depth_soil1
      DO nd=1,nbdirs
        heat_flux_snow_fw(nd) = ((temp_snow-temp_soil1_last)*&
&         lambda_snow_fw(nd)+lambda_snow*(temp_snow_fw(nd)-&
&         temp_soil1_last_fw(nd))-temp1*depth_snow_fw(nd))/(depth_soil1*&
&         0.5+depth_snow)
        heat_flux_soil_fw(nd) = heat_flux_snow*(temp_any0_fw(nd)-&
&         temp_soil1_last_fw(nd))/depth_soil1 + (temp_any0-&
&         temp_soil1_last)*heat_flux_snow_fw(nd)/depth_soil1
!!!!Wrong???
        heat_flux_fw(nd) = percent_snow_g*heat_flux_snow_fw(nd) + (&
&         heat_flux_snow-heat_flux_soil)*percent_snow_g_fw(nd) + (1-&
&         percent_snow_g)*heat_flux_soil_fw(nd)
      END DO
      heat_flux = heat_flux_snow*percent_snow_g + heat_flux_soil*(1-&
&       percent_snow_g)
      IF (100. .GT. heat_flux) THEN
        heat_flux = heat_flux
      ELSE
        heat_flux = 100.
        heat_flux_fw(:) = 0.0_8
      END IF
      IF (-100. .LT. heat_flux) THEN
        heat_flux = heat_flux
      ELSE
        heat_flux = -100.
        heat_flux_fw(:) = 0.0_8
      END IF
! starting to melt
      IF (temp_snow .GT. zero .AND. temp_snow_last .LE. zero .AND. &
&         depth_snow .GT. zero) THEN
        temp_snow = 0
        temp_snow_fw(:) = 0.0_8
      END IF
! frozen
      IF (temp_snow .LT. zero .AND. temp_snow_last .GE. zero .AND. &
&         depth_water .GT. zero) THEN
        temp_snow = 0
        temp_snow_fw(:) = 0.0_8
      END IF
      DO nd=1,nbdirs
        temp_ground_fw(nd) = percent_snow_g*temp_snow_fw(nd) + (&
&         temp_snow-temp_soil0)*percent_snow_g_fw(nd) + (1-&
&         percent_snow_g)*temp_soil0_fw(nd)
      END DO
      temp_ground = temp_snow*percent_snow_g + temp_soil0*(1-&
&       percent_snow_g)
      IF (temp_air - 25 .LT. temp_ground) THEN
        temp_ground = temp_ground
      ELSE
        temp_ground = temp_air - 25
        temp_ground_fw(:) = 0.0_8
      END IF
      IF (temp_air + 25 .GT. temp_ground) THEN
        temp_ground = temp_ground
      ELSE
        temp_ground = temp_air + 25
        temp_ground_fw(:) = 0.0_8
      END IF
      DO nd=1,nbdirs
        temp_snow1_fw(nd) = temp_snow_fw(nd)
        temp_snow2_fw(nd) = temp_snow_fw(nd)
      END DO
      temp_snow1 = temp_snow
      temp_snow2 = temp_snow
    ELSE IF (depth_snow .GT. 0.05) THEN
      ttt = cp_ice*density_snow*0.02/kstep
      temp1 = 0.04*density_air*cp_air + ra_g*lambda_snow + 0.04*ttt*ra_g
      temp0 = (0.04*density_air*cp_air*temp_air+0.04*temp_snow_last*ttt*&
&       ra_g+0.02*gg*ra_g+ra_g*lambda_snow*temp_snow1_last)/temp1
      DO nd=1,nbdirs
!! case 3
!! snow_cover on ground is 100%
!! teh first layer of snow is set as 2cm
!! second layer as 2cm, too
!! the depth of third snow layer is depth_snow-0.04
        ttt_fw(nd) = cp_ice*0.02*density_snow_fw(nd)/kstep
        temp_snow_fw(nd) = (0.04*(ra_g*(ttt*temp_snow_last_fw(nd)+&
&         temp_snow_last*ttt_fw(nd))+temp_snow_last*ttt*ra_g_fw(nd))+&
&         0.02*(ra_g*gg_fw(nd)+gg*ra_g_fw(nd))+temp_snow1_last*(&
&         lambda_snow*ra_g_fw(nd)+ra_g*lambda_snow_fw(nd))+ra_g*&
&         lambda_snow*temp_snow1_last_fw(nd)-temp0*(lambda_snow*ra_g_fw(&
&         nd)+ra_g*lambda_snow_fw(nd)+0.04*(ra_g*ttt_fw(nd)+ttt*ra_g_fw(&
&         nd))))/temp1
      END DO
      temp_snow = temp0
      IF (temp_air - 25 .LT. temp_snow) THEN
        temp_snow = temp_snow
      ELSE
        temp_snow = temp_air - 25
        temp_snow_fw(:) = 0.0_8
      END IF
      IF (temp_air + 25 .GT. temp_snow) THEN
        temp_snow = temp_snow
      ELSE
        temp_snow = temp_air + 25
        temp_snow_fw(:) = 0.0_8
      END IF
      DO nd=1,nbdirs
!why 0.04 here?
        heat_flux_snow_fw(nd) = (temp_snow-temp_snow1_last)*&
&         lambda_snow_fw(nd)/0.04 + lambda_snow*(temp_snow_fw(nd)-&
&         temp_snow1_last_fw(nd))/0.04
        heat_flux_fw(nd) = heat_flux_snow_fw(nd)
      END DO
      heat_flux_snow = lambda_snow*(temp_snow-temp_snow1_last)/0.04
      heat_flux = heat_flux_snow
      IF (100. .GT. heat_flux) THEN
        heat_flux = heat_flux
      ELSE
        heat_flux = 100.
        heat_flux_fw(:) = 0.0_8
      END IF
      IF (-100. .LT. heat_flux) THEN
        heat_flux = heat_flux
      ELSE
        heat_flux = -100.
        heat_flux_fw(:) = 0.0_8
      END IF
      temp1 = lambda_snow/(depth_snow-0.02)
      DO nd=1,nbdirs
        heat_flux_snow1_fw(nd) = temp1*(temp_snow1_last_fw(nd)-&
&         temp_snow2_last_fw(nd)) + (temp_snow1_last-temp_snow2_last)*(&
&         lambda_snow_fw(nd)-temp1*depth_snow_fw(nd))/(depth_snow-0.02)
      END DO
      heat_flux_snow1 = (temp_snow1_last-temp_snow2_last)*temp1
      temp1 = 0.02*cp_ice*density_snow
      temp0 = (heat_flux-heat_flux_snow1)/temp1
      DO nd=1,nbdirs
        temp_snow1_fw(nd) = temp_snow1_last_fw(nd) + kstep*(heat_flux_fw&
&         (nd)-heat_flux_snow1_fw(nd)-temp0*cp_ice*0.02*density_snow_fw(&
&         nd))/temp1
      END DO
      temp_snow1 = temp_snow1_last + kstep*temp0
      temp1 = (depth_snow-0.04)/lambda_snow
      temp0 = 0.5*temp1 + 0.02/lambda_soil1
      temp = (temp_snow2_last-temp_any0_last)/temp0
      DO nd=1,nbdirs
        heat_flux_snow2_fw(nd) = (temp_snow2_last_fw(nd)-&
&         temp_any0_last_fw(nd)-temp*(0.5*(depth_snow_fw(nd)-temp1*&
&         lambda_snow_fw(nd))/lambda_snow-0.02*lambda_soil1_fw(nd)/&
&         lambda_soil1**2))/temp0
      END DO
      heat_flux_snow2 = temp
      temp1 = cp_ice*density_snow*(depth_snow-0.04)
      temp0 = (heat_flux_snow1-heat_flux_snow2)/temp1
      DO nd=1,nbdirs
        temp_snow2_fw(nd) = temp_snow2_last_fw(nd) + kstep*(&
&         heat_flux_snow1_fw(nd)-heat_flux_snow2_fw(nd)-temp0*((&
&         depth_snow-0.04)*cp_ice*density_snow_fw(nd)+cp_ice*&
&         density_snow*depth_snow_fw(nd)))/temp1
      END DO
      temp_snow2 = temp_snow2_last + kstep*temp0
      temp1 = (heat_flux_snow2-heat_flux_soil1)/(0.02*&
&       capacity_heat_soil0)
      DO nd=1,nbdirs
        temp_any0_fw(nd) = temp_any0_last_fw(nd) + kstep*(&
&         heat_flux_snow2_fw(nd)-heat_flux_soil1_fw(nd)-temp1*0.02*&
&         capacity_heat_soil0_fw(nd))/(0.02*capacity_heat_soil0)
        temp_soil0_fw(nd) = temp_any0_fw(nd)
      END DO
      temp_any0 = temp_any0_last + kstep*temp1
      temp_soil0 = temp_any0
      IF (temp_snow .GT. zero .AND. temp_snow_last .LE. zero .AND. &
&         depth_snow .GT. zero) THEN
        temp_snow = 0
        temp_snow_fw(:) = 0.0_8
      END IF
      IF (temp_snow .LT. zero .AND. temp_snow_last .GE. zero .AND. &
&         depth_water .GT. zero) THEN
        temp_snow = 0
        temp_snow_fw(:) = 0.0_8
      END IF
      DO nd=1,nbdirs
        temp_ground_fw(nd) = temp_snow_fw(nd)
      END DO
      temp_ground = temp_snow
    END IF
    RETURN
  END SUBROUTINE SURFACETEMPERATURE_FWV

!****************************************************
!  soil thermal regime
! update the soil temperatures for each soil layer
!****************************************************
  SUBROUTINE SURFACETEMPERATURE(temp_air, rh_air, depth_snow, &
&   depth_water, capacity_heat_soil1, capacity_heat_soil0, gheat_g, &
&   depth_soil1, density_snow, templ_u, netrad_g, evapo_soil, &
&   evapo_water_g, evapo_snow_g, lambda_soil1, percent_snow_g, &
&   heat_flux_soil1, temp_ground_last, temp_soil1_last, temp_any0_last, &
&   temp_snow_last, temp_soil0_last, temp_snow1_last, temp_snow2_last, &
&   temp_ground, temp_any0, temp_snow, temp_soil0, temp_snow1, &
&   temp_snow2, heat_flux)
    IMPLICIT NONE
    REAL(r8), INTENT(IN) :: temp_air, rh_air, depth_snow, depth_water, &
&   capacity_heat_soil1, capacity_heat_soil0
! aerodynamic conductance of heat at ground Gheat = 1/ra_g
    REAL(r8), INTENT(IN) :: gheat_g
    REAL(r8), INTENT(IN) :: depth_soil1, density_snow, templ_u, netrad_g
    REAL(r8), INTENT(IN) :: evapo_soil, evapo_water_g, evapo_snow_g
! thermal conductivity of first layer soil
    REAL(r8), INTENT(IN) :: lambda_soil1
    REAL(r8), INTENT(IN) :: percent_snow_g, heat_flux_soil1
    REAL(r8), INTENT(IN) :: temp_ground_last, temp_soil1_last, &
&   temp_any0_last, temp_snow_last, temp_soil0_last, temp_snow1_last, &
&   temp_snow2_last
! ground => ground surface; soil0=>temperature of soil surface right above the soil in last step,the part is not covered by snow;
! soil1=>temperature of first layer soil in last step
! ground surface tem in current
    REAL(r8), INTENT(OUT) :: temp_ground
! temperature of any layer right abover the soil,could be a mixture of snow temperature and soil surface temperature
    REAL(r8), INTENT(OUT) :: temp_any0
    REAL(r8), INTENT(OUT) :: temp_snow
! temperature of soil surface right above the soil, the part not covered by snow
    REAL(r8), INTENT(OUT) :: temp_soil0
! temperature of snow layer 2 and 3, used when depth_snow > 0.05m
    REAL(r8), INTENT(OUT) :: temp_snow1, temp_snow2
! heat_flux from ground to soil
    REAL(r8), INTENT(OUT) :: heat_flux
! radiation available for heating the ground
    REAL(r8) :: gg
! thermal conductivity
    REAL(r8) :: lambda_snow
! heat flux through the soil and snow fraction on ground, separatively
    REAL(r8) :: heat_flux_soil, heat_flux_snow
    REAL(r8) :: heat_flux_snow1, heat_flux_snow2
! aerodynamic resistence of heat
    REAL(r8) :: ra_g
! temporary vars
    REAL(r8) :: ttt
    INTRINSIC MAX
    INTRINSIC MIN
    CALL METEO_PACK(temp_air, rh_air)
    ra_g = 1./gheat_g
    lambda_snow = 0.021 + 4.2*density_snow/10000. + 2.2*density_snow**3*&
&     1e-9
! available energy on ground
    gg = netrad_g - evapo_snow_g*latent_snow - (evapo_water_g+evapo_soil&
&     )*latent_water
!!case 1 snow depth < 2cm, snow temperature ,ground temperature, soil surface temperature are the same
    IF (depth_snow .LE. 0.02) THEN
      ttt = capacity_heat_soil1*0.02/kstep
      temp_ground = temp_ground_last*ttt*ra_g*depth_soil1 + gg*ra_g*&
&       depth_soil1 + density_air*cp_air*temp_air*depth_soil1 + ra_g*&
&       lambda_soil1*temp_soil1_last
      temp_ground = temp_ground/(density_air*cp_air*depth_soil1+ra_g*&
&       lambda_soil1+ttt*ra_g*depth_soil1)
      IF (temp_ground_last - 25 .LT. temp_ground) THEN
        temp_ground = temp_ground
      ELSE
        temp_ground = temp_ground_last - 25
      END IF
      IF (temp_ground_last + 25 .GT. temp_ground) THEN
        temp_ground = temp_ground
      ELSE
        temp_ground = temp_ground_last + 25
      END IF
      temp_any0 = temp_ground
      temp_snow = temp_any0
      temp_soil0 = temp_any0
      temp_snow1 = temp_any0
      temp_snow2 = temp_any0
      heat_flux = 2*lambda_soil1*(temp_any0-temp_soil1_last)/depth_soil1
      IF (100. .GT. heat_flux) THEN
        heat_flux = heat_flux
      ELSE
        heat_flux = 100.
      END IF
      IF (-100. .LT. heat_flux) THEN
        heat_flux = heat_flux
      ELSE
        heat_flux = -100.
      END IF
    ELSE IF (depth_snow .GT. 0.02 .AND. depth_snow .LE. 0.05) THEN
!! snow fraction on ground decide the snow temperature based on energy balance
!! soil fraction on ground decide the soil surface temperature based on energy balance
!! snow and soil fraction works in parallel to determine the ground surface temperature
! for soil
      ttt = capacity_heat_soil1*0.02/kstep
      temp_soil0 = (temp_soil0_last*ttt*ra_g*depth_soil1+gg*ra_g*&
&       depth_soil1+density_air*cp_air*temp_air*depth_soil1+2*ra_g*&
&       lambda_soil1*temp_soil1_last)/(density_air*cp_air*depth_soil1+2*&
&       ra_g*lambda_soil1+ttt*ra_g*depth_soil1)
      IF (temp_air - 25 .LT. temp_soil0) THEN
        temp_soil0 = temp_soil0
      ELSE
        temp_soil0 = temp_air - 25
      END IF
      IF (temp_air + 25 .GT. temp_soil0) THEN
        temp_soil0 = temp_soil0
      ELSE
        temp_soil0 = temp_air + 25
      END IF
      ttt = cp_ice*density_snow*depth_snow/kstep
      temp_snow = (temp_snow_last*ttt*ra_g*depth_snow+gg*ra_g*depth_snow&
&       +density_air*cp_air*templ_u*depth_snow+ra_g*lambda_snow*&
&       temp_any0_last)/(density_air*cp_air*depth_snow+ra_g*lambda_snow+&
&       ttt*ra_g*depth_snow)
      IF (temp_air - 25 .LT. temp_snow) THEN
        temp_snow = temp_snow
      ELSE
        temp_snow = temp_air - 25
      END IF
      IF (temp_air + 25 .GT. temp_snow) THEN
        temp_snow = temp_snow
      ELSE
        temp_snow = temp_air + 25
      END IF
      ttt = (lambda_soil1*temp_soil1_last/depth_soil1+temp_snow*&
&       lambda_snow+0.02*capacity_heat_soil1/kstep*temp_any0_last)/(&
&       lambda_soil1/depth_soil1+lambda_snow/depth_snow+0.02*&
&       capacity_heat_soil1/kstep)
      temp_any0 = temp_soil0*(1-percent_snow_g) + ttt*percent_snow_g
      heat_flux_snow = lambda_snow/(depth_snow+0.5*depth_soil1)*(&
&       temp_snow-temp_soil1_last)
      heat_flux_soil = heat_flux_snow*(temp_any0-temp_soil1_last)/&
&       depth_soil1
!!!!Wrong???
      heat_flux = heat_flux_snow*percent_snow_g + heat_flux_soil*(1-&
&       percent_snow_g)
      IF (100. .GT. heat_flux) THEN
        heat_flux = heat_flux
      ELSE
        heat_flux = 100.
      END IF
      IF (-100. .LT. heat_flux) THEN
        heat_flux = heat_flux
      ELSE
        heat_flux = -100.
      END IF
! starting to melt
      IF (temp_snow .GT. zero .AND. temp_snow_last .LE. zero .AND. &
&         depth_snow .GT. zero) temp_snow = 0
! frozen
      IF (temp_snow .LT. zero .AND. temp_snow_last .GE. zero .AND. &
&         depth_water .GT. zero) temp_snow = 0
      temp_ground = temp_snow*percent_snow_g + temp_soil0*(1-&
&       percent_snow_g)
      IF (temp_air - 25 .LT. temp_ground) THEN
        temp_ground = temp_ground
      ELSE
        temp_ground = temp_air - 25
      END IF
      IF (temp_air + 25 .GT. temp_ground) THEN
        temp_ground = temp_ground
      ELSE
        temp_ground = temp_air + 25
      END IF
      temp_snow1 = temp_snow
      temp_snow2 = temp_snow
    ELSE IF (depth_snow .GT. 0.05) THEN
!! case 3
!! snow_cover on ground is 100%
!! teh first layer of snow is set as 2cm
!! second layer as 2cm, too
!! the depth of third snow layer is depth_snow-0.04
      ttt = cp_ice*density_snow*0.02/kstep
      temp_snow = (temp_snow_last*ttt*ra_g*0.04+gg*ra_g*0.02+density_air&
&       *cp_air*temp_air*0.04+ra_g*lambda_snow*temp_snow1_last)/(&
&       density_air*cp_air*0.04+ra_g*lambda_snow+ttt*ra_g*0.04)
      IF (temp_air - 25 .LT. temp_snow) THEN
        temp_snow = temp_snow
      ELSE
        temp_snow = temp_air - 25
      END IF
      IF (temp_air + 25 .GT. temp_snow) THEN
        temp_snow = temp_snow
      ELSE
        temp_snow = temp_air + 25
      END IF
!why 0.04 here?
      heat_flux_snow = lambda_snow*(temp_snow-temp_snow1_last)/0.04
      heat_flux = heat_flux_snow
      IF (100. .GT. heat_flux) THEN
        heat_flux = heat_flux
      ELSE
        heat_flux = 100.
      END IF
      IF (-100. .LT. heat_flux) THEN
        heat_flux = heat_flux
      ELSE
        heat_flux = -100.
      END IF
      heat_flux_snow1 = lambda_snow*(temp_snow1_last-temp_snow2_last)/(&
&       depth_snow-0.02)
      temp_snow1 = temp_snow1_last + (heat_flux-heat_flux_snow1)/(cp_ice&
&       *density_snow*0.02)*kstep
      heat_flux_snow2 = (temp_snow2_last-temp_any0_last)/(0.5*(&
&       depth_snow-0.04)/lambda_snow+0.02/lambda_soil1)
      temp_snow2 = temp_snow2_last + (heat_flux_snow1-heat_flux_snow2)/(&
&       cp_ice*density_snow*(depth_snow-0.04))*kstep
      temp_any0 = temp_any0_last + (heat_flux_snow2-heat_flux_soil1)/(&
&       capacity_heat_soil0*0.02)*kstep
      temp_soil0 = temp_any0
      IF (temp_snow .GT. zero .AND. temp_snow_last .LE. zero .AND. &
&         depth_snow .GT. zero) temp_snow = 0
      IF (temp_snow .LT. zero .AND. temp_snow_last .GE. zero .AND. &
&         depth_water .GT. zero) temp_snow = 0
      temp_ground = temp_snow
    END IF
    RETURN
  END SUBROUTINE SURFACETEMPERATURE

!  Differentiation of updateheatflux in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: p.ice_ratio p.temp_soil_p p.temp_soil_c
!                p.g
!   with respect to varying inputs: p.ice_ratio p.thetam p.thetam_prev
!                p.temp_soil_p p.temp_soil_c p.cs p.lambda p.g
  SUBROUTINE UPDATEHEATFLUX_FWV(p, p_fw, xg_snow, lambda_snow, tsn0, &
&   tair_annual_mean, period_in_seconds, nbdirs)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
    TYPE(SOIL) :: p
    TYPE(SOIL_DIFFV) :: p_fw
    REAL(r8), INTENT(IN) :: xg_snow
    REAL(r8), INTENT(IN) :: lambda_snow
    REAL(r8), INTENT(IN) :: tsn0, tair_annual_mean
    INTEGER, INTENT(IN) :: period_in_seconds
!-- iLab::no need to have variable 's' 'implicitl save',
!         or may also switch to parameter?
! real(r8)              :: S = 0.    !what? Wangjun
    REAL(r8) :: s
    INTRINSIC REAL
    INTEGER :: nd
    REAL(r8) :: temp
    REAL(r8) :: temp0
    REAL(r8) :: temp1
    REAL(r8) :: temp2
    REAL :: temp3
    INTEGER :: nbdirs
    s = 0._r8
    DO i=1,p%n_layer
      IF (i .LT. p%n_layer) THEN
        temp = 0.5*p%d_soil(i)/p%lambda(i)
        temp0 = 0.5*p%d_soil(i-1)/p%lambda(i-1)
        temp1 = temp0 + temp
        temp2 = (p%temp_soil_p(i-1)-p%temp_soil_p(i))/temp1
        DO nd=1,nbdirs
          p_fw%g(nd, i) = (p_fw%temp_soil_p(nd, i-1)-p_fw%temp_soil_p(nd&
&           , i)-temp2*(-(temp0*p_fw%lambda(nd, i-1)/p%lambda(i-1))-temp&
&           *p_fw%lambda(nd, i)/p%lambda(i)))/temp1
        END DO
        p%g(i) = temp2
      ELSE
        temp2 = depth_f + 0.5*p%d_soil(i-1)
        DO nd=1,nbdirs
          p_fw%g(nd, i) = ((p%temp_soil_p(i-1)-tair_annual_mean)*p_fw%&
&           lambda(nd, i-1)+p%lambda(i-1)*p_fw%temp_soil_p(nd, i-1))/&
&           temp2
        END DO
        p%g(i) = p%lambda(i-1)*(p%temp_soil_p(i-1)-tair_annual_mean)/&
&         temp2
      END IF
      IF (p%g(i) .GT. 200) THEN
        DO nd=1,nbdirs
          p_fw%g(nd, i) = 0.0_8
        END DO
        p%g(i) = 200
      END IF
      IF (p%g(i) .LT. -200) THEN
        DO nd=1,nbdirs
          p_fw%g(nd, i) = 0.0_8
        END DO
        p%g(i) = -200
      END IF
    END DO
    DO i=0,p%n_layer-1
      temp3 = REAL(period_in_seconds)
      temp2 = p%d_soil(i)*p%cs(i)
      temp1 = (s+p%g(i)-p%g(i+1))/temp2
      DO nd=1,nbdirs
        p_fw%temp_soil_c(nd, i) = p_fw%temp_soil_p(nd, i) + temp3*(p_fw%&
&         g(nd, i)-p_fw%g(nd, i+1)-temp1*p%d_soil(i)*p_fw%cs(nd, i))/&
&         temp2
      END DO
      p%temp_soil_c(i) = p%temp_soil_p(i) + temp3*temp1
      IF (p%temp_soil_c(i) .GT. 50.0) THEN
        DO nd=1,nbdirs
          p_fw%temp_soil_c(nd, i) = 0.0_8
        END DO
        p%temp_soil_c(i) = 50.
      END IF
      IF (p%temp_soil_c(i) .LT. -50.0) THEN
        DO nd=1,nbdirs
          p_fw%temp_soil_c(nd, i) = 0.0_8
        END DO
        p%temp_soil_c(i) = -50.
      END IF
    END DO
! do i = 0,p%n_layer-1
!  write(*,*) 'DG0031: soil temperature diagnosis', p%temp_soil_c(i)
! end do
    CALL UPDATE_ICE_RATIO_FWV(p, p_fw, nbdirs)
    DO i=0,p%n_layer-1
      DO nd=1,nbdirs
        p_fw%temp_soil_p(nd, i) = p_fw%temp_soil_c(nd, i)
      END DO
      p%temp_soil_p(i) = p%temp_soil_c(i)
    END DO
    RETURN
  END SUBROUTINE UPDATEHEATFLUX_FWV

  SUBROUTINE UPDATEHEATFLUX(p, xg_snow, lambda_snow, tsn0, &
&   tair_annual_mean, period_in_seconds)
    IMPLICIT NONE
    TYPE(SOIL) :: p
    REAL(r8), INTENT(IN) :: xg_snow
    REAL(r8), INTENT(IN) :: lambda_snow
    REAL(r8), INTENT(IN) :: tsn0, tair_annual_mean
    INTEGER, INTENT(IN) :: period_in_seconds
!-- iLab::no need to have variable 's' 'implicitl save',
!         or may also switch to parameter?
! real(r8)              :: S = 0.    !what? Wangjun
    REAL(r8) :: s
    INTRINSIC REAL
    s = 0._r8
    DO i=1,p%n_layer
      IF (i .LT. p%n_layer) THEN
        p%g(i) = (p%temp_soil_p(i-1)-p%temp_soil_p(i))/(0.5*p%d_soil(i-1&
&         )/p%lambda(i-1)+0.5*p%d_soil(i)/p%lambda(i))
      ELSE
        p%g(i) = p%lambda(i-1)*(p%temp_soil_p(i-1)-tair_annual_mean)/(&
&         depth_f+p%d_soil(i-1)*0.5)
      END IF
      IF (p%g(i) .GT. 200) p%g(i) = 200
      IF (p%g(i) .LT. -200) p%g(i) = -200
    END DO
    DO i=0,p%n_layer-1
      p%temp_soil_c(i) = p%temp_soil_p(i) + (p%g(i)-p%g(i+1)+s)/(p%cs(i)&
&       *p%d_soil(i))*REAL(period_in_seconds)
      IF (p%temp_soil_c(i) .GT. 50.0) p%temp_soil_c(i) = 50.
      IF (p%temp_soil_c(i) .LT. -50.0) p%temp_soil_c(i) = -50.
    END DO
! do i = 0,p%n_layer-1
!  write(*,*) 'DG0031: soil temperature diagnosis', p%temp_soil_c(i)
! end do
    CALL UPDATE_ICE_RATIO(p)
    DO i=0,p%n_layer-1
      p%temp_soil_p(i) = p%temp_soil_c(i)
    END DO
    RETURN
  END SUBROUTINE UPDATEHEATFLUX

!  Differentiation of update_cs in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: p.cs
!   with respect to varying inputs: p.ice_ratio p.thetam p.cs
  SUBROUTINE UPDATE_CS_FWV(p, p_fw, nbdirs)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
    TYPE(SOIL) :: p
    TYPE(SOIL_DIFFV) :: p_fw
    REAL(r8) :: term1, term2, term3
    REAL(r8), DIMENSION(nbdirsmax) :: term2_fw
    INTEGER :: nd
    REAL(r8) :: temp
    INTEGER :: nbdirs
!Chen B. (2007) Ecological Modelling 209, 277-300  (equation 18)
    DO i=0,p%n_layer-1
      term1 = 2.*1.e3*p%density_soil(i)/2.65
      temp = 4.2*(-p%ice_ratio(i)+1.) + 2.09*p%ice_ratio(i)
      DO nd=1,nbdirs
        term2_fw(nd) = 1.e6*(temp*p_fw%thetam(nd, i)-p%thetam(i)*2.11*&
&         p_fw%ice_ratio(nd, i))
        p_fw%cs(nd, i) = term2_fw(nd)
      END DO
      term2 = 1.e6*(p%thetam(i)*temp)
      term3 = 2.5*1.e6*p%f_org(i)
      p%cs(i) = term1 + term2 + term3
    END DO
    RETURN
  END SUBROUTINE UPDATE_CS_FWV

  SUBROUTINE UPDATE_CS(p)
    IMPLICIT NONE
    TYPE(SOIL) :: p
    REAL(r8) :: term1, term2, term3
!Chen B. (2007) Ecological Modelling 209, 277-300  (equation 18)
    DO i=0,p%n_layer-1
      term1 = 2.*1.e3*p%density_soil(i)/2.65
      term2 = 1.e6*p%thetam(i)*(4.2*(1.-p%ice_ratio(i))+2.09*p%ice_ratio&
&       (i))
      term3 = 2.5*1.e6*p%f_org(i)
      p%cs(i) = term1 + term2 + term3
    END DO
    RETURN
  END SUBROUTINE UPDATE_CS

!  Differentiation of update_ice_ratio in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: p.ice_ratio p.temp_soil_c
!   with respect to varying inputs: p.ice_ratio p.thetam p.thetam_prev
!                p.temp_soil_c p.cs
  SUBROUTINE UPDATE_ICE_RATIO_FWV(p, p_fw, nbdirs)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
    TYPE(SOIL) :: p
    TYPE(SOIL_DIFFV) :: p_fw
! latent heat of fusion at 0C
    REAL(r8), SAVE :: lf0=3.34*1.e5
    REAL(r8) :: tmp
    REAL(r8), DIMENSION(nbdirsmax) :: tmp_fw
    INTRINSIC MIN
    INTRINSIC MAX
    INTEGER :: nd
    REAL(r8) :: temp
    REAL(r8) :: temp0
    INTEGER :: nbdirs
    DO i=0,p%n_layer-1
! starting to frozen
      IF (p%temp_soil_p(i) .GE. 0. .AND. p%temp_soil_c(i) .LT. 0. .AND. &
&         p%ice_ratio(i) .LT. 1.0 .AND. p%thetam(i) .GT. 0.) THEN
        tmp = (0.-p%temp_soil_c(i))*p%cs(i)*p%d_soil(i)
        temp = 1000.*lf0*p%d_soil(i)
        temp0 = temp*p%thetam(i)
        DO nd=1,nbdirs
!! Add p%thetam(i) >0. by @J.Wang
          tmp_fw(nd) = p%d_soil(i)*(-(p%cs(i)*p_fw%temp_soil_c(nd, i))-p&
&           %temp_soil_c(i)*p_fw%cs(nd, i))
          p_fw%ice_ratio(nd, i) = p_fw%ice_ratio(nd, i) + (tmp_fw(nd)-&
&           tmp*temp*p_fw%thetam(nd, i)/temp0)/temp0
        END DO
        p%ice_ratio(i) = p%ice_ratio(i) + tmp/temp0
        IF (1.0 .GT. p%ice_ratio(i)) THEN
          p%ice_ratio(i) = p%ice_ratio(i)
        ELSE
          DO nd=1,nbdirs
            p_fw%ice_ratio(nd, i) = 0.0_8
          END DO
          p%ice_ratio(i) = 1.0
        END IF
        DO nd=1,nbdirs
          p_fw%temp_soil_c(nd, i) = 0.0_8
        END DO
        p%temp_soil_c(i) = 0
! Be melting
      ELSE IF (p%temp_soil_p(i) .LE. 0 .AND. p%temp_soil_c(i) .GT. 0. &
&         .AND. p%ice_ratio(i) .GT. 0.) THEN
        tmp = (p%temp_soil_c(i)-0.0)*p%cs(i)*p%d_soil(i)
        temp0 = 1000.*lf0*p%d_soil(i)
        temp = temp0*p%thetam(i)
        DO nd=1,nbdirs
          tmp_fw(nd) = p%d_soil(i)*(p%cs(i)*p_fw%temp_soil_c(nd, i)+p%&
&           temp_soil_c(i)*p_fw%cs(nd, i))
          p_fw%ice_ratio(nd, i) = p_fw%ice_ratio(nd, i) - (tmp_fw(nd)-&
&           tmp*temp0*p_fw%thetam(nd, i)/temp)/temp
        END DO
        p%ice_ratio(i) = p%ice_ratio(i) - tmp/temp
        IF (0. .LT. p%ice_ratio(i)) THEN
          p%ice_ratio(i) = p%ice_ratio(i)
        ELSE
          DO nd=1,nbdirs
            p_fw%ice_ratio(nd, i) = 0.0_8
          END DO
          p%ice_ratio(i) = 0.
        END IF
        DO nd=1,nbdirs
          p_fw%temp_soil_c(nd, i) = 0.0_8
        END DO
        p%temp_soil_c(i) = 0
      END IF
      temp0 = p%ice_ratio(i)*p%thetam_prev(i)/p%thetam(i)
      DO nd=1,nbdirs
        p_fw%ice_ratio(nd, i) = (p%thetam_prev(i)*p_fw%ice_ratio(nd, i)+&
&         p%ice_ratio(i)*p_fw%thetam_prev(nd, i)-temp0*p_fw%thetam(nd, i&
&         ))/p%thetam(i)
      END DO
      p%ice_ratio(i) = temp0
      IF (1. .GT. p%ice_ratio(i)) THEN
        p%ice_ratio(i) = p%ice_ratio(i)
      ELSE
        DO nd=1,nbdirs
          p_fw%ice_ratio(nd, i) = 0.0_8
        END DO
        p%ice_ratio(i) = 1.
      END IF
    END DO
    RETURN
  END SUBROUTINE UPDATE_ICE_RATIO_FWV

  SUBROUTINE UPDATE_ICE_RATIO(p)
    IMPLICIT NONE
    TYPE(SOIL) :: p
! latent heat of fusion at 0C
    REAL(r8), SAVE :: lf0=3.34*1.e5
    REAL(r8) :: tmp
    INTRINSIC MIN
    INTRINSIC MAX
    DO i=0,p%n_layer-1
! starting to frozen
      IF (p%temp_soil_p(i) .GE. 0. .AND. p%temp_soil_c(i) .LT. 0. .AND. &
&         p%ice_ratio(i) .LT. 1.0 .AND. p%thetam(i) .GT. 0.) THEN
!! Add p%thetam(i) >0. by @J.Wang
        tmp = (0.-p%temp_soil_c(i))*p%cs(i)*p%d_soil(i)
        p%ice_ratio(i) = p%ice_ratio(i) + tmp/lf0/1000./(p%thetam(i)*p%&
&         d_soil(i))
        IF (1.0 .GT. p%ice_ratio(i)) THEN
          p%ice_ratio(i) = p%ice_ratio(i)
        ELSE
          p%ice_ratio(i) = 1.0
        END IF
        p%temp_soil_c(i) = 0
! Be melting
      ELSE IF (p%temp_soil_p(i) .LE. 0 .AND. p%temp_soil_c(i) .GT. 0. &
&         .AND. p%ice_ratio(i) .GT. 0.) THEN
        tmp = (p%temp_soil_c(i)-0.0)*p%cs(i)*p%d_soil(i)
        p%ice_ratio(i) = p%ice_ratio(i) - tmp/lf0/1000./(p%thetam(i)*p%&
&         d_soil(i))
        IF (0. .LT. p%ice_ratio(i)) THEN
          p%ice_ratio(i) = p%ice_ratio(i)
        ELSE
          p%ice_ratio(i) = 0.
        END IF
        p%temp_soil_c(i) = 0
      END IF
      p%ice_ratio(i) = p%ice_ratio(i)*p%thetam_prev(i)/p%thetam(i)
      IF (1. .GT. p%ice_ratio(i)) THEN
        p%ice_ratio(i) = p%ice_ratio(i)
      ELSE
        p%ice_ratio(i) = 1.
      END IF
    END DO
    RETURN
  END SUBROUTINE UPDATE_ICE_RATIO

!  Differentiation of updatesoilthermalconductivity in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: p.lambda
!   with respect to varying inputs: p.ice_ratio p.thetam p.lambda
  SUBROUTINE UPDATESOILTHERMALCONDUCTIVITY_FWV(p, p_fw, nbdirs)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
    TYPE(SOIL) :: p
    TYPE(SOIL_DIFFV) :: p_fw
! the thermal conductivity of ice
    REAL(r8), SAVE :: ki=2.1
! the thermal conductivity of water
    REAL(r8), SAVE :: kw=0.61
    REAL(r8) :: tmp1, tmp2, tmp3, tmp4
    REAL(r8), DIMENSION(nbdirsmax) :: tmp2_fw, tmp3_fw, tmp4_fw
    INTRINSIC MAX
    INTEGER :: nd
    REAL(r8) :: temp
    INTEGER :: nbdirs
    DO i=0,p%n_layer-1
! dry
      tmp1 = p%thermal_cond(i)**(1-p%fei(i))
!ice
      temp = ki**(1.2*p%thetam(i)*p%ice_ratio(i))
      DO nd=1,nbdirs
        IF (ki .LE. 0.0_8) THEN
          tmp2_fw(nd) = 0.0_8
        ELSE
          tmp2_fw(nd) = temp*LOG(ki)*1.2*(p%ice_ratio(i)*p_fw%thetam(nd&
&           , i)+p%thetam(i)*p_fw%ice_ratio(nd, i))
        END IF
!!Sr ??
        tmp4_fw(nd) = p_fw%thetam(nd, i)/p%fei(i)
      END DO
      tmp2 = temp
!water
      temp = kw**(p%thetam(i)*(-p%ice_ratio(i)+1))
      DO nd=1,nbdirs
        IF (kw .LE. 0.0_8) THEN
          tmp3_fw(nd) = 0.0_8
        ELSE
          tmp3_fw(nd) = temp*LOG(kw)*((1-p%ice_ratio(i))*p_fw%thetam(nd&
&           , i)-p%thetam(i)*p_fw%ice_ratio(nd, i))
        END IF
      END DO
      tmp3 = temp
      tmp4 = p%thetam(i)/p%fei(i)
!eq. 8. LHE
      temp = tmp1*tmp2*tmp3 - 0.15
      DO nd=1,nbdirs
        p_fw%lambda(nd, i) = tmp4*tmp1*(tmp3*tmp2_fw(nd)+tmp2*tmp3_fw(nd&
&         )) + temp*tmp4_fw(nd)
      END DO
      p%lambda(i) = temp*tmp4 + 0.15
      IF (p%lambda(i) .LT. 0.15) THEN
        DO nd=1,nbdirs
          p_fw%lambda(nd, i) = 0.0_8
        END DO
        p%lambda(i) = 0.15
      ELSE
        p%lambda(i) = p%lambda(i)
      END IF
    END DO
    RETURN
  END SUBROUTINE UPDATESOILTHERMALCONDUCTIVITY_FWV

  SUBROUTINE UPDATESOILTHERMALCONDUCTIVITY(p)
    IMPLICIT NONE
    TYPE(SOIL) :: p
! the thermal conductivity of ice
    REAL(r8), SAVE :: ki=2.1
! the thermal conductivity of water
    REAL(r8), SAVE :: kw=0.61
    REAL(r8) :: tmp1, tmp2, tmp3, tmp4
    INTRINSIC MAX
    DO i=0,p%n_layer-1
! dry
      tmp1 = p%thermal_cond(i)**(1-p%fei(i))
!ice
      tmp2 = ki**(1.2*p%thetam(i)*p%ice_ratio(i))
!water
      tmp3 = kw**(p%thetam(i)*(1-p%ice_ratio(i)))
!!Sr ??
      tmp4 = p%thetam(i)/p%fei(i)
!eq. 8. LHE
      p%lambda(i) = (tmp1*tmp2*tmp3-0.15)*tmp4 + 0.15
      IF (p%lambda(i) .LT. 0.15) THEN
        p%lambda(i) = 0.15
      ELSE
        p%lambda(i) = p%lambda(i)
      END IF
    END DO
    RETURN
  END SUBROUTINE UPDATESOILTHERMALCONDUCTIVITY

!  Differentiation of updatesoilmoisture in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: p.zp p.ice_ratio p.thetam p.thetam_prev
!                p.f_ice p.psim p.thetab p.psib p.r_waterflow p.km
!                p.kb p.kk
!   with respect to varying inputs: p.zp p.r_rain_g p.ksat p.b
!                p.ice_ratio p.thetam p.thetam_prev p.temp_soil_c
!                p.f_ice p.psim p.thetab p.psib p.r_waterflow p.km
!                p.kb p.kk p.ett
!******************************************************
! Soil hydraulic state
!******************************************************
!remove the parameter 'kstep'@J.Wang
  SUBROUTINE UPDATESOILMOISTURE_FWV(p, p_fw, nbdirs)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
    TYPE(SOIL) :: p
    TYPE(SOIL_DIFFV) :: p_fw
! infiltration, and Maximum infiltration
    REAL(r8) :: infil, infil_max
    REAL(r8), DIMENSION(nbdirsmax) :: infil_fw, infil_max_fw
    REAL(r8) :: this_step, total_t, max_fb, kkstep
    REAL(r8) :: d1
    REAL(r8), DIMENSION(nbdirsmax) :: d1_fw
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC ABS
    REAL(r8) :: x1
    REAL(r8), DIMENSION(nbdirsmax) :: x1_fw
    REAL(r8) :: abs0
    INTEGER :: nd
    REAL(r8) :: temp
    REAL(r8) :: temp0
    REAL(r8) :: temp1
    REAL(r8) :: temp2
    REAL(r8), DIMENSION(nbdirsmax) :: temp_fw
    REAL(r8) :: temp3
    REAL(r8), DIMENSION(nbdirsmax) :: temp_fw0
    REAL(r8), DIMENSION(nbdirsmax) :: temp_fw1
    INTEGER :: nbdirs
    kkstep = 1.*kstep
    DO i=0,p%n_layer
!save previous thetam
      DO nd=1,nbdirs
        p_fw%thetam_prev(nd, i) = p_fw%thetam(nd, i)
      END DO
      p%thetam_prev(i) = p%thetam(i)
    END DO
    DO i=0,p%n_layer
      IF (p%temp_soil_c(i) .GT. 0.0) THEN
!! f_ice should be named as f_water
        DO nd=1,nbdirs
          p_fw%f_ice(nd, i) = 0.0_8
        END DO
        p%f_ice(i) = 1.0
      ELSE IF (p%temp_soil_c(i) .LT. -1.) THEN
        DO nd=1,nbdirs
          p_fw%f_ice(nd, i) = 0.0_8
        END DO
        p%f_ice(i) = 0.1
      ELSE
        DO nd=1,nbdirs
          p_fw%f_ice(nd, i) = 0.9*p_fw%temp_soil_c(nd, i)
        END DO
        p%f_ice(i) = 0.1 + 0.9*(p%temp_soil_c(i)+1.0)
      END IF
    END DO
!write(*,*) p%f_ice(0),p%Zp,p%r_rain_g
!! juweimin
!! this part solve the upper boundary condition (Infiltration). LHE
!! the maximum Infiltration. The Inf should be changing very fast during precipitation because thetam
!! is changing. LHE
    temp = p%psi_sat(0)*(p%fei(0)-p%thetam_prev(0))*p%b(0)/(p%d_soil(0)*&
&     p%fei(0)) + 1.
    DO nd=1,nbdirs
      infil_max_fw(nd) = temp*(p%ksat(0)*p_fw%f_ice(nd, 0)+p%f_ice(0)*&
&       p_fw%ksat(nd, 0)) + p%f_ice(0)*p%ksat(0)*p%psi_sat(0)*((p%fei(0)&
&       -p%thetam_prev(0))*p_fw%b(nd, 0)-p%b(0)*p_fw%thetam_prev(nd, 0))&
&       /(p%d_soil(0)*p%fei(0))
    END DO
    infil_max = p%f_ice(0)*p%ksat(0)*temp
    IF (p%f_ice(0)*(p%zp/kkstep+p%r_rain_g) .LT. 0.) THEN
      infil = 0.
      infil_fw(:) = 0.0_8
    ELSE
      temp = p%zp/kkstep + p%r_rain_g
      DO nd=1,nbdirs
        infil_fw(nd) = temp*p_fw%f_ice(nd, 0) + p%f_ice(0)*(p_fw%zp(nd)/&
&         kkstep+p_fw%r_rain_g(nd))
      END DO
      infil = p%f_ice(0)*temp
    END IF
    IF (infil_max .GT. infil) THEN
      infil = infil
    ELSE
      DO nd=1,nbdirs
        infil_fw(nd) = infil_max_fw(nd)
      END DO
      infil = infil_max
    END IF
    IF (0. .LT. infil) THEN
      infil = infil
    ELSE
      infil = 0.
      infil_fw(:) = 0.0_8
    END IF
! Ponded water after runoff. This one is related to runoff
    DO nd=1,nbdirs
      p_fw%zp(nd) = kkstep*p%r_drainage*(p_fw%zp(nd)/kkstep+p_fw%&
&       r_rain_g(nd)-infil_fw(nd))
    END DO
    p%zp = (p%zp/kkstep+p%r_rain_g-infil)*kkstep*p%r_drainage
    this_step = 0.
    total_t = 0.
    max_fb = 0.
    DO WHILE (total_t .LT. kkstep)
      DO i=0,p%n_layer-1
        temp = 2.*p%b(i) + 3.
        temp0 = p%thetam(i)/p%fei(i)
        temp1 = temp0**temp
        temp2 = p%f_ice(i)*p%ksat(i)
        DO nd=1,nbdirs
          IF (temp0 .LE. 0.0_8 .AND. (temp .EQ. 0.0_8 .OR. temp .NE. INT&
&             (temp))) THEN
            temp_fw(nd) = 0.0_8
          ELSE IF (temp0 .LE. 0.0_8) THEN
            temp_fw(nd) = temp*temp0**(temp-1)*p_fw%thetam(nd, i)/p%fei(&
&             i)
          ELSE
            temp_fw(nd) = temp*temp0**(temp-1)*p_fw%thetam(nd, i)/p%fei(&
&             i) + temp1*LOG(temp0)*2.*p_fw%b(nd, i)
          END IF
          p_fw%km(nd, i) = temp1*(p%ksat(i)*p_fw%f_ice(nd, i)+p%f_ice(i)&
&           *p_fw%ksat(nd, i)) + temp2*temp_fw(nd)
        END DO
        p%km(i) = temp2*temp1
      END DO
      DO i=0,p%n_layer-1
        IF (i .LT. p%n_layer - 1) THEN
          temp2 = 1.0/p%d_soil(i) + 1.0/p%d_soil(i+1)
          DO nd=1,nbdirs
            p_fw%thetab(nd, i) = (p_fw%thetam(nd, i+1)/p%d_soil(i+1)+&
&             p_fw%thetam(nd, i)/p%d_soil(i))/temp2
          END DO
          p%thetab(i) = (p%thetam(i+1)/p%d_soil(i+1)+p%thetam(i)/p%&
&           d_soil(i))/temp2
        ELSE
          DO nd=1,nbdirs
            d1_fw(nd) = 2.*(p_fw%thetam(nd, i)-p_fw%thetab(nd, i-1))/p%&
&             d_soil(i)
          END DO
          d1 = (p%thetam(i)-p%thetab(i-1))*2./p%d_soil(i)
          IF (d1 .LT. 0.) THEN
            d1 = 0.
            d1_fw(:) = 0.0_8
          ELSE
            d1 = d1
          END IF
          DO nd=1,nbdirs
            p_fw%thetab(nd, i) = p_fw%thetam(nd, i) + p%d_soil(i)*d1_fw(&
&             nd)/2.
          END DO
          p%thetab(i) = p%thetam(i) + d1*p%d_soil(i)/2.
          IF (p%thetab(i) .GT. p%fei(i)) THEN
            DO nd=1,nbdirs
              p_fw%thetab(nd, i) = 0.0_8
            END DO
            p%thetab(i) = p%fei(i)
          ELSE
            p%thetab(i) = p%thetab(i)
          END IF
        END IF
      END DO
      DO i=0,p%n_layer-1
        IF (i .LT. p%n_layer - 1) THEN
! the unsaturated hydraulic conductivity at soil lower boundary
!! Note: Kb(0) to Kb(n_layer-1) are not used in the model
          temp2 = 2.*p%b(i) + 3.
          temp1 = p%thetab(i)/p%fei(i)
          temp0 = temp1**temp2
          temp = p%f_ice(i)/(p%d_soil(i)+p%d_soil(i+1))
          temp3 = p%d_soil(i)*p%ksat(i) + p%d_soil(i+1)*p%ksat(i+1)
          DO nd=1,nbdirs
            IF (temp1 .LE. 0.0_8 .AND. (temp2 .EQ. 0.0_8 .OR. temp2 .NE.&
&               INT(temp2))) THEN
              temp_fw0(nd) = 0.0_8
            ELSE IF (temp1 .LE. 0.0_8) THEN
              temp_fw0(nd) = temp2*temp1**(temp2-1)*p_fw%thetab(nd, i)/p&
&               %fei(i)
            ELSE
              temp_fw0(nd) = temp2*temp1**(temp2-1)*p_fw%thetab(nd, i)/p&
&               %fei(i) + temp0*LOG(temp1)*2.*p_fw%b(nd, i)
            END IF
            p_fw%kb(nd, i) = temp0*(temp*(p%d_soil(i)*p_fw%ksat(nd, i)+p&
&             %d_soil(i+1)*p_fw%ksat(nd, i+1))+temp3*p_fw%f_ice(nd, i)/(&
&             p%d_soil(i)+p%d_soil(i+1))) + temp3*temp*temp_fw0(nd)
          END DO
          p%kb(i) = temp3*temp*temp0
        ELSE
! i= n_layer-1
          temp3 = 2.*p%b(i) + 3.
          temp2 = p%thetab(i)/p%fei(i)
          temp1 = temp2**temp3
          temp0 = p%f_ice(i)*p%ksat(i)
          DO nd=1,nbdirs
            IF (temp2 .LE. 0.0_8 .AND. (temp3 .EQ. 0.0_8 .OR. temp3 .NE.&
&               INT(temp3))) THEN
              temp_fw(nd) = 0.0_8
            ELSE IF (temp2 .LE. 0.0_8) THEN
              temp_fw(nd) = temp3*temp2**(temp3-1)*p_fw%thetab(nd, i)/p%&
&               fei(i)
            ELSE
              temp_fw(nd) = temp3*temp2**(temp3-1)*p_fw%thetab(nd, i)/p%&
&               fei(i) + temp1*LOG(temp2)*2.*p_fw%b(nd, i)
            END IF
            p_fw%kb(nd, i) = 0.5*(temp1*(p%ksat(i)*p_fw%f_ice(nd, i)+p%&
&             f_ice(i)*p_fw%ksat(nd, i))+temp0*temp_fw(nd))
          END DO
          p%kb(i) = 0.5*(temp0*temp1)
        END IF
      END DO
! the unsaturated soil water retention
      DO i=0,p%n_layer-1
        temp2 = p%thetam(i)/p%fei(i)
        temp3 = temp2**(-p%b(i))
        DO nd=1,nbdirs
          IF (temp2 .LE. 0.0_8 .AND. (-p%b(i) .EQ. 0.0_8 .OR. -p%b(i) &
&             .NE. INT(-p%b(i)))) THEN
            temp_fw1(nd) = 0.0_8
          ELSE IF (temp2 .LE. 0.0_8) THEN
            temp_fw1(nd) = -(p%b(i)*temp2**((-1)-p%b(i))*p_fw%thetam(nd&
&             , i)/p%fei(i))
          ELSE
            temp_fw1(nd) = -(p%b(i)*temp2**((-1)-p%b(i))*p_fw%thetam(nd&
&             , i)/p%fei(i)) - temp3*LOG(temp2)*p_fw%b(nd, i)
          END IF
          p_fw%psim(nd, i) = p%psi_sat(i)*temp_fw1(nd)
        END DO
        p%psim(i) = p%psi_sat(i)*temp3
        IF (p%psi_sat(i) .LT. p%psim(i)) THEN
          p%psim(i) = p%psim(i)
        ELSE
          DO nd=1,nbdirs
            p_fw%psim(nd, i) = 0.0_8
          END DO
          p%psim(i) = p%psi_sat(i)
        END IF
      END DO
! the unsaturated soil water retention @boundary LHE
      DO i=0,p%n_layer-1
        temp2 = p%thetab(i)/p%fei(i)
        temp3 = temp2**(-p%b(i))
        DO nd=1,nbdirs
          IF (temp2 .LE. 0.0_8 .AND. (-p%b(i) .EQ. 0.0_8 .OR. -p%b(i) &
&             .NE. INT(-p%b(i)))) THEN
            temp_fw1(nd) = 0.0_8
          ELSE IF (temp2 .LE. 0.0_8) THEN
            temp_fw1(nd) = -(p%b(i)*temp2**((-1)-p%b(i))*p_fw%thetab(nd&
&             , i)/p%fei(i))
          ELSE
            temp_fw1(nd) = -(p%b(i)*temp2**((-1)-p%b(i))*p_fw%thetab(nd&
&             , i)/p%fei(i)) - temp3*LOG(temp2)*p_fw%b(nd, i)
          END IF
          p_fw%psib(nd, i) = p%psi_sat(i)*temp_fw1(nd)
        END DO
        p%psib(i) = p%psi_sat(i)*temp3
        IF (p%psi_sat(i) .LT. p%psib(i)) THEN
          p%psib(i) = p%psib(i)
        ELSE
          DO nd=1,nbdirs
            p_fw%psib(nd, i) = 0.0_8
          END DO
          p%psib(i) = p%psi_sat(i)
        END IF
      END DO
! the unsaturated hydraulic conductivity of soil p%n_layer
      DO i=0,p%n_layer-1
        IF (i .LT. p%n_layer - 1) THEN
! see seller's
          temp3 = p%b(i) + p%b(i+1) + 6
          temp2 = (p%psim(i)+p%psim(i+1))*temp3
          temp1 = (p%b(i)+p%b(i+1))/temp2
          temp0 = p%km(i)*p%psim(i) + p%km(i+1)*p%psim(i+1)
          DO nd=1,nbdirs
            p_fw%kk(nd, i) = temp1*(p%psim(i)*p_fw%km(nd, i)+p%km(i)*&
&             p_fw%psim(nd, i)+p%psim(i+1)*p_fw%km(nd, i+1)+p%km(i+1)*&
&             p_fw%psim(nd, i+1)) + temp0*(p_fw%b(nd, i)+p_fw%b(nd, i+1)&
&             -temp1*(temp3*(p_fw%psim(nd, i)+p_fw%psim(nd, i+1))+(p%&
&             psim(i)+p%psim(i+1))*(p_fw%b(nd, i)+p_fw%b(nd, i+1))))/&
&             temp2
          END DO
          p%kk(i) = temp0*temp1
        ELSE
          temp3 = (p%psim(i)+p%psib(i))*(p%b(i)+3)
          temp2 = p%b(i)/temp3
          temp1 = p%km(i)*p%psim(i) + p%kb(i)*p%psib(i)
          DO nd=1,nbdirs
            p_fw%kk(nd, i) = temp2*(p%psim(i)*p_fw%km(nd, i)+p%km(i)*&
&             p_fw%psim(nd, i)+p%psib(i)*p_fw%kb(nd, i)+p%kb(i)*p_fw%&
&             psib(nd, i)) + temp1*(p_fw%b(nd, i)-temp2*((p%b(i)+3)*(&
&             p_fw%psim(nd, i)+p_fw%psib(nd, i))+(p%psim(i)+p%psib(i))*&
&             p_fw%b(nd, i)))/temp3
          END DO
          p%kk(i) = temp1*temp2
        END IF
      END DO
! Fb flow speed, Dancy's law LHE
      DO i=0,p%n_layer-1
        IF (i .LT. p%n_layer - 1) THEN
! downwards positive , +1 accounts for gravitational drainage LHE
          temp3 = 2*(p%psim(i+1)-p%psim(i))/(p%d_soil(i)+p%d_soil(i+1)) &
&           + 1
          DO nd=1,nbdirs
            p_fw%r_waterflow(nd, i) = temp3*p_fw%kk(nd, i) + p%kk(i)*2*(&
&             p_fw%psim(nd, i+1)-p_fw%psim(nd, i))/(p%d_soil(i)+p%d_soil&
&             (i+1))
          END DO
          p%r_waterflow(i) = p%kk(i)*temp3
        ELSE
! from Ju
          DO nd=1,nbdirs
            p_fw%r_waterflow(nd, i) = 0.0_8
          END DO
          p%r_waterflow(i) = 0.
        END IF
      END DO
! check the r_waterflow further
      DO i=0,p%n_layer-2
        DO nd=1,nbdirs
          x1_fw(nd) = p_fw%ett(nd, i+1) - p%d_soil(i+1)*p_fw%thetam(nd, &
&           i+1)/kkstep
        END DO
        x1 = (p%fei(i+1)-p%thetam(i+1))*p%d_soil(i+1)/kkstep + p%ett(i+1&
&         )
        IF (x1 .GT. p%r_waterflow(i)) THEN
          p%r_waterflow(i) = p%r_waterflow(i)
        ELSE
          DO nd=1,nbdirs
            p_fw%r_waterflow(nd, i) = x1_fw(nd)
          END DO
          p%r_waterflow(i) = x1
        END IF
        IF (p%r_waterflow(i) .GE. 0.) THEN
          abs0 = p%r_waterflow(i)
        ELSE
          abs0 = -p%r_waterflow(i)
        END IF
! find max_Fb for all p%LAYERS
        IF (abs0 .GT. max_fb) THEN
          IF (p%r_waterflow(i) .GE. 0.) THEN
            max_fb = p%r_waterflow(i)
          ELSE
            max_fb = -p%r_waterflow(i)
          END IF
        END IF
      END DO
      IF (max_fb .GT. 1.e-5) THEN
! determine the sub_step according to order of Fb emirically
        this_step = 1.
      ELSE IF (max_fb .GT. 1.e-6) THEN
        this_step = 30.
      ELSE
!       this_step  = 360.
!!@J.Wang replace 360 by kstep
        this_step = kkstep
      END IF
      total_t = total_t + this_step
      IF (total_t .GT. kstep) this_step = this_step - (total_t-kkstep)
      DO i=0,p%n_layer-1
        IF (i .EQ. 0) THEN
          DO nd=1,nbdirs
            p_fw%thetam(nd, i) = p_fw%thetam(nd, i) + (this_step*&
&             infil_fw(nd)-this_step*p_fw%r_waterflow(nd, i)-this_step*&
&             p_fw%ett(nd, i))/p%d_soil(i)
          END DO
          p%thetam(i) = p%thetam(i) + (infil*this_step-p%r_waterflow(i)*&
&           this_step-p%ett(i)*this_step)/p%d_soil(i)
        ELSE
          DO nd=1,nbdirs
            p_fw%thetam(nd, i) = p_fw%thetam(nd, i) + this_step*(p_fw%&
&             r_waterflow(nd, i-1)-p_fw%r_waterflow(nd, i)-p_fw%ett(nd, &
&             i))/p%d_soil(i)
          END DO
          p%thetam(i) = p%thetam(i) + (p%r_waterflow(i-1)-p%r_waterflow(&
&           i)-p%ett(i))*this_step/p%d_soil(i)
        END IF
        IF (p%theta_vwp(i) .LT. p%thetam(i)) THEN
          p%thetam(i) = p%thetam(i)
        ELSE
          DO nd=1,nbdirs
            p_fw%thetam(nd, i) = 0.0_8
          END DO
          p%thetam(i) = p%theta_vwp(i)
        END IF
        IF (p%fei(i) .GT. p%thetam(i)) THEN
          p%thetam(i) = p%thetam(i)
        ELSE
          DO nd=1,nbdirs
            p_fw%thetam(nd, i) = 0.0_8
          END DO
          p%thetam(i) = p%fei(i)
        END IF
      END DO
    END DO
! end do while
    DO i=0,p%n_layer-1
      temp3 = p%ice_ratio(i)*p%thetam_prev(i)/p%thetam(i)
      DO nd=1,nbdirs
        p_fw%ice_ratio(nd, i) = (p%thetam_prev(i)*p_fw%ice_ratio(nd, i)+&
&         p%ice_ratio(i)*p_fw%thetam_prev(nd, i)-temp3*p_fw%thetam(nd, i&
&         ))/p%thetam(i)
      END DO
      p%ice_ratio(i) = temp3
      IF (1.0 .GT. p%ice_ratio(i)) THEN
        p%ice_ratio(i) = p%ice_ratio(i)
      ELSE
        DO nd=1,nbdirs
          p_fw%ice_ratio(nd, i) = 0.0_8
        END DO
        p%ice_ratio(i) = 1.0
      END IF
    END DO
    RETURN
  END SUBROUTINE UPDATESOILMOISTURE_FWV

!******************************************************
! Soil hydraulic state
!******************************************************
!remove the parameter 'kstep'@J.Wang
  SUBROUTINE UPDATESOILMOISTURE(p)
    IMPLICIT NONE
    TYPE(SOIL) :: p
! infiltration, and Maximum infiltration
    REAL(r8) :: infil, infil_max
    REAL(r8) :: this_step, total_t, max_fb, kkstep
    REAL(r8) :: d1
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC ABS
    REAL(r8) :: x1
    REAL(r8) :: abs0
    kkstep = 1.*kstep
    DO i=0,p%n_layer
!save previous thetam
      p%thetam_prev(i) = p%thetam(i)
    END DO
    DO i=0,p%n_layer
      IF (p%temp_soil_c(i) .GT. 0.0) THEN
!! f_ice should be named as f_water
        p%f_ice(i) = 1.0
      ELSE IF (p%temp_soil_c(i) .LT. -1.) THEN
        p%f_ice(i) = 0.1
      ELSE
        p%f_ice(i) = 0.1 + 0.9*(p%temp_soil_c(i)+1.0)
      END IF
    END DO
!write(*,*) p%f_ice(0),p%Zp,p%r_rain_g
!! juweimin
!! this part solve the upper boundary condition (Infiltration). LHE
!! the maximum Infiltration. The Inf should be changing very fast during precipitation because thetam
!! is changing. LHE
    infil_max = p%f_ice(0)*p%ksat(0)*(1.+(p%fei(0)-p%thetam_prev(0))/p%&
&     d_soil(0)*p%psi_sat(0)*p%b(0)/p%fei(0))
    IF (p%f_ice(0)*(p%zp/kkstep+p%r_rain_g) .LT. 0.) THEN
      infil = 0.
    ELSE
      infil = p%f_ice(0)*(p%zp/kkstep+p%r_rain_g)
    END IF
    IF (infil_max .GT. infil) THEN
      infil = infil
    ELSE
      infil = infil_max
    END IF
    IF (0. .LT. infil) THEN
      infil = infil
    ELSE
      infil = 0.
    END IF
! Ponded water after runoff. This one is related to runoff
    p%zp = (p%zp/kkstep+p%r_rain_g-infil)*kkstep*p%r_drainage
    this_step = 0.
    total_t = 0.
    max_fb = 0.
    DO WHILE (total_t .LT. kkstep)
      DO i=0,p%n_layer-1
        p%km(i) = p%f_ice(i)*p%ksat(i)*(p%thetam(i)/p%fei(i))**(2.*p%b(i&
&         )+3.)
      END DO
      DO i=0,p%n_layer-1
        IF (i .LT. p%n_layer - 1) THEN
          p%thetab(i) = (p%thetam(i+1)/p%d_soil(i+1)+p%thetam(i)/p%&
&           d_soil(i))/(1./p%d_soil(i)+1./p%d_soil(i+1))
        ELSE
          d1 = (p%thetam(i)-p%thetab(i-1))*2./p%d_soil(i)
          IF (d1 .LT. 0.) THEN
            d1 = 0.
          ELSE
            d1 = d1
          END IF
          p%thetab(i) = p%thetam(i) + d1*p%d_soil(i)/2.
          IF (p%thetab(i) .GT. p%fei(i)) THEN
            p%thetab(i) = p%fei(i)
          ELSE
            p%thetab(i) = p%thetab(i)
          END IF
        END IF
      END DO
      DO i=0,p%n_layer-1
        IF (i .LT. p%n_layer - 1) THEN
! the unsaturated hydraulic conductivity at soil lower boundary
!! Note: Kb(0) to Kb(n_layer-1) are not used in the model
          p%kb(i) = p%f_ice(i)*(p%ksat(i)*p%d_soil(i)+p%ksat(i+1)*p%&
&           d_soil(i+1))/(p%d_soil(i)+p%d_soil(i+1))*(p%thetab(i)/p%fei(&
&           i))**(2.*p%b(i)+3.)
        ELSE
! i= n_layer-1
          p%kb(i) = 0.5*p%f_ice(i)*p%ksat(i)*(p%thetab(i)/p%fei(i))**(2.&
&           *p%b(i)+3.)
        END IF
      END DO
! the unsaturated soil water retention
      DO i=0,p%n_layer-1
        p%psim(i) = p%psi_sat(i)*(p%thetam(i)/p%fei(i))**(-p%b(i))
        IF (p%psi_sat(i) .LT. p%psim(i)) THEN
          p%psim(i) = p%psim(i)
        ELSE
          p%psim(i) = p%psi_sat(i)
        END IF
      END DO
! the unsaturated soil water retention @boundary LHE
      DO i=0,p%n_layer-1
        p%psib(i) = p%psi_sat(i)*(p%thetab(i)/p%fei(i))**(-(1.*p%b(i)))
        IF (p%psi_sat(i) .LT. p%psib(i)) THEN
          p%psib(i) = p%psib(i)
        ELSE
          p%psib(i) = p%psi_sat(i)
        END IF
      END DO
! the unsaturated hydraulic conductivity of soil p%n_layer
      DO i=0,p%n_layer-1
        IF (i .LT. p%n_layer - 1) THEN
! see seller's
          p%kk(i) = (p%km(i)*p%psim(i)+p%km(i+1)*p%psim(i+1))/(p%psim(i)&
&           +p%psim(i+1))*(p%b(i)+p%b(i+1))/(p%b(i)+p%b(i+1)+6)
        ELSE
          p%kk(i) = (p%km(i)*p%psim(i)+p%kb(i)*p%psib(i))/(p%psim(i)+p%&
&           psib(i))*p%b(i)/(p%b(i)+3)
        END IF
      END DO
! Fb flow speed, Dancy's law LHE
      DO i=0,p%n_layer-1
        IF (i .LT. p%n_layer - 1) THEN
! downwards positive , +1 accounts for gravitational drainage LHE
          p%r_waterflow(i) = p%kk(i)*(2*(p%psim(i+1)-p%psim(i))/(p%&
&           d_soil(i)+p%d_soil(i+1))+1)
        ELSE
! from Ju
          p%r_waterflow(i) = 0.
        END IF
      END DO
! check the r_waterflow further
      DO i=0,p%n_layer-2
        x1 = (p%fei(i+1)-p%thetam(i+1))*p%d_soil(i+1)/kkstep + p%ett(i+1&
&         )
        IF (x1 .GT. p%r_waterflow(i)) THEN
          p%r_waterflow(i) = p%r_waterflow(i)
        ELSE
          p%r_waterflow(i) = x1
        END IF
        IF (p%r_waterflow(i) .GE. 0.) THEN
          abs0 = p%r_waterflow(i)
        ELSE
          abs0 = -p%r_waterflow(i)
        END IF
! find max_Fb for all p%LAYERS
        IF (abs0 .GT. max_fb) THEN
          IF (p%r_waterflow(i) .GE. 0.) THEN
            max_fb = p%r_waterflow(i)
          ELSE
            max_fb = -p%r_waterflow(i)
          END IF
        END IF
      END DO
      IF (max_fb .GT. 1.e-5) THEN
! determine the sub_step according to order of Fb emirically
        this_step = 1.
      ELSE IF (max_fb .GT. 1.e-6) THEN
        this_step = 30.
      ELSE
!       this_step  = 360.
!!@J.Wang replace 360 by kstep
        this_step = kkstep
      END IF
      total_t = total_t + this_step
      IF (total_t .GT. kstep) this_step = this_step - (total_t-kkstep)
      DO i=0,p%n_layer-1
        IF (i .EQ. 0) THEN
          p%thetam(i) = p%thetam(i) + (infil*this_step-p%r_waterflow(i)*&
&           this_step-p%ett(i)*this_step)/p%d_soil(i)
        ELSE
          p%thetam(i) = p%thetam(i) + (p%r_waterflow(i-1)-p%r_waterflow(&
&           i)-p%ett(i))*this_step/p%d_soil(i)
        END IF
        IF (p%theta_vwp(i) .LT. p%thetam(i)) THEN
          p%thetam(i) = p%thetam(i)
        ELSE
          p%thetam(i) = p%theta_vwp(i)
        END IF
        IF (p%fei(i) .GT. p%thetam(i)) THEN
          p%thetam(i) = p%thetam(i)
        ELSE
          p%thetam(i) = p%fei(i)
        END IF
      END DO
    END DO
! end do while
    DO i=0,p%n_layer-1
      p%ice_ratio(i) = p%ice_ratio(i)*p%thetam_prev(i)/p%thetam(i)
      IF (1.0 .GT. p%ice_ratio(i)) THEN
        p%ice_ratio(i) = p%ice_ratio(i)
      ELSE
        p%ice_ratio(i) = 1.0
      END IF
    END DO
    RETURN
  END SUBROUTINE UPDATESOILMOISTURE

!  Differentiation of soil_water_uptake in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: p.ett
!   with respect to varying inputs: p.dt p.ett trans_o evap_soil
!                trans_u
  SUBROUTINE SOIL_WATER_UPTAKE_FWV(p, p_fw, trans_o, trans_o_fw, trans_u&
&   , trans_u_fw, evap_soil, evap_soil_fw, nbdirs)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
    TYPE(SOIL) :: p
    TYPE(SOIL_DIFFV) :: p_fw
    REAL(r8) :: trans_o, trans_u, evap_soil
    REAL(r8), DIMENSION(nbdirsmax) :: trans_o_fw, trans_u_fw, &
&   evap_soil_fw
    REAL(r8) :: source
    REAL(r8), DIMENSION(nbdirsmax) :: source_fw
    INTEGER :: nd
    INTEGER :: nbdirs
    source = trans_o + trans_u
    DO nd=1,nbdirs
      source_fw(nd) = trans_o_fw(nd) + trans_u_fw(nd)
! for the top layer
      p_fw%ett(nd, 0) = source*p_fw%dt(nd, 0)/rho_w + p%dt(0)*source_fw(&
&       nd)/rho_w + evap_soil_fw(nd)/rho_w
    END DO
    p%ett(0) = source/rho_w*p%dt(0) + evap_soil/rho_w
!  p%Ett(0) = 0.
! for each layer
    DO i=1,p%n_layer-1
      DO nd=1,nbdirs
        p_fw%ett(nd, i) = source*p_fw%dt(nd, i)/rho_w + p%dt(i)*&
&         source_fw(nd)/rho_w
      END DO
      p%ett(i) = source/rho_w*p%dt(i)
    END DO
    RETURN
  END SUBROUTINE SOIL_WATER_UPTAKE_FWV

  SUBROUTINE SOIL_WATER_UPTAKE(p, trans_o, trans_u, evap_soil)
    IMPLICIT NONE
    TYPE(SOIL) :: p
    REAL(r8) :: trans_o, trans_u, evap_soil
    REAL(r8) :: source
    source = trans_o + trans_u
! for the top layer
    p%ett(0) = source/rho_w*p%dt(0) + evap_soil/rho_w
!  p%Ett(0) = 0.
! for each layer
    DO i=1,p%n_layer-1
      p%ett(i) = source/rho_w*p%dt(i)
    END DO
    RETURN
  END SUBROUTINE SOIL_WATER_UPTAKE

!  Differentiation of soil_water_factor_v2 in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: p.f_soilwater p.dt p.psim
!   with respect to varying inputs: p.dt p.b p.thetam p.temp_soil_p
!                p.psim
  SUBROUTINE SOIL_WATER_FACTOR_V2_FWV(p, p_fw, nbdirs)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
    TYPE(SOIL) :: p
    TYPE(SOIL_DIFFV) :: p_fw
    REAL(r8) :: ft(0:max_layers-1), fpsisr(0:max_layers-1)
    REAL(r8) :: ft_fw(nbdirsmax, 0:max_layers-1), fpsisr_fw(nbdirsmax, 0&
&   :max_layers-1)
    REAL(r8) :: dtt(0:max_layers-1)
    REAL(r8) :: dtt_fw(nbdirsmax, 0:max_layers-1)
    REAL(r8), SAVE :: t1=-0.02
    REAL(r8), SAVE :: t2=2.0
!--iLab::changed in order to avoid "implicit save" for these variables
! real(r8):: dtt_sum = 0.,fpsisr_sum = 0.
    REAL(r8) :: dtt_sum, fpsisr_sum
    REAL(r8), DIMENSION(nbdirsmax) :: dtt_sum_fw, fpsisr_sum_fw
    INTRINSIC MAX
    INTRINSIC EXP
    REAL(r8) :: arg1
    REAL(r8), DIMENSION(nbdirsmax) :: arg1_fw
    INTEGER :: nd
    REAL(r8) :: temp
    REAL(r8), DIMENSION(nbdirsmax) :: temp_fw
    REAL(r8) :: temp0
    REAL(r8) :: temp1
    REAL(r8), DIMENSION(nbdirsmax) :: temp_fw0
    INTEGER :: nbdirs
    dtt_sum = 0._8
    fpsisr_sum = 0._8
!! change the rule for updating p%psim @MOUSONG.WU,2018.11
    DO i=0,p%n_layer-1
      temp0 = p%thetam(i)/p%fei(i)
      temp = temp0**(-p%b(i))
      DO nd=1,nbdirs
        IF (temp0 .LE. 0.0_8 .AND. (-p%b(i) .EQ. 0.0_8 .OR. -p%b(i) .NE.&
&           INT(-p%b(i)))) THEN
          temp_fw(nd) = 0.0_8
        ELSE IF (temp0 .LE. 0.0_8) THEN
          temp_fw(nd) = -(p%b(i)*temp0**((-1)-p%b(i))*p_fw%thetam(nd, i)&
&           /p%fei(i))
        ELSE
          temp_fw(nd) = -(p%b(i)*temp0**((-1)-p%b(i))*p_fw%thetam(nd, i)&
&           /p%fei(i)) - temp*LOG(temp0)*p_fw%b(nd, i)
        END IF
        p_fw%psim(nd, i) = p%psi_sat(i)*temp_fw(nd)
      END DO
      p%psim(i) = p%psi_sat(i)*temp
      IF (p%psi_sat(i) .LT. 1.e-6) THEN
        DO nd=1,nbdirs
          p_fw%psim(nd, i) = 0.0_8
        END DO
        p%psim(i) = 1.e-6
      ELSE
        DO nd=1,nbdirs
          p_fw%psim(nd, i) = 0.0_8
        END DO
        p%psim(i) = p%psi_sat(i)
      END IF
    END DO
    fpsisr_fw(:, :) = 0.0_8
    ft_fw(:, :) = 0.0_8
    DO i=0,p%n_layer-1
      IF (p%psim(i) .GT. p%psi_min) THEN
        temp0 = (p%psim(i)-p%psi_min)/p%psi_min
        temp = 1.0/(temp0**p%alpha+1.)
        DO nd=1,nbdirs
          IF (temp0 .LE. 0.0_8 .AND. (p%alpha .EQ. 0.0_8 .OR. p%alpha &
&             .NE. INT(p%alpha))) THEN
            temp_fw0(nd) = 0.0_8
          ELSE
            temp_fw0(nd) = p%alpha*temp0**(p%alpha-1)*p_fw%psim(nd, i)/p&
&             %psi_min
          END IF
          fpsisr_fw(nd, i) = -(temp*temp_fw0(nd)/(temp0**p%alpha+1.))
        END DO
        fpsisr(i) = temp
      ELSE
        DO nd=1,nbdirs
          fpsisr_fw(nd, i) = 0.0_8
        END DO
        fpsisr(i) = 1.
      END IF
      IF (p%temp_soil_p(i) .GT. 0.) THEN
        arg1 = t1*p%temp_soil_p(i)**t2
        DO nd=1,nbdirs
          IF (p%temp_soil_p(i) .LE. 0.0_8 .AND. (t2 .EQ. 0.0_8 .OR. t2 &
&             .NE. INT(t2))) THEN
            temp_fw0(nd) = 0.0_8
          ELSE
            temp_fw0(nd) = t2*p%temp_soil_p(i)**(t2-1)*p_fw%temp_soil_p(&
&             nd, i)
          END IF
          arg1_fw(nd) = t1*temp_fw0(nd)
          ft_fw(nd, i) = -(EXP(arg1)*arg1_fw(nd))
        END DO
        ft(i) = 1. - EXP(arg1)
      ELSE
        DO nd=1,nbdirs
          ft_fw(nd, i) = 0.0_8
        END DO
        ft(i) = 0.
      END IF
      DO nd=1,nbdirs
        fpsisr_fw(nd, i) = ft(i)*fpsisr_fw(nd, i) + fpsisr(i)*ft_fw(nd, &
&         i)
      END DO
      fpsisr(i) = fpsisr(i)*ft(i)
    END DO
    IF (fw_version .EQ. 1) THEN
      dtt_fw(:, :) = 0.0_8
      DO i=0,p%n_layer-1
!eq. 14 in Ju 2006
        DO nd=1,nbdirs
          dtt_fw(nd, i) = p%f_root(i)*fpsisr_fw(nd, i)
        END DO
        dtt(i) = p%f_root(i)*fpsisr(i)
      END DO
      dtt_sum_fw(:) = 0.0_8
    ELSE
      DO i=0,p%n_layer-1
        dtt(i) = p%f_root(i)
      END DO
      dtt_fw(:, :) = 0.0_8
      dtt_sum_fw(:) = 0.0_8
    END IF
    DO i=0,p%n_layer-1
      DO nd=1,nbdirs
        dtt_sum_fw(nd) = dtt_sum_fw(nd) + dtt_fw(nd, i)
      END DO
      dtt_sum = dtt_sum + dtt(i)
    END DO
    IF (dtt_sum .LT. 1.e-6) THEN
      p%f_soilwater = 0.1
      DO i=0,p%n_layer-1
        DO nd=1,nbdirs
          p_fw%dt(nd, i) = 0.0_8
        END DO
        p%dt(i) = 0.
      END DO
      p_fw%f_soilwater(:) = 0.0_8
    ELSE
      DO i=0,p%n_layer-1
        temp1 = dtt(i)/dtt_sum
        DO nd=1,nbdirs
          p_fw%dt(nd, i) = (dtt_fw(nd, i)-temp1*dtt_sum_fw(nd))/dtt_sum
        END DO
        p%dt(i) = temp1
        IF (p%dt(i) .LT. 1.e-6) THEN
          DO nd=1,nbdirs
            p_fw%dt(nd, i) = 0.0_8
          END DO
          p%dt(i) = 1.e-6
        ELSE
          p%dt(i) = p%dt(i)
        END IF
      END DO
      fpsisr_sum_fw(:) = 0.0_8
!if(isnan(p%dt(i))) then
!p%dt(i) = 0.
!write(*,*) p%dt(i)
!end if
      DO i=0,p%n_layer-1
! eq. 12, in Chen 2012 GBC; eq 15 in JU
        DO nd=1,nbdirs
          fpsisr_sum_fw(nd) = fpsisr_sum_fw(nd) + p%dt(i)*fpsisr_fw(nd, &
&           i) + fpsisr(i)*p_fw%dt(nd, i)
        END DO
        fpsisr_sum = fpsisr_sum + fpsisr(i)*p%dt(i)
      END DO
      IF (0.1 .LT. fpsisr_sum) THEN
        DO nd=1,nbdirs
          p_fw%f_soilwater(nd) = fpsisr_sum_fw(nd)
        END DO
        p%f_soilwater = fpsisr_sum
      ELSE
        p%f_soilwater = 0.1
        p_fw%f_soilwater(:) = 0.0_8
      END IF
    END IF
    RETURN
  END SUBROUTINE SOIL_WATER_FACTOR_V2_FWV

  SUBROUTINE SOIL_WATER_FACTOR_V2(p)
    IMPLICIT NONE
    TYPE(SOIL) :: p
    REAL(r8) :: ft(0:max_layers-1), fpsisr(0:max_layers-1)
    REAL(r8) :: dtt(0:max_layers-1)
    REAL(r8), SAVE :: t1=-0.02
    REAL(r8), SAVE :: t2=2.0
!--iLab::changed in order to avoid "implicit save" for these variables
! real(r8):: dtt_sum = 0.,fpsisr_sum = 0.
    REAL(r8) :: dtt_sum, fpsisr_sum
    INTRINSIC MAX
    INTRINSIC EXP
    REAL(r8) :: arg1
    dtt_sum = 0._8
    fpsisr_sum = 0._8
!! change the rule for updating p%psim @MOUSONG.WU,2018.11
    DO i=0,p%n_layer-1
      p%psim(i) = p%psi_sat(i)*(p%thetam(i)/p%fei(i))**(-p%b(i))
      IF (p%psi_sat(i) .LT. 1.e-6) THEN
        p%psim(i) = 1.e-6
      ELSE
        p%psim(i) = p%psi_sat(i)
      END IF
    END DO
    DO i=0,p%n_layer-1
      IF (p%psim(i) .GT. p%psi_min) THEN
        fpsisr(i) = 1./(1.+((p%psim(i)-p%psi_min)/p%psi_min)**p%alpha)
      ELSE
        fpsisr(i) = 1.
      END IF
      IF (p%temp_soil_p(i) .GT. 0.) THEN
        arg1 = t1*p%temp_soil_p(i)**t2
        ft(i) = 1. - EXP(arg1)
      ELSE
        ft(i) = 0.
      END IF
      fpsisr(i) = fpsisr(i)*ft(i)
    END DO
    IF (fw_version .EQ. 1) THEN
      DO i=0,p%n_layer-1
!eq. 14 in Ju 2006
        dtt(i) = p%f_root(i)*fpsisr(i)
      END DO
    ELSE
      DO i=0,p%n_layer-1
        dtt(i) = p%f_root(i)
      END DO
    END IF
    DO i=0,p%n_layer-1
      dtt_sum = dtt_sum + dtt(i)
    END DO
    IF (dtt_sum .LT. 1.e-6) THEN
      p%f_soilwater = 0.1
      DO i=0,p%n_layer-1
        p%dt(i) = 0.
      END DO
    ELSE
      DO i=0,p%n_layer-1
        p%dt(i) = dtt(i)/dtt_sum
        IF (p%dt(i) .LT. 1.e-6) THEN
          p%dt(i) = 1.e-6
        ELSE
          p%dt(i) = p%dt(i)
        END IF
      END DO
!if(isnan(p%dt(i))) then
!p%dt(i) = 0.
!write(*,*) p%dt(i)
!end if
      DO i=0,p%n_layer-1
! eq. 12, in Chen 2012 GBC; eq 15 in JU
        fpsisr_sum = fpsisr_sum + fpsisr(i)*p%dt(i)
      END DO
      IF (0.1 .LT. fpsisr_sum) THEN
        p%f_soilwater = fpsisr_sum
      ELSE
        p%f_soilwater = 0.1
      END IF
    END IF
    RETURN
  END SUBROUTINE SOIL_WATER_FACTOR_V2

!  Differentiation of soil_evaporation in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: mass_snow_g evapo_soil evapo_snow_g
!                percent_snow_g mass_water_g evapo_water_g
!   with respect to varying inputs: gheat_g density_snow mass_snow_g
!                depth_water swc_g temp_g mass_water_g netrad_g
  SUBROUTINE SOIL_EVAPORATION_FWV(temp_air, temp_g, temp_g_fw, rh_air, &
&   netrad_g, netrad_g_fw, gheat_g, gheat_g_fw, percent_snow_g, &
&   percent_snow_g_fw, depth_water, depth_water_fw, depth_snow, &
&   mass_water_g, mass_water_g_fw, mass_snow_g, mass_snow_g_fw, &
&   density_snow, density_snow_fw, swc_g, swc_g_fw, porosity_g, &
&   evapo_soil, evapo_soil_fw, evapo_water_g, evapo_water_g_fw, &
&   evapo_snow_g, evapo_snow_g_fw, nbdirs)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
    REAL(r8), INTENT(IN) :: temp_air, temp_g, rh_air
    REAL(r8), DIMENSION(nbdirsmax), INTENT(IN) :: temp_g_fw
! net radiation on ground
    REAL(r8), INTENT(IN) :: netrad_g
    REAL(r8), DIMENSION(nbdirsmax), INTENT(IN) :: netrad_g_fw
! aerodynamic conductantce of heat on ground surface
    REAL(r8), INTENT(IN) :: gheat_g
    REAL(r8), DIMENSION(nbdirsmax), INTENT(IN) :: gheat_g_fw
    REAL(r8), INTENT(INOUT) :: percent_snow_g
    REAL(r8), DIMENSION(nbdirsmax), INTENT(INOUT) :: percent_snow_g_fw
! depth of water and snow on ground after rainfall/snowfall stage1 befor evap
    REAL(r8), INTENT(INOUT) :: depth_water, depth_snow
    REAL(r8), DIMENSION(nbdirsmax), INTENT(INOUT) :: depth_water_fw
! output after substacting evps
    REAL(r8), INTENT(INOUT) :: mass_water_g, mass_snow_g
    REAL(r8), DIMENSION(nbdirsmax), INTENT(INOUT) :: mass_water_g_fw, &
&   mass_snow_g_fw
    REAL(r8), INTENT(IN) :: density_snow
    REAL(r8), DIMENSION(nbdirsmax), INTENT(IN) :: density_snow_fw
! soil water content (from last step) and porosity on ground
    REAL(r8), INTENT(IN) :: swc_g, porosity_g
    REAL(r8), DIMENSION(nbdirsmax), INTENT(IN) :: swc_g_fw
    REAL(r8), INTENT(OUT) :: evapo_soil, evapo_water_g, evapo_snow_g
    REAL(r8), DIMENSION(nbdirsmax), INTENT(OUT) :: evapo_soil_fw, &
&   evapo_water_g_fw, evapo_snow_g_fw
    REAL(r8) :: density_air_g, cp_air_g, vpd_g, slope_vapor_g, psy_air_g
    REAL(r8), DIMENSION(nbdirsmax) :: cp_air_g_fw, vpd_g_fw, &
&   slope_vapor_g_fw
!conductance of water on soil surface
    REAL(r8) :: gwater_g
    REAL(r8), DIMENSION(nbdirsmax) :: gwater_g_fw
    REAL(r8) :: lantent_water, latent_snow
    REAL(r8) :: density_water
    REAL(r8) :: length_step
    INTRINSIC EXP
    INTRINSIC MAX
    INTRINSIC MIN
    REAL(r8) :: arg1
    REAL(r8), DIMENSION(nbdirsmax) :: arg1_fw
    INTEGER :: nd
    REAL(r8) :: temp
    REAL(r8) :: temp0
    REAL(r8) :: temp1
    INTEGER :: nbdirs
    CALL METEO_PACK_FWV(temp_g, temp_g_fw, rh_air, nbdirs)
    density_air_g = density_air
    DO nd=1,nbdirs
      cp_air_g_fw(nd) = cp_air_fw(nd)
      vpd_g_fw(nd) = vpd_fw(nd)
      slope_vapor_g_fw(nd) = slope_vapor_fw(nd)
    END DO
    cp_air_g = cp_air
    vpd_g = vpd
    slope_vapor_g = slope_vapor
    psy_air_g = psy
    latent_water = (2.501-0.00237*temp_air)*1e6
    latent_snow = 2.83*1e6
    density_water = rho_w
    length_step = kstep
! adjust the rs due to CO2 impacts in non-water-limited areas, according to Yang et al., 2019, Nature Climate Change
! rs = rs_300*(1+S_rs(CO2-300)), rs_300=55 s m-1, S_rs=0.09% ppm-1, Mousong.Wu@2019.04
    IF (swc_g/porosity_g .LT. 0.5) THEN
      arg1 = 8.2 - 4.2*swc_g/porosity_g
      temp = 1.0/(4.0*EXP(arg1))
      DO nd=1,nbdirs
        arg1_fw(nd) = -(4.2*swc_g_fw(nd)/porosity_g)
        gwater_g_fw(nd) = -(temp*arg1_fw(nd))
      END DO
      gwater_g = temp
    ELSE
      gwater_g = 1./(55*(1+0.09/100.0*(co2_air-300.)))
      gwater_g_fw(:) = 0.0_8
    END IF
! get the percentage of snow
    IF (depth_snow .GT. 0.02) THEN
      percent_snow_g = 1.
      percent_snow_g_fw(:) = 0.0_8
    ELSE
      temp = mass_snow_g/(0.025*density_snow)
      DO nd=1,nbdirs
        percent_snow_g_fw(nd) = (mass_snow_g_fw(nd)-temp*0.025*&
&         density_snow_fw(nd))/(0.025*density_snow)
      END DO
      percent_snow_g = temp
    END IF
    IF (percent_snow_g .LT. 0.) THEN
      percent_snow_g = 0.
      percent_snow_g_fw(:) = 0.0_8
    ELSE
      percent_snow_g = percent_snow_g
    END IF
    IF (percent_snow_g .GT. 1.) THEN
      percent_snow_g = 1.
      percent_snow_g_fw(:) = 0.0_8
    ELSE
      percent_snow_g = percent_snow_g
    END IF
! when there are pond water on ground, there is evaporation from the water
    IF (depth_water .GT. 0 .AND. depth_snow .EQ. 0) THEN
      temp = latent_water*(slope_vapor_g+psy_air_g*(gheat_g/0.01+1))
      temp0 = (0.8*slope_vapor_g*netrad_g+density_air_g*cp_air_g*vpd_g*&
&       gheat_g)/temp
      DO nd=1,nbdirs
        evapo_water_g_fw(nd) = (0.8*netrad_g*slope_vapor_g_fw(nd)+&
&         slope_vapor_g*0.8*netrad_g_fw(nd)+density_air_g*(gheat_g*(&
&         vpd_g*cp_air_g_fw(nd)+cp_air_g*vpd_g_fw(nd))+cp_air_g*vpd_g*&
&         gheat_g_fw(nd))-temp0*latent_water*(slope_vapor_g_fw(nd)+&
&         psy_air_g*gheat_g_fw(nd)/0.01))/temp
      END DO
      evapo_water_g = temp0
    ELSE
      evapo_water_g = 0
      evapo_water_g_fw(:) = 0.0_8
    END IF
    IF (0. .LT. evapo_water_g) THEN
      evapo_water_g = evapo_water_g
    ELSE
      evapo_water_g = 0.
      evapo_water_g_fw(:) = 0.0_8
    END IF
    IF (evapo_water_g .GT. 0) THEN
      IF (evapo_water_g .GT. depth_water*density_water/length_step) THEN
        DO nd=1,nbdirs
          evapo_water_g_fw(nd) = density_water*depth_water_fw(nd)/&
&           length_step
        END DO
        evapo_water_g = depth_water*density_water/length_step
      ELSE
        evapo_water_g = evapo_water_g
      END IF
    END IF
    depth_water = depth_water - evapo_water_g/density_water*length_step
    IF (0. .LT. depth_water) THEN
      depth_water = depth_water
    ELSE
      depth_water = 0.
    END IF
    DO nd=1,nbdirs
      mass_water_g_fw(nd) = mass_water_g_fw(nd) - length_step*&
&       evapo_water_g_fw(nd)
    END DO
    mass_water_g = mass_water_g - evapo_water_g*length_step
! when there are snow on ground, there s ony evaporation from the snow
    IF (depth_snow .GT. 0) THEN
      temp0 = latent_snow*(slope_vapor_g+psy_air_g*(gheat_g/0.01+1))
      temp = percent_snow_g/temp0
      temp1 = 0.8*slope_vapor_g*netrad_g + density_air_g*cp_air_g*vpd_g*&
&       gheat_g
      DO nd=1,nbdirs
        evapo_snow_g_fw(nd) = temp*(0.8*netrad_g*slope_vapor_g_fw(nd)+&
&         slope_vapor_g*0.8*netrad_g_fw(nd)+density_air_g*(gheat_g*(&
&         vpd_g*cp_air_g_fw(nd)+cp_air_g*vpd_g_fw(nd))+cp_air_g*vpd_g*&
&         gheat_g_fw(nd))) + temp1*(percent_snow_g_fw(nd)-temp*&
&         latent_snow*(slope_vapor_g_fw(nd)+psy_air_g*gheat_g_fw(nd)/&
&         0.01))/temp0
      END DO
      evapo_snow_g = temp1*temp
    ELSE
      evapo_snow_g = 0
      evapo_snow_g_fw(:) = 0.0_8
    END IF
    IF (0. .LT. evapo_snow_g) THEN
      evapo_snow_g = evapo_snow_g
    ELSE
      evapo_snow_g = 0.
      evapo_snow_g_fw(:) = 0.0_8
    END IF
    IF (evapo_snow_g .GT. 0) THEN
      IF (evapo_snow_g .GT. mass_snow_g/length_step) THEN
        DO nd=1,nbdirs
          evapo_snow_g_fw(nd) = mass_snow_g_fw(nd)/length_step
        END DO
        evapo_snow_g = mass_snow_g/length_step
      ELSE
        evapo_snow_g = evapo_snow_g
      END IF
    END IF
    DO nd=1,nbdirs
      mass_snow_g_fw(nd) = mass_snow_g_fw(nd) - length_step*&
&       evapo_snow_g_fw(nd)
    END DO
    mass_snow_g = mass_snow_g - evapo_snow_g*length_step
    IF (mass_snow_g .LT. 0.) THEN
      mass_snow_g = 0.
      mass_snow_g_fw(:) = 0.0_8
    ELSE
      mass_snow_g = mass_snow_g
    END IF
    IF (mass_snow_g .GT. 0) THEN
      depth_snow = depth_snow - evapo_snow_g/density_snow*length_step
    ELSE
      depth_snow = 0
    END IF
    IF (depth_water .GT. 0 .OR. depth_snow .GT. 0) THEN
      evapo_soil = 0
      evapo_soil_fw(:) = 0.0_8
    ELSE
      temp1 = latent_water*(slope_vapor_g+psy_air_g*(gheat_g/gwater_g+1)&
&       )
      temp0 = (-percent_snow_g+1.)/temp1
      temp = slope_vapor_g*netrad_g + density_air_g*cp_air_g*vpd_g*&
&       gheat_g
      DO nd=1,nbdirs
        evapo_soil_fw(nd) = temp0*(netrad_g*slope_vapor_g_fw(nd)+&
&         slope_vapor_g*netrad_g_fw(nd)+density_air_g*(gheat_g*(vpd_g*&
&         cp_air_g_fw(nd)+cp_air_g*vpd_g_fw(nd))+cp_air_g*vpd_g*&
&         gheat_g_fw(nd))) + temp*(-percent_snow_g_fw(nd)-temp0*&
&         latent_water*(slope_vapor_g_fw(nd)+psy_air_g*(gheat_g_fw(nd)-&
&         gheat_g*gwater_g_fw(nd)/gwater_g)/gwater_g))/temp1
      END DO
      evapo_soil = temp*temp0
      IF (0. .LT. evapo_soil) THEN
        evapo_soil = evapo_soil
      ELSE
        evapo_soil = 0.
        evapo_soil_fw(:) = 0.0_8
      END IF
    END IF
    RETURN
  END SUBROUTINE SOIL_EVAPORATION_FWV

  SUBROUTINE SOIL_EVAPORATION(temp_air, temp_g, rh_air, netrad_g, &
&   gheat_g, percent_snow_g, depth_water, depth_snow, mass_water_g, &
&   mass_snow_g, density_snow, swc_g, porosity_g, evapo_soil, &
&   evapo_water_g, evapo_snow_g)
    IMPLICIT NONE
    REAL(r8), INTENT(IN) :: temp_air, temp_g, rh_air
! net radiation on ground
    REAL(r8), INTENT(IN) :: netrad_g
! aerodynamic conductantce of heat on ground surface
    REAL(r8), INTENT(IN) :: gheat_g
    REAL(r8), INTENT(INOUT) :: percent_snow_g
! depth of water and snow on ground after rainfall/snowfall stage1 befor evap
    REAL(r8), INTENT(INOUT) :: depth_water, depth_snow
! output after substacting evps
    REAL(r8), INTENT(INOUT) :: mass_water_g, mass_snow_g
    REAL(r8), INTENT(IN) :: density_snow
! soil water content (from last step) and porosity on ground
    REAL(r8), INTENT(IN) :: swc_g, porosity_g
    REAL(r8), INTENT(OUT) :: evapo_soil, evapo_water_g, evapo_snow_g
    REAL(r8) :: density_air_g, cp_air_g, vpd_g, slope_vapor_g, psy_air_g
!conductance of water on soil surface
    REAL(r8) :: gwater_g
    REAL(r8) :: lantent_water, latent_snow
    REAL(r8) :: density_water
    REAL(r8) :: length_step
    INTRINSIC EXP
    INTRINSIC MAX
    INTRINSIC MIN
    REAL(r8) :: arg1
    CALL METEO_PACK(temp_g, rh_air)
    density_air_g = density_air
    cp_air_g = cp_air
    vpd_g = vpd
    slope_vapor_g = slope_vapor
    psy_air_g = psy
    latent_water = (2.501-0.00237*temp_air)*1e6
    latent_snow = 2.83*1e6
    density_water = rho_w
    length_step = kstep
! adjust the rs due to CO2 impacts in non-water-limited areas, according to Yang et al., 2019, Nature Climate Change
! rs = rs_300*(1+S_rs(CO2-300)), rs_300=55 s m-1, S_rs=0.09% ppm-1, Mousong.Wu@2019.04
    IF (swc_g/porosity_g .LT. 0.5) THEN
      arg1 = 8.2 - 4.2*swc_g/porosity_g
      gwater_g = 1./(4.0*EXP(arg1))
    ELSE
      gwater_g = 1./(55*(1+0.09/100.0*(co2_air-300.)))
    END IF
! get the percentage of snow
    IF (depth_snow .GT. 0.02) THEN
      percent_snow_g = 1.
    ELSE
      percent_snow_g = mass_snow_g/(0.025*density_snow)
    END IF
    IF (percent_snow_g .LT. 0.) THEN
      percent_snow_g = 0.
    ELSE
      percent_snow_g = percent_snow_g
    END IF
    IF (percent_snow_g .GT. 1.) THEN
      percent_snow_g = 1.
    ELSE
      percent_snow_g = percent_snow_g
    END IF
! when there are pond water on ground, there is evaporation from the water
    IF (depth_water .GT. 0 .AND. depth_snow .EQ. 0) THEN
      evapo_water_g = 1./latent_water*(slope_vapor_g*(netrad_g*0.8-0)+&
&       density_air_g*cp_air_g*vpd_g*gheat_g)/(slope_vapor_g+psy_air_g*(&
&       1+gheat_g/0.01))
    ELSE
      evapo_water_g = 0
    END IF
    IF (0. .LT. evapo_water_g) THEN
      evapo_water_g = evapo_water_g
    ELSE
      evapo_water_g = 0.
    END IF
    IF (evapo_water_g .GT. 0) THEN
      IF (evapo_water_g .GT. depth_water*density_water/length_step) THEN
        evapo_water_g = depth_water*density_water/length_step
      ELSE
        evapo_water_g = evapo_water_g
      END IF
    END IF
    depth_water = depth_water - evapo_water_g/density_water*length_step
    IF (0. .LT. depth_water) THEN
      depth_water = depth_water
    ELSE
      depth_water = 0.
    END IF
    mass_water_g = mass_water_g - evapo_water_g*length_step
! when there are snow on ground, there s ony evaporation from the snow
    IF (depth_snow .GT. 0) THEN
      evapo_snow_g = 1./latent_snow*(slope_vapor_g*(netrad_g*0.8-0)+&
&       density_air_g*cp_air_g*vpd_g*gheat_g)/(slope_vapor_g+psy_air_g*(&
&       1+gheat_g/0.01))*percent_snow_g
    ELSE
      evapo_snow_g = 0
    END IF
    IF (0. .LT. evapo_snow_g) THEN
      evapo_snow_g = evapo_snow_g
    ELSE
      evapo_snow_g = 0.
    END IF
    IF (evapo_snow_g .GT. 0) THEN
      IF (evapo_snow_g .GT. mass_snow_g/length_step) THEN
        evapo_snow_g = mass_snow_g/length_step
      ELSE
        evapo_snow_g = evapo_snow_g
      END IF
    END IF
    mass_snow_g = mass_snow_g - evapo_snow_g*length_step
    IF (mass_snow_g .LT. 0.) THEN
      mass_snow_g = 0.
    ELSE
      mass_snow_g = mass_snow_g
    END IF
    IF (mass_snow_g .GT. 0) THEN
      depth_snow = depth_snow - evapo_snow_g/density_snow*length_step
    ELSE
      depth_snow = 0
    END IF
    IF (depth_water .GT. 0 .OR. depth_snow .GT. 0) THEN
      evapo_soil = 0
    ELSE
      evapo_soil = (1.-percent_snow_g)*1/latent_water*(slope_vapor_g*(&
&       netrad_g-0)+density_air_g*cp_air_g*vpd_g*gheat_g)/(slope_vapor_g&
&       +psy_air_g*(1+gheat_g/gwater_g))
      IF (0. .LT. evapo_soil) THEN
        evapo_soil = evapo_soil
      ELSE
        evapo_soil = 0.
      END IF
    END IF
    RETURN
  END SUBROUTINE SOIL_EVAPORATION

END MODULE BEPS_SOILMOD_DIFFV

MODULE ECORESPMOD_DIFFV
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE BEPS_PAR
  USE MID_RESULTS_DIFFV
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
  REAL(r8), PARAMETER :: sec_per_day=86400.

CONTAINS
  SUBROUTINE PLANT_RESP(f_q10, lc, mid_res, lai_yr, lai, temp_air, &
&   temp_soil, coszs)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: lc
    TYPE(RESULTS), INTENT(INOUT) :: mid_res
    REAL(r8), INTENT(IN) :: f_q10, lai_yr
    REAL(r8), INTENT(IN) :: lai, temp_air, temp_soil, coszs
    REAL(r8), SAVE :: temp_opt25=25.0
    REAL(r8) :: biomass, biomass_leaf_o, biomass_stem_o, biomass_root_o&
&   , biomass_leaf_u, biomass_stem_u, biomass_root_u
    REAL(r8) :: respir_croot_o, respir_root_o, respir_stem_o, &
&   respir_leaf_o
    REAL(r8) :: respir_croot_u, respir_root_u, respir_stem_u, &
&   respir_leaf_u
    REAL(r8) :: q10
    REAL(r8) :: exponent1
    REAL(r8) :: lai_u, lai_max_o, lai_max_u
    REAL(r8) :: ra
    REAL(r8) :: coef_leaf_respir, coef_stem_respir, coef_root_respir, &
&   coef_fineroot_respir
    REAL(r8) :: gpp_o, gpp_u, gpp_r, rg, ratio_froot
    INTRINSIC EXP
    INTRINSIC MAX
    INTRINSIC MIN
    REAL(r8) :: arg1
    IF ((lc .EQ. 25 .OR. lc .EQ. 40) .OR. lc .EQ. 41) THEN
      lai_u = 0.01
    ELSE
      arg1 = -(0.99*lai)
      lai_u = 1.18*EXP(arg1)
    END IF
    IF (lai_u .GT. lai) lai_u = 0.01
    IF (lc .EQ. 6) THEN
      ra = 0.6
    ELSE
      ra = 1.0
    END IF
! f_q10 default value 0.046
    q10 = 3.22 - f_q10*temp_air
    IF (lc .GE. 1 .AND. lc .LE. 5) THEN
!
      biomass = 0.9097*lai_yr + 0.125*lai_yr*lai_yr
!
      biomass_leaf_o = 0.05*biomass
!
      biomass_stem_o = 0.95*biomass
      biomass_root_o = 0.454*biomass
!
!
      biomass_leaf_u = 0.3*biomass_leaf_o
!
      biomass_stem_u = 0.02*biomass_stem_o
!
      biomass_root_u = 0.05*biomass_root_o
!
      coef_leaf_respir = 0.0015/sec_per_day
!
      coef_stem_respir = 0.0020/sec_per_day
!
      coef_root_respir = 0.0020/sec_per_day
!
      coef_fineroot_respir = 0.003/sec_per_day
! 
      lai_max_o = 4.5
! 
      lai_max_u = 2.4
    ELSE IF (lc .EQ. 6 .OR. lc .EQ. 9) THEN
!!
      biomass = 1.545*lai_yr + 0.183*lai_yr*lai_yr
!
      biomass_leaf_o = 0.04*biomass
!
      biomass_stem_o = 0.96*biomass
!
      biomass_root_o = 1.432*biomass**0.639
!
      biomass_leaf_u = 0.3*biomass_leaf_o
!
      biomass_stem_u = 0.01*biomass_stem_o
!
      biomass_root_u = 0.01*biomass_root_o
!
      coef_leaf_respir = 0.015/sec_per_day
!
      coef_stem_respir = 0.0035/sec_per_day
!
      coef_root_respir = 0.0025/sec_per_day
!
      coef_fineroot_respir = 0.003/sec_per_day
!
      lai_max_o = 4.5
!
      lai_max_u = 2.4
    ELSE IF (lc .EQ. 10) THEN
      biomass = 1.227*lai_yr + 0.154*lai_yr*lai_yr
      biomass_leaf_o = 0.045*biomass
      biomass_stem_o = 0.95*biomass
      biomass_root_o = (0.454*biomass+1.432*biomass**0.639)/2.
      biomass_leaf_u = 0.3*biomass_leaf_o
      biomass_stem_u = 0.015*biomass_stem_o
      biomass_root_u = 0.03*biomass_root_o
      coef_leaf_respir = 0.008/sec_per_day
      coef_stem_respir = 0.0028/sec_per_day
      coef_root_respir = 0.0023/sec_per_day
      coef_fineroot_respir = 0.003/sec_per_day
      lai_max_o = 4.5
      lai_max_u = 2.4
    ELSE IF (lc .EQ. 13) THEN
      biomass = 1.545*lai_yr + 0.183*lai_yr*lai_yr
!
      biomass_leaf_o = 0.1*biomass
!
      biomass_stem_o = 0.90*biomass
!
      biomass_root_o = 1.432*biomass**0.639
!
      biomass_leaf_u = 0.3*biomass_leaf_o
! 
      biomass_stem_u = 0.01*biomass_stem_o
!
      biomass_root_u = 0.01*biomass_root_o
!
      coef_leaf_respir = 0.001/sec_per_day
!
      coef_stem_respir = 0.002/sec_per_day
!
      coef_root_respir = 0.0015/sec_per_day
!
      coef_fineroot_respir = 0.003/sec_per_day
! 
      lai_max_o = 3.3
!
      lai_max_u = 0.01
    ELSE IF ((((lc .EQ. 14 .OR. lc .EQ. 15) .OR. lc .EQ. 25) .OR. lc &
&       .EQ. 40) .OR. lc .EQ. 41) THEN
! 
      biomass_leaf_o = 0.05*lai_yr
!
      biomass_stem_o = 0.0
!
      biomass_root_o = 0.061*lai_yr
      biomass_leaf_u = 0.0
      biomass_stem_u = 0.0
      biomass_root_u = 0.0
      coef_leaf_respir = 0.001/sec_per_day
!
      coef_stem_respir = 0.002/sec_per_day
!
      coef_root_respir = 0.0015/sec_per_day
!
      coef_fineroot_respir = 0.003/sec_per_day
!  
      lai_max_o = 3.3
!  !
      lai_max_u = 0.01
    END IF
!! calculation for overstorey
! stem maintenance respiration
    exponent1 = (temp_air-temp_opt25)/10.0
    respir_stem_o = biomass_stem_o*0.35/(biomass_stem_o+0.35)*&
&     coef_stem_respir*q10**exponent1*ra
    IF (respir_stem_o .LT. 0.0) THEN
      respir_stem_o = 0.0
    ELSE
      respir_stem_o = respir_stem_o
    END IF
! root maintenance
    exponent1 = (temp_soil-temp_opt25)/10.0
    IF ((((lc .EQ. 14 .OR. lc .EQ. 15) .OR. lc .EQ. 25) .OR. lc .EQ. 40)&
&       .OR. lc .EQ. 41) THEN
      respir_root_o = biomass_root_o*coef_root_respir*q10**exponent1*ra
    ELSE
      ratio_froot = EXP(1.007)*biomass_root_o**(-0.841)
      IF (0.9 .GT. ratio_froot) THEN
        ratio_froot = ratio_froot
      ELSE
        ratio_froot = 0.9
      END IF
!
      respir_croot_o = 0.05*biomass_root_o*(1-ratio_froot)*&
&       coef_root_respir*q10**exponent1
! 
      respir_root_o = respir_croot_o + 0.05*biomass_root_o*ratio_froot*&
&       coef_fineroot_respir*q10**exponent1
    END IF
    IF (respir_root_o .LT. 0.0) THEN
      respir_root_o = 0.0
    ELSE
      respir_root_o = respir_root_o
    END IF
!
    IF (coszs .GT. 0.01) THEN
      respir_leaf_o = 0
    ELSE
      exponent1 = (temp_air-temp_opt25)/10.0
!kgC/m2/s
      respir_leaf_o = lai/lai_max_o*biomass_leaf_o*coef_leaf_respir*q10&
&       **exponent1*ra
    END IF
    IF (respir_leaf_o .LT. 0.0) THEN
      respir_leaf_o = 0.0
    ELSE
      respir_leaf_o = respir_leaf_o
    END IF
!   
!kgC/m2/s
    gpp_o = mid_res%gpp_o_sunlit + mid_res%gpp_o_shaded
    gpp_r = gpp_o - (respir_leaf_o+respir_stem_o+respir_root_o)
    IF (gpp_r .LE. 0) THEN
      rg = 0.
    ELSE
      rg = 0.35*gpp_r
    END IF
!mid_res%npp_o  = gpp_r - rg    !kgC/m2/s
!kgC/m2/s @J.Wang
    mid_res%npp_o = gpp_o*0.45
!! calculation for understorey
! 
    exponent1 = (temp_air-temp_opt25)/10.0
    respir_stem_u = biomass_stem_u*0.35/(biomass_stem_u+0.35)*&
&     coef_stem_respir*q10**exponent1*ra
    IF (respir_stem_u .LT. 0.0) THEN
      respir_stem_u = 0.0
    ELSE
      respir_stem_u = respir_stem_u
    END IF
!
    exponent1 = (temp_soil-temp_opt25)/10.0
    IF ((((lc .EQ. 14 .OR. lc .EQ. 15) .OR. lc .EQ. 25) .OR. lc .EQ. 40)&
&       .OR. lc .EQ. 41) THEN
      respir_root_u = biomass_root_u*coef_root_respir*q10**exponent1*ra
    ELSE
      ratio_froot = EXP(1.007)*biomass_root_u**(-0.841)
      IF (0.9 .GT. ratio_froot) THEN
        ratio_froot = ratio_froot
      ELSE
        ratio_froot = 0.9
      END IF
      respir_croot_u = 0.05*biomass_root_u*(1-ratio_froot)*&
&       coef_root_respir*q10**exponent1
      respir_root_u = respir_croot_u + 0.05*biomass_root_u*ratio_froot*&
&       coef_fineroot_respir*q10**exponent1
    END IF
    IF (respir_root_u .LT. 0.0) THEN
      respir_root_u = 0.0
    ELSE
      respir_root_u = respir_root_u
    END IF
    IF (coszs .GT. 0.01) THEN
      respir_leaf_u = 0
    ELSE
      exponent1 = (temp_air-temp_opt25)/10.0
      respir_leaf_u = lai_u/lai_max_u*biomass_leaf_u*coef_leaf_respir*&
&       q10**exponent1*ra*0.5
    END IF
    IF (respir_leaf_u .LT. 0.0) THEN
      respir_leaf_u = 0.0
    ELSE
      respir_leaf_u = respir_leaf_u
    END IF
!!
    gpp_u = mid_res%gpp_u_sunlit + mid_res%gpp_u_shaded
    gpp_r = gpp_u - (respir_leaf_u+respir_stem_u+respir_root_u)
    IF (gpp_r .LE. 0) THEN
      rg = 0
    ELSE
      rg = 0.35*gpp_r
    END IF
!mid_res%npp_u = gpp_r - rg  !kgC/m2/s
!kgC/m2/s
    mid_res%npp_u = gpp_u*0.45
    mid_res%npp = mid_res%npp_u + mid_res%npp_o
  END SUBROUTINE PLANT_RESP

  SUBROUTINE SOIL_RESP(ccd, cssd, csmd, cfsd, cfmd, csm, cm, cs, cp, &
&   npp_yr, coef, soiltype, soilp, mid_res)
    USE BEPS_SOILMOD_DIFFV
    USE BEPS_PAR
    IMPLICIT NONE
    REAL(r8), INTENT(INOUT) :: ccd(0:4), cssd(0:4), csmd(0:4), cfsd(0:4)&
&   , cfmd(0:4), csm(0:4), cm(0:4), cs(0:4), cp(0:4)
    REAL(r8), INTENT(IN) :: npp_yr
    REAL(r8), INTENT(IN) :: coef(0:49)
    INTEGER, INTENT(IN) :: soiltype
    TYPE(SOIL), INTENT(IN) :: soilp
    TYPE(RESULTS), INTENT(INOUT) :: mid_res
    REAL(r8) :: fw, fcr, fl, ffr, kw_cd, kcr_cd, kl_sl, kfr_fl, km_p, &
&   ks_p
    REAL(r8) :: kssd_a, kssd_sm, kssd_s, ksmd_a, ksmd_sm, kfsd_a, kfsd_m&
&   , kfsd_s, kfmd_a, kfmd_m
    REAL(r8) :: kcd_a, kcd_m
    REAL(r8) :: kcd_s, ksm_a, ksm_s, km_a, km_s, ks_a, ks_m, kp_a, kp_m
    REAL(r8) :: cw(0:9), ccr(0:9), cl(0:9), cfr(0:9), dcw(0:9), dccr(0:9&
&   ), dcl(0:9), dcfr(0:9)
    REAL(r8) :: dccd(0:9), dcssd(0:9), dcsmd(0:9), dcfsd(0:9), dcfmd(0:9&
&   ), dcsm(0:9), dcm(0:9), dcs(0:9), dcp(0:9)
    REAL(r8) :: part1, part2
    REAL(r8) :: fm(0:9), npp
    REAL(r8) :: lambda(0:layer), lambda_t(0:layer), lambda_w(0:layer)
    REAL(r8) :: lam_u, lam_d
    INTEGER :: ii
    INTRINSIC EXP
    INTRINSIC MIN
    INTRINSIC MAX
    REAL(r8) :: arg1
    DO ii=1,layer
      IF (308.56*(1/(35.0+46.032)-1/(46.032+soilp%temp_soil_c(ii-1))) &
&         .LT. -2.3) THEN
!! to get rid of enormous value @MOUSONG.WU
        lambda_t(ii) = 0.1
      ELSE IF (308.56*(1/(35.0+46.032)-1/(46.032+soilp%temp_soil_c(ii-1)&
&         )) .GT. 0.) THEN
        lambda_t(ii) = 1.
      ELSE
! Arrenius Equation
        arg1 = 308.56*(1/(35.0+46.032)-1/(46.032+soilp%temp_soil_c(ii-1)&
&         ))
        lambda_t(ii) = EXP(arg1)
      END IF
      IF (1.0 .GT. lambda_t(ii)) THEN
        lambda_t(ii) = lambda_t(ii)
      ELSE
        lambda_t(ii) = 1.0
      END IF
      IF (0.3 .LT. lambda_t(ii)) THEN
        lambda_t(ii) = lambda_t(ii)
      ELSE
        lambda_t(ii) = 0.3
      END IF
    END DO
    DO ii=1,layer
      IF (soiltype .GE. 6) THEN
        lambda_w(ii) = 5.44*soilp%thetam(ii-1)/soilp%fei(ii-1) - 5.03*(&
&         soilp%thetam(ii-1)/soilp%fei(ii-1))**2 - 0.472
      ELSE
        lambda_w(ii) = 5.63*soilp%thetam(ii-1)/soilp%fei(ii-1) - 4.64*(&
&         soilp%thetam(ii-1)/soilp%fei(ii-1))**2 - 0.710
      END IF
      IF (0.3 .LT. lambda_w(ii)) THEN
        lambda_w(ii) = lambda_w(ii)
      ELSE
        lambda_w(ii) = 0.3
      END IF
    END DO
    DO ii=1,layer
      lambda(ii) = lambda_t(ii)*lambda_w(ii)
    END DO
! for surface pool
    lam_u = lambda(1)
! for soil pool
    lam_d = lambda(2)
    fw = coef(0)
    fcr = coef(1)
    fl = coef(2)
    ffr = coef(3)
! units?? @J.Wang
    kw_cd = coef(4)/8760
    kcr_cd = coef(5)/8760
    kl_sl = coef(6)/8760
    kfr_fl = coef(7)/8760
    kssd_a = coef(8)/8760
    kssd_sm = coef(9)/8760
    kssd_s = coef(10)/8760
    ksmd_a = coef(11)/8760
    ksmd_sm = coef(12)/8760
    kfsd_a = coef(13)/8760
    kfsd_m = coef(14)/8760
    kfsd_s = coef(15)/8760
    kfmd_a = coef(16)/8760
    kfmd_m = coef(17)/8760
    kcd_a = coef(18)/8760
    kcd_m = coef(19)/8760
    kcd_s = coef(20)/8760
    km_a = coef(21)/8760
    km_p = coef(22)/8760
    km_s = coef(23)/8760
    ksm_a = coef(24)/8760
    ksm_s = coef(25)/8760
    ks_a = coef(26)/8760
    ks_p = coef(27)/8760
    ks_m = coef(28)/8760
    kp_a = coef(29)/8760
    kp_m = coef(30)/8760
!for stem gC.m2
    cw(0) = coef(0)/coef(4)*npp_yr
! for coast root
    ccr(0) = coef(1)/coef(5)*npp_yr
! for leaf
    cl(0) = coef(2)/coef(6)*npp_yr
! for fine root
    cfr(0) = coef(3)/coef(7)*npp_yr
    fm(1) = 0.2
!kg/m2/s
    npp = mid_res%npp_o + mid_res%npp_u
!gC/m2/step return to original units @J.Wang
    npp = npp*1000*step
    dcw(1) = fw*npp - kw_cd*cw(0)
    dccr(1) = fcr*npp - kcr_cd*ccr(0)
    dcl(1) = fl*npp - kl_sl*cl(0)
    dcfr(1) = ffr*npp - kfr_fl*cfr(0)
    cw(1) = cw(0) + dcw(1)
    ccr(1) = ccr(0) + dccr(1)
    cl(1) = cl(0) + dcl(1)
    cfr(1) = cfr(0) + dcfr(1)
    part1 = (kw_cd*cw(1)+kcr_cd*ccr(1))/(1+lam_d*(kcd_a+kcd_m+kcd_s))
    part2 = ccd(0)*lam_d*(kcd_a+kcd_m+kcd_s)
    dccd(1) = part1 - part2
    ccd(1) = ccd(0) + dccd(1)
!Coarse detrius from woody and coarse root
    part1 = (1-fm(1))*kl_sl*cl(1)/(1+lam_u*(kssd_a+kssd_sm+kssd_s))
    part2 = cssd(0)*lam_u*(kssd_a+kssd_sm+kssd_s)
    dcssd(1) = part1 - part2
    cssd(1) = cssd(0) + dcssd(1)
!surface structural litter
    part1 = fm(1)*kl_sl*cl(1)/(1+lam_u*(ksmd_a+ksmd_sm))
    part2 = csmd(0)*lam_u*(ksmd_a+ksmd_sm)
    dcsmd(1) = part1 - part2
    csmd(1) = csmd(0) - dcsmd(1)
!surface metobolic litter
    part1 = (1-fm(1))*kfr_fl*cfr(1)/(1+lam_d*(kfsd_a+kfsd_m+kfsd_s))
    part2 = cfsd(0)*lam_d*(kfsd_a+kfsd_m+kfsd_s)
    dcfsd(1) = part1 - part2
    cfsd(1) = cfsd(0) + dcfsd(1)
!for soil strutural litter pool
    part1 = fm(1)*kfr_fl*cfr(1)/(1+lam_d*(kfmd_a+kfmd_m))
    part2 = lam_d*(kfmd_a+kfmd_m)*cfmd(0)
    dcfmd(1) = part1 - part2
    cfmd(1) = cfmd(0) + dcfmd(1)
! soil metobolic pool
    part1 = lam_u*(cssd(1)*kssd_sm+csmd(1)*ksmd_sm)
    part2 = lam_u*csm(0)*(ksm_a+ksm_s)
    dcsm(1) = part1 - part2
    csm(1) = csm(0) + dcsm(1)
! surface microbe pool
    part1 = lam_d*(kfsd_m*cfsd(1)+kfmd_m*cfmd(1)+ccd(1)*kcd_m) + lam_d*(&
&     cs(0)*ks_m+cp(0)*kp_m)
    part2 = cm(0)*lam_d*(km_a+km_s+km_p)
    dcm(1) = part1 - part2
    cm(1) = cm(0) + dcm(1)
!soil microbe pool
    part1 = lam_d*(cm(1)*km_s+ccd(1)*kcd_s+cfsd(1)*kfsd_s) + lam_u*(csm(&
&     1)*ksm_s+cssd(1)*kssd_s)
    part2 = cs(0)*lam_d*(ks_a+ks_p+ks_m)
    dcs(1) = part1 - part2
    cs(1) = cs(0) + dcs(1)
!for slow carbon pool
    dcp(1) = lam_d*(km_p*cm(1)+ks_p*cs(1)) - lam_d*(kp_m*cp(0)+kp_a*cp(0&
&     ))
    cp(1) = cp(0) + dcp(1)
! passive carbon pool
!NEP
    mid_res%nep = npp + (dcsmd(1)+dcssd(1)+dcfsd(1)+dcfmd(1)+dccd(1)+dcm&
&     (1)+dcsm(1)+dcs(1)+dcp(1))
!kgC/m2/s
    mid_res%nep = mid_res%nep*1e-3/step
    mid_res%npp = npp*1e-3/step
    RETURN
  END SUBROUTINE SOIL_RESP

END MODULE ECORESPMOD_DIFFV

MODULE OUTPUTMOD_DIFFV
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE BEPSTYPE_DIFFV
  USE CONTROLINPUT_MOD_DIFFV, ONLY : beps_out_dir, beps_rst_dir, nhtfrq,&
& nstpd, nscale, nlat, nlon, check
!--iLab::avoid beps_time_manager, all temporal information now passed as actual arguments
! use beps_time_manager
  USE BEPS_PAR
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
!! Here add variables for output by USERS
  REAL(r8), ALLOCATABLE :: nep9(:)
  REAL(r8), ALLOCATABLE :: gpp9(:)
  REAL(r8), ALLOCATABLE :: sif9(:)
  REAL(r8), ALLOCATABLE :: sif9_sat(:)
  REAL(r8), ALLOCATABLE :: npp9(:)
  REAL(r8), ALLOCATABLE :: gpppft9(:, :)
  REAL(r8), ALLOCATABLE :: sifpft9(:, :)
  REAL(r8), ALLOCATABLE :: lhpft9(:, :)
  REAL(r8), ALLOCATABLE :: shpft9(:, :)
  REAL(r8), ALLOCATABLE :: transpft9(:, :)
  REAL(r8), ALLOCATABLE :: evappft9(:, :)
  REAL(r8), ALLOCATABLE :: thetampft9(:, :)
  REAL(r8), ALLOCATABLE :: sifpft9_sat(:, :)
  REAL(r8), ALLOCATABLE :: faparpft9(:, :)
  REAL(r8), ALLOCATABLE :: vodpft9(:, :)
  REAL(r8), ALLOCATABLE :: cos_fluxpft9(:, :)
  REAL(r8), ALLOCATABLE :: temp9(:)
  REAL(r8), ALLOCATABLE :: wind9(:)
  REAL(r8), ALLOCATABLE :: rh9(:)
  REAL(r8), ALLOCATABLE :: rain9(:)
  REAL(r8), ALLOCATABLE :: snow9(:)
  REAL(r8), ALLOCATABLE :: swdr9(:)
  REAL(r8), ALLOCATABLE :: swdf9(:)
  REAL(r8), ALLOCATABLE :: lai9(:)
  REAL(r8), ALLOCATABLE :: lh9(:)
  REAL(r8), ALLOCATABLE :: sh9(:)
  REAL(r8), ALLOCATABLE :: trans9(:)
  REAL(r8), ALLOCATABLE :: evap9(:)
  REAL(r8), ALLOCATABLE :: thetam9(:)
  REAL(r8), ALLOCATABLE :: fapar9(:)
  REAL(r8), ALLOCATABLE :: vod9(:)
  REAL(r8), ALLOCATABLE :: cos_flux9(:)
! for counting the simulation steps for monthly output
  INTEGER, SAVE :: nst=0

CONTAINS
  SUBROUTINE INIT_OUTPUT()
    IMPLICIT NONE
    ALLOCATE(nep9(npoints))
    ALLOCATE(gpp9(npoints))
    ALLOCATE(npp9(npoints))
    ALLOCATE(gpppft9(npoints, pft))
    ALLOCATE(sifpft9(npoints, pft))
    ALLOCATE(lhpft9(npoints, pft))
    ALLOCATE(shpft9(npoints, pft))
    ALLOCATE(transpft9(npoints, pft))
    ALLOCATE(evappft9(npoints, pft))
    ALLOCATE(thetampft9(npoints, pft))
    ALLOCATE(sifpft9_sat(npoints, pft))
    ALLOCATE(sif9(npoints))
    ALLOCATE(sif9_sat(npoints))
    ALLOCATE(faparpft9(npoints, pft))
    ALLOCATE(vodpft9(npoints, pft))
    ALLOCATE(cos_fluxpft9(npoints, pft))
    ALLOCATE(temp9(npoints))
    ALLOCATE(wind9(npoints))
    ALLOCATE(rh9(npoints))
    ALLOCATE(rain9(npoints))
    ALLOCATE(snow9(npoints))
    ALLOCATE(swdr9(npoints))
    ALLOCATE(swdf9(npoints))
    ALLOCATE(lai9(npoints))
    ALLOCATE(lh9(npoints))
    ALLOCATE(sh9(npoints))
    ALLOCATE(trans9(npoints))
    ALLOCATE(evap9(npoints))
    ALLOCATE(thetam9(npoints))
    ALLOCATE(fapar9(npoints))
    ALLOCATE(vod9(npoints))
    ALLOCATE(cos_flux9(npoints))
    nep9(:) = 0.0
    gpp9(:) = 0.
    npp9(:) = 0.
    sif9(:) = 0.
    sif9_sat(:) = 0.
    gpppft9(:, :) = 0.
    sifpft9(:, :) = 0.
    lhpft9(:, :) = 0.
    shpft9(:, :) = 0.
    transpft9(:, :) = 0.
    evappft9(:, :) = 0.
    thetampft9(:, :) = 0.
    sifpft9_sat(:, :) = 0.
    faparpft9(:, :) = 0.
    vodpft9(:, :) = 0.
    cos_fluxpft9(:, :) = 0.
    temp9(:) = 0.
    wind9(:) = 0.
    rh9(:) = 0.
    rain9(:) = 0.
    snow9(:) = 0.
    swdr9(:) = 0.
    swdf9(:) = 0.
    lai9(:) = 0.
    lh9(:) = 0.
    sh9(:) = 0.
    trans9(:) = 0.
    evap9(:) = 0.
    thetam9(:) = 0.
    fapar9(:) = 0.
    vod9(:) = 0.
    cos_flux9(:) = 0.
  END SUBROUTINE INIT_OUTPUT

!! average variables according to user's definition
  SUBROUTINE AV_OUTPUT(yr, mon, day, tod, kount, is_end_curr_month, &
&   ref_date, secs_since_ref)
    IMPLICIT NONE
!deallocate(NEP9)
!deallocate(GPP9)
!deallocate(NPP9)
!deallocate(GPPpft9)
!deallocate(SIFpft9)
!deallocate(Thetampft9)
!deallocate(SIFpft9_sat)
!deallocate(SIF9)
!deallocate(SIF9_sat)
!deallocate(temp9)
!deallocate(Wind9)
!deallocate(Rh9)
!deallocate(Rain9)
!deallocate(Snow9)
!deallocate(Swdr9)
!deallocate(Swdf9)
!deallocate(lai9)
!deallocate(Thetam9)
!-- iLab::turned yr,mon,day,tod to arguments and added the further arguments
    INTEGER, INTENT(IN) :: yr, mon, day, tod
    INTEGER, INTENT(IN) :: kount
    LOGICAL, INTENT(IN) :: is_end_curr_month
    CHARACTER(len=*), INTENT(IN) :: ref_date
    REAL(r8), INTENT(IN) :: secs_since_ref
    INTEGER :: ii, iii
    TYPE(RES), POINTER :: pp
    TYPE(FORC), POINTER :: ff
    TYPE(SURF), POINTER :: ss
    INTRINSIC MOD
    pp => output
    ff => clim
    ss => bound
!! accumulate
    nep9 = nep9 + pp%nep
    gpp9 = gpp9 + pp%gpp
    sif9 = sif9 + pp%sif
    sif9_sat = sif9_sat + pp%sif_sat
    npp9 = npp9 + pp%npp
    gpppft9 = gpppft9 + pp%gpppft
    sifpft9 = sifpft9 + pp%sifpft
    lhpft9 = lhpft9 + pp%lhpft
    shpft9 = shpft9 + pp%shpft
    transpft9 = transpft9 + pp%transpft
    evappft9 = evappft9 + pp%evappft
    thetampft9 = thetampft9 + pp%thetampft
    sifpft9_sat = sifpft9_sat + pp%sifpft_sat
    faparpft9 = faparpft9 + pp%faparpft
    vodpft9 = vodpft9 + pp%vodpft
    cos_fluxpft9 = cos_fluxpft9 + pp%cos_fluxpft
    temp9 = temp9 + ff%temp
    wind9 = wind9 + ff%wind
    rh9 = rh9 + ff%rh
    rain9 = rain9 + ff%rain
    snow9 = snow9 + ff%snow
    swdr9 = swdr9 + ff%swdr
    swdf9 = swdf9 + ff%swdf
    lai9 = lai9 + pp%lai
    lh9 = lh9 + pp%lh
    sh9 = sh9 + pp%sh
    trans9 = trans9 + pp%trans
    evap9 = evap9 + pp%evap
    thetam9 = thetam9 + pp%thetam
    fapar9 = fapar9 + pp%fapar
    vod9 = vod9 + pp%vod
    cos_flux9 = cos_flux9 + pp%cos_flux
!! currently I did not include the satellite SIF when nhtfrq < 0 @J.Wang
    IF (nhtfrq .LT. 0) THEN
! kount  = get_nstep()
      IF (MOD(kount, nstpd) .EQ. 0) THEN
!! average
        nep9 = nep9/nstpd
        gpp9 = gpp9/nstpd
        sif9 = sif9/nstpd
        npp9 = npp9/nstpd
        gpppft9 = gpppft9/nstpd
        sifpft9 = sifpft9/nstpd
        lhpft9 = lhpft9/nstpd
        shpft9 = shpft9/nstpd
        transpft9 = transpft9/nstpd
        evappft9 = evappft9/nstpd
        thetampft9 = thetampft9/nstpd
        faparpft9 = faparpft9/nstpd
        vodpft9 = vodpft9/nstpd
        cos_fluxpft9 = cos_fluxpft9/nstpd
        IF (nhtfrq .EQ. -24) THEN
          sif9_sat = sif9_sat
          sifpft9_sat = sifpft9_sat
        ELSE
          sif9_sat = 0.
          sifpft9_sat = 0.
        END IF
        temp9 = temp9/nstpd
        wind9 = wind9/nstpd
        rh9 = rh9/nstpd
        rain9 = rain9/nstpd
        snow9 = snow9/nstpd
        swdr9 = swdr9/nstpd
        swdf9 = swdf9/nstpd
        lai9 = lai9/nstpd
        lh9 = lh9/nstpd
        sh9 = sh9/nstpd
        trans9 = trans9/nstpd
        evap9 = evap9/nstpd
        thetam9 = thetam9/nstpd
        fapar9 = fapar9/nstpd
        vod9 = vod9/nstpd
        cos_flux9 = cos_flux9/nstpd
        IF (nscale .EQ. 0) THEN
          CALL WRITE_OUTPUT_GLOBAL(yr, mon, day, tod)
        ELSE
          CALL WRITE_OUTPUT_SITE(yr, mon, day, tod, ref_date, &
&                          secs_since_ref)
        END IF
        nep9 = 0.
        gpp9 = 0.
        sif9 = 0.
        npp9 = 0.
        sif9_sat = 0.
        gpppft9 = 0.
        sifpft9 = 0.
        lhpft9 = 0.
        shpft9 = 0.
        transpft9 = 0.
        evappft9 = 0.
        thetampft9 = 0.
        sifpft9_sat = 0.
        faparpft9 = 0.
        vodpft9 = 0.
        cos_fluxpft9 = 0.
        temp9 = 0.
        wind9 = 0.
        rh9 = 0.
        rain9 = 0.
        snow9 = 0.
        swdr9 = 0.
        swdf9 = 0.
        lai9 = 0.
        lh9 = 0.
        sh9 = 0.
        trans9 = 0.
        evap9 = 0.
        thetam9 = 0.
        fapar9 = 0.
        vod9 = 0.
        cos_flux9 = 0.
      END IF
    ELSE IF (nhtfrq .EQ. 0) THEN
!!monthly output
      nst = nst + 1
      IF (is_end_curr_month) THEN
!! average
        nep9 = nep9/nst
        gpp9 = gpp9/nst
        sif9 = sif9/nst
        npp9 = npp9/nst
!kg/m2/s
        gpppft9 = gpppft9/nst
        sifpft9 = sifpft9/nst
        lhpft9 = lhpft9/nst
        shpft9 = shpft9/nst
        transpft9 = transpft9/nst
        evappft9 = evappft9/nst
        thetampft9 = thetampft9/nst
        faparpft9 = faparpft9/nst
        vodpft9 = vodpft9/nst
        cos_fluxpft9 = cos_fluxpft9/nst
        temp9 = temp9/nst
        wind9 = wind9/nst
        rh9 = rh9/nst
        rain9 = rain9/nst
        snow9 = snow9/nst
        swdr9 = swdr9/nst
        swdf9 = swdf9/nst
        lai9 = lai9/nst
        lh9 = lh9/nst
        sh9 = sh9/nst
        trans9 = trans9/nst
        evap9 = evap9/nst
        thetam9 = thetam9/nst
        fapar9 = fapar9/nst
        vod9 = vod9/nst
        cos_flux9 = cos_flux9/nst
!--iLab::yr,mon,day,tod now provided as arguments
! call get_prev_date(yr, mon, day, tod)
!!              write(*,*) "write out data on ",yr,mon,day
        sifpft9_sat = sifpft9_sat/day
        sif9_sat = sif9_sat/day
        IF (nscale .EQ. 0) THEN
          CALL WRITE_OUTPUT_GLOBAL(yr, mon, day, tod)
        ELSE
          CALL WRITE_OUTPUT_SITE(yr, mon, day, tod, ref_date, &
&                          secs_since_ref)
        END IF
        nep9 = 0.
        gpp9 = 0.
        sif9 = 0.
        sif9_sat = 0.
        npp9 = 0.
        gpppft9 = 0.
        sifpft9 = 0.
        lhpft9 = 0.
        shpft9 = 0.
        transpft9 = 0.
        evappft9 = 0.
        thetampft9 = 0.
        sifpft9_sat = 0.
        faparpft9 = 0.
        vodpft9 = 0.
        cos_fluxpft9 = 0.
        temp9 = 0.
        wind9 = 0.
        rh9 = 0.
        rain9 = 0.
        snow9 = 0.
        swdr9 = 0.
        swdf9 = 0.
        lai9 = 0.
        lh9 = 0.
        sh9 = 0.
        trans9 = 0.
        evap9 = 0.
        thetam9 = 0.
        fapar9 = 0.
        vod9 = 0.
        cos_flux9 = 0.
        nst = 0
      END IF
    END IF
  END SUBROUTINE AV_OUTPUT

  SUBROUTINE WRITE_OUTPUT_GLOBAL(yy, mm, dd, tod)
    USE NETCDF
    IMPLICIT NONE
!end if
!call mpi_barrier(mpi_comm_world,ierr)
!--iLab::yy,mm,dd,tod turned to arguments
    INTEGER, INTENT(IN) :: yy, mm, dd, tod
    REAL(r8), DIMENSION(nlp) :: nep1, gpp1, sif1, sif_sat1, npp1, temp1&
&   , wind1, rh1, rain1, snow1, swdr1, swdf1, lai1, lh1, sh1, trans1, &
&   evap1, thetam1, fapar1, vod1, cos_flux1
    REAL(r8), DIMENSION(nlon*nlat) :: nep2, gpp2, sif2, sif_sat2, npp2, &
&   temp2, wind2, rh2, rain2, snow2, swdr2, swdf2, lai2, lh2, sh2, &
&   trans2, evap2, thetam2, fapar2, vod2, cos_flux2
    REAL(r8), DIMENSION(nlon, nlat) :: nep3, gpp3, sif3, sif_sat3, npp3&
&   , temp3, wind3, rh3, rain3, snow3, swdr3, swdf3, lai3, lh3, sh3, &
&   trans3, evap3, thetam3, fapar3, vod3, cos_flux3
    REAL(r8), DIMENSION(nlp, pft) :: gpppft1, lhpft1, shpft1, transpft1&
&   , evappft1, thetampft1, faparpft1, vodpft1, cos_fluxpft1
    REAL(r8), DIMENSION(nlon*nlat, pft) :: gpppft2, lhpft2, shpft2, &
&   transpft2, evappft2, thetampft2, faparpft2, vodpft2, cos_fluxpft2
    REAL(r8), DIMENSION(nlon, nlat, pft) :: gpppft3, lhpft3, shpft3, &
&   transpft3, evappft3, thetampft3, faparpft3, vodpft3, cos_fluxpft3
    REAL(r8) :: lon(nlon), lat(nlat)
    INTEGER :: ierr
    INTEGER :: ncid, dimid_lon, dimid_lat, dimid_time, dimid_pft, varid
    CHARACTER(len=8) :: datestr
    CHARACTER(len=255) :: fln1, fln2, name, unit
    INTEGER :: nt, status
    INTEGER :: i
    INTRINSIC RESHAPE
    INTRINSIC TRIM
    INTEGER :: result1
!call mpi_barrier(mpi_comm_world,ierr)
!call mpi_gatherv(NEP9(1),npoints,mpi_real8,NEP1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(GPP9(1),npoints,mpi_real8,GPP1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(SIF9(1),npoints,mpi_real8,SIF1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(SIF9_sat(1),npoints,mpi_real8,SIF_sat1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(NPP9(1),npoints,mpi_real8,NPP1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(fAPAR9(1),npoints,mpi_real8,fAPAR1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(VOD9(1),npoints,mpi_real8,VOD1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(COS_flux9(1),npoints,mpi_real8,COS_flux1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(temp9(1),npoints,mpi_real8,temp1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(Wind9(1),npoints,mpi_real8,Wind1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(Rh9(1),npoints,mpi_real8,Rh1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(Rain9(1),npoints,mpi_real8,Rain1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(Snow9(1),npoints,mpi_real8,Snow1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(Swdr9(1),npoints,mpi_real8,Swdr1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(Swdf9(1),npoints,mpi_real8,Swdf1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(lai9(1),npoints,mpi_real8,lai1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(LH9(1),npoints,mpi_real8,LH1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(SH9(1),npoints,mpi_real8,SH1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(Trans9(1),npoints,mpi_real8,Trans1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(Evap9(1),npoints,mpi_real8,Evap1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(Thetam9(1),npoints,mpi_real8,Thetam1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!do i = 1,PFT
!   call mpi_gatherv(GPPpft9(1,i),npoints,mpi_real8,GPPpft1(1,i),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!   call mpi_gatherv(Evappft9(1,i),npoints,mpi_real8,Evappft1(1,i),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!   call mpi_gatherv(Thetampft9(1,i),npoints,mpi_real8,Thetampft1(1,i),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!   call mpi_gatherv(fAPARpft9(1,i),npoints,mpi_real8,fAPARpft1(1,i),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!   call mpi_gatherv(VODpft9(1,i),npoints,mpi_real8,VODpft1(1,i),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!   call mpi_gatherv(COS_fluxpft9(1,i),npoints,mpi_real8,COS_fluxpft1(1,i),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!end do
!call mpi_barrier(mpi_comm_world,ierr)
    nep1 = nep9
    gpp1 = gpp9
    sif1 = sif9
    sif_sat1 = sif9_sat
    npp1 = npp9
    fapar1 = fapar9
    vod1 = vod9
    cos_flux1 = cos_flux9
    temp1 = temp9
    wind1 = wind9
    rh1 = rh9
    rain1 = rain9
    snow1 = snow9
    swdr1 = swdr9
    swdf1 = swdf9
    lai1 = lai9
    lh1 = lh9
    sh1 = sh9
    trans1 = trans9
    evap1 = evap9
    thetam1 = thetam9
    gpppft1 = gpppft9
    evappft1 = evappft9
    thetampft1 = thetampft9
    faparpft1 = faparpft9
    vodpft1 = vodpft9
    cos_fluxpft1 = cos_fluxpft9
!if(myid ==0) then
    nep2 = 0.
    gpp2 = 0.
    npp2 = 0.
    gpppft2 = 0.
    lhpft2 = 0.
    shpft2 = 0.
    transpft2 = 0.
    evappft2 = 0.
    thetampft2 = 0.
    faparpft2 = 0.
    vodpft2 = 0.
    cos_fluxpft2 = 0.
    temp2 = 0.
    wind2 = 0.
    rh2 = 0.
    rain2 = 0.
    snow2 = 0.
    swdr2 = 0.
    swdf2 = 0.
    lai2 = 0.
    lh2 = 0.
    sh2 = 0.
    trans2 = 0.
    evap2 = 0.
    thetam2 = 0.
    sif2 = 0.
    sif_sat2 = 0.
    fapar2 = 0.
    vod2 = 0.
    cos_flux2 = 0.
    sif2(mapping) = sif1
    sif_sat2(mapping) = sif_sat1
    nep2(mapping) = nep1
    gpp2(mapping) = gpp1
    npp2(mapping) = npp1
    gpppft2(mapping, :) = gpppft1
    lhpft2(mapping, :) = lhpft1
    shpft2(mapping, :) = shpft1
    transpft2(mapping, :) = transpft1
    evappft2(mapping, :) = evappft1
    thetampft2(mapping, :) = thetampft1
    faparpft2(mapping, :) = faparpft1
    vodpft2(mapping, :) = vodpft1
    cos_fluxpft2(mapping, :) = cos_fluxpft1
    temp2(mapping) = temp1
    wind2(mapping) = wind1
    rh2(mapping) = rh1
    rain2(mapping) = rain1
    snow2(mapping) = snow1
    swdr2(mapping) = swdr1
    swdf2(mapping) = swdf1
    lai2(mapping) = lai1
    lh2(mapping) = lh1
    sh2(mapping) = sh1
    trans2(mapping) = trans1
    evap2(mapping) = evap1
    thetam2(mapping) = thetam1
    fapar2(mapping) = fapar1
    vod2(mapping) = vod1
    cos_flux2(mapping) = cos_flux1
    nep3 = RESHAPE(nep2, (/nlon, nlat/))
    gpp3 = RESHAPE(gpp2, (/nlon, nlat/))
    npp3 = RESHAPE(npp2, (/nlon, nlat/))
    sif3 = RESHAPE(sif2, (/nlon, nlat/))
    sif_sat3 = RESHAPE(sif_sat2, (/nlon, nlat/))
    gpppft3 = RESHAPE(gpppft2, (/nlon, nlat, pft/))
    lhpft3 = RESHAPE(lhpft2, (/nlon, nlat, pft/))
    shpft3 = RESHAPE(shpft2, (/nlon, nlat, pft/))
    transpft3 = RESHAPE(transpft2, (/nlon, nlat, pft/))
    evappft3 = RESHAPE(evappft2, (/nlon, nlat, pft/))
    thetampft3 = RESHAPE(thetampft2, (/nlon, nlat, pft/))
    faparpft3 = RESHAPE(faparpft2, (/nlon, nlat, pft/))
    vodpft3 = RESHAPE(vodpft2, (/nlon, nlat, pft/))
    cos_fluxpft3 = RESHAPE(cos_fluxpft2, (/nlon, nlat, pft/))
    temp3 = RESHAPE(temp2, (/nlon, nlat/))
    wind3 = RESHAPE(wind2, (/nlon, nlat/))
    rh3 = RESHAPE(rh2, (/nlon, nlat/))
    rain3 = RESHAPE(rain2, (/nlon, nlat/))
    snow3 = RESHAPE(snow2, (/nlon, nlat/))
    swdr3 = RESHAPE(swdr2, (/nlon, nlat/))
    swdf3 = RESHAPE(swdf2, (/nlon, nlat/))
    lai3 = RESHAPE(lai2, (/nlon, nlat/))
    lh3 = RESHAPE(lh2, (/nlon, nlat/))
    sh3 = RESHAPE(sh2, (/nlon, nlat/))
    trans3 = RESHAPE(trans2, (/nlon, nlat/))
    evap3 = RESHAPE(evap2, (/nlon, nlat/))
    thetam3 = RESHAPE(thetam2, (/nlon, nlat/))
    fapar3 = RESHAPE(fapar2, (/nlon, nlat/))
    vod3 = RESHAPE(vod2, (/nlon, nlat/))
    cos_flux3 = RESHAPE(cos_flux2, (/nlon, nlat/))
!--iLab::yy,mm,dd,tod are arguments now
! call get_prev_date(yy,mm,dd,tod)
    IF (nhtfrq .LT. 0) THEN
      WRITE(datestr, '(i8)') yy*10000 + mm*100 + dd
      nt = (tod/3600+1)/(-nhtfrq)
    ELSE IF (nhtfrq .EQ. 0) THEN
      WRITE(datestr, '(i6)') yy*100 + mm
      nt = 1
    END IF
    WRITE(*, *) 'Writing out simulation file now!'
    fln1 = TRIM(beps_out_dir)//'beps_global_'//TRIM(datestr)//'.nc'
    status = NF90_OPEN(fln1, nf90_write, ncid)
    IF (status .NE. nf90_noerr) THEN
      result1 = NF90_CREATE(fln1, nf90_share, ncid)
      CALL CHECK(result1)
      result1 = NF90_DEF_DIM(ncid, 'lon', nlon, dimid_lon)
      CALL CHECK(result1)
      result1 = NF90_DEF_DIM(ncid, 'lat', nlat, dimid_lat)
      CALL CHECK(result1)
      result1 = NF90_DEF_DIM(ncid, 'PFT', pft, dimid_pft)
      CALL CHECK(result1)
      result1 = NF90_DEF_DIM(ncid, 'time', nf90_unlimited, dimid_time)
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'time', nf90_double, (/dimid_time/), &
&       varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'calendar', 'Gregorian')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'lon', nf90_double, (/dimid_lon/), &
&       varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'degree_east')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'long_name', 'longitude')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'axis', 'X')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'lat', nf90_double, (/dimid_lat/), &
&       varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'degree_north')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'long_name', 'latitude')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'axis', 'Y')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'NEP', nf90_double, (/dimid_lon, &
&       dimid_lat, dimid_time/), varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'kg/m2/s')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', &
&       'Net Ecosystem Productivity')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'GPP', nf90_double, (/dimid_lon, &
&       dimid_lat, dimid_time/), varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'kg/m2/s')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', &
&       'Gross Primary Productivity')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'VOD', nf90_double, (/dimid_lon, &
&       dimid_lat, dimid_time/), varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', '-')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', &
&       'Vegetation Optical Depth')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'fAPAR', nf90_double, (/dimid_lon, &
&       dimid_lat, dimid_time/), varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', '-')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', &
&       'Fraction of Absorbed Photosynthetically Active Radiation')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'COS_flux', nf90_double, (/dimid_lon&
&       , dimid_lat, dimid_time/), varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'pmol/m2/s')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', &
&       'COS flux for soil and plant')
      CALL CHECK(result1)
!   call check(nf90_def_var(ncid,"SIF_sat",nf90_double,(/dimid_lon,dimid_lat,dimid_time/),varid))
!   call check(nf90_put_att(ncid,varid,"units","mW/m2/nm/sr"))
!   call check(nf90_put_att(ncid,varid,"name","solar-induced SIF over the OCO2 pass-time"))
      result1 = NF90_DEF_VAR(ncid, 'SIF', nf90_double, (/dimid_lon, &
&       dimid_lat, dimid_time/), varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'mW/m2/nm/sr')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', 'solar-induced SIF')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'GPPpft', nf90_double, (/dimid_lon, &
&       dimid_lat, dimid_pft, dimid_time/), varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'kg/m2/s')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', &
&       'Gross Primary Productivity')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, nf90_global, 'model', 'Beps runs')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, nf90_global, 'institution', &
&       'Nanjing University')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'Thetam', nf90_double, (/dimid_lon, &
&       dimid_lat, dimid_time/), varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'm3/m3')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', &
&       'Surface soil moisture')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'LH', nf90_double, (/dimid_lon, &
&       dimid_lat, dimid_time/), varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'W/m2')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', 'Latent heat flux')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'SH', nf90_double, (/dimid_lon, &
&       dimid_lat, dimid_time/), varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'W/m2')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', 'Sensible heat flux')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'Trans', nf90_double, (/dimid_lon, &
&       dimid_lat, dimid_time/), varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'm/s')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', 'Transpiration')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'Evap', nf90_double, (/dimid_lon, &
&       dimid_lat, dimid_time/), varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'm/s')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', 'Evaporation')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'Evappft', nf90_double, (/dimid_lon, &
&       dimid_lat, dimid_pft, dimid_time/), varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'm/s')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', 'Evaporation')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'Thetampft', nf90_double, (/dimid_lon&
&       , dimid_lat, dimid_pft, dimid_time/), varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'm3/m3')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', &
&       'Surface soil moisture')
      CALL CHECK(result1)
      result1 = NF90_ENDDEF(ncid)
      CALL CHECK(result1)
    END IF
!! For temporary output  , Should be improved later @J.Wang
    DO i=1,nlat
      lat(i) = -89.5 + i - 1
    END DO
    result1 = NF90_INQ_VARID(ncid, 'lat', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, lat)
    CALL CHECK(result1)
    DO i=1,nlon
      lon(i) = 0.5 + i - 1.
    END DO
    result1 = NF90_INQ_VARID(ncid, 'lon', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, lon)
    CALL CHECK(result1)
!    call check(nf90_inq_varid(ncid,"time",varid))
!    call check(nf90_put_var(ncid,varid,nt,start=(/nt/),count=(/1/)))
    result1 = NF90_INQ_VARID(ncid, 'NEP', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, nep3, start=(/1, 1, nt/), count=&
&     (/nlon, nlat, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'GPP', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, gpp3, start=(/1, 1, nt/), count=&
&     (/nlon, nlat, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'VOD', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, vod3, start=(/1, 1, nt/), count=&
&     (/nlon, nlat, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'fAPAR', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, fapar3, start=(/1, 1, nt/), &
&     count=(/nlon, nlat, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'COS_flux', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, cos_flux3, start=(/1, 1, nt/), &
&     count=(/nlon, nlat, 1/))
    CALL CHECK(result1)
!    call check(nf90_inq_varid(ncid,"SIF_sat",varid))
!    call check(nf90_put_var(ncid,varid,SIF_sat3,start=(/1,1,nt/),count=(/nlon,nlat,1/)))
    result1 = NF90_INQ_VARID(ncid, 'SIF', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, sif3, start=(/1, 1, nt/), count=&
&     (/nlon, nlat, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'GPPpft', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, gpppft3, start=(/1, 1, 1, nt/), &
&     count=(/nlon, nlat, pft, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'Thetam', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, thetam3, start=(/1, 1, nt/), &
&     count=(/nlon, nlat, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'LH', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, lh3, start=(/1, 1, nt/), count=&
&     (/nlon, nlat, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'SH', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, sh3, start=(/1, 1, nt/), count=&
&     (/nlon, nlat, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'Trans', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, trans3, start=(/1, 1, nt/), &
&     count=(/nlon, nlat, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'Evap', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, evap3, start=(/1, 1, nt/), count&
&     =(/nlon, nlat, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'Thetampft', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, thetampft3, start=(/1, 1, 1, nt&
&     /), count=(/nlon, nlat, pft, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'Evappft', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, evappft3, start=(/1, 1, 1, nt/)&
&     , count=(/nlon, nlat, pft, 1/))
    CALL CHECK(result1)
    result1 = NF90_CLOSE(ncid)
    CALL CHECK(result1)
  END SUBROUTINE WRITE_OUTPUT_GLOBAL

  SUBROUTINE WRITE_OUTPUT_SITE(yy, mm, dd, tod, ref_date, secs_since_ref&
& )
    USE NETCDF
    IMPLICIT NONE
!end if
!call mpi_barrier(mpi_comm_world,ierr)
!--iLab::yy,mm,dd,tod turned into arguments
    INTEGER, INTENT(IN) :: yy, mm, dd, tod
    CHARACTER(len=*), INTENT(IN) :: ref_date
    REAL(r8), INTENT(IN) :: secs_since_ref
    CHARACTER(len=*), PARAMETER :: sub='write_output_site'
    REAL(r8), DIMENSION(nlp) :: nep1, gpp1, sif1, sif_sat1, npp1, temp1&
&   , wind1, rh1, rain1, snow1, swdr1, swdf1, lai1, lh1, sh1, trans1, &
&   evap1, thetam1, fapar1, vod1, cos_flux1
    REAL(r8), DIMENSION(nlp, pft) :: gpppft1, lhpft1, shpft1, transpft1&
&   , evappft1, thetampft1, faparpft1, vodpft1, cos_fluxpft1
    INTEGER :: ierr
    INTEGER :: ncid, dimid_site, dimid_time, dimid_pft, varid
    INTEGER :: nsite(nlp)
    CHARACTER(len=8) :: datestr
    CHARACTER(len=255) :: fln1, fln2, name, unit
    INTEGER :: nt, status
    INTEGER :: i
!-- iLab::reduce amount of terminal output (to be reactivated on purpose)
    LOGICAL, SAVE :: ldebug=.false.
!-- iLab::added for consistent initialisation of NetCDF variables
    REAL(r8), PARAMETER :: fill_value=-99999._r8
    INTRINSIC TRIM
    INTEGER :: result1
!call mpi_barrier(mpi_comm_world,ierr)
!call mpi_gatherv(NEP9(1),npoints,mpi_real8,NEP1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(GPP9(1),npoints,mpi_real8,GPP1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(SIF9(1),npoints,mpi_real8,SIF1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(SIF9_sat(1),npoints,mpi_real8,SIF_sat1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(NPP9(1),npoints,mpi_real8,NPP1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(fAPAR9(1),npoints,mpi_real8,fAPAR1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(VOD9(1),npoints,mpi_real8,VOD1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(COS_flux9(1),npoints,mpi_real8,COS_flux1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(temp9(1),npoints,mpi_real8,temp1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(Wind9(1),npoints,mpi_real8,Wind1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(Rh9(1),npoints,mpi_real8,Rh1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(Rain9(1),npoints,mpi_real8,Rain1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(Snow9(1),npoints,mpi_real8,Snow1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(Swdr9(1),npoints,mpi_real8,Swdr1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(Swdf9(1),npoints,mpi_real8,Swdf1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(lai9(1),npoints,mpi_real8,lai1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(LH9(1),npoints,mpi_real8,LH1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(SH9(1),npoints,mpi_real8,SH1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(Trans9(1),npoints,mpi_real8,Trans1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(Evap9(1),npoints,mpi_real8,Evap1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(Thetam9(1),npoints,mpi_real8,Thetam1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!do i = 1,PFT
!   call mpi_gatherv(GPPpft9(1,i),npoints,mpi_real8,GPPpft1(1,i),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!   call mpi_gatherv(Evappft9(1,i),npoints,mpi_real8,Evappft1(1,i),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!   call mpi_gatherv(Thetampft9(1,i),npoints,mpi_real8,Thetampft1(1,i),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!   call mpi_gatherv(fAPARpft9(1,i),npoints,mpi_real8,fAPARpft1(1,i),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!   call mpi_gatherv(VODpft9(1,i),npoints,mpi_real8,VODpft1(1,i),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!   call mpi_gatherv(COS_fluxpft9(1,i),npoints,mpi_real8,COS_fluxpft1(1,i),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!end do
!call mpi_barrier(mpi_comm_world,ierr)
    nep1 = nep9
    gpp1 = gpp9
    sif1 = sif9
    sif_sat1 = sif9_sat
    npp1 = npp9
    fapar1 = fapar9
    vod1 = vod9
    cos_flux1 = cos_flux9
    temp1 = temp9
    wind1 = wind9
    rh1 = rh9
    rain1 = rain9
    snow1 = snow9
    swdr1 = swdr9
    swdf1 = swdf9
    lai1 = lai9
    lh1 = lh9
    sh1 = sh9
    trans1 = trans9
    evap1 = evap9
    thetam1 = thetam9
    gpppft1 = gpppft9
    evappft1 = evappft9
    thetampft1 = thetampft9
    faparpft1 = faparpft9
    vodpft1 = vodpft9
    cos_fluxpft1 = cos_fluxpft9
!if(myid ==0) then
!--iLab::yy,mm,dd,tod are arguments now
! call get_prev_date(yy,mm,dd,tod)
    IF (nhtfrq .LT. 0) THEN
      WRITE(datestr, '(i8)') yy*10000 + mm*100 + dd
      nt = (tod/3600+1)/(-nhtfrq)
! !-- iLab::seconds elapsed since reference time (added for time-variable output)
! call timemgr_diff_secs(yy_ref*10000+mm_ref*100+dd_ref, tod_ref, yy*10000+mm*100+dd, tod,&
!      secs_since_ref(1))
    ELSE IF (nhtfrq .EQ. 0) THEN
      WRITE(datestr, '(i6)') yy*100 + mm
      nt = 1
    END IF
!-- iLab::make logging output depend on flag
    IF (ldebug) WRITE(*, *) 'Writing out simulation file now!'
    fln1 = TRIM(beps_out_dir)//'beps_site_'//TRIM(datestr)//'.nc'
    status = NF90_OPEN(fln1, nf90_write, ncid)
    IF (status .NE. nf90_noerr) THEN
      result1 = NF90_CREATE(fln1, nf90_share, ncid)
      CALL CHECK(result1)
      result1 = NF90_DEF_DIM(ncid, 'nsite', nlp, dimid_site)
      CALL CHECK(result1)
      result1 = NF90_DEF_DIM(ncid, 'PFT', pft, dimid_pft)
      CALL CHECK(result1)
      result1 = NF90_DEF_DIM(ncid, 'time', nf90_unlimited, dimid_time)
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'time', nf90_double, (/dimid_time/), &
&       varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'long_name', 'time')
      CALL CHECK(result1)
!-- iLab::added for proper time-variable (hourly output only)
      IF (nhtfrq .LT. 0) THEN
        result1 = NF90_PUT_ATT(ncid, varid, 'units', 'seconds since '//&
&         ref_date)
        CALL CHECK(result1)
      END IF
      result1 = NF90_PUT_ATT(ncid, varid, 'calendar', 'Gregorian')
      CALL CHECK(result1)
!-- iLab::added NetCDF output initialisation with prescribed _FillValue
!         *UPDATE*: disabled for now, since maybe not compatible on
!                   platform which Mousong is using.
      result1 = NF90_DEF_VAR(ncid, 'nsite', nf90_double, (/dimid_site/)&
&       , varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', '-')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'long_name', 'site_number')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'axis', 'X')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'NEP', nf90_double, (/dimid_site, &
&       dimid_time/), varid)
      CALL CHECK(result1)
! call check(nf90_def_var_fill(ncid, varid,  NF90_FILL, fill_value))
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'kg/m2/s')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'missing_value', fill_value)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', &
&       'Net Ecosystem Productivity')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'GPP', nf90_double, (/dimid_site, &
&       dimid_time/), varid)
      CALL CHECK(result1)
! call check(nf90_def_var_fill(ncid, varid,  NF90_FILL, fill_value))
      result1 = NF90_PUT_ATT(ncid, varid, 'missing_value', fill_value)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'kg/m2/s')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', &
&       'Gross Primary Productivity')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'VOD', nf90_double, (/dimid_site, &
&       dimid_time/), varid)
      CALL CHECK(result1)
! call check(nf90_def_var_fill(ncid, varid,  NF90_FILL, fill_value))
      result1 = NF90_PUT_ATT(ncid, varid, 'missing_value', fill_value)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', '-')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', &
&       'Vegetation Optical Depth')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'fAPAR', nf90_double, (/dimid_site, &
&       dimid_time/), varid)
      CALL CHECK(result1)
! call check(nf90_def_var_fill(ncid, varid,  NF90_FILL, fill_value))
      result1 = NF90_PUT_ATT(ncid, varid, 'missing_value', fill_value)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', '-')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', &
&       'Fraction of Absorbed Photosynthetically Active Radiation')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'COS_flux', nf90_double, (/dimid_site&
&       , dimid_time/), varid)
      CALL CHECK(result1)
! call check(nf90_def_var_fill(ncid, varid,  NF90_FILL, fill_value))
      result1 = NF90_PUT_ATT(ncid, varid, 'missing_value', fill_value)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'pmol/m2/s')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', &
&       'COS flux for soil and plant')
      CALL CHECK(result1)
!   call check(nf90_def_var(ncid,"SIF_sat",nf90_double,(/dimid_site,dimid_time/),varid))
!   call check(nf90_put_att(ncid,varid,"units","mW/m2/nm/sr"))
!   call check(nf90_put_att(ncid,varid,"name","solar-induced SIF over the OCO2 pass-time"))
      result1 = NF90_DEF_VAR(ncid, 'SIF', nf90_double, (/dimid_site, &
&       dimid_time/), varid)
      CALL CHECK(result1)
! call check(nf90_def_var_fill(ncid, varid,  NF90_FILL, fill_value))
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'mW/m2/nm/sr')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'missing_value', fill_value)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', 'solar-induced SIF')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'GPPpft', nf90_double, (/dimid_site, &
&       dimid_pft, dimid_time/), varid)
      CALL CHECK(result1)
! call check(nf90_def_var_fill(ncid, varid,  NF90_FILL, fill_value))
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'kg/m2/s')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'missing_value', fill_value)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', &
&       'Gross Primary Productivity')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, nf90_global, 'model', 'Beps runs')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, nf90_global, 'institution', &
&       'Nanjing University')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'Thetam', nf90_double, (/dimid_site, &
&       dimid_time/), varid)
      CALL CHECK(result1)
! call check(nf90_def_var_fill(ncid, varid,  NF90_FILL, fill_value))
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'm3/m3')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'missing_value', fill_value)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', &
&       'Surface soil moisture')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'LH', nf90_double, (/dimid_site, &
&       dimid_time/), varid)
      CALL CHECK(result1)
! call check(nf90_def_var_fill(ncid, varid,  NF90_FILL, fill_value))
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'W/m2')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'missing_value', fill_value)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', 'Latent heat flux')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'SH', nf90_double, (/dimid_site, &
&       dimid_time/), varid)
      CALL CHECK(result1)
! call check(nf90_def_var_fill(ncid, varid,  NF90_FILL, fill_value))
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'W/m2')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'missing_value', fill_value)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', 'Sensible heat flux')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'Trans', nf90_double, (/dimid_site, &
&       dimid_time/), varid)
      CALL CHECK(result1)
! call check(nf90_def_var_fill(ncid, varid,  NF90_FILL, fill_value))
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'm/s')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'missing_value', fill_value)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', 'Transpiration')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'Evap', nf90_double, (/dimid_site, &
&       dimid_time/), varid)
      CALL CHECK(result1)
! call check(nf90_def_var_fill(ncid, varid,  NF90_FILL, fill_value))
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'm/s')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'missing_value', fill_value)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', 'Evaporation')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'Evappft', nf90_double, (/dimid_site&
&       , dimid_pft, dimid_time/), varid)
      CALL CHECK(result1)
! call check(nf90_def_var_fill(ncid, varid,  NF90_FILL, fill_value))
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'm/s')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'missing_value', fill_value)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', 'Evaporation')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'Thetampft', nf90_double, (/&
&       dimid_site, dimid_pft, dimid_time/), varid)
      CALL CHECK(result1)
! call check(nf90_def_var_fill(ncid, varid,  NF90_FILL, fill_value))
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'm3/m3')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'missing_value', fill_value)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', &
&       'Surface soil moisture')
      CALL CHECK(result1)
      result1 = NF90_ENDDEF(ncid)
      CALL CHECK(result1)
    END IF
!! For temporary output  , Should be improved later @J.Wang
    DO i=1,nlp
      nsite(i) = i
    END DO
    result1 = NF90_INQ_VARID(ncid, 'nsite', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, nsite)
    CALL CHECK(result1)
!-- iLab::added writing of time-values (hourly output only)
    IF (nhtfrq .LT. 0) THEN
      result1 = NF90_INQ_VARID(ncid, 'time', varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_VAR(ncid, varid, (/secs_since_ref/), start=(/nt&
&       /), count=(/1/))
      CALL CHECK(result1)
    END IF
!    call check(nf90_inq_varid(ncid,"time",varid))
!    call check(nf90_put_var(ncid,varid,nt,start=(/nt/),count=(/1/)))
    result1 = NF90_INQ_VARID(ncid, 'NEP', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, nep1, start=(/1, nt/), count=(/&
&     nlp, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'GPP', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, gpp1, start=(/1, nt/), count=(/&
&     nlp, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'VOD', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, vod1, start=(/1, nt/), count=(/&
&     nlp, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'fAPAR', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, fapar1, start=(/1, nt/), count=&
&     (/nlp, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'COS_flux', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, cos_flux1, start=(/1, nt/), &
&     count=(/nlp, 1/))
    CALL CHECK(result1)
!    call check(nf90_inq_varid(ncid,"SIF_sat",varid))
!    call check(nf90_put_var(ncid,varid,SIF_sat1,start=(/1,nt/),count=(/nlp,1/)))
    result1 = NF90_INQ_VARID(ncid, 'SIF', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, sif1, start=(/1, nt/), count=(/&
&     nlp, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'GPPpft', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, gpppft1, start=(/1, 1, nt/), &
&     count=(/nlp, pft, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'Thetam', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, thetam1, start=(/1, nt/), count=&
&     (/nlp, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'LH', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, lh1, start=(/1, nt/), count=(/&
&     nlp, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'SH', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, sh1, start=(/1, nt/), count=(/&
&     nlp, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'Trans', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, trans1, start=(/1, nt/), count=&
&     (/nlp, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'Evap', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, evap1, start=(/1, nt/), count=(/&
&     nlp, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'Thetampft', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, thetampft1, start=(/1, 1, nt/), &
&     count=(/nlp, pft, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'Evappft', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, evappft1, start=(/1, 1, nt/), &
&     count=(/nlp, pft, 1/))
    CALL CHECK(result1)
    result1 = NF90_CLOSE(ncid)
    CALL CHECK(result1)
  END SUBROUTINE WRITE_OUTPUT_SITE

END MODULE OUTPUTMOD_DIFFV

MODULE RAINSNOWMOD_DIFFV
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE BEPS_CON, ONLY : cp_ice, latent_fusion, density_water => rho_w
  USE BEPS_PAR
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
  PUBLIC :: rainfall_stage1, rainfall_stage2, snowpack_stage1, &
& snowpack_stage2, snowpack_stage3
  PUBLIC :: rainfall_stage1_fwv, rainfall_stage2_fwv, &
& snowpack_stage1_fwv, snowpack_stage2_fwv, snowpack_stage3_fwv

CONTAINS
!  Differentiation of rainfall_stage1 in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: precipitation_g percent_water_o
!                percent_water_u mass_water_o mass_water_u
!   with respect to varying inputs: lai_o mass_water_o_last lai_u
!                mass_water_u_last
!!rainfall_stage1 happens before evporation of intercepted water from canopy (supply)
!!rainfall_stage2 happens after evaporation of intercepted water from canopy (demand)
!*output:
!percentage of canopy covered by rainfall,overstorey and understorey (provided to evaporation_canopy)
!mass of water available for evaporation on canopy in this step
!precipitation on ground
!optical output:intercepted mass of rainfall in this step
!*input:
!air temperature
!precipitation (m/s)
!remain of water on leaves from last step(kg/m2) per leaf area
!lead area index of overstorey and understorey,excluding stem
!length of this step(s),if 10min,then it is set as 600
!air temperature and humidity
!*
  SUBROUTINE RAINFALL_STAGE1_FWV(temp_air, precipitation, &
&   mass_water_o_last, mass_water_o_last_fw, mass_water_u_last, &
&   mass_water_u_last_fw, lai_o, lai_o_fw, lai_u, lai_u_fw, clumping, &
&   mass_water_o, mass_water_o_fw, mass_water_u, mass_water_u_fw, &
&   percent_water_o, percent_water_o_fw, percent_water_u, &
&   percent_water_u_fw, precipitation_g, precipitation_g_fw, nbdirs)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
!(oC,m/s)  precipitation=liquidwater @J.Wang
    REAL(r8), INTENT(IN) :: temp_air, precipitation
!remins of water from last step
    REAL(r8), INTENT(IN) :: mass_water_o_last, mass_water_u_last
    REAL(r8), DIMENSION(nbdirsmax), INTENT(IN) :: mass_water_o_last_fw, &
&   mass_water_u_last_fw
    REAL(r8), INTENT(IN) :: lai_o, lai_u, clumping
    REAL(r8), DIMENSION(nbdirsmax), INTENT(IN) :: lai_o_fw, lai_u_fw
!mass of water on leaves kg/m2 per ground area
    REAL(r8), INTENT(OUT) :: mass_water_o, mass_water_u
    REAL(r8), DIMENSION(nbdirsmax), INTENT(OUT) :: mass_water_o_fw, &
&   mass_water_u_fw
    REAL(r8), INTENT(OUT) :: percent_water_o, percent_water_u
    REAL(r8), DIMENSION(nbdirsmax), INTENT(OUT) :: percent_water_o_fw, &
&   percent_water_u_fw
    REAL(r8), INTENT(OUT) :: precipitation_g
    REAL(r8), DIMENSION(nbdirsmax), INTENT(OUT) :: precipitation_g_fw
    REAL(r8) :: precipitation_o, precipitation_u
    REAL(r8), DIMENSION(nbdirsmax) :: precipitation_u_fw
!Maximum mass of water could be intercepted per leaf area(kg/m2)
    REAL(r8) :: massmax_water_o, massmax_water_u
    REAL(r8), DIMENSION(nbdirsmax) :: massmax_water_o_fw, &
&   massmax_water_u_fw
! mass of water intercepted in this step per leaf area
    REAL(r8) :: massstep_water_o, massstep_water_u
    REAL(r8), DIMENSION(nbdirsmax) :: massstep_water_o_fw, &
&   massstep_water_u_fw
    REAL(r8) :: length_step
    INTRINSIC EXP
    INTRINSIC MAX
    INTRINSIC MIN
    REAL(r8) :: arg1
    REAL(r8), DIMENSION(nbdirsmax) :: arg1_fw
    INTEGER :: nd
    REAL(r8) :: temp
    INTEGER :: nbdirs
    length_step = kstep
    precipitation_g = 0.
!! overstorey
    precipitation_o = precipitation
    arg1 = -(lai_o*clumping)
    temp = precipitation_o*length_step*density_water
    DO nd=1,nbdirs
      arg1_fw(nd) = -(clumping*lai_o_fw(nd))
      mass_water_o_fw(nd) = mass_water_o_last_fw(nd) - temp*EXP(arg1)*&
&       arg1_fw(nd)
      massmax_water_o_fw(nd) = 0.1*lai_o_fw(nd)
    END DO
    mass_water_o = mass_water_o_last + temp*(1-EXP(arg1))
    massmax_water_o = 0.1*lai_o
    IF (0. .LT. mass_water_o) THEN
      mass_water_o = mass_water_o
    ELSE
      mass_water_o = 0.
      mass_water_o_fw(:) = 0.0_8
    END IF
    IF (massmax_water_o .GT. mass_water_o) THEN
      mass_water_o = mass_water_o
    ELSE
      DO nd=1,nbdirs
        mass_water_o_fw(nd) = massmax_water_o_fw(nd)
      END DO
      mass_water_o = massmax_water_o
    END IF
    DO nd=1,nbdirs
      massstep_water_o_fw(nd) = mass_water_o_fw(nd) - &
&       mass_water_o_last_fw(nd)
    END DO
    massstep_water_o = mass_water_o - mass_water_o_last
    IF (0. .LT. massstep_water_o) THEN
      massstep_water_o = massstep_water_o
    ELSE
      massstep_water_o = 0.
      massstep_water_o_fw(:) = 0.0_8
    END IF
    IF (1. .GT. mass_water_o/massmax_water_o) THEN
      DO nd=1,nbdirs
        percent_water_o_fw(nd) = (mass_water_o_fw(nd)-mass_water_o*&
&         massmax_water_o_fw(nd)/massmax_water_o)/massmax_water_o
      END DO
      percent_water_o = mass_water_o/massmax_water_o
    ELSE
      percent_water_o = 1.
      percent_water_o_fw(:) = 0.0_8
    END IF
    precipitation_u = precipitation_o - massstep_water_o/density_water/&
&     length_step
    arg1 = -(lai_u*clumping)
    temp = -EXP(arg1) + 1
    DO nd=1,nbdirs
!! understorey
      precipitation_u_fw(nd) = -(massstep_water_o_fw(nd)/(density_water*&
&       length_step))
      arg1_fw(nd) = -(clumping*lai_u_fw(nd))
      mass_water_u_fw(nd) = mass_water_u_last_fw(nd) + length_step*&
&       density_water*(temp*precipitation_u_fw(nd)-precipitation_u*EXP(&
&       arg1)*arg1_fw(nd))
      massmax_water_u_fw(nd) = 0.1*lai_u_fw(nd)
    END DO
    mass_water_u = mass_water_u_last + length_step*density_water*(&
&     precipitation_u*temp)
    massmax_water_u = 0.1*lai_u
    IF (0. .LT. mass_water_u) THEN
      mass_water_u = mass_water_u
    ELSE
      mass_water_u = 0.
      mass_water_u_fw(:) = 0.0_8
    END IF
    IF (mass_water_u .GT. massmax_water_u) THEN
      DO nd=1,nbdirs
        mass_water_u_fw(nd) = massmax_water_u_fw(nd)
      END DO
      mass_water_u = massmax_water_u
    ELSE
      mass_water_u = mass_water_u
    END IF
    DO nd=1,nbdirs
      massstep_water_u_fw(nd) = mass_water_u_fw(nd) - &
&       mass_water_u_last_fw(nd)
    END DO
    massstep_water_u = mass_water_u - mass_water_u_last
    IF (massstep_water_u .LT. 0.) THEN
      massstep_water_u = 0.
      massstep_water_u_fw(:) = 0.0_8
    ELSE
      massstep_water_u = massstep_water_u
    END IF
    IF (1. .GT. mass_water_u/massmax_water_u) THEN
      DO nd=1,nbdirs
        percent_water_u_fw(nd) = (mass_water_u_fw(nd)-mass_water_u*&
&         massmax_water_u_fw(nd)/massmax_water_u)/massmax_water_u
      END DO
      percent_water_u = mass_water_u/massmax_water_u
    ELSE
      percent_water_u = 1.
      percent_water_u_fw(:) = 0.0_8
    END IF
!! ground
    DO nd=1,nbdirs
      precipitation_g_fw(nd) = precipitation_u_fw(nd) - &
&       massstep_water_u_fw(nd)/(density_water*length_step)
    END DO
    precipitation_g = precipitation_u - massstep_water_u/density_water/&
&     length_step
    RETURN
  END SUBROUTINE RAINFALL_STAGE1_FWV

!!rainfall_stage1 happens before evporation of intercepted water from canopy (supply)
!!rainfall_stage2 happens after evaporation of intercepted water from canopy (demand)
!*output:
!percentage of canopy covered by rainfall,overstorey and understorey (provided to evaporation_canopy)
!mass of water available for evaporation on canopy in this step
!precipitation on ground
!optical output:intercepted mass of rainfall in this step
!*input:
!air temperature
!precipitation (m/s)
!remain of water on leaves from last step(kg/m2) per leaf area
!lead area index of overstorey and understorey,excluding stem
!length of this step(s),if 10min,then it is set as 600
!air temperature and humidity
!*
  SUBROUTINE RAINFALL_STAGE1(temp_air, precipitation, mass_water_o_last&
&   , mass_water_u_last, lai_o, lai_u, clumping, mass_water_o, &
&   mass_water_u, percent_water_o, percent_water_u, precipitation_g)
    IMPLICIT NONE
!(oC,m/s)  precipitation=liquidwater @J.Wang
    REAL(r8), INTENT(IN) :: temp_air, precipitation
!remins of water from last step
    REAL(r8), INTENT(IN) :: mass_water_o_last, mass_water_u_last
    REAL(r8), INTENT(IN) :: lai_o, lai_u, clumping
!mass of water on leaves kg/m2 per ground area
    REAL(r8), INTENT(OUT) :: mass_water_o, mass_water_u
    REAL(r8), INTENT(OUT) :: percent_water_o, percent_water_u
    REAL(r8), INTENT(OUT) :: precipitation_g
    REAL(r8) :: precipitation_o, precipitation_u
!Maximum mass of water could be intercepted per leaf area(kg/m2)
    REAL(r8) :: massmax_water_o, massmax_water_u
! mass of water intercepted in this step per leaf area
    REAL(r8) :: massstep_water_o, massstep_water_u
    REAL(r8) :: length_step
    INTRINSIC EXP
    INTRINSIC MAX
    INTRINSIC MIN
    REAL(r8) :: arg1
    length_step = kstep
    precipitation_g = 0.
!! overstorey
    precipitation_o = precipitation
    arg1 = -(lai_o*clumping)
    mass_water_o = mass_water_o_last + precipitation_o*length_step*&
&     density_water*(1-EXP(arg1))
    massmax_water_o = 0.1*lai_o
    IF (0. .LT. mass_water_o) THEN
      mass_water_o = mass_water_o
    ELSE
      mass_water_o = 0.
    END IF
    IF (massmax_water_o .GT. mass_water_o) THEN
      mass_water_o = mass_water_o
    ELSE
      mass_water_o = massmax_water_o
    END IF
    massstep_water_o = mass_water_o - mass_water_o_last
    IF (0. .LT. massstep_water_o) THEN
      massstep_water_o = massstep_water_o
    ELSE
      massstep_water_o = 0.
    END IF
    IF (1. .GT. mass_water_o/massmax_water_o) THEN
      percent_water_o = mass_water_o/massmax_water_o
    ELSE
      percent_water_o = 1.
    END IF
!! understorey
    precipitation_u = precipitation_o - massstep_water_o/density_water/&
&     length_step
    arg1 = -(lai_u*clumping)
    mass_water_u = mass_water_u_last + precipitation_u*length_step*&
&     density_water*(1-EXP(arg1))
    massmax_water_u = 0.1*lai_u
    IF (0. .LT. mass_water_u) THEN
      mass_water_u = mass_water_u
    ELSE
      mass_water_u = 0.
    END IF
    IF (mass_water_u .GT. massmax_water_u) THEN
      mass_water_u = massmax_water_u
    ELSE
      mass_water_u = mass_water_u
    END IF
    massstep_water_u = mass_water_u - mass_water_u_last
    IF (massstep_water_u .LT. 0.) THEN
      massstep_water_u = 0.
    ELSE
      massstep_water_u = massstep_water_u
    END IF
    IF (1. .GT. mass_water_u/massmax_water_u) THEN
      percent_water_u = mass_water_u/massmax_water_u
    ELSE
      percent_water_u = 1.
    END IF
!! ground
    precipitation_g = precipitation_u - massstep_water_u/density_water/&
&     length_step
    RETURN
  END SUBROUTINE RAINFALL_STAGE1

!  Differentiation of rainfall_stage2 in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: mass_water_o mass_water_u
!   with respect to varying inputs: mass_water_o mass_water_u evapo_water_o
!                evapo_water_u
!!this module will calculate the water remained on canopy surface after evaporation in this step
  SUBROUTINE RAINFALL_STAGE2_FWV(evapo_water_o, evapo_water_o_fw, &
&   evapo_water_u, evapo_water_u_fw, mass_water_o, mass_water_o_fw, &
&   mass_water_u, mass_water_u_fw, nbdirs)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
    REAL(r8), INTENT(IN) :: evapo_water_o, evapo_water_u
    REAL(r8), DIMENSION(nbdirsmax), INTENT(IN) :: evapo_water_o_fw, &
&   evapo_water_u_fw
    REAL(r8), INTENT(INOUT) :: mass_water_o, mass_water_u
    REAL(r8), DIMENSION(nbdirsmax), INTENT(INOUT) :: mass_water_o_fw, &
&   mass_water_u_fw
    INTRINSIC MAX
    INTEGER :: nd
    INTEGER :: nbdirs
    DO nd=1,nbdirs
      mass_water_o_fw(nd) = mass_water_o_fw(nd) - kstep*evapo_water_o_fw&
&       (nd)
    END DO
    mass_water_o = mass_water_o - evapo_water_o*kstep
    IF (0. .LT. mass_water_o) THEN
      mass_water_o = mass_water_o
    ELSE
      mass_water_o = 0.
      mass_water_o_fw(:) = 0.0_8
    END IF
    DO nd=1,nbdirs
      mass_water_u_fw(nd) = mass_water_u_fw(nd) - kstep*evapo_water_u_fw&
&       (nd)
    END DO
    mass_water_u = mass_water_u - evapo_water_u*kstep
    IF (0. .LT. mass_water_u) THEN
      mass_water_u = mass_water_u
    ELSE
      mass_water_u = 0.
      mass_water_u_fw(:) = 0.0_8
    END IF
    RETURN
  END SUBROUTINE RAINFALL_STAGE2_FWV

!!this module will calculate the water remained on canopy surface after evaporation in this step
  SUBROUTINE RAINFALL_STAGE2(evapo_water_o, evapo_water_u, mass_water_o&
&   , mass_water_u)
    IMPLICIT NONE
    REAL(r8), INTENT(IN) :: evapo_water_o, evapo_water_u
    REAL(r8), INTENT(INOUT) :: mass_water_o, mass_water_u
    INTRINSIC MAX
    mass_water_o = mass_water_o - evapo_water_o*kstep
    IF (0. .LT. mass_water_o) THEN
      mass_water_o = mass_water_o
    ELSE
      mass_water_o = 0.
    END IF
    mass_water_u = mass_water_u - evapo_water_u*kstep
    IF (0. .LT. mass_water_u) THEN
      mass_water_u = mass_water_u
    ELSE
      mass_water_u = 0.
    END IF
    RETURN
  END SUBROUTINE RAINFALL_STAGE2

!  Differentiation of snowpack_stage1 in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: albedo_n_snow area_snow_o albedo_v_snow
!                area_snow_u density_snow mass_snow_g mass_snow_o
!                mass_snow_u percent_snow_g percent_snow_o percent_snow_u
!   with respect to varying inputs: area_snow_o_last albedo_n_snow
!                density_snow_last mass_snow_o_last area_snow_u_last
!                mass_snow_u_last albedo_v_snow lai_o lai_u depth_snow
!                mass_snow_g_last
!*****************************************************
!     Snow Pack
!*****************************************************
!! this module will calculate the percentage of canopy and ground covered by snow
!! and output albedo of snow (used in enverge balance) and density of snow in this step
!! by XZ Luo, May 25,2015
!! snowpack_stage1 happens before any consumption of snow in this step, after the snow fall (supply)
!! snowpack_stage2 happens after sublimation from ground and canopy (demand)
!! snowpack_stage3 happens after frozen and melt of snow pack (demand)
!*input:
! air temperature,preciipitation, depth of snow from last step
! density of snow from last step,mass of snow on canopy and ground  from last step
! length of step, LAI_o/u and albedo of snow from last step
!*output
! mass of snow on canopy and ground accululation of snowfall
! albedo of snow in this step
! density of snow in this step
  SUBROUTINE SNOWPACK_STAGE1_FWV(temp_air, precipitation, &
&   mass_snow_o_last, mass_snow_o_last_fw, mass_snow_u_last, &
&   mass_snow_u_last_fw, mass_snow_g_last, mass_snow_g_last_fw, &
&   density_snow_last, density_snow_last_fw, area_snow_o_last, &
&   area_snow_o_last_fw, area_snow_u_last, area_snow_u_last_fw, &
&   mass_snow_o, mass_snow_o_fw, mass_snow_u, mass_snow_u_fw, &
&   mass_snow_g, mass_snow_g_fw, lai_o, lai_o_fw, lai_u, lai_u_fw, &
&   clumping, area_snow_o, area_snow_o_fw, area_snow_u, area_snow_u_fw, &
&   percent_snow_o, percent_snow_o_fw, percent_snow_u, percent_snow_u_fw&
&   , percent_snow_g, percent_snow_g_fw, density_snow, density_snow_fw, &
&   depth_snow, depth_snow_fw, albedo_v_snow, albedo_v_snow_fw, &
&   albedo_n_snow, albedo_n_snow_fw, nbdirs)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
! here precipitation = solid water @J.Wang
    REAL(r8), INTENT(IN) :: temp_air, precipitation
    REAL(r8), INTENT(IN) :: mass_snow_o_last, mass_snow_u_last, &
&   mass_snow_g_last, density_snow_last, area_snow_o_last, &
&   area_snow_u_last
    REAL(r8), DIMENSION(nbdirsmax), INTENT(IN) :: mass_snow_o_last_fw, &
&   mass_snow_u_last_fw, mass_snow_g_last_fw, density_snow_last_fw, &
&   area_snow_o_last_fw, area_snow_u_last_fw
    REAL(r8), INTENT(IN) :: lai_o, lai_u, clumping
    REAL(r8), DIMENSION(nbdirsmax), INTENT(IN) :: lai_o_fw, lai_u_fw
! mass of intercepted snow on canopy and gournd 
    REAL(r8), INTENT(OUT) :: mass_snow_o, mass_snow_u, mass_snow_g
    REAL(r8), DIMENSION(nbdirsmax), INTENT(OUT) :: mass_snow_o_fw, &
&   mass_snow_u_fw, mass_snow_g_fw
    REAL(r8), INTENT(OUT) :: area_snow_o, area_snow_u
    REAL(r8), DIMENSION(nbdirsmax), INTENT(OUT) :: area_snow_o_fw, &
&   area_snow_u_fw
!percentage of snow cover on canopy and ground
    REAL(r8), INTENT(OUT) :: percent_snow_o, percent_snow_u, &
&   percent_snow_g
    REAL(r8), DIMENSION(nbdirsmax), INTENT(OUT) :: percent_snow_o_fw, &
&   percent_snow_u_fw, percent_snow_g_fw
    REAL(r8), INTENT(INOUT) :: density_snow
    REAL(r8), DIMENSION(nbdirsmax), INTENT(INOUT) :: density_snow_fw
    REAL(r8), INTENT(INOUT) :: depth_snow, albedo_v_snow, albedo_n_snow
    REAL(r8), DIMENSION(nbdirsmax), INTENT(INOUT) :: depth_snow_fw, &
&   albedo_v_snow_fw, albedo_n_snow_fw
    REAL(r8) :: massmax_snow_o, massmax_snow_u
    REAL(r8), DIMENSION(nbdirsmax) :: massmax_snow_o_fw, &
&   massmax_snow_u_fw
    REAL(r8) :: massstep_snow_o, massstep_snow_u
    REAL(r8), DIMENSION(nbdirsmax) :: massstep_snow_o_fw, &
&   massstep_snow_u_fw
!Maximum area of snow at overstorey and understorey
    REAL(r8) :: areamax_snow_o, areamax_snow_u
    REAL(r8), DIMENSION(nbdirsmax) :: areamax_snow_o_fw, &
&   areamax_snow_u_fw
!change of snow depth on ground
    REAL(r8) :: change_depth_snow
    REAL(r8), DIMENSION(nbdirsmax) :: change_depth_snow_fw
!density of water, density of newly fallen snow
    REAL(r8) :: density_water, density_new_snow
    REAL(r8) :: snowrate, snowrate_o, snowrate_u, snowrate_g
    REAL(r8), DIMENSION(nbdirsmax) :: snowrate_u_fw, snowrate_g_fw
! albedo of newly fallen snow in visible and near infrared band
    REAL(r8) :: albedo_v_newsnow, albedo_n_newsnow
    INTRINSIC EXP
    INTRINSIC MAX
    INTRINSIC MIN
    REAL(r8) :: arg1
    REAL(r8), DIMENSION(nbdirsmax) :: arg1_fw
    REAL :: arg10
    INTEGER :: nd
    REAL(r8) :: temp
    REAL :: temp0
    INTEGER :: nbdirs
    arg1 = temp_air/2.6
    density_new_snow = 67.9 + 51.3*EXP(arg1)
    albedo_v_newsnow = 0.94
    albedo_n_newsnow = 0.8
    DO nd=1,nbdirs
      massmax_snow_o_fw(nd) = 0.1*lai_o_fw(nd)
      massmax_snow_u_fw(nd) = 0.1*lai_u_fw(nd)
      areamax_snow_o_fw(nd) = 0.01*lai_o_fw(nd)
      areamax_snow_u_fw(nd) = 0.01*lai_u_fw(nd)
    END DO
    massmax_snow_o = 0.1*lai_o
    massmax_snow_u = 0.1*lai_u
    areamax_snow_o = lai_o*0.01
    areamax_snow_u = lai_u*0.01
!!@J.Wang
    snowrate = precipitation
    IF (snowrate .LT. 1.e-6) THEN
      snowrate_o = 1.e-6
    ELSE
      snowrate_o = snowrate
    END IF
    IF (temp_air .LT. 0) THEN
      arg1 = -(lai_o*clumping)
      temp = snowrate_o*kstep*density_new_snow
      mass_snow_o = mass_snow_o_last + temp*(1-EXP(arg1))
      DO nd=1,nbdirs
!! overstorey
!  snowrate_o   = max(snowrate,1.e-6)         !! @MOUSONG.WU
!  write(*,*) 'snowrate_o: ', snowrate_o
        arg1_fw(nd) = -(clumping*lai_o_fw(nd))
        mass_snow_o_fw(nd) = mass_snow_o_last_fw(nd) - temp*EXP(arg1)*&
&         arg1_fw(nd)
!  write(*,*) 'mass_snow_o', mass_snow_o, massMax_snow_o
        percent_snow_o_fw(nd) = (mass_snow_o_fw(nd)-mass_snow_o*&
&         massmax_snow_o_fw(nd)/massmax_snow_o)/massmax_snow_o
      END DO
      percent_snow_o = mass_snow_o/massmax_snow_o
      IF (0. .LT. percent_snow_o) THEN
        percent_snow_o = percent_snow_o
      ELSE
        percent_snow_o = 0.
        percent_snow_o_fw(:) = 0.0_8
      END IF
      IF (1. .GT. percent_snow_o) THEN
        percent_snow_o = percent_snow_o
      ELSE
        percent_snow_o = 1.
        percent_snow_o_fw(:) = 0.0_8
      END IF
      DO nd=1,nbdirs
        area_snow_o_fw(nd) = areamax_snow_o*percent_snow_o_fw(nd) + &
&         percent_snow_o*areamax_snow_o_fw(nd)
        massstep_snow_o_fw(nd) = mass_snow_o_fw(nd) - &
&         mass_snow_o_last_fw(nd)
!! understorey
        snowrate_u_fw(nd) = -(massstep_snow_o_fw(nd)/(density_new_snow*&
&         kstep))
      END DO
      area_snow_o = percent_snow_o*areamax_snow_o
      massstep_snow_o = mass_snow_o - mass_snow_o_last
      snowrate_u = snowrate - massstep_snow_o/density_new_snow/kstep
      IF (0. .LT. snowrate_u) THEN
        snowrate_u = snowrate_u
      ELSE
        snowrate_u = 0.
        snowrate_u_fw(:) = 0.0_8
      END IF
      arg1 = -(lai_u*clumping)
      temp = -EXP(arg1) + 1
      mass_snow_u = mass_snow_u_last + kstep*density_new_snow*(&
&       snowrate_u*temp)
      DO nd=1,nbdirs
        arg1_fw(nd) = -(clumping*lai_u_fw(nd))
        mass_snow_u_fw(nd) = mass_snow_u_last_fw(nd) + kstep*&
&         density_new_snow*(temp*snowrate_u_fw(nd)-snowrate_u*EXP(arg1)*&
&         arg1_fw(nd))
        percent_snow_u_fw(nd) = (mass_snow_u_fw(nd)-mass_snow_u*&
&         massmax_snow_u_fw(nd)/massmax_snow_u)/massmax_snow_u
      END DO
      percent_snow_u = mass_snow_u/massmax_snow_u
      IF (0. .LT. percent_snow_u) THEN
        percent_snow_u = percent_snow_u
      ELSE
        percent_snow_u = 0.
        percent_snow_u_fw(:) = 0.0_8
      END IF
      IF (1. .GT. percent_snow_u) THEN
        percent_snow_u = percent_snow_u
      ELSE
        percent_snow_u = 1.
        percent_snow_u_fw(:) = 0.0_8
      END IF
      DO nd=1,nbdirs
        area_snow_u_fw(nd) = areamax_snow_u*percent_snow_u_fw(nd) + &
&         percent_snow_u*areamax_snow_u_fw(nd)
        massstep_snow_u_fw(nd) = mass_snow_u_fw(nd) - &
&         mass_snow_u_last_fw(nd)
!! ground
        snowrate_g_fw(nd) = snowrate_u_fw(nd) - massstep_snow_u_fw(nd)/(&
&         density_new_snow*kstep)
      END DO
      area_snow_u = percent_snow_u*areamax_snow_u
      massstep_snow_u = mass_snow_u - mass_snow_u_last
      snowrate_g = snowrate_u - massstep_snow_u/density_new_snow/kstep
      IF (0. .LT. snowrate_g) THEN
        snowrate_g = snowrate_g
      ELSE
        snowrate_g = 0.
        snowrate_g_fw(:) = 0.0_8
      END IF
      DO nd=1,nbdirs
        change_depth_snow_fw(nd) = kstep*snowrate_g_fw(nd)
      END DO
      change_depth_snow = snowrate_g*kstep
    ELSE
      mass_snow_o = mass_snow_o_last
      DO nd=1,nbdirs
!! overstorey
        mass_snow_o_fw(nd) = mass_snow_o_last_fw(nd)
        percent_snow_o_fw(nd) = (mass_snow_o_fw(nd)-mass_snow_o*&
&         massmax_snow_o_fw(nd)/massmax_snow_o)/massmax_snow_o
      END DO
      percent_snow_o = mass_snow_o/massmax_snow_o
      IF (0. .LT. percent_snow_o) THEN
        percent_snow_o = percent_snow_o
      ELSE
        percent_snow_o = 0.
        percent_snow_o_fw(:) = 0.0_8
      END IF
      IF (1. .GT. percent_snow_o) THEN
        percent_snow_o = percent_snow_o
      ELSE
        percent_snow_o = 1.
        percent_snow_o_fw(:) = 0.0_8
      END IF
      mass_snow_u = mass_snow_u_last
      DO nd=1,nbdirs
        area_snow_o_fw(nd) = area_snow_o_last_fw(nd)
!! understorey
        mass_snow_u_fw(nd) = mass_snow_u_last_fw(nd)
        percent_snow_u_fw(nd) = (mass_snow_u_fw(nd)-mass_snow_u*&
&         massmax_snow_u_fw(nd)/massmax_snow_u)/massmax_snow_u
      END DO
      area_snow_o = area_snow_o_last
      percent_snow_u = mass_snow_u/massmax_snow_u
      IF (0. .LT. percent_snow_u) THEN
        percent_snow_u = percent_snow_u
      ELSE
        percent_snow_u = 0.
        percent_snow_u_fw(:) = 0.0_8
      END IF
      IF (1. .GT. percent_snow_u) THEN
        percent_snow_u = percent_snow_u
      ELSE
        percent_snow_u = 1.
        percent_snow_u_fw(:) = 0.0_8
      END IF
      DO nd=1,nbdirs
        area_snow_u_fw(nd) = area_snow_u_last_fw(nd)
      END DO
      area_snow_u = area_snow_u_last
!!ground 
      change_depth_snow = 0.
      change_depth_snow_fw(:) = 0.0_8
    END IF
    IF (0. .LT. change_depth_snow) THEN
      change_depth_snow = change_depth_snow
    ELSE
      change_depth_snow = 0.
      change_depth_snow_fw(:) = 0.0_8
    END IF
    DO nd=1,nbdirs
      mass_snow_g_fw(nd) = mass_snow_g_last_fw(nd) + density_new_snow*&
&       change_depth_snow_fw(nd)
    END DO
    mass_snow_g = mass_snow_g_last + change_depth_snow*density_new_snow
    IF (0. .LT. mass_snow_g) THEN
      mass_snow_g = mass_snow_g
    ELSE
      mass_snow_g = 0.
      mass_snow_g_fw(:) = 0.0_8
    END IF
!  write(*,*) 'change_depth_snow', change_depth_snow
!  write(*,*) 'density_snow', density_snow_last
    IF (change_depth_snow .GT. 0.) THEN
      temp = (density_snow_last*depth_snow+density_new_snow*&
&       change_depth_snow)/(depth_snow+change_depth_snow)
      DO nd=1,nbdirs
        density_snow_fw(nd) = (depth_snow*density_snow_last_fw(nd)+&
&         density_snow_last*depth_snow_fw(nd)+density_new_snow*&
&         change_depth_snow_fw(nd)-temp*(depth_snow_fw(nd)+&
&         change_depth_snow_fw(nd)))/(depth_snow+change_depth_snow)
      END DO
      density_snow = temp
    ELSE
!!@J.Wang ???
      arg10 = -(0.001*kstep/3600.)
      temp0 = EXP(arg10)
      DO nd=1,nbdirs
        density_snow_fw(nd) = temp0*density_snow_last_fw(nd)
      END DO
      density_snow = temp0*(density_snow_last-250.) + 250.0
!    density_snow= 250.
    END IF
    IF (mass_snow_g .GT. 0.) THEN
      depth_snow = mass_snow_g/density_snow
    ELSE
      depth_snow = 0.
    END IF
    temp = mass_snow_g/(0.05*density_snow)
    DO nd=1,nbdirs
      percent_snow_g_fw(nd) = (mass_snow_g_fw(nd)-temp*0.05*&
&       density_snow_fw(nd))/(0.05*density_snow)
    END DO
    percent_snow_g = temp
    IF (percent_snow_g .GT. 1.) THEN
      percent_snow_g = 1.
      percent_snow_g_fw(:) = 0.0_8
    ELSE
      percent_snow_g = percent_snow_g
    END IF
!! albedo of snow in this step 
    IF (snowrate_o .GT. 0.) THEN
!!@J.Wang cannot understand clearly
      arg10 = -(0.005*kstep/3600.)
      temp0 = EXP(arg10)
      DO nd=1,nbdirs
        albedo_v_snow_fw(nd) = temp0*albedo_v_snow_fw(nd)
      END DO
      albedo_v_snow = temp0*(albedo_v_snow-0.70) + 0.7
      arg10 = -(0.005*kstep/3600.)
      temp0 = EXP(arg10)
      DO nd=1,nbdirs
        albedo_n_snow_fw(nd) = temp0*albedo_n_snow_fw(nd)
      END DO
      albedo_n_snow = temp0*(albedo_n_snow-0.42) + 0.42
    ELSE
      albedo_v_snow = albedo_v_newsnow
      albedo_n_snow = albedo_n_newsnow
      albedo_n_snow_fw(:) = 0.0_8
      albedo_v_snow_fw(:) = 0.0_8
    END IF
    RETURN
  END SUBROUTINE SNOWPACK_STAGE1_FWV

!*****************************************************
!     Snow Pack
!*****************************************************
!! this module will calculate the percentage of canopy and ground covered by snow
!! and output albedo of snow (used in enverge balance) and density of snow in this step
!! by XZ Luo, May 25,2015
!! snowpack_stage1 happens before any consumption of snow in this step, after the snow fall (supply)
!! snowpack_stage2 happens after sublimation from ground and canopy (demand)
!! snowpack_stage3 happens after frozen and melt of snow pack (demand)
!*input:
! air temperature,preciipitation, depth of snow from last step
! density of snow from last step,mass of snow on canopy and ground  from last step
! length of step, LAI_o/u and albedo of snow from last step
!*output
! mass of snow on canopy and ground accululation of snowfall
! albedo of snow in this step
! density of snow in this step
  SUBROUTINE SNOWPACK_STAGE1(temp_air, precipitation, mass_snow_o_last, &
&   mass_snow_u_last, mass_snow_g_last, density_snow_last, &
&   area_snow_o_last, area_snow_u_last, mass_snow_o, mass_snow_u, &
&   mass_snow_g, lai_o, lai_u, clumping, area_snow_o, area_snow_u, &
&   percent_snow_o, percent_snow_u, percent_snow_g, density_snow, &
&   depth_snow, albedo_v_snow, albedo_n_snow)
    IMPLICIT NONE
! here precipitation = solid water @J.Wang
    REAL(r8), INTENT(IN) :: temp_air, precipitation
    REAL(r8), INTENT(IN) :: mass_snow_o_last, mass_snow_u_last, &
&   mass_snow_g_last, density_snow_last, area_snow_o_last, &
&   area_snow_u_last
    REAL(r8), INTENT(IN) :: lai_o, lai_u, clumping
! mass of intercepted snow on canopy and gournd 
    REAL(r8), INTENT(OUT) :: mass_snow_o, mass_snow_u, mass_snow_g
    REAL(r8), INTENT(OUT) :: area_snow_o, area_snow_u
!percentage of snow cover on canopy and ground
    REAL(r8), INTENT(OUT) :: percent_snow_o, percent_snow_u, &
&   percent_snow_g
    REAL(r8), INTENT(INOUT) :: density_snow
    REAL(r8), INTENT(INOUT) :: depth_snow, albedo_v_snow, albedo_n_snow
    REAL(r8) :: massmax_snow_o, massmax_snow_u
    REAL(r8) :: massstep_snow_o, massstep_snow_u
!Maximum area of snow at overstorey and understorey
    REAL(r8) :: areamax_snow_o, areamax_snow_u
!change of snow depth on ground
    REAL(r8) :: change_depth_snow
!density of water, density of newly fallen snow
    REAL(r8) :: density_water, density_new_snow
    REAL(r8) :: snowrate, snowrate_o, snowrate_u, snowrate_g
! albedo of newly fallen snow in visible and near infrared band
    REAL(r8) :: albedo_v_newsnow, albedo_n_newsnow
    INTRINSIC EXP
    INTRINSIC MAX
    INTRINSIC MIN
    REAL(r8) :: arg1
    REAL :: arg10
    arg1 = temp_air/2.6
    density_new_snow = 67.9 + 51.3*EXP(arg1)
    albedo_v_newsnow = 0.94
    albedo_n_newsnow = 0.8
    massmax_snow_o = 0.1*lai_o
    massmax_snow_u = 0.1*lai_u
    areamax_snow_o = lai_o*0.01
    areamax_snow_u = lai_u*0.01
!!@J.Wang
    snowrate = precipitation
    IF (snowrate .LT. 1.e-6) THEN
      snowrate_o = 1.e-6
    ELSE
      snowrate_o = snowrate
    END IF
    IF (temp_air .LT. 0) THEN
!! overstorey
!  snowrate_o   = max(snowrate,1.e-6)         !! @MOUSONG.WU
!  write(*,*) 'snowrate_o: ', snowrate_o
      arg1 = -(lai_o*clumping)
      mass_snow_o = mass_snow_o_last + snowrate_o*kstep*density_new_snow&
&       *(1-EXP(arg1))
!  write(*,*) 'mass_snow_o', mass_snow_o, massMax_snow_o
      percent_snow_o = mass_snow_o/massmax_snow_o
      IF (0. .LT. percent_snow_o) THEN
        percent_snow_o = percent_snow_o
      ELSE
        percent_snow_o = 0.
      END IF
      IF (1. .GT. percent_snow_o) THEN
        percent_snow_o = percent_snow_o
      ELSE
        percent_snow_o = 1.
      END IF
      area_snow_o = percent_snow_o*areamax_snow_o
      massstep_snow_o = mass_snow_o - mass_snow_o_last
!! understorey
      snowrate_u = snowrate - massstep_snow_o/density_new_snow/kstep
      IF (0. .LT. snowrate_u) THEN
        snowrate_u = snowrate_u
      ELSE
        snowrate_u = 0.
      END IF
      arg1 = -(lai_u*clumping)
      mass_snow_u = mass_snow_u_last + snowrate_u*kstep*density_new_snow&
&       *(1-EXP(arg1))
      percent_snow_u = mass_snow_u/massmax_snow_u
      IF (0. .LT. percent_snow_u) THEN
        percent_snow_u = percent_snow_u
      ELSE
        percent_snow_u = 0.
      END IF
      IF (1. .GT. percent_snow_u) THEN
        percent_snow_u = percent_snow_u
      ELSE
        percent_snow_u = 1.
      END IF
      area_snow_u = percent_snow_u*areamax_snow_u
      massstep_snow_u = mass_snow_u - mass_snow_u_last
!! ground
      snowrate_g = snowrate_u - massstep_snow_u/density_new_snow/kstep
      IF (0. .LT. snowrate_g) THEN
        snowrate_g = snowrate_g
      ELSE
        snowrate_g = 0.
      END IF
      change_depth_snow = snowrate_g*kstep
    ELSE
!! overstorey
      mass_snow_o = mass_snow_o_last
      percent_snow_o = mass_snow_o/massmax_snow_o
      IF (0. .LT. percent_snow_o) THEN
        percent_snow_o = percent_snow_o
      ELSE
        percent_snow_o = 0.
      END IF
      IF (1. .GT. percent_snow_o) THEN
        percent_snow_o = percent_snow_o
      ELSE
        percent_snow_o = 1.
      END IF
      area_snow_o = area_snow_o_last
!! understorey
      mass_snow_u = mass_snow_u_last
      percent_snow_u = mass_snow_u/massmax_snow_u
      IF (0. .LT. percent_snow_u) THEN
        percent_snow_u = percent_snow_u
      ELSE
        percent_snow_u = 0.
      END IF
      IF (1. .GT. percent_snow_u) THEN
        percent_snow_u = percent_snow_u
      ELSE
        percent_snow_u = 1.
      END IF
      area_snow_u = area_snow_u_last
!!ground 
      change_depth_snow = 0.
    END IF
    IF (0. .LT. change_depth_snow) THEN
      change_depth_snow = change_depth_snow
    ELSE
      change_depth_snow = 0.
    END IF
    mass_snow_g = mass_snow_g_last + change_depth_snow*density_new_snow
    IF (0. .LT. mass_snow_g) THEN
      mass_snow_g = mass_snow_g
    ELSE
      mass_snow_g = 0.
    END IF
!  write(*,*) 'change_depth_snow', change_depth_snow
!  write(*,*) 'density_snow', density_snow_last
    IF (change_depth_snow .GT. 0.) THEN
      density_snow = (density_snow_last*depth_snow+density_new_snow*&
&       change_depth_snow)/(depth_snow+change_depth_snow)
    ELSE
!!@J.Wang ???
      arg10 = -(0.001*kstep/3600.)
      density_snow = (density_snow_last-250.)*EXP(arg10) + 250.0
!    density_snow= 250.
    END IF
    IF (mass_snow_g .GT. 0.) THEN
      depth_snow = mass_snow_g/density_snow
    ELSE
      depth_snow = 0.
    END IF
    percent_snow_g = mass_snow_g/(0.05*density_snow)
    IF (percent_snow_g .GT. 1.) THEN
      percent_snow_g = 1.
    ELSE
      percent_snow_g = percent_snow_g
    END IF
!! albedo of snow in this step 
    IF (snowrate_o .GT. 0.) THEN
!!@J.Wang cannot understand clearly
      arg10 = -(0.005*kstep/3600.)
      albedo_v_snow = (albedo_v_snow-0.70)*EXP(arg10) + 0.7
      arg10 = -(0.005*kstep/3600.)
      albedo_n_snow = (albedo_n_snow-0.42)*EXP(arg10) + 0.42
    ELSE
      albedo_v_snow = albedo_v_newsnow
      albedo_n_snow = albedo_n_newsnow
    END IF
    RETURN
  END SUBROUTINE SNOWPACK_STAGE1

!  Differentiation of snowpack_stage2 in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: mass_snow_o mass_snow_u
!   with respect to varying inputs: mass_snow_o mass_snow_u evapo_snow_o
!                evapo_snow_u
!this module will calculate the snow remained on canopy surface after evaporation in this step
  SUBROUTINE SNOWPACK_STAGE2_FWV(evapo_snow_o, evapo_snow_o_fw, &
&   evapo_snow_u, evapo_snow_u_fw, mass_snow_o, mass_snow_o_fw, &
&   mass_snow_u, mass_snow_u_fw, nbdirs)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
    REAL(r8), INTENT(IN) :: evapo_snow_o, evapo_snow_u
    REAL(r8), DIMENSION(nbdirsmax), INTENT(IN) :: evapo_snow_o_fw, &
&   evapo_snow_u_fw
    REAL(r8), INTENT(INOUT) :: mass_snow_o, mass_snow_u
    REAL(r8), DIMENSION(nbdirsmax), INTENT(INOUT) :: mass_snow_o_fw, &
&   mass_snow_u_fw
    INTRINSIC MAX
    INTEGER :: nd
    INTEGER :: nbdirs
    IF (0. .LT. mass_snow_o - evapo_snow_o*kstep) THEN
      DO nd=1,nbdirs
        mass_snow_o_fw(nd) = mass_snow_o_fw(nd) - kstep*evapo_snow_o_fw(&
&         nd)
      END DO
      mass_snow_o = mass_snow_o - evapo_snow_o*kstep
    ELSE
      mass_snow_o = 0.
      mass_snow_o_fw(:) = 0.0_8
    END IF
    IF (0. .LT. mass_snow_u - evapo_snow_u*kstep) THEN
      DO nd=1,nbdirs
        mass_snow_u_fw(nd) = mass_snow_u_fw(nd) - kstep*evapo_snow_u_fw(&
&         nd)
      END DO
      mass_snow_u = mass_snow_u - evapo_snow_u*kstep
    ELSE
      mass_snow_u = 0.
      mass_snow_u_fw(:) = 0.0_8
    END IF
    RETURN
  END SUBROUTINE SNOWPACK_STAGE2_FWV

!this module will calculate the snow remained on canopy surface after evaporation in this step
  SUBROUTINE SNOWPACK_STAGE2(evapo_snow_o, evapo_snow_u, mass_snow_o, &
&   mass_snow_u)
    IMPLICIT NONE
    REAL(r8), INTENT(IN) :: evapo_snow_o, evapo_snow_u
    REAL(r8), INTENT(INOUT) :: mass_snow_o, mass_snow_u
    INTRINSIC MAX
    IF (0. .LT. mass_snow_o - evapo_snow_o*kstep) THEN
      mass_snow_o = mass_snow_o - evapo_snow_o*kstep
    ELSE
      mass_snow_o = 0.
    END IF
    IF (0. .LT. mass_snow_u - evapo_snow_u*kstep) THEN
      mass_snow_u = mass_snow_u - evapo_snow_u*kstep
    ELSE
      mass_snow_u = 0.
    END IF
    RETURN
  END SUBROUTINE SNOWPACK_STAGE2

!  Differentiation of snowpack_stage3 in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: mass_snow_g depth_water depth_snow
!   with respect to varying inputs: mass_snow_g density_snow depth_water
!                temp_snow depth_snow
!This module simulates the process of snow melting and water frozen in this step
!*input
! depth of snow on ground after stage 1,
! air temperature
! ground surface temperature
! // output:
! the amount of the melted snow, frozen snow
!
  SUBROUTINE SNOWPACK_STAGE3_FWV(temp_air, temp_snow, temp_snow_fw, &
&   temp_snow_last, density_snow, density_snow_fw, depth_snow, &
&   depth_snow_fw, depth_water, depth_water_fw, mass_snow_g, &
&   mass_snow_g_fw, nbdirs)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
    REAL(r8), INTENT(IN) :: temp_air, temp_snow, temp_snow_last, &
&   density_snow
    REAL(r8), DIMENSION(nbdirsmax), INTENT(IN) :: temp_snow_fw, &
&   density_snow_fw
    REAL(r8), INTENT(INOUT) :: depth_snow, depth_water, mass_snow_g
    REAL(r8), DIMENSION(nbdirsmax), INTENT(INOUT) :: depth_snow_fw, &
&   depth_water_fw, mass_snow_g_fw
! depth and mass of snow after stage1, and minus the amount of sublimation
    REAL(r8) :: depth_snow_sup, mass_snow_sup
    REAL(r8), DIMENSION(nbdirsmax) :: depth_snow_sup_fw, &
&   mass_snow_sup_fw
    REAL(r8) :: mass_snow_melt, mass_water_frozen
    REAL(r8), DIMENSION(nbdirsmax) :: mass_snow_melt_fw, &
&   mass_water_frozen_fw
    REAL(r8) :: melt_depth_snow, frozen_depth_snow
    REAL(r8), DIMENSION(nbdirsmax) :: melt_depth_snow_fw, &
&   frozen_depth_snow_fw
    REAL(r8) :: melt_depth_water, frozen_depth_water
    REAL(r8), DIMENSION(nbdirsmax) :: melt_depth_water_fw, &
&   frozen_depth_water_fw
    INTRINSIC MIN
    INTRINSIC MAX
    INTRINSIC ISNAN
    INTEGER :: nd
    INTEGER :: nbdirs
    DO nd=1,nbdirs
!! assumed sublimation happens before the melting and freezing 
      depth_snow_sup_fw(nd) = depth_snow_fw(nd)
      mass_snow_sup_fw(nd) = mass_snow_g_fw(nd)
    END DO
    depth_snow_sup = depth_snow
    mass_snow_sup = mass_snow_g
!!simulate snow melt and freeze process
    mass_snow_melt = 0.
    mass_water_frozen = 0.
    IF (depth_snow_sup .LE. 0.02) THEN
      IF (temp_air .GT. 0. .AND. depth_snow_sup .GT. 0.) THEN
        mass_snow_melt = temp_air*0.0075*kstep/3600*0.3
        IF (mass_snow_sup .GT. mass_snow_melt) THEN
          mass_snow_melt = mass_snow_melt
          mass_snow_melt_fw(:) = 0.0_8
          mass_water_frozen_fw(:) = 0.0_8
        ELSE
          DO nd=1,nbdirs
            mass_snow_melt_fw(nd) = mass_snow_sup_fw(nd)
          END DO
          mass_snow_melt = mass_snow_sup
          mass_water_frozen_fw(:) = 0.0_8
        END IF
      ELSE
        mass_snow_melt = 0.
        mass_snow_melt_fw(:) = 0.0_8
        mass_water_frozen_fw(:) = 0.0_8
      END IF
    ELSE IF (depth_snow_sup .GT. 0.02 .AND. depth_snow_sup .LE. 0.05) &
&   THEN
      IF (temp_snow .GT. 0. .AND. temp_snow_last .LT. 0. .AND. &
&         mass_snow_sup .GT. 0.) THEN
        DO nd=1,nbdirs
          mass_snow_melt_fw(nd) = cp_ice*(depth_snow_sup*(density_snow*&
&           temp_snow_fw(nd)+temp_snow*density_snow_fw(nd))/&
&           latent_fusion+temp_snow*density_snow*depth_snow_sup_fw(nd)/&
&           latent_fusion)
        END DO
        mass_snow_melt = temp_snow*cp_ice*density_snow*depth_snow_sup/&
&         latent_fusion
        IF (mass_snow_sup .GT. mass_snow_melt) THEN
          mass_snow_melt = mass_snow_melt
        ELSE
          DO nd=1,nbdirs
            mass_snow_melt_fw(nd) = mass_snow_sup_fw(nd)
          END DO
          mass_snow_melt = mass_snow_sup
        END IF
      ELSE
        mass_snow_melt = 0.
        mass_snow_melt_fw(:) = 0.0_8
      END IF
      IF (temp_snow .LE. 0. .AND. temp_snow_last .GT. 0. .AND. &
&         depth_water .GT. 0.) THEN
        DO nd=1,nbdirs
          mass_water_frozen_fw(nd) = cp_ice*(-(density_snow*&
&           depth_snow_sup*temp_snow_fw(nd)/latent_fusion)-temp_snow*(&
&           depth_snow_sup*density_snow_fw(nd)+density_snow*&
&           depth_snow_sup_fw(nd))/latent_fusion)
        END DO
        mass_water_frozen = (0.-temp_snow)*cp_ice*density_snow*&
&         depth_snow_sup/latent_fusion
        IF (mass_water_frozen .LT. depth_water*density_water) THEN
          DO nd=1,nbdirs
            mass_water_frozen_fw(nd) = density_water*depth_water_fw(nd)
          END DO
          mass_water_frozen = depth_water*density_water
        ELSE
          mass_water_frozen = mass_water_frozen
        END IF
      ELSE
        mass_water_frozen = 0.
        mass_water_frozen_fw(:) = 0.0_8
      END IF
    ELSE IF (depth_snow_sup .GT. 0.05) THEN
      IF (temp_snow .GT. 0. .AND. temp_snow_last .LE. 0. .AND. &
&         mass_snow_sup .GT. 0.) THEN
        DO nd=1,nbdirs
          mass_snow_melt_fw(nd) = cp_ice*0.02*(depth_snow_sup*(&
&           density_snow*temp_snow_fw(nd)+temp_snow*density_snow_fw(nd))&
&           /latent_fusion+temp_snow*density_snow*depth_snow_sup_fw(nd)/&
&           latent_fusion)
        END DO
        mass_snow_melt = temp_snow*cp_ice*density_snow*depth_snow_sup*&
&         0.02/latent_fusion
        IF (mass_snow_sup .GT. mass_snow_melt) THEN
          mass_snow_melt = mass_snow_melt
        ELSE
          DO nd=1,nbdirs
            mass_snow_melt_fw(nd) = mass_snow_sup_fw(nd)
          END DO
          mass_snow_melt = mass_snow_sup
        END IF
      ELSE
        mass_snow_melt = 0.
        mass_snow_melt_fw(:) = 0.0_8
      END IF
      IF (temp_snow .LE. 0. .AND. temp_snow_last .GT. 0. .AND. &
&         depth_water .GT. 0.) THEN
        DO nd=1,nbdirs
          mass_water_frozen_fw(nd) = cp_ice*0.02*(-(density_snow*&
&           depth_snow_sup*temp_snow_fw(nd)/latent_fusion)-temp_snow*(&
&           depth_snow_sup*density_snow_fw(nd)+density_snow*&
&           depth_snow_sup_fw(nd))/latent_fusion)
        END DO
        mass_water_frozen = (0.-temp_snow)*cp_ice*density_snow*&
&         depth_snow_sup*0.02/latent_fusion
        IF (mass_water_frozen .LT. depth_water*density_water) THEN
          DO nd=1,nbdirs
            mass_water_frozen_fw(nd) = density_water*depth_water_fw(nd)
          END DO
          mass_water_frozen = depth_water*density_water
        ELSE
          mass_water_frozen = mass_water_frozen
        END IF
      ELSE
        mass_water_frozen = 0.
        mass_water_frozen_fw(:) = 0.0_8
      END IF
    ELSE
      mass_snow_melt_fw(:) = 0.0_8
      mass_water_frozen_fw(:) = 0.0_8
    END IF
!!change in mass of snow on ground
    DO nd=1,nbdirs
      mass_snow_g_fw(nd) = mass_snow_g_fw(nd) - mass_snow_melt_fw(nd) + &
&       mass_water_frozen_fw(nd)
    END DO
    mass_snow_g = mass_snow_g - mass_snow_melt + mass_water_frozen
    IF (0. .LT. mass_snow_g) THEN
      mass_snow_g = mass_snow_g
    ELSE
      mass_snow_g = 0.
      mass_snow_g_fw(:) = 0.0_8
    END IF
    DO nd=1,nbdirs
!!change of depth in snow
      melt_depth_snow_fw(nd) = (mass_snow_melt_fw(nd)-mass_snow_melt*&
&       density_snow_fw(nd)/density_snow)/density_snow
      frozen_depth_snow_fw(nd) = (mass_water_frozen_fw(nd)-&
&       mass_water_frozen*density_snow_fw(nd)/density_snow)/density_snow
      depth_snow_fw(nd) = depth_snow_sup_fw(nd) - melt_depth_snow_fw(nd)&
&       + frozen_depth_snow_fw(nd)
    END DO
    melt_depth_snow = mass_snow_melt/density_snow
    frozen_depth_snow = mass_water_frozen/density_snow
    depth_snow = depth_snow_sup - melt_depth_snow + frozen_depth_snow
    IF (ISNAN(depth_snow)) THEN
      depth_snow = 0.
      depth_snow_fw(:) = 0.0_8
    END IF
    IF (0. .LT. depth_snow) THEN
      depth_snow = depth_snow
    ELSE
      depth_snow = 0.
      depth_snow_fw(:) = 0.0_8
    END IF
    DO nd=1,nbdirs
!!channge of depth in water
      melt_depth_water_fw(nd) = mass_snow_melt_fw(nd)/density_water
      frozen_depth_water_fw(nd) = mass_water_frozen_fw(nd)/density_water
      depth_water_fw(nd) = depth_water_fw(nd) + melt_depth_water_fw(nd) &
&       - frozen_depth_water_fw(nd)
    END DO
    melt_depth_water = mass_snow_melt/density_water
    frozen_depth_water = mass_water_frozen/density_water
    depth_water = depth_water + melt_depth_water - frozen_depth_water
    IF (0. .LT. depth_water) THEN
      depth_water = depth_water
    ELSE
      depth_water = 0.
      depth_water_fw(:) = 0.0_8
    END IF
    RETURN
  END SUBROUTINE SNOWPACK_STAGE3_FWV

!This module simulates the process of snow melting and water frozen in this step
!*input
! depth of snow on ground after stage 1,
! air temperature
! ground surface temperature
! // output:
! the amount of the melted snow, frozen snow
!
  SUBROUTINE SNOWPACK_STAGE3(temp_air, temp_snow, temp_snow_last, &
&   density_snow, depth_snow, depth_water, mass_snow_g)
    IMPLICIT NONE
    REAL(r8), INTENT(IN) :: temp_air, temp_snow, temp_snow_last, &
&   density_snow
    REAL(r8), INTENT(INOUT) :: depth_snow, depth_water, mass_snow_g
! depth and mass of snow after stage1, and minus the amount of sublimation
    REAL(r8) :: depth_snow_sup, mass_snow_sup
    REAL(r8) :: mass_snow_melt, mass_water_frozen
    REAL(r8) :: melt_depth_snow, frozen_depth_snow
    REAL(r8) :: melt_depth_water, frozen_depth_water
    INTRINSIC MIN
    INTRINSIC MAX
    INTRINSIC ISNAN
!! assumed sublimation happens before the melting and freezing 
    depth_snow_sup = depth_snow
    mass_snow_sup = mass_snow_g
!!simulate snow melt and freeze process
    mass_snow_melt = 0.
    mass_water_frozen = 0.
    IF (depth_snow_sup .LE. 0.02) THEN
      IF (temp_air .GT. 0. .AND. depth_snow_sup .GT. 0.) THEN
        mass_snow_melt = temp_air*0.0075*kstep/3600*0.3
        IF (mass_snow_sup .GT. mass_snow_melt) THEN
          mass_snow_melt = mass_snow_melt
        ELSE
          mass_snow_melt = mass_snow_sup
        END IF
      ELSE
        mass_snow_melt = 0.
      END IF
    ELSE IF (depth_snow_sup .GT. 0.02 .AND. depth_snow_sup .LE. 0.05) &
&   THEN
      IF (temp_snow .GT. 0. .AND. temp_snow_last .LT. 0. .AND. &
&         mass_snow_sup .GT. 0.) THEN
        mass_snow_melt = temp_snow*cp_ice*density_snow*depth_snow_sup/&
&         latent_fusion
        IF (mass_snow_sup .GT. mass_snow_melt) THEN
          mass_snow_melt = mass_snow_melt
        ELSE
          mass_snow_melt = mass_snow_sup
        END IF
      ELSE
        mass_snow_melt = 0.
      END IF
      IF (temp_snow .LE. 0. .AND. temp_snow_last .GT. 0. .AND. &
&         depth_water .GT. 0.) THEN
        mass_water_frozen = (0.-temp_snow)*cp_ice*density_snow*&
&         depth_snow_sup/latent_fusion
        IF (mass_water_frozen .LT. depth_water*density_water) THEN
          mass_water_frozen = depth_water*density_water
        ELSE
          mass_water_frozen = mass_water_frozen
        END IF
      ELSE
        mass_water_frozen = 0.
      END IF
    ELSE IF (depth_snow_sup .GT. 0.05) THEN
      IF (temp_snow .GT. 0. .AND. temp_snow_last .LE. 0. .AND. &
&         mass_snow_sup .GT. 0.) THEN
        mass_snow_melt = temp_snow*cp_ice*density_snow*depth_snow_sup*&
&         0.02/latent_fusion
        IF (mass_snow_sup .GT. mass_snow_melt) THEN
          mass_snow_melt = mass_snow_melt
        ELSE
          mass_snow_melt = mass_snow_sup
        END IF
      ELSE
        mass_snow_melt = 0.
      END IF
      IF (temp_snow .LE. 0. .AND. temp_snow_last .GT. 0. .AND. &
&         depth_water .GT. 0.) THEN
        mass_water_frozen = (0.-temp_snow)*cp_ice*density_snow*&
&         depth_snow_sup*0.02/latent_fusion
        IF (mass_water_frozen .LT. depth_water*density_water) THEN
          mass_water_frozen = depth_water*density_water
        ELSE
          mass_water_frozen = mass_water_frozen
        END IF
      ELSE
        mass_water_frozen = 0.
      END IF
    END IF
!!change in mass of snow on ground
    mass_snow_g = mass_snow_g - mass_snow_melt + mass_water_frozen
    IF (0. .LT. mass_snow_g) THEN
      mass_snow_g = mass_snow_g
    ELSE
      mass_snow_g = 0.
    END IF
!!change of depth in snow
    melt_depth_snow = mass_snow_melt/density_snow
    frozen_depth_snow = mass_water_frozen/density_snow
    depth_snow = depth_snow_sup - melt_depth_snow + frozen_depth_snow
    IF (ISNAN(depth_snow)) depth_snow = 0.
    IF (0. .LT. depth_snow) THEN
      depth_snow = depth_snow
    ELSE
      depth_snow = 0.
    END IF
!!channge of depth in water
    melt_depth_water = mass_snow_melt/density_water
    frozen_depth_water = mass_water_frozen/density_water
    depth_water = depth_water + melt_depth_water - frozen_depth_water
    IF (0. .LT. depth_water) THEN
      depth_water = depth_water
    ELSE
      depth_water = 0.
    END IF
    RETURN
  END SUBROUTINE SNOWPACK_STAGE3

END MODULE RAINSNOWMOD_DIFFV

MODULE RESTART_DIFFV
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE BEPS_PAR
  USE OUTPUTMOD_DIFFV
  USE BEPSTYPE_DIFFV
!--iLab::can avoid beps_time_manager, date information now passed as actual arguments
! use beps_time_manager, only:get_curr_date
  USE BEPS_SOILMOD_DIFFV
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTEGER :: rst_icdate
  INTEGER :: rst_icsec

CONTAINS
  SUBROUTINE RESTART_IO(flag, yy, mm, dd, tod)
    IMPLICIT NONE
    CHARACTER(len=*) :: flag
!-- iLab::yy,mm,dd,tod turned to input arguments
!         (can be omitted when in  flag=='read')
    INTEGER, INTENT(IN), OPTIONAL :: yy, mm, dd, tod
    REAL(r8) :: v2last1(nlp, 0:40, pft)
    INTEGER :: i, j, ierr
    CHARACTER(len=255) :: fln1, fln2
! integer          :: yy,mm,dd,tod
    CHARACTER(len=8) :: datestr
    INTRINSIC TRIM
    INTRINSIC PRESENT
    IF (TRIM(flag) .EQ. 'write') THEN
      IF (.NOT.PRESENT(yy)) THEN
        WRITE(*, '(a)') &
&       ' FATAL::restart_io::yy must be given in write mode!'
        STOP
      ELSE IF (.NOT.PRESENT(mm)) THEN
        WRITE(*, '(a)') &
&       ' FATAL::restart_io::mm must be given in write mode!'
        STOP
      ELSE IF (.NOT.PRESENT(dd)) THEN
        WRITE(*, '(a)') &
&       ' FATAL::restart_io::dd must be given in write mode!'
        STOP
      ELSE IF (.NOT.PRESENT(tod)) THEN
        WRITE(*, '(a)') &
&       ' FATAL::restart_io::tod must be given in write mode!'
        STOP
      ELSE
!   call mpi_barrier(mpi_comm_world,ierr)
!   do i = 1,PFT
!      do j = 0,40
!         call mpi_gatherv(v2last(1,j,i),npoints,mpi_real8,v2last1(1,j,i),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!      end do
!   end do
!   call mpi_barrier(mpi_comm_world,ierr)
        v2last1 = v2last
! call get_curr_date(yy,mm,dd,tod)
        WRITE(datestr, '(i8)') yy*10000 + mm*100 + dd
!   if(myid ==0) 
        WRITE(*, *) 'restart file on ', tod
!   if(myid ==0) then
        fln1 = TRIM(beps_rst_dir)//'beps.restart.'//TRIM(datestr)
        rst_icdate = yy*10000 + mm*100 + dd
        rst_icsec = tod
        OPEN(80, file=fln1, form='unformatted', status='unknown') 
        WRITE(80) rst_icdate, rst_icsec, v2last1
        CLOSE(80) 
        fln2 = TRIM(beps_rst_dir)//'rpointer'
        OPEN(81, file=fln2, form='formatted', status='REPLACE') 
        WRITE(81, '(A)') fln1
        CLOSE(81) 
!    end if
!    call mpi_barrier(mpi_comm_world,ierr)
      END IF
    ELSE IF (TRIM(flag) .EQ. 'read') THEN
!   if(myid ==0) then
      fln2 = TRIM(beps_rst_dir)//'rpointer'
      OPEN(81, file=fln2, form='formatted') 
      READ(81, '(A)') fln1
      CLOSE(81) 
      OPEN(80, file=trim(fln1), form='unformatted') 
      READ(80) rst_icdate, rst_icsec, v2last1
      CLOSE(80) 
!   end if
!   call mpi_barrier(mpi_comm_world,ierr)
!   do i = 1,PFT
!     do j = 0,40
!        call mpi_scatterv(v2last1(1,j,i),dp,sp,mpi_real8,v2last(1,j,i),npoints,mpi_real8,0,mpi_comm_world,ierr)
!     end do
!   end do
!   call mpi_bcast(rst_icdate,1,mpi_integer,0,mpi_comm_world,ierr)
!   call mpi_bcast(rst_icsec,1,mpi_integer,0,mpi_comm_world,ierr)
!   call mpi_barrier(mpi_comm_world,ierr)
      v2last = v2last1
    END IF
  END SUBROUTINE RESTART_IO

END MODULE RESTART_DIFFV

!***********************************************************
!     initx
!
!> @brief method to access the prior control vector in normalised units
!>        and the prior uncertainty in physical units
!>
!> @param[in]   n   overall length of control vector
!> @param[out]  x   control vector (in normalised units)
!> @param[out]  sx  uncertainty of control vector elements (physical units)
!
!> \authors Michael Vossbeck, The Inversion Lab
!> \date    January 2020
SUBROUTINE INITX_CDV(n, x, sx)
  USE MO_PRIOR
  USE BEPSTYPE_DIFFV, ONLY : assim
  USE BEPS_PAR, ONLY : pft, texture
  USE CONTROLINPUT_MOD_DIFFV, ONLY : read_prior_para
  IMPLICIT NONE
! arguments
  INTEGER, INTENT(IN) :: n
  REAL(kind=8), INTENT(OUT) :: x(n), sx(n)
! local variables
  REAL(kind=8) :: xphys(n)
  INTEGER :: i1, i2, ii
  CHARACTER(len=2) :: str2
  INTRINSIC TRIM
!-- allocate prior module
  ALLOCATE(x_pr(n))
  ALLOCATE(x_sigma(n))
  ALLOCATE(x_mask(n))
  ALLOCATE(x_prname(n))
! put the parameters to be optimized in a NETCDF
  CALL READ_PRIOR_PARA()
!file and read them as well their
!uncertainties,@MOUSONG.WU,2019-11
!-- assign/mapping
!-- Vcmax
  i1 = 1
  i2 = i1 + pft - 1
  xphys(i1:i2) = assim%p_vcmax
  x_sigma(i1:i2) = assim%u_vcmax
  DO ii=i1,i2
    WRITE(str2, '(i2.2)') ii - i1 + 1
    x_prname(ii) = 'Vcmax_PFT'//str2
  END DO
!-- VJ_slope
  i1 = i2 + 1
  i2 = i1 + pft - 1
  xphys(i1:i2) = assim%p_vj_slope
  x_sigma(i1:i2) = assim%u_vj_slope
  DO ii=i1,i2
    WRITE(str2, '(i2.2)') ii - i1 + 1
    x_prname(ii) = 'VJ_slope_PFT'//str2
  END DO
!-- Q10
!   (parameter to adjust 'q10' in calculation plant respiration)
  i1 = i2 + 1
  i2 = i1 + pft - 1
  xphys(i1:i2) = assim%p_q10
  x_sigma(i1:i2) = assim%u_q10
  DO ii=i1,i2
    WRITE(str2, '(i2.2)') ii - i1 + 1
    x_prname(ii) = 'Q10_PFT'//str2
  END DO
!-- sif_alpha
!   (...)
  i1 = i2 + 1
  i2 = i1 + pft - 1
  xphys(i1:i2) = assim%p_sif_alpha
  x_sigma(i1:i2) = assim%u_sif_alpha
  DO ii=i1,i2
    WRITE(str2, '(i2.2)') ii - i1 + 1
    x_prname(ii) = 'sif_alpha_PFT'//str2
  END DO
!-- sif_beta
!   (...)
  i1 = i2 + 1
  i2 = i1 + pft - 1
  xphys(i1:i2) = assim%p_sif_beta
  x_sigma(i1:i2) = assim%u_sif_beta
  DO ii=i1,i2
    WRITE(str2, '(i2.2)') ii - i1 + 1
    x_prname(ii) = 'sif_beta_PFT'//str2
  END DO
!-- iLab::CHANGED 06/2022: D0,TAWEFF not required since VOD is not assimilated
! !-- D0
! !   (...)
! i1 = i2+1
! i2 = i1+PFT-1
! xphys(i1:i2)   = assim%p_D0
! x_sigma(i1:i2) = assim%u_D0
! do ii=i1,i2
!    write(str2, '(i2.2)') ii-i1+1
!    x_prname(ii) = 'D0_PFT'//str2
! enddo
! !-- TAWEFF
! !   (...)
! i1 = i2+1
! i2 = i1+PFT-1
! xphys(i1:i2)   = assim%p_taweff
! x_sigma(i1:i2) = assim%u_taweff
! do ii=i1,i2
!    write(str2, '(i2.2)') ii-i1+1
!    x_prname(ii) = 'taweff_PFT'//str2
! enddo
!-- Ksat
!   (parameter to adjust 'Ksat', the saturated hydraulic conductivity, in beps_soilMod.F90)
  i1 = i2 + 1
  i2 = i1 + texture - 1
  xphys(i1:i2) = assim%p_ksat_scalar
  x_sigma(i1:i2) = assim%u_ksat_scalar
  DO ii=i1,i2
    WRITE(str2, '(i2.2)') ii - i1 + 1
    x_prname(ii) = 'Ksat_Txt'//str2
  END DO
!-- u
!   (parameter to adjust 'b', the parameters for calculating soil water characteristic, in beps_soilMode.F90)
  i1 = i2 + 1
  i2 = i1 + texture - 1
  xphys(i1:i2) = assim%p_b_scalar
  x_sigma(i1:i2) = assim%u_b_scalar
  DO ii=i1,i2
    WRITE(str2, '(i2.2)') ii - i1 + 1
    x_prname(ii) = 'b_Txt'//str2
  END DO
!-- f_leaf
  i1 = i2 + 1
  xphys(i1) = assim%p_f_leaf
  x_sigma(i1) = assim%u_f_leaf
  x_prname(i1) = 'f_leaf'
!-- kc25
  i1 = i1 + 1
  xphys(i1) = assim%p_kc25
  x_sigma(i1) = assim%u_kc25
  x_prname(i1) = 'kc25'
!-- ko25
  i1 = i1 + 1
  xphys(i1) = assim%p_ko25
  x_sigma(i1) = assim%u_ko25
  x_prname(i1) = 'ko25'
!-- tau25
  i1 = i1 + 1
  xphys(i1) = assim%p_tau25
  x_sigma(i1) = assim%u_tau25
  x_prname(i1) = 'tau25'
!-- iLab::CHANGED 06/2022: D0,TAWEFF not required since VOD is not assimilated
! !-- agb2vod
! i1 = i1+1
! xphys(i1)    = assim%p_agb2vod
! x_sigma(i1)  = assim%u_agb2vod
! x_prname(i1) = 'agb2vod'
!-- save normalised prior module
  x_pr = xphys/x_sigma
!-- by default deviation from prior is activated
  x_mask = .true.
!-- assign to output arguments
  x = x_pr
  sx = x_sigma
!-- write list of parameter names (to ease consistency of post-processing)
  OPEN(18, file='ctlvec_scaled.txt', form='formatted') 
  WRITE(str2, '(i2.2)') pft
  WRITE(18, '(a)') '#npft='//str2
  WRITE(str2, '(i2.2)') texture
  WRITE(18, '(a)') '#ntexture='//str2
  WRITE(18, '(a,a31,a20,a20)') '#', 'name', 'scaled prior', &
& 'prior uncertainty'
  DO ii=1,n
    WRITE(18, '(a32,e20.6,e20.6)') TRIM(x_prname(ii)), x_pr(ii), x_sigma&
&   (ii)
  END DO
  CLOSE(18) 
END SUBROUTINE INITX_CDV

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!> \file bepsfunc.F90
!> \brief defines a functional implementation for running BEPS model,
!>        and defines the interface for using BEPS within
!>        a sensitivity and/or optimisation framework.
!>        It defines the top-level interface 'evalf' that maps
!>        a one-dimensional control vector (normalised coordinates)
!>        to a one-dimensional simulation vector.
!>        Please note, that the implementation core of this routine
!>        was taken/transferrred from the original BEPS driver.
!>
!> \authors The Inversion Lab (Michael Vossbeck, Thomas Kaminski) 
!> \date  January 2020 (with several updates applied thereafter)
!                               
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!***********************************************************
!     evalf
!
!> @brief function like BEPS model evaluation (or simulation)
!>        that maps a given one-dimensional control vector x ("independents")
!>        in normalised units to a one-dimensional simulation vector y ("dependents")
!>        The 1D control vector captures 3 BEPS quantities (SIF, Thetam, COSflux),
!>        ordering in the 1D vector is (varying slowest to fastest)
!>        time (hourly), site, BEPS-quantity.
!>
!> @param[in]   n   length of control vector
!> @param[in]   x   control vector (in normalised units)
!> @param[in]   m   length of simulation vector
!> @param[out]  y   simulation vector
!
!> \authors Michael Vossbeck, The Inversion Lab
!> \date    January 2020
!> \last    June 2022
!>
SUBROUTINE EVALF_CDV(n, x, m, y)
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE BEPS_CON, ONLY : pi
  USE CONTROLINPUT_MOD_DIFFV, ONLY : lai_input, meteo_input, &
& sim_duration, restart_frq, nscale, read_meteo_site, read_meteo_daily, &
& read_meteo_hourly, read_lai_site, read_lai
! use controlInput_mod
  USE BEPSTYPE_DIFFV, ONLY : bound, clim, assim
  USE ECORESPMOD_DIFFV, ONLY : plant_resp, soil_resp
  USE MID_RESULTS_DIFFV
  USE BEPS_SOILMOD_DIFFV, ONLY : soil, init_soil_parameters, &
& init_soil_status
  USE BEPS_PAR
  USE OUTPUTMOD_DIFFV, ONLY : output, av_output
  USE RESTART_DIFFV, ONLY : v2last, restart_io
  USE MO_BEPSFUNC_CTL
  IMPLICIT NONE
! arguments
  INTEGER, INTENT(IN) :: n, m
  REAL(kind=8), INTENT(IN) :: x(n)
  REAL(kind=8), INTENT(OUT) :: y(m)
! local declarations
  CHARACTER(len=*), PARAMETER :: sub='evalf_cdv'
  TYPE(CLIMATEDATA) :: meteo
  TYPE(RESULTS) :: mid_res
!! solar zenith angle, local time, local time arc
  REAL(r8) :: coszs, hr_loc, hr_arc
  INTEGER :: i, j, k, jj, ii, kk
!! at single point
  TYPE(SOIL) :: soilp
  REAL(r8) :: ccd(0:4), cssd(0:4), csmd(0:4), cfsd(0:4), cfmd(0:4), csm(&
& 0:4), cm(0:4), cs(0:4), cp(0:4)
  REAL(r8) :: param(0:49), var_o(0:40), var_n(0:40), coef(0:49)
  REAL(r8) :: lai
  REAL(r8) :: ratio_cloud, shortrad_df, shortrad_dir
!-- iLab::similar changes as in driver.F90 by MSWU@2020-09-21
! real(r8)             :: NPP_yr_acc           !! for storing yearly accumulated NPP, Mh/ha/s
! real(r8)             :: agb2vod
! real(r8)             :: D0(1:9)
! real(r8)             :: taweff(1:9)
  INTEGER :: kount, rst_nstep
  INTEGER :: yr, mn, dy, tod, caldy
  INTEGER :: yr_next, mn_next, dy_next, tod_next
  REAL(r8) :: daylen
! .. Parameters for model-internal use
  REAL(r8), SAVE :: pio180=pi/180.
! variables for daily input, used in climin and getmonth
  REAL(r8) :: spds, cpds
! .. Local Arrays
  REAL(r8) :: atmean, atrange
! .. Local Scalars ..
! real(r8)             :: r
  REAL(r8) :: rdaymid, delta, arg, h0, h1, sd, sd1, dhour, tmin, tmp1
  REAL(r8) :: a, b, sunset_arc
!! for counting the time-step number, i.e. ith step
  INTEGER :: nd
!-- iLab::ported from MSWU changes () in driver.f90
!-- index being passed to read_meteo_site
  INTEGER :: n_meteo
! .. Intrinsic Functions ..
  INTRINSIC ACOS, COS, SIN, MOD, ATAN, REAL
!-- counter for 1D simulation vector
  INTEGER :: jcnt
!-- number of days in (actual) year
  INTEGER :: doys
  LOGICAL :: is_end_curr_year, is_end_curr_month, is_end_curr_day, &
& is_first_step
  LOGICAL, SAVE :: bepsf_debug=.false.
  INTRINSIC MIN
  INTRINSIC MAX
  INTRINSIC SUM
  REAL(r8) :: arg1
  REAL(r8) :: arg2
  REAL(r8) :: result1
!-- consistency
  IF (nscale .NE. 1) THEN
    WRITE(*, '(a)') ' FATAL::'//sub//&
&   ':setup was *not* set for site-level!'
    STOP
  ELSE IF (meteo_input .LT. 0) THEN
    WRITE(*, '(a)') ' FATAL::'//sub//&
&   ':for site-level only hourly meteorological input'//' is supported.'
    STOP
  ELSE IF (lai_input .LT. 0) THEN
    WRITE(*, '(a)') ' FATAL::'//sub//&
&   ':for site-level LAI is expected to be forcing input.'
    STOP
  ELSE
! parameters used for calculating VOD,@MOUSONG.WU,2019-11
!-- iLab::similar changes as in driver.F90 by MSWU@2020-09-21
! NPP_yr_acc = 0.
! agb2vod = 0.9517
! D0 = (/0.05,0.05,0.05,0.05,0.05,0.05,0.05,0.05,0.05/)
! taweff = (/15.0, 15.0, 0., 0., 0., 15., 0., 0., 15./)
    output%npp_yr_acc = 0._r8
!-- initialise simulation vector
    y = fillval_r8
!-- map actual control vector to model parameter
    CALL X2BEPS_CDV(n, x)
    jcnt = 1
!! end time loop
!! start time looping
timeloop:DO nd=1,ntp
      yr = time_points(1, nd)
      mn = time_points(2, nd)
      dy = time_points(3, nd)
      tod = time_points(4, nd)
      caldy = time_points(5, nd)
      doys = time_points(6, nd)
      is_first_step = nd .EQ. 1
!--iLab::equations taken from beps_time_manager
      is_end_curr_year = mn .EQ. 1 .AND. dy .EQ. 1 .AND. tod .EQ. 0
      is_end_curr_month = dy .EQ. 1 .AND. tod .EQ. 0
      is_end_curr_day = tod .EQ. 0
      CALL GET_CO2_CONCENTRATION(yr, co2_air)
      CALL GET_COS_CONCENTRATION(yr, cos_air)
!! change hourly input into daily input for further using model for long-term simulations, @MOUSONG.WU, 201905
      IF (meteo_input .GE. 0) THEN
! call hourly meteo. input
        IF (nscale .EQ. 0) THEN
          CALL READ_METEO_HOURLY(yr, mn, dy, tod)
        ELSE
!-- iLab::adapted index (similar to changes in driver.f90 by MSWU,bepspkg_2020-09-21_essi)
          CALL GET_NMETEO_CDV(yr, mn, dy, tod, n_meteo)
          CALL READ_METEO_SITE(n_meteo)
        END IF
      ELSE IF (is_first_step .OR. is_end_curr_day) THEN
        CALL READ_METEO_DAILY(yr, mn, dy, tod)
      END IF
      IF (lai_input .GE. 0) THEN
! print *, 'lai is input!'
        IF (is_first_step .OR. is_end_curr_day) THEN
          IF (nscale .EQ. 0) THEN
            CALL READ_LAI(yr, mn, dy, tod, caldy)
          ELSE
            CALL READ_LAI_SITE(caldy)
          END IF
        END IF
      END IF
! print *, 'lai is simulated with phenology scheme!'
!! end spatial loop
! Reading the Vcmax here for assimilation usage @J.Wang
!if(is_first_step() .or. is_end_curr_month()) then
!   if (nscale == 0) then
!    call read_Vcmax(yr, mn, dy, tod)
!   else
!    call read_Vcmax_site(yr, mn, dy, tod)
!   end if
!end if
!    call mpi_barrier(mpi_comm_world,ierr)
!! spatial iteration
pointloop:DO i=1,npoints
!! calculate the solar zenith
        CALL S_COSZS(yr, mn, dy, tod, caldy, doys, bound%latitude(i), &
&              bound%longitude(i), coszs, hr_loc, hr_arc)
!!if(myid == 0) write(*,*) "hr_loc=",hr_loc
!! retrieve meteo for this point
        meteo%srad = clim%srad(i)
        meteo%wind = clim%wind(i)
        meteo%rainfall = clim%rain(i)
        meteo%snow = clim%snow(i)
        meteo%rh = clim%rh(i)
        IF (meteo_input .LT. 0) THEN
! read daily max and min temperatures instead
          meteo%tempmx = clim%tempmx(i)
          meteo%tempmn = clim%tempmn(i)
        ELSE
          meteo%temp = clim%temp(i)
        END IF
! .. compute daily course of temperature and daylength
        rdaymid = REAL(sim_duration+1)/2.
        arg1 = 2.*pi*(rdaymid+10.)/365.
        delta = -(23.4*COS(arg1))
        arg1 = bound%latitude(i)*pio180
        arg2 = delta*pio180
        spds = SIN(arg1)*SIN(arg2)
        arg1 = bound%latitude(i)*pio180
        arg2 = delta*pio180
        cpds = COS(arg1)*COS(arg2)
        arg = -(spds/cpds)
        IF (arg .GT. 1.) THEN
!        polar night:
          daylen = 0.
        ELSE IF (arg .LT. -1) THEN
!        polar day:
          daylen = 24.
        ELSE
!        normal day / night:
          result1 = ACOS(arg)
          daylen = result1/pi*24.
        END IF
!###########Compute subdaily temperature based on daily input,@MOUSONG.WU,201905#####################
        IF (meteo_input .LT. 0) THEN
! .. compute average conditions
          atmean = (meteo%tempmx+meteo%tempmn)/2.
          atrange = meteo%tempmx - meteo%tempmn
!  hour angle at sunset, added by MOUSONG.WU, 201905
          sunset_arc = daylen/2.*2.0*pi/24.0
          IF (daylen .GE. 4. .AND. daylen .LE. 20.) THEN
!        sunrise
            h0 = 12. - daylen/2.
!        sundown
            h1 = 12. + daylen/2.
!        at sundown:
            arg1 = pi*(2.*h1+(daylen-52.)/2.)/(daylen+4.)
            sd1 = SIN(arg1)
!! unroll zum vektorisieren
            IF (hr_loc .GT. h0 .AND. hr_loc .LT. h1) THEN
              arg1 = pi*(2.*hr_loc+(daylen-52.)/2.)/(daylen+4.)
              sd = SIN(arg1)
              meteo%temp = atmean + atrange/2.*sd
            ELSE
! temperature at sundown
              tmp1 = atmean + atrange/2.*sd1
! hours since sundown
              arg1 = hr_loc - h1 + 24.
              dhour = MOD(arg1, 24.)
              tmin = atmean - atrange/2.
              meteo%temp = tmp1 - (tmp1-tmin)*(dhour/(24.-daylen))
            END IF
          ELSE IF (daylen .GT. 20.) THEN
            arg1 = pi*(hr_loc-14.)/(daylen/2.+2.)
            sd = COS(arg1)
            meteo%temp = atmean + atrange/2.*sd
          ELSE
            meteo%temp = atmean
          END IF
          clim%temp(i) = meteo%temp
! convert daily solar radiation into hourly using the method by M. Collares-Pereira and A. Rabl,
! The average distribution of solar radiation-correlations between diffuse and hemispherical
!and between daily and hourly insolation values, Solar Energy,vol. 22, no. 2, pp. 155164, 1979.
          a = 0.409 + 0.5016*SIN(sunset_arc-60.)
          b = 0.6609 - 0.4767*SIN(sunset_arc-60.)
          meteo%srad = meteo%srad*(a+b*COS(hr_arc))*(pi/24.)*(COS(hr_arc&
&           )-COS(sunset_arc))/(SIN(sunset_arc)-2*pi*sunset_arc/360.*COS&
&           (sunset_arc))
        END IF
! Calculate cloud fraction, separate shortwave radiation
        IF (coszs .LT. 0.001) THEN
          ratio_cloud = 0.
        ELSE
          ratio_cloud = meteo%srad/(1367.*coszs)
        END IF
        IF (ratio_cloud .GT. 0.8) THEN
          shortrad_df = 0.13*meteo%srad
        ELSE
          shortrad_df = (0.943+0.734*ratio_cloud-4.9*ratio_cloud**2+&
&           1.796*ratio_cloud**3+2.058*ratio_cloud**4)*meteo%srad
        END IF
        IF (shortrad_df .GT. meteo%srad) THEN
          shortrad_df = meteo%srad
        ELSE
          shortrad_df = shortrad_df
        END IF
        IF (shortrad_df .LT. 0.) THEN
          shortrad_df = 0.
        ELSE
          shortrad_df = shortrad_df
        END IF
        shortrad_dir = meteo%srad - shortrad_df
        meteo%s_dff = shortrad_df
        meteo%s_dir = shortrad_dir
        clim%swdr(i) = shortrad_dir
        clim%swdf(i) = shortrad_df
!! end PFT loop
!! PFT iteration
pftloop:DO j=1,pft
          IF (bound%lcno(i, j) .GT. 0 .AND. bound%sw(i) .GT. 0. .AND. &
&             bound%stext(i) .GT. 0 .AND. bound%clumping(i) .GT. 0.5) &
&         THEN
            CALL READPARAM(bound%lcno(i, j), param)
            IF (lai_input .GE. 0) THEN
              lai = bound%lai(i, j)
            ELSE IF (is_first_step) THEN
              lai = bound%laiyr(i, j)
              mid_res%lai_old = lai
            ELSE
              lai = mid_res%lai_new
            END IF
            lai = lai*param(2)/bound%clumping(i)
            CALL READCOEF(bound%lcno(i, j), bound%stext(i), coef)
            IF (nsrest .EQ. nsrstartup .AND. is_first_step) THEN
              CALL INIT_SOIL_PARAMETERS(bound%lcno(i, j), bound%stext(i)&
&                                 , param(27), soilp)
!-- iLab::applied similar changes as in driver.F90 (MSWU@2020-09-21)
              soilp%r_drainage = param(26)
! soilp%r_drainage = assim%p_drainage(j)            ! read this
!para from NC file,@MOUSONG.WU,2019-11
              ii = bound%stext(i)
! write(*,*) 'p_Ksat = ',assim%p_Ksat(ii) 
! write(*,*) 'Ksat_old = ',soilp%Ksat(0)
              DO kk=0,4
                soilp%ksat(kk) = assim%p_ksat_scalar(ii)*soilp%ksat(kk)
                soilp%b(kk) = assim%p_b_scalar(ii)*soilp%b(kk)
              END DO
! replace these three para. above with values from nc
! file,@MOUSONG.WU,2019-11
              CALL INIT_SOIL_STATUS(soilp, bound%st(i), clim%temp(i), &
&                             bound%sw(i), bound%sdp(i))
              DO k=0,40
                var_o(k) = 0.
              END DO
              DO k=3,8
                var_o(k) = clim%temp(i)
              END DO
              DO k=9,14
                var_o(k) = soilp%temp_soil_p(k-9)
              END DO
              DO k=21,26
                var_o(k) = soilp%thetam_prev(k-21)
              END DO
              DO k=27,32
                var_o(k) = soilp%ice_ratio(k-27)
              END DO
            ELSE IF (nsrest .EQ. nsrcontinue .AND. is_first_step) THEN
              CALL INIT_SOIL_PARAMETERS(bound%lcno(i, j), bound%stext(i)&
&                                 , param(27), soilp)
!-- iLab::applied similar changes as in driver.F90 (MSWU@2020-09-21)
              soilp%r_drainage = param(26)
! soilp%r_drainage = assim%p_drainage(j)  ! read from nc
!                                         ! file,MOUSONG.WU@2019-11
              ii = bound%stext(i)
              DO kk=0,4
                soilp%ksat(kk) = assim%p_ksat_scalar(ii)*soilp%ksat(kk)
                soilp%b(kk) = assim%p_b_scalar(ii)*soilp%b(kk)
              END DO
!Replace with NC values,for optimization
!purpose,@MOUSONG.WU,2019-11
              var_o(:) = v2last(i, :, j)
              DO k=9,14
                soilp%temp_soil_c(k-9) = var_o(k)
              END DO
              DO k=21,26
                soilp%thetam(k-21) = var_o(k)
              END DO
            ELSE
!                 do k = 27,32
!                    soilp%ice_ratio(k-27)   = var_o(k)
!                 end do
              var_o(:) = v2last(i, :, j)
              CALL RETRIVE_SOILP_CDV(soilp, i, j, 0)
            END IF
!!! simulating photosynthesis
!              do llll = 0,40
!                 write(*,*)  "DG004: Var_o = ",llll, var_o(llll)
!              end do
            CALL INTER_PRG_CDV(yr, mn, dy, tod, lai, lai_input, bound%&
&                        lcno(i, j), bound%clumping(i), assim%p_vcmax(j)&
&                        , assim%p_vj_slope(j), assim%p_f_leaf, assim%&
&                        p_kc25, assim%p_ko25, assim%p_tau25, assim%&
&                        p_sif_alpha(j), assim%p_sif_beta(j), param, &
&                        meteo, coszs, var_o, var_n, soilp, mid_res, &
&                        daylen)
! CHANGE Vcmax read from Vcmax file with the Vcmax read from initial para. NC
! file, for optimization purpose,@MOUSONG.WU,2019-11
!              do llll =0,40
!                write(*,*)  "DG004: Var_n = ",llll,var_n(llll)
!             end do
            v2last(i, :, j) = var_n(:)
            CALL RETRIVE_SOILP_CDV(soilp, i, j, 1)
!!! simluating Ra
            CALL PLANT_RESP(assim%p_q10(j), bound%lcno(i, j), mid_res, &
&                     bound%laiyr(i, j), lai, meteo%temp, soilp%&
&                     temp_soil_c(1), coszs)
!USE p_q10 here to adjust q10,p_q10 is read from initial para. NC file, for
!optimization purpose,@MOUSONG.WU,2019-11
!!! simulating Rh
            ccd(0) = bound%ccd(i, j)
            cssd(0) = bound%cssd(i, j)
            csmd(0) = bound%csmd(i, j)
            cfsd(0) = bound%cfsd(i, j)
            cfmd(0) = bound%cfmd(i, j)
            csm(0) = bound%csm(i, j)
            cm(0) = bound%cm(i, j)
            cs(0) = bound%cm(i, j)
            cp(0) = bound%cp(i, j)
! to get soil texture for this point,@MOUSONG.WU,2019-11
            jj = bound%stext(i)
!-- iLab::similar changes as in driver.F90 (MSWU@2020-09-21),
!         'beta' no longer parameter
            CALL SOIL_RESP(ccd, cssd, csmd, cfsd, cfmd, csm, cm, cs, cp&
&                    , bound%nppyr(i, j), coef, bound%stext(i), soilp, &
&                    mid_res)
! call soil_resp(Ccd,Cssd,Csmd,Cfsd,Cfmd,Csm,Cm,Cs,&
!      Cp,bound%nppyr(i,j),coef,bound%stext(i),assim%p_beta(jj),soilp,mid_res)
! !! use p_beta read from initial para. NC file, to adjust slow
! !carbon pool, for optimization purpose,@MOUSONG.WU,2019-11
! mid_res%COS_grnd2 = mid_res%COS_grnd2 * (mid_res%NPP - mid_res%NEP)
! ! COS_flux_buf = mid_res%COS_plant + max(mid_res%COS_grnd1,mid_res%COS_grnd2)
! mid_res%COS_flux  = mid_res%COS_plant + max(mid_res%COS_grnd1,mid_res%COS_grnd2)
!! for output variables
! remove 100. for site since the PCT_PFT is fraction, @MOUSONG.WU,2019-11
            output%gpppft(i, j) = mid_res%gpp*bound%pct_pft(i, j)/100.
            output%sifpft(i, j) = mid_res%sif*bound%pct_pft(i, j)/100.
            output%npppft(i, j) = mid_res%npp*bound%pct_pft(i, j)/100.
            output%neppft(i, j) = mid_res%nep*bound%pct_pft(i, j)/100.
            output%shpft(i, j) = mid_res%sh*bound%pct_pft(i, j)/100.
            output%lhpft(i, j) = mid_res%lh*bound%pct_pft(i, j)/100.
            output%transpft(i, j) = mid_res%trans*bound%pct_pft(i, j)/&
&             100.
            output%evappft(i, j) = mid_res%evap*bound%pct_pft(i, j)/100.
            output%net_radpft(i, j) = mid_res%net_rad*bound%pct_pft(i, j&
&             )/100.
            output%laipft(i, j) = lai*bound%pct_pft(i, j)/100.
            output%thetampft(i, j) = mid_res%thetam_surf*bound%pct_pft(i&
&             , j)/100.
            output%faparpft(i, j) = mid_res%fapar*bound%pct_pft(i, j)/&
&             100.
!-- iLab::COS_flux computation now similar as in driver.F90 (MSWU@2020-09-21)
            output%cos_fluxpft(i, j) = (mid_res%cos_plant+mid_res%&
&             cos_grnd)*bound%pct_pft(i, j)/100.
!-- iLab::annual NPP, VOD computation now similar as in driver.F90 (MSWU@2020-09-21)
! convert NPP to Mg/ha for calculation of VOD
            output%npp_yr_acc(i, j) = output%npp_yr_acc(i, j) + mid_res%&
&             npp*bound%pct_pft(i, j)/100.*1.e-2*step
            IF (is_end_curr_year) THEN
! calculate VOD (vegetation optical depth) with results derived from SMOS-IC product, @Mousong.Wu, 201905,taweff is a PFT specifi
!c parameter
              arg1 = assim%p_taweff(j)*output%npp_yr_acc(i, j)
              output%vodpft(i, j) = assim%p_agb2vod*ATAN(arg1) + assim%&
&               p_d0(j)*lai
              output%npp_yr_acc(i, j) = 0.
!                  write(*,*) 'VOD= ',output%VODpft(i,j)
            ELSE
              output%vodpft(i, j) = 0.
            END IF
! write(*,*) 'hr_loc = ', hr_loc
!! calculate the OCO-2 SIF   across at 1:30pm
!write(*,*) 'SIFpft= ',mid_res%SIF*bound%PCT_PFT(i,j)/100. 
            IF (hr_loc .GE. 13. .AND. hr_loc .LT. 14.) THEN
              output%sifpft_sat(i, j) = mid_res%sif*bound%pct_pft(i, j)/&
&               100.
            ELSE
              output%sifpft_sat(i, j) = 0.
            END IF
          END IF
        END DO pftloop
!output%SIFpft_sat(i,j) = max(output%SIFpft_sat(i,j),0.)
!write(*,*) 'SIFpft_sat = ', output%SIFpft_sat(i,j)
        output%gpp(i) = SUM(output%gpppft(i, :))
        output%sif(i) = SUM(output%sifpft(i, :))
        output%sif_sat(i) = SUM(output%sifpft_sat(i, :))
        output%npp(i) = SUM(output%npppft(i, :))
        output%nep(i) = SUM(output%neppft(i, :))
        output%sh(i) = SUM(output%shpft(i, :))
        output%lh(i) = SUM(output%lhpft(i, :))
        output%trans(i) = SUM(output%transpft(i, :))
        output%evap(i) = SUM(output%evappft(i, :))
        output%net_rad(i) = SUM(output%net_radpft(i, :))
        output%lai(i) = SUM(output%laipft(i, :))
        output%thetam(i) = SUM(output%thetampft(i, :))
        output%fapar(i) = SUM(output%faparpft(i, :))
        output%vod(i) = SUM(output%vodpft(i, :))
        output%cos_flux(i) = SUM(output%cos_fluxpft(i, :))
!--iLab::mapping to target vector:SIF/Thetam/COSflux ->per time ->per point
!        (see mo_bepsfunc_ctl.f90 for order of simulated BEPS quantities)
        y(jcnt) = output%sif(i)
        y(jcnt+1) = output%thetam(i)
        y(jcnt+2) = output%cos_flux(i)
        jcnt = jcnt + 3
      END DO pointloop
    END DO timeloop
!          call mpi_barrier(mpi_comm_world,ierr)
!--iLab::target vector should have been written completely (dimension consistency)!
    IF (jcnt - 1 .NE. m) WRITE(*, '(a,2(a,i4,1x))') &
&                   ' FATAL::dimension inconsistency for target mapping'&
&                        , 'expected m=', m, 'got jcnt=', jcnt
  END IF
END SUBROUTINE EVALF_CDV

!! Last update: July,2015
!! Fortran version: 3/5/2017 @J.Wang
SUBROUTINE INTER_PRG_CDV(yr, mn, dy, tod, lai, lai_input, lc, clumping, &
& vcmax0, vj_slope, f_leaf, p_kc25, p_ko25, p_tau25, sif_alpha, sif_beta&
& , param, meteo, coszs, var_o, var_n, soilp, mid_res, daylen)
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
!--iLab::restrict use of beps_time_manager to required entities  
!--iLab-update::extended arguments to avoid time manager completely
! use beps_time_manager, only:is_end_curr_day, get_curr_date
  USE BEPS_SOILMOD_DIFFV
  USE BEPSTYPE_DIFFV
  USE MID_RESULTS_DIFFV
  USE BEPS_PAR
  USE ANGSMOD_DIFFV
  USE RAINSNOWMOD_DIFFV
  IMPLICIT NONE
!--iLab::added date-elements as argument to avoid 'call get_curr_date' further below
  INTEGER, INTENT(IN) :: yr, mn, dy, tod
  INTEGER, INTENT(IN) :: lc
!!J.Wang
  REAL(r8), INTENT(IN) :: clumping, vcmax0, vj_slope, f_leaf, p_ko25, &
& p_kc25, p_tau25, sif_alpha, sif_beta, coszs, daylen
  REAL(r8), INTENT(IN) :: param(0:49)
  TYPE(CLIMATEDATA), INTENT(IN) :: meteo
  REAL(r8), INTENT(IN) :: var_o(0:40)
  REAL(r8), INTENT(OUT) :: var_n(0:40)
  REAL(r8), INTENT(INOUT) :: lai
  TYPE(SOIL) :: soilp
  TYPE(RESULTS) :: mid_res
  INTEGER, INTENT(IN) :: lai_input
!real(r8),intent(out) :: gs_h2o,G_o_b
  INTEGER :: num, kkk, i, j
  INTEGER, PARAMETER :: iter_max=20
  INTEGER :: landcover
  REAL(r8) :: lai_o, lai_u, stem_o, stem_u
  REAL(r8) :: d_soil(0:layer)
!the depth of snow on the surface
  REAL(r8) :: zsp
!depth of pounded water on the surface
  REAL(r8) :: zp
  REAL(r8), SAVE :: zp1=0.
  REAL(r8), SAVE :: zp2=0.
!height of the Va measured for calculation of L
  REAL(r8) :: height_wind_sp
!sensible heating
  REAL(r8) :: qhc_o(0:iter_max), qhc_u(0:iter_max), qhg(0:iter_max)
!the heat flux into the canopy of over story --in W/m^2
  REAL(r8) :: g(0:layer+1, 0:iter_max)
!the masses od rain and snow on the canopy
  REAL(r8) :: wcl_o(0:iter_max), wcs_o(0:iter_max)
!the fractoion of canopy coverd by liquid water and snow
  REAL(r8) :: xcl_o(0:iter_max), xcs_o(0:iter_max)
  REAL(r8) :: wcl_u(0:iter_max), wcs_u(0:iter_max)
  REAL(r8) :: xcl_u(0:iter_max), xcs_u(0:iter_max)
!the rainfall rate on ground surface m/s
  REAL(r8) :: r_rain_g(0:iter_max)
!density of snow
  REAL(r8) :: rho_snow(0:iter_max)
!albedo of snow
  REAL(r8) :: alpha_v_sw(0:iter_max), alpha_n_sw(0:iter_max)
! amount of snow on ground
  REAL(r8) :: wg_snow(0:iter_max)
! fraction of the ground surface overed by snow
  REAL(r8) :: xg_snow(0:iter_max)
! area of canopy covered by snow
  REAL(r8) :: ac_snow_o(0:iter_max), ac_snow_u(0:iter_max)
!surface temperature
  REAL(r8) :: ts0(0:iter_max), tsn0(0:iter_max), tsm0(0:iter_max), tsn1(&
& 0:iter_max), tsn2(0:iter_max)
!effective canopy temperature in K
  REAL(r8) :: tc_u(0:iter_max)
!soil temperature at the bottom and middle of each layer
  REAL(r8) :: tm(0:layer+1, 0:iter_max)
!thermal conductivity of each soil layer
  REAL(r8) :: lambda_soil(0:layer+1)
! soil volumetric hear capacity of each soil layer J/m3/K
  REAL(r8) :: cs(0:layer+1, 0:iter_max)
  REAL(r8) :: temp_air, temp_grd
!%,m/s,m/s @J.Wang  make original precipitation into rainfall and snow
  REAL(r8) :: rh_air, wind_sp, snow, rainfall
!the evaporation rate of intercepted water of overstory--in kg/m^2/s
  REAL(r8) :: eil_o(0:iter_max), eis_o(0:iter_max)
  REAL(r8) :: eil_u(0:iter_max), eis_u(0:iter_max)
!transpiration
  REAL(r8) :: trans_o(0:iter_max), trans_u(0:iter_max)
  REAL(r8) :: evap_soil(0:iter_max)
!evaporation from water pond
  REAL(r8) :: evap_sw(0:iter_max)
!evaporation from snow pack
  REAL(r8) :: evap_ss(0:iter_max)
!effective thermal conductivity of snow in m2/s
  REAL(r8) :: lambda_snow(0:iter_max)
! vapour partial pressure of water in kPa
  REAL(r8) :: e_a10
! the latent heat of vaporation from liquid at air temperature=Ta
  REAL(r8) :: lv_liquid
! the latent heat of vaporation from solid (snow/ice) at air temperature
  REAL(r8), SAVE :: lv_solid=2.83*1e6
! instantaneous total short wave radiation (Global radiation)
  REAL(r8) :: ks
  REAL(r8) :: alpha_sat, alpha_dry
!visible albedo of overstory,  o--overstory, u--understory
  REAL(r8) :: alpha_v_o, alpha_v_u
!near_infrared albedo
  REAL(r8) :: alpha_n_o, alpha_n_u
! all-wave ground surface albedo
  REAL(r8) :: alpha_g
  REAL(r8) :: alpha_v_g, alpha_n_g
! specific heat of moist air above the canopy
  REAL(r8) :: cp_ca
! the aerodynamic resistance of overstory, understory and ground surface
  REAL(r8) :: ra_o, ra_u, ra_g
! actural canopy stomatal resistance  --in s/m
  REAL(r8) :: q_ca
  REAL(r8) :: radiation_o, radiation_u, radiation_g
!the cumulative infiltration at the time of ponding   --in m/s
  REAL(r8), SAVE :: ip=0.
  REAL(r8), SAVE :: infil=0.
  REAL(r8), SAVE :: zr=0.8
  REAL(r8), SAVE :: cpd=1004.65
  REAL(r8) :: cs_o_sunlit_old, cs_o_shaded_old, cs_u_sunlit_old, &
& cs_u_shaded_old
! CO2 concentration on the surfaces of leaves
  REAL(r8) :: coss_o_sunlit_old, coss_o_shaded_old, coss_u_sunlit_old, &
& coss_u_shaded_old
! COS concentration on the surfaces of leaves
  REAL(r8) :: tc_o_sunlit_old, tc_o_shaded_old, tc_u_sunlit_old, &
& tc_u_shaded_old
! the effective canopy temperature in K
  REAL(r8) :: gs_o_sunlit_new, gs_o_shaded_new, gs_u_sunlit_new, &
& gs_u_shaded_new
!stomatal conductance of the big leaf     for water
  REAL(r8) :: gs_o_sunlit_old, gs_o_shaded_old, gs_u_sunlit_old, &
& gs_u_shaded_old
! net photosynthesis rate
  REAL(r8) :: ac_o_sunlit, ac_o_shaded, ac_u_sunlit, ac_u_shaded
  REAL(r8) :: cs_o_sunlit_new, cs_o_shaded_new, cs_u_sunlit_new, &
& cs_u_shaded_new
! CO2 concentration on the surfaces of     leaves
  REAL(r8) :: coss_o_sunlit_new, coss_o_shaded_new, coss_u_sunlit_new, &
& coss_u_shaded_new
! COS concentration on the surfaces of     leaves
  REAL(r8) :: ci_o_sunlit_new, ci_o_shaded_new, ci_u_sunlit_new, &
& ci_u_shaded_new
! intercellular CO2 concentration pn th    e leaf
  REAL(r8) :: cosi_o_sunlit_new, cosi_o_shaded_new, cosi_u_sunlit_new, &
& cosi_u_shaded_new
! intercellular COS concentration pn the leaf
  REAL(r8) :: ci_o_sunlit_old, ci_o_shaded_old, ci_u_sunlit_old, &
& ci_u_shaded_old
  REAL(r8) :: cosi_o_sunlit_old, cosi_o_shaded_old, cosi_u_sunlit_old, &
& cosi_u_shaded_old
  REAL(r8) :: cc_o_sunlit_new, cc_o_shaded_new, cc_u_sunlit_new, &
& cc_u_shaded_new
! CO2 concentration in the chloroplast
  REAL(r8) :: cosc_o_sunlit_new, cosc_o_shaded_new, cosc_u_sunlit_new, &
& cosc_u_shaded_new
! COS concentration in the chloroplast
  REAL(r8) :: tc_o_sunlit_new, tc_o_shaded_new, tc_u_sunlit_new, &
& tc_u_shaded_new
! the effective canopy temperature in K
! an emperical parameter describin    g the relative availability of soil water for plants
  REAL(r8) :: f_soilwater
! the total conductance for water from     the intercellular space of the leaves to the reference height above the canopy
  REAL(r8) :: gw_o_sunlit, gw_o_shaded, gw_u_sunlit, gw_u_shaded
! the total conductance for CO2 from th    e intercellular space of the leaves to the reference height above the canopy
  REAL(r8) :: gc_o_sunlit, gc_o_shaded, gc_u_sunlit, gc_u_shaded
! the total conductance for water from     the surface of the leaves to the reference height above the canopy
  REAL(r8) :: gww_o_sunlit, gww_o_shaded, gww_u_sunlit, gww_u_shaded
!total conductance for heat transfer f    rom the leaf surface to the reference height above the canopy
  REAL(r8) :: gh_o_sunlit, gh_o_shaded, gh_u_sunlit, gh_u_shaded
  REAL(r8) :: psychrometer
!solar radiation absorbed by sunlit, s    haded leaves
  REAL(r8) :: r_o_sunlit, r_o_shaded, r_u_sunlit, r_u_shaded
  REAL(r8) :: tco, tcu, slope
!sensible heat flux from leaves
  REAL(r8) :: h_o_sunlit, h_o_shaded
  REAL(r8) :: lai_o_sunlit, lai_o_shaded, lai_u_sunlit, lai_u_shaded
  REAL(r8) :: laio_sunlit, laio_shaded, laiu_sunlit, laiu_shaded
! net radiation of leaves
  REAL(r8) :: radiation_o_sun, radiation_o_shaded, radiation_u_sun, &
& radiation_u_shaded
  REAL(r8) :: gpp_o_sunlit, gpp_o_shaded, gpp_u_sunlit, gpp_u_shaded
!canopy level
  REAL(r8) :: sif_o_sunlit, sif_o_shaded, sif_u_sunlit, sif_u_shaded
!leaf level
  REAL(r8) :: lsif_o_sunlit, lsif_o_shaded, lsif_u_sunlit, lsif_u_shaded
!scat
  REAL(r8) :: stsif_o_sunlit, stsif_o_shaded, stsif_u_sunlit, &
& stsif_u_shaded
  REAL(r8) :: cos_o_sunlit, cos_o_shaded, cos_u_sunlit, cos_u_shaded
  REAL(r8) :: lcos_o_sunlit, lcos_o_shaded, lcos_u_sunlit, lcos_u_shaded
  REAL(r8) :: vps_air
  REAL(r8) :: gs_h2o
  REAL(r8) :: gh_o, g_o_a, g_o_b, g_u_a, g_u_b
  REAL(r8) :: canopyh_o, canopyh_u
  REAL(r8) :: vpd_air
  REAL(r8) :: mass_water_g
  REAL(r8) :: percentarea_snow_o, percentarea_snow_u
  REAL(r8) :: gheat_g
!the intercept term in BWB model (mol H2O m-2 s-1)
  REAL(r8) :: b_h2o
! the slope in BWB model
  REAL(r8) :: m_h2o
!leaf latent heat flux (mol/m2/s)
  REAL(r8) :: leleaf_o_sunlit, leleaf_o_shaded, leleaf_u_sunlit, &
& leleaf_u_shaded
!for the Vcmax-Nitrogen calculation
  REAL(r8), SAVE :: kn=0.3
  REAL(r8), SAVE :: g_theta=0.5
!real(r8)             :: K,Vcmax0,Vcmax_sunlit,Vcmax_shaded,expr1,expr2,expr3
!Vcmax0 as an input from outside
  REAL(r8) :: k, vcmax_sunlit, vcmax_shaded, expr1, expr2, expr3
  REAL(r8) :: slope_vcmax_n, leaf_n, jmax_sunlit, jmax_shaded
! for SIF simulation @JWang
  REAL(r8) :: ffpa
! for storing daily mean temperature
  REAL(r8) :: temp_day
! for storing daily mean surface soil moisture
  REAL(r8) :: theta_day
! for storing daily mean transpiration
  REAL(r8) :: trans_day
  REAL(r8) :: cosa
  REAL(r8) :: cos_soil
!--iLab::introduced to avoid calling is_end_curr_day() from beps_time_manager
  LOGICAL :: is_end_curr_day
  INTRINSIC EXP
  INTRINSIC INT
  INTRINSIC MAX
  INTRINSIC MIN
  INTRINSIC ABS
  REAL(r8) :: abs0
  REAL(r8) :: abs1
  REAL(r8) :: abs2
  REAL(r8) :: abs3
  REAL(r8) :: arg1
  REAL(r8) :: arg2
!--iLab: taken from BEPS time manager
  is_end_curr_day = tod .EQ. 0
  temp_day = 0.
  theta_day = 0.
  trans_day = 0.
  psychrometer = 0.066
  alpha_sat = param(24)
  alpha_dry = param(25)
! to be used for module aerodynamic_conductance
  canopyh_o = param(29)
  canopyh_u = param(30)
  height_wind_sp = param(31)
!height_wind_sp   = 30.
! used for photosynthesis
  m_h2o = param(33)
  b_h2o = param(34)
!-- iLab::g2_h2o is *only* set from other routines in case 'CosZs>0.',
!         so we *must* initialise it and have uncommented the initialiser
!         that was already present.
  gs_h2o = 0.
!gs_h2o      = 0.
! Vcmax-Nitrogen calculations by G,Mo 2011.04
  IF (coszs .GT. 0.) THEN
    k = g_theta*clumping/coszs
!   Vcmax0  = param(36)    !an input from outside @J.Wang
    IF (k .GT. 10.) THEN
!! adjust K range here to get rid of floating-point exceptions,@MOUSONG.WU
      expr1 = 1.
      expr2 = 1.
    ELSE
      arg1 = -(k*lai)
      expr1 = 1. - EXP(arg1)
      arg1 = -(lai*(kn+k))
      expr2 = 1. - EXP(arg1)
    END IF
    arg1 = -(kn*lai)
    expr3 = 1. - EXP(arg1)
    IF (expr1 .GT. 0.) THEN
      vcmax_sunlit = vcmax0*param(47)*param(46)*k*expr2/(kn+k)/expr1
    ELSE
      vcmax_sunlit = vcmax0
    END IF
    IF (k .GT. 0 .AND. lai .GT. expr1/k) THEN
      vcmax_shaded = vcmax0*param(47)*param(46)*(expr3/kn-expr2/(kn+k))/&
&       (lai-expr1/k)
    ELSE
      vcmax_shaded = vcmax0
    END IF
  END IF
!! LAI calculation module by B.Chen
  lai_o = lai
  IF (lai .LT. 0.1) lai_o = 0.1
  landcover = INT(param(4))
! Calculate ffpa as a function of lai, this makes the ffpa vary with time, instead of being a constant as below,@MOUSONG WU, 2020
!-09-14
  ffpa = 1. - EXP(-(0.45*lai))
  IF (1.e-2 .LT. ffpa) THEN
    ffpa = ffpa
  ELSE
    ffpa = 1.e-2
  END IF
  IF (1.0 .GT. ffpa) THEN
    ffpa = ffpa
  ELSE
    ffpa = 1.0
  END IF
! added for sif simulation @J. Wang
!select case (landcover)
!   case (1)    !conifer evergreen
!    ffpa = 0.6
!   case(2)      !conifer decidous
!    ffpa = 0.6
!   case(6)      !broadleaf decidous
!    ffpa = 0.8
!   case(9)      !broadleaf evergreen
!    ffpa = 0.8
!   case(10)     !mix
!    ffpa = 0.4
!   case(13)     !shrub
!    ffpa = 0.8
!   case(14)     ! grass
!    ffpa = 0.8
!   case(15)     ! crop
!    ffpa = 0.6
!   case(40)     ! c4 grass
!    ffpa = 0.6  
!   case(41)     ! C4 crop
!    ffpa = 0.6
!end select
!if(landcover == 25 .or. landcover ==40) then
  IF (((landcover .EQ. 14 .OR. landcover .EQ. 15) .OR. landcover .EQ. 40&
&     ) .OR. landcover .EQ. 41) THEN
!14->grass 15->crop @JWang
    lai_u = 0.01
  ELSE
    arg1 = -(0.99*lai_o)
    lai_u = 1.18*EXP(arg1)
  END IF
  IF (lai_u .GT. lai_o) lai_u = 0.01
  stem_o = param(8)*0.2
  stem_u = param(9)*0.2
!Bing Chen
  CALL LAI_CAL(stem_o, stem_u, landcover, coszs, lai_o, clumping, lai_u&
&        , laio_sunlit, laio_shaded, laiu_sunlit, laiu_shaded, &
&        lai_o_sunlit, lai_o_shaded, lai_u_sunlit, lai_u_shaded)
!-------initalization of this time step
  ks = meteo%srad
  rh_air = meteo%rh
  wind_sp = meteo%wind
!m/s   liquid water
  rainfall = meteo%rainfall
!m/s   snow
  snow = meteo%snow
  temp_air = meteo%temp
  IF (ks .LE. 0) THEN
    alpha_v_o = 0.
    alpha_n_o = 0.
    alpha_v_u = 0.
    alpha_n_u = 0.
  ELSE
    alpha_v_o = param(22)
    alpha_n_o = param(23)
    alpha_v_u = param(22)
    alpha_n_u = param(23)
  END IF
  qhc_o(0) = var_o(1)
  ts0(0) = var_o(3)
  IF (ts0(0) - temp_air .GT. 2.0) ts0(0) = temp_air + 2.0
  IF (ts0(0) - temp_air .LT. -2.0) ts0(0) = temp_air - 2.0
  tsn0(0) = var_o(4)
  IF (tsn0(0) - temp_air .GT. 2.0) tsn0(0) = temp_air + 2.0
  IF (tsn0(0) - temp_air .LT. -2.0) tsn0(0) = temp_air - 2.0
  tsm0(0) = var_o(5)
  IF (tsm0(0) - temp_air .GT. 2.) tsm0(0) = temp_air + 2.0
  IF (tsm0(0) - temp_air .LT. -2.) tsm0(0) = temp_air - 2.0
  tsn1(0) = var_o(6)
  IF (tsn1(0) - temp_air .GT. 2.0) tsn1(0) = temp_air + 2.0
  IF (tsn1(0) - temp_air .LT. -2.) tsn1(0) = temp_air - 2.0
  tsn2(0) = var_o(7)
  IF (tsn2(0) - temp_air .GT. 2.0) tsn2(0) = temp_air + 2.0
  IF (tsn2(0) - temp_air .LT. -2.) tsn2(0) = temp_air - 2.0
!the mass of intercepted liquid water and snow, overstory
  wcl_o(0) = var_o(15)
  wcs_o(0) = var_o(16)
  wcl_u(0) = var_o(18)
  wcs_u(0) = var_o(19)
!  fraction of ground surface covered by snow and snow mass
  wg_snow(0) = var_o(20)
  soilp%zsp = var_o(33)
  soilp%zp = var_o(34)
  soilp%r_rain_g = var_o(35)
!-- iLab::*must* at least initialise arrays for complete number of iterations
!          (and not only the first element),
!         since elements are input/output(!) arguments to called routines
!         (snowpack_stage1,netRadiation)
  ac_snow_o(0:iter_max) = var_o(36)
  ac_snow_u(0:iter_max) = var_o(37)
  rho_snow(0:iter_max) = var_o(38)
  alpha_v_sw(0:iter_max) = var_o(39)
  alpha_n_sw(0:iter_max) = var_o(40)
! Ac_snow_o(0)    = var_o(36)
! Ac_snow_u(0)    = var_o(37)
! rho_snow(0)     = var_o(38)
! alpha_v_sw(0)   = var_o(39)
! alpha_n_sw(0)   = var_o(40)
  zsp = soilp%zsp
  zp = soilp%zp
  IF (zp .LT. 0.001) zp = 0.
!if(Zp < 1.e-6) Zp = 0.
  DO i=9,14
    soilp%temp_soil_p(i-9) = var_o(i)
  END DO
  DO i=21,26
    soilp%thetam_prev(i-21) = var_o(i)
  END DO
  DO i=27,32
    soilp%ice_ratio(i-27) = var_o(i)
  END DO
! vcmax jmax module  by L. He
  slope_vcmax_n = param(47)
  leaf_n = param(46)
  CALL VCMAX_JMAX(lai_o, clumping, vcmax0, vj_slope, slope_vcmax_n, &
&           leaf_n, coszs, vcmax_sunlit, vcmax_shaded, jmax_sunlit, &
&           jmax_shaded)
! temperatures of overstorey and understorey canopies
  tc_o_sunlit_old = temp_air - 0.5
  tc_o_shaded_old = temp_air - 0.5
  tc_u_sunlit_old = temp_air - 0.5
  tc_u_shaded_old = temp_air - 0.5
!sub-time iteration @J.Wang
  DO kkk=1,kloop
! Snow pack stage 1  by R.Luo
    CALL SNOWPACK_STAGE1(temp_air, snow, wcs_o(kkk-1), wcs_u(kkk-1), &
&                  wg_snow(kkk-1), rho_snow(kkk-1), ac_snow_o(kkk-1), &
&                  ac_snow_u(kkk-1), wcs_o(kkk), wcs_u(kkk), wg_snow(kkk&
&                  ), lai_o, lai_u, clumping, ac_snow_o(kkk), ac_snow_u(&
&                  kkk), xcs_o(kkk), xcs_u(kkk), xg_snow(kkk), rho_snow(&
&                  kkk), zsp, alpha_v_sw(kkk), alpha_n_sw(kkk))
!    write(*,*) "DG01: Ac_snow_o(kkk) =",Ac_snow_o(kkk)
! rainfall stag 1
    CALL RAINFALL_STAGE1(temp_air, rainfall, wcl_o(kkk-1), wcl_u(kkk-1)&
&                  , lai_o, lai_u, clumping, wcl_o(kkk), wcl_u(kkk), &
&                  xcl_o(kkk), xcl_u(kkk), r_rain_g(kkk))
    IF (soilp%thetam_prev(1) .LT. soilp%theta_vwp(1)*0.5) THEN
      alpha_g = alpha_dry
    ELSE
      alpha_g = (soilp%thetam_prev(1)-soilp%theta_vwp(1)*0.5)/(soilp%fei&
&       (1)-soilp%theta_vwp(1)*0.5)*(alpha_sat-alpha_dry) + alpha_dry
    END IF
    alpha_v_g = 2./3.*alpha_g
    alpha_n_g = 4./3.*alpha_g
! soil water factor module
    CALL SOIL_WATER_FACTOR_V2(soilp)
    f_soilwater = soilp%f_soilwater
    IF (f_soilwater .GT. 1.0) f_soilwater = 1.0
!used as the init. for module aerodynamic_conductance
    gh_o = qhc_o(kkk-1)
    arg1 = 17.3*temp_air/(237.3+temp_air)
    vps_air = 0.61078*EXP(arg1)
    e_a10 = vps_air*rh_air/100.
!water vapor deficit at the reference height @J.Wang maybe directly use meteo_pack
    vpd_air = vps_air - e_a10
!g/g  no dimention
    q_ca = 0.622*e_a10/(101.35-0.378*e_a10)
    cp_ca = cpd*(1.+0.84*q_ca)
    arg1 = 17.27*temp_air/(temp_air+237.3)
    slope = 2503.0/(temp_air+237.3)**2*EXP(arg1)
    gs_o_sunlit_old = 1./200.0
    ci_o_sunlit_old = 0.7*co2_air
    gs_o_shaded_old = 1./200.0
    ci_o_shaded_old = 0.7*co2_air
    gs_u_sunlit_old = 1./300.0
    ci_u_sunlit_old = 0.7*co2_air
    gs_u_shaded_old = 1./300.0
    ci_u_shaded_old = 0.7*co2_air
    cosi_o_sunlit_old = 0.7*cos_air
    cosi_o_shaded_old = 0.7*cos_air
    cosi_u_sunlit_old = 0.7*cos_air
    cosi_u_shaded_old = 0.7*cos_air
    percentarea_snow_o = ac_snow_o(kkk)/lai_o/2.
    percentarea_snow_u = ac_snow_u(kkk)/lai_u/2.
!ground temperature substituted by air temperature
    temp_grd = temp_air
    num = 0
    DO WHILE (.true.)
      num = num + 1
! aerodynamic_conductance module by G.Mo
      arg1 = lai_o + stem_o
      arg2 = lai_u + stem_u
      CALL AERODYNAMIC_CONDUCTANCE(canopyh_o, canopyh_u, height_wind_sp&
&                            , clumping, temp_air, wind_sp, gh_o, arg1, &
&                            arg2, ra_o, ra_u, ra_g, g_o_a, g_o_b, g_u_a&
&                            , g_u_b)
!heat conductance of sunlit leaves of overstorey
      gh_o_sunlit = 1.0/(1.0/g_o_a+0.5/g_o_b)
      gh_o_shaded = 1.0/(1.0/g_o_a+0.5/g_o_b)
      gh_u_sunlit = 1.0/(1.0/g_u_a+0.5/g_u_b)
      gh_u_shaded = 1.0/(1.0/g_u_a+0.5/g_u_b)
! conductance for intercepted water of sunlit leaves of overstorey
      gww_o_sunlit = 1.0/(1.0/g_o_a+1.0/g_o_b+100.)
      gww_o_shaded = 1.0/(1.0/g_o_a+1.0/g_o_b+100.)
      gww_u_sunlit = 1.0/(1.0/g_u_a+1.0/g_u_b+100.)
      gww_u_shaded = 1.0/(1.0/g_u_a+1.0/g_u_b+100.)
! temperatures of overstorey and understorey canopies
      tco = (tc_o_sunlit_old*lai_o_sunlit+tc_o_shaded_old*lai_o_shaded)/&
&       (lai_o_sunlit+lai_o_shaded)
      tcu = (tc_u_sunlit_old*lai_u_sunlit+tc_u_shaded_old*lai_u_shaded)/&
&       (lai_u_sunlit+lai_u_shaded)
! net Radiation at canopy and leaf level module by X.Luo
      arg1 = lai_o + stem_o
      arg2 = lai_u + stem_u
      CALL NETRADIATION_CDV(meteo%s_dff, meteo%s_dir, coszs, tco, tcu, &
&                     temp_grd, lai_o, lai_u, arg1, arg2, lai_o_sunlit, &
&                     lai_o_shaded, lai_u_sunlit, lai_u_shaded, clumping&
&                     , temp_air, rh_air, alpha_v_sw(kkk), alpha_n_sw(&
&                     kkk), percentarea_snow_o, percentarea_snow_u, &
&                     xg_snow(kkk), alpha_v_o, alpha_n_o, alpha_v_u, &
&                     alpha_n_u, alpha_v_g, alpha_n_g, radiation_o, &
&                     radiation_u, radiation_g, radiation_o_sun, &
&                     radiation_o_shaded, radiation_u_sun, &
&                     radiation_u_shaded, r_o_sunlit, r_o_shaded, &
&                     r_u_sunlit, r_u_shaded)
! photosynthesis module by B. Chen
!conductance of sunlit leaves of overstorey for water
      gw_o_sunlit = 1.0/(1.0/g_o_a+1.0/g_o_b+1.0/gs_o_sunlit_old)
      gw_o_shaded = 1.0/(1.0/g_o_a+1.0/g_o_b+1.0/gs_o_shaded_old)
      gw_u_sunlit = 1.0/(1.0/g_u_a+1.0/g_u_b+1.0/gs_u_sunlit_old)
      gw_u_shaded = 1.0/(1.0/g_u_a+1.0/g_u_b+1.0/gs_u_shaded_old)
      leleaf_o_sunlit = gw_o_sunlit*(vpd_air+slope*(tc_o_sunlit_old-&
&       temp_air))*rho_a*cp_ca/psychrometer
      leleaf_o_shaded = gw_o_shaded*(vpd_air+slope*(tc_o_shaded_old-&
&       temp_air))*rho_a*cp_ca/psychrometer
      leleaf_u_sunlit = gw_u_sunlit*(vpd_air+slope*(tc_u_sunlit_old-&
&       temp_air))*rho_a*cp_ca/psychrometer
      leleaf_u_shaded = gw_u_shaded*(vpd_air+slope*(tc_u_shaded_old-&
&       temp_air))*rho_a*cp_ca/psychrometer
      IF (coszs .GT. 0.) THEN
        CALL PHOTOSYNTHESIS(landcover, tc_o_sunlit_old, f_leaf, p_kc25, &
&                     p_ko25, p_tau25, r_o_sunlit, e_a10, g_o_b, &
&                     vcmax_sunlit, vj_slope, f_soilwater, b_h2o, m_h2o&
&                     , ci_o_sunlit_old, temp_air, leleaf_o_sunlit, &
&                     gs_o_sunlit_new, gs_h2o, ac_o_sunlit, &
&                     ci_o_sunlit_new, ffpa, sif_alpha, sif_beta, &
&                     lsif_o_sunlit, cosi_o_sunlit_old, &
&                     cosi_o_sunlit_new, lcos_o_sunlit)
        CALL PHOTOSYNTHESIS(landcover, tc_o_shaded_old, f_leaf, p_kc25, &
&                     p_ko25, p_tau25, r_o_shaded, e_a10, g_o_b, &
&                     vcmax_shaded, vj_slope, f_soilwater, b_h2o, m_h2o&
&                     , ci_o_shaded_old, temp_air, leleaf_o_shaded, &
&                     gs_o_shaded_new, gs_h2o, ac_o_shaded, &
&                     ci_o_shaded_new, ffpa, sif_alpha, sif_beta, &
&                     lsif_o_shaded, cosi_o_shaded_old, &
&                     cosi_o_shaded_new, lcos_o_shaded)
        CALL PHOTOSYNTHESIS(landcover, tc_u_sunlit_old, f_leaf, p_kc25, &
&                     p_ko25, p_tau25, r_u_sunlit, e_a10, g_u_b, &
&                     vcmax_sunlit, vj_slope, f_soilwater, b_h2o, m_h2o&
&                     , ci_u_sunlit_old, temp_air, leleaf_u_sunlit, &
&                     gs_u_sunlit_new, gs_h2o, ac_u_sunlit, &
&                     ci_u_sunlit_new, ffpa, sif_alpha, sif_beta, &
&                     lsif_u_sunlit, cosi_u_sunlit_old, &
&                     cosi_u_sunlit_new, lcos_u_sunlit)
        CALL PHOTOSYNTHESIS(landcover, tc_u_shaded_old, f_leaf, p_kc25, &
&                     p_ko25, p_tau25, r_u_shaded, e_a10, g_u_b, &
&                     vcmax_shaded, vj_slope, f_soilwater, b_h2o, m_h2o&
&                     , ci_u_shaded_old, temp_air, leleaf_u_shaded, &
&                     gs_u_shaded_new, gs_h2o, ac_u_shaded, &
&                     ci_u_shaded_new, ffpa, sif_alpha, sif_beta, &
&                     lsif_u_shaded, cosi_u_shaded_old, &
&                     cosi_u_shaded_new, lcos_u_shaded)
      ELSE
        gs_o_sunlit_new = 0.0001
        ac_o_sunlit = 0.0
        lsif_o_sunlit = 0.0
        lcos_o_sunlit = 0.0
        ci_o_sunlit_new = co2_air*0.7
        cs_o_sunlit_new = co2_air
        cc_o_sunlit_new = co2_air*0.7*0.8
        cosi_o_sunlit_new = cos_air*0.7
        coss_o_sunlit_new = cos_air
        cosc_o_sunlit_new = cos_air*0.7*0.8
        gs_o_shaded_new = 0.0001
        ac_o_shaded = 0.0
        lsif_o_shaded = 0.0
        lcos_o_shaded = 0.0
        ci_o_shaded_new = co2_air*0.7
        cs_o_shaded_new = co2_air
        cc_o_shaded_new = co2_air*0.7*0.8
        cosi_o_shaded_new = cos_air*0.7
        coss_o_shaded_new = cos_air
        cosc_o_shaded_new = cos_air*0.7*0.8
        gs_u_sunlit_new = 0.0001
        ac_u_sunlit = 0.0
        lsif_u_sunlit = 0.
        lcos_u_sunlit = 0.
        ci_u_sunlit_new = co2_air*0.7
        cs_u_sunlit_new = co2_air
        cc_u_sunlit_new = co2_air*0.7*0.8
        cosi_u_sunlit_new = cos_air*0.7
        coss_u_sunlit_new = cos_air
        cosc_u_sunlit_new = cos_air*0.7*0.8
        gs_u_shaded_new = 0.0001
        ac_u_shaded = 0.0
        lsif_u_shaded = 0.
        lcos_u_shaded = 0.
        ci_u_shaded_new = co2_air*0.7
        cs_u_shaded_new = co2_air
        cc_u_shaded_new = co2_air*0.7*0.8
        cosi_u_shaded_new = cos_air*0.7
        coss_u_shaded_new = cos_air
        cosc_u_shaded_new = cos_air*0.7*0.8
      END IF
!       write(*,*) G_o_b,gs_h2o
      ci_o_sunlit_old = ci_o_sunlit_new
      cs_o_sunlit_old = cs_o_sunlit_new
      cosi_o_sunlit_old = cosi_o_sunlit_new
      coss_o_sunlit_old = coss_o_sunlit_new
      gs_o_sunlit_old = gs_o_sunlit_new
!conductance of sunlit leaves of overstorey for water
      gw_o_sunlit = 1.0/(1.0/g_o_a+1.0/g_o_b+1.0/gs_o_sunlit_new)
!conductance of sunlit leaves of overstorey for CO2
      gc_o_sunlit = 1.0/(1.0/g_o_a+1.4/g_o_b+1.6/gs_o_sunlit_new)
      ci_o_shaded_old = ci_o_shaded_new
      cs_o_shaded_old = cs_o_shaded_new
      cosi_o_shaded_old = cosi_o_shaded_new
      coss_o_shaded_old = coss_o_shaded_new
      gs_o_shaded_old = gs_o_shaded_new
      gw_o_shaded = 1.0/(1.0/g_o_a+1.0/g_o_b+1.0/gs_o_shaded_new)
      gc_o_shaded = 1.0/(1.0/g_o_a+1.4/g_o_b+1.6/gs_o_shaded_new)
      ci_u_sunlit_old = ci_o_sunlit_new
      cs_u_sunlit_old = cs_u_sunlit_new
      cosi_u_sunlit_old = cosi_o_sunlit_new
      coss_u_sunlit_old = coss_u_sunlit_new
      gs_u_sunlit_old = gs_o_sunlit_new
      gw_u_sunlit = 1.0/(1.0/g_u_a+1.0/g_u_b+1.0/gs_u_sunlit_new)
      gc_u_sunlit = 1.0/(1.0/g_u_a+1.4/g_u_b+1.6/gs_u_sunlit_new)
      ci_u_shaded_old = ci_u_shaded_new
      cs_u_shaded_old = cs_u_shaded_new
      cosi_u_shaded_old = cosi_u_shaded_new
      coss_u_shaded_old = coss_u_shaded_new
      gs_u_shaded_old = gs_u_shaded_new
      gw_u_shaded = 1.0/(1.0/g_u_a+1.0/g_u_b+1.0/gs_u_shaded_new)
      gc_u_shaded = 1.0/(1.0/g_u_a+1.4/g_u_b+1.6/gs_u_shaded_new)
! leaf tempratures module by L. He
      CALL LEAF_TEMPERATURES(temp_air, slope, psychrometer, vpd_air, &
&                      cp_ca, gw_o_sunlit, gw_o_shaded, gw_u_sunlit, &
&                      gw_u_shaded, gww_o_sunlit, gww_o_shaded, &
&                      gww_u_sunlit, gww_u_shaded, gh_o_sunlit, &
&                      gh_o_shaded, gh_u_sunlit, gh_u_shaded, xcs_o(kkk)&
&                      , xcl_o(kkk), xcs_u(kkk), xcl_u(kkk), &
&                      radiation_o_sun, radiation_o_shaded, &
&                      radiation_u_sun, radiation_u_shaded, &
&                      tc_o_sunlit_new, tc_o_shaded_new, tc_u_sunlit_new&
&                      , tc_u_shaded_new)
      h_o_sunlit = (tc_o_sunlit_new-temp_air)*rho_a*cp_ca*gh_o_sunlit
      h_o_shaded = (tc_o_shaded_new-temp_air)*rho_a*cp_ca*gh_o_shaded
!for next num aerodynamic conductance calculation
      gh_o = h_o_sunlit*lai_o_sunlit + h_o_shaded*lai_o_shaded
      IF (tc_o_sunlit_new - tc_o_sunlit_old .GE. 0.) THEN
        abs0 = tc_o_sunlit_new - tc_o_sunlit_old
      ELSE
        abs0 = -(tc_o_sunlit_new-tc_o_sunlit_old)
      END IF
      IF (tc_o_shaded_new - tc_o_shaded_old .GE. 0.) THEN
        abs1 = tc_o_shaded_new - tc_o_shaded_old
      ELSE
        abs1 = -(tc_o_shaded_new-tc_o_shaded_old)
      END IF
      IF (tc_u_sunlit_new - tc_u_sunlit_old .GE. 0.) THEN
        abs2 = tc_u_sunlit_new - tc_u_sunlit_old
      ELSE
        abs2 = -(tc_u_sunlit_new-tc_u_sunlit_old)
      END IF
      IF (tc_u_shaded_new - tc_u_shaded_old .GE. 0.) THEN
        abs3 = tc_u_shaded_new - tc_u_shaded_old
      ELSE
        abs3 = -(tc_u_shaded_new-tc_u_shaded_old)
      END IF
      IF (abs0 .LT. 0.02 .AND. abs1 .LT. 0.02 .AND. abs2 .LT. 0.02 .AND.&
&         abs3 .LT. 0.02) THEN
        GOTO 100
      ELSE IF (num .GT. 22) THEN
!iteration does not converge.
        tc_o_sunlit_old = temp_air
        tc_o_shaded_old = temp_air
        tc_u_sunlit_old = temp_air
        tc_u_shaded_old = temp_air
        GOTO 100
      ELSE
        tc_o_sunlit_old = tc_o_sunlit_new
        tc_o_shaded_old = tc_o_shaded_new
        tc_u_sunlit_old = tc_u_sunlit_new
        tc_u_shaded_old = tc_u_shaded_new
      END IF
    END DO
! end do while
!    write(*,*) G_o_b,gs_h2o
 100 gpp_o_sunlit = ac_o_sunlit*laio_sunlit
    gpp_o_shaded = ac_o_shaded*laio_shaded
    gpp_u_sunlit = ac_u_sunlit*laiu_sunlit
    gpp_u_shaded = ac_u_shaded*laiu_shaded
    cos_o_sunlit = lcos_o_sunlit*laio_sunlit
    cos_o_shaded = lcos_o_shaded*laio_shaded
    cos_u_sunlit = lcos_u_sunlit*laiu_sunlit
    cos_u_shaded = lcos_u_shaded*laiu_shaded
!    stSIF_o_sunlit=lSIF_o_sunlit*0.5*clumping*(1.1-0.1*LAIo_sunlit)*exp(-CosZs)*LAIo_sunlit
!    stSIF_o_shaded=lSIF_o_shaded*0.5*clumping*(1.1-0.1*LAIo_shaded)*exp(-CosZs)*LAIo_shaded
!    stSIF_u_sunlit=lSIF_u_sunlit*0.5*clumping*(1.1-0.1*LAIu_sunlit)*exp(-CosZs)*LAIu_sunlit
!    stSIF_u_shaded=lSIF_u_shaded*0.5*clumping*(1.1-0.1*LAIu_shaded)*exp(-CosZs)*LAIu_shaded
!    SIF_o_sunlit=lSIF_o_sunlit*exp(-0.5*clumping*LAIo_sunlit/CosZs)*LAIo_sunlit+stSIF_o_sunlit
!    SIF_o_shaded=lSIF_o_shaded*exp(-0.5*clumping*LAIo_shaded/CosZs)*LAIo_shaded+stSIF_o_shaded
!    SIF_u_sunlit=lSIF_u_sunlit*exp(-0.5*clumping*LAIu_sunlit/CosZs)*LAIu_sunlit+stSIF_u_sunlit
!    SIF_u_shaded=lSIF_u_shaded*exp(-0.5*clumping*LAIu_shaded/CosZs)*LAIu_shaded+stSIF_u_shaded
    stsif_o_sunlit = lsif_o_sunlit*0.3*clumping*(1.1-0.1*laio_sunlit)*&
&     EXP(-coszs)
    stsif_o_shaded = lsif_o_shaded*0.3*clumping*(1.1-0.1*laio_shaded)*&
&     EXP(-coszs)
    stsif_u_sunlit = lsif_u_sunlit*0.3*clumping*(1.1-0.1*laiu_sunlit)*&
&     EXP(-coszs)
    stsif_u_shaded = lsif_u_shaded*0.3*clumping*(1.1-0.1*laiu_shaded)*&
&     EXP(-coszs)
!    stSIF_o_sunlit = 0.0   !!@JWang  for scattering correction,@MOUSONG,make sure this is correct???
!    stSIF_o_shaded = 0.0
!    stSIF_u_sunlit = 0.0
!    stSIF_u_shaded = 0.0
    sif_o_sunlit = (lsif_o_sunlit+stsif_o_sunlit)*laio_sunlit*0.1
    sif_o_shaded = (lsif_o_shaded+stsif_o_shaded)*laio_shaded*0.1
    sif_u_sunlit = (lsif_u_sunlit+stsif_u_sunlit)*laiu_sunlit*0.1
    sif_u_shaded = (lsif_u_shaded+stsif_u_shaded)*laiu_shaded*0.1
!Transpiration module by X. Luo
    CALL TRANSPIRATION(tc_o_sunlit_new, tc_o_shaded_new, tc_u_sunlit_new&
&                , tc_u_shaded_new, temp_air, rh_air, gw_o_sunlit, &
&                gw_o_shaded, gw_u_sunlit, gw_u_shaded, lai_o_sunlit, &
&                lai_o_shaded, lai_u_sunlit, lai_u_shaded, trans_o(kkk)&
&                , trans_u(kkk))
! Evaporation and sublimation from canopy by X. Luo
    CALL EVAPORATION_CANOPY(tc_o_sunlit_new, tc_o_shaded_new, &
&                     tc_u_sunlit_new, tc_u_shaded_new, temp_air, rh_air&
&                     , gww_o_sunlit, gww_o_shaded, gww_u_sunlit, &
&                     gww_u_shaded, lai_o_sunlit, lai_o_shaded, &
&                     lai_u_sunlit, lai_u_shaded, xcl_o(kkk), xcl_u(kkk)&
&                     , xcs_o(kkk), xcs_u(kkk), eil_o(kkk), eil_u(kkk), &
&                     eis_o(kkk), eis_u(kkk))
! Rainfall stage 2 by X. Luo
    CALL RAINFALL_STAGE2(eil_o(kkk), eil_u(kkk), wcl_o(kkk), wcl_u(kkk))
! Snow pack stage2
    CALL SNOWPACK_STAGE2(eis_o(kkk), eis_u(kkk), wcs_o(kkk), wcs_u(kkk))
! Evaporation from soil module
    gheat_g = 1./ra_g
    mass_water_g = rho_w*zp
    CALL SOIL_EVAPORATION(temp_grd, ts0(kkk-1), rh_air, radiation_g, &
&                   gheat_g, xg_snow(kkk), zp, zsp, mass_water_g, &
&                   wg_snow(kkk), rho_snow(kkk), soilp%thetam_prev(0), &
&                   soilp%fei(0), evap_soil(kkk), evap_sw(kkk), evap_ss(&
&                   kkk))
! update surface ponding after ponding evaporation calculation
    zp = mass_water_g/rho_w
! update snow depth as well after snow evaporation calculation
    zsp = wg_snow(kkk)/rho_snow(kkk)
! to be checked later:  why set these 4 to 0
    eil_o(kkk) = 0.
    eis_o(kkk) = 0.
    eil_u(kkk) = 0.
    eis_u(kkk) = 0.
! soil Thermal Conductivity module by L. He
    CALL UPDATESOILTHERMALCONDUCTIVITY(soilp)
    CALL UPDATE_CS(soilp)
! Surface temperature
    cs(0, kkk) = soilp%cs(0)
    cs(1, kkk) = soilp%cs(0)
    tc_u(kkk) = tcu
    lambda_soil(1) = soilp%lambda(0)
    d_soil(1) = soilp%d_soil(0)
    tm(1, kkk-1) = soilp%temp_soil_p(1)
    tm(0, kkk-1) = soilp%temp_soil_p(0)
    g(1, kkk) = soilp%g(0)
    CALL SURFACETEMPERATURE(temp_air, rh_air, zsp, zp, cs(1, kkk), cs(0&
&                     , kkk), gheat_g, d_soil(1), rho_snow(kkk), tc_u(&
&                     kkk), radiation_g, evap_soil(kkk), evap_sw(kkk), &
&                     evap_ss(kkk), lambda_soil(1), xg_snow(kkk), g(1, &
&                     kkk), ts0(kkk-1), tm(1, kkk-1), tm(0, kkk-1), tsn0&
&                     (kkk-1), tsm0(kkk-1), tsn1(kkk-1), tsn2(kkk-1), &
&                     ts0(kkk), tm(0, kkk), tsn0(kkk), tsm0(kkk), tsn1(&
&                     kkk), tsn2(kkk), g(0, kkk))
    soilp%temp_soil_c(0) = tm(0, kkk)
! Snow pack stage3 module
    CALL SNOWPACK_STAGE3(temp_air, tsn0(kkk), tsn0(kkk-1), rho_snow(kkk)&
&                  , zsp, zp, wg_snow(kkk))
    CALL SENSIBLEHEAT_CDV(tc_o_sunlit_new, tc_o_shaded_new, &
&                   tc_u_sunlit_new, tc_u_shaded_new, ts0(kkk), temp_air&
&                   , rh_air, gh_o_sunlit, gh_o_shaded, gh_u_sunlit, &
&                   gh_u_shaded, gheat_g, lai_o_sunlit, lai_o_shaded, &
&                   lai_u_sunlit, lai_u_shaded, qhc_o(kkk), qhc_u(kkk), &
&                   qhg(kkk))
! soil water module
    soilp%zsp = zsp
    soilp%g(0) = g(0, kkk)
    CALL UPDATEHEATFLUX(soilp, xg_snow(kkk), lambda_snow(kkk), tsn0(kkk)&
&                 , temp_air, kstep)
    CALL SOIL_WATER_UPTAKE(soilp, trans_o(kkk), trans_u(kkk), evap_soil(&
&                    kkk))
    soilp%r_rain_g = r_rain_g(kkk)
    soilp%zp = zp
    CALL UPDATESOILMOISTURE(soilp)
    zp = soilp%zp
  END DO
!END kkk iteration
!    write(*,*) G_o_b,gs_h2o
  kkk = kloop
!True? or Tsn1 @J.Wang
  IF (tsn1(kkk) .GT. 40.) tsn2(kkk) = 40.
  IF (tsn1(kkk) .LT. -40.) tsn2(kkk) = -40.
  IF (tsn2(kkk) .GT. 40.) tsn2(kkk) = 40.
  IF (tsn2(kkk) .LT. -40.) tsn2(kkk) = -40.
! SH
  var_n(1) = qhc_o(kkk)
! The temperature of ground surface
  var_n(3) = ts0(kkk)
!The temperature of ground surface
  var_n(4) = tsn0(kkk)
  var_n(5) = tsm0(kkk)
  var_n(6) = tsn1(kkk)
  var_n(7) = tsn2(kkk)
  DO i=9,14
    var_n(i) = soilp%temp_soil_c(i-9)
  END DO
  DO i=21,26
    var_n(i) = soilp%thetam(i-21)
  END DO
  DO i=27,32
    var_n(i) = soilp%ice_ratio(i-27)
  END DO
  var_n(15) = wcl_o(kkk)
!the mass of intercepted liquid water and snow, overstory
  var_n(16) = wcs_o(kkk)
  var_n(18) = wcl_u(kkk)
  var_n(19) = wcs_u(kkk)
! fraction of ground surface covered by snow and snow mass
  var_n(20) = wg_snow(kkk)
  var_n(33) = soilp%zsp
  var_n(34) = soilp%zp
  var_n(35) = soilp%r_rain_g
  var_n(36) = ac_snow_o(kkk)
  var_n(37) = ac_snow_u(kkk)
  var_n(38) = rho_snow(kkk)
  var_n(39) = alpha_v_sw(kkk)
  var_n(40) = alpha_n_sw(kkk)
!laten heat of water vaporization in j/kg
  lv_liquid = (2.501-0.00237*temp_air)*1000000.
!for output
  mid_res%net_rad = radiation_o + radiation_u + radiation_g
  mid_res%lh = lv_liquid*(trans_o(kkk)+eil_o(kkk)+trans_u(kkk)+eil_u(kkk&
&   )+evap_soil(kkk)+evap_sw(kkk)) + lv_solid*(eis_o(kkk)+eis_u(kkk)+&
&   evap_ss(kkk))
  mid_res%sh = qhc_o(kkk) + qhc_u(kkk) + qhg(kkk)
  mid_res%trans = (trans_o(kkk)+trans_u(kkk))/rho_w
  mid_res%evap = (eil_o(kkk)+eil_u(kkk)+evap_soil(kkk)+evap_sw(kkk))/&
&   rho_w + (eis_o(kkk)+eis_u(kkk)+evap_ss(kkk))/rho_snow(kkk)
!J.Wang kg/m2/s// umol C/m2/s
  mid_res%gpp_o_sunlit = gpp_o_sunlit*12.*1.e-6*1.e-3
  mid_res%gpp_u_sunlit = gpp_u_sunlit*12.*1.e-6*1.e-3
  mid_res%gpp_o_shaded = gpp_o_shaded*12.*1.e-6*1.e-3
  mid_res%gpp_u_shaded = gpp_u_shaded*12.*1.e-6*1.e-3
  mid_res%gpp = mid_res%gpp_o_sunlit + mid_res%gpp_u_sunlit + mid_res%&
&   gpp_o_shaded + mid_res%gpp_u_shaded
  mid_res%sif = sif_o_sunlit + sif_o_shaded + sif_u_sunlit + &
&   sif_u_shaded
  mid_res%thetam_surf = soilp%thetam(0)
! pmol/m2/s
  mid_res%cos_plant = cos_o_sunlit + cos_o_shaded + cos_u_sunlit + &
&   cos_u_shaded
!    write(*,*) "thetam_surf = ", mid_res%thetam_surf
  IF (lai_input .LT. 0) THEN
    temp_day = temp_day + meteo%temp
    theta_day = theta_day + (soilp%theta_vfc(0)-soilp%theta_vwp(0))
    trans_day = trans_day + mid_res%trans
    IF (is_end_curr_day) THEN
      temp_day = temp_day/24.
      theta_day = theta_day/24.
      trans_day = trans_day/24.
! use the method in BETHY to calculate phenology, with a little modification, @Mousong.Wu,201905
      CALL BEPS_PHENOLOGY_CDV(lc, daylen, temp_day, theta_day, trans_day&
&                       , mid_res%lai_old)
      temp_day = 0.
      theta_day = 0.
      trans_day = 0.
      mid_res%lai_new = mid_res%lai_old
    ELSE
      mid_res%lai_new = mid_res%lai_old
    END IF
    lai = mid_res%lai_new
!mid_res%fAPAR = 1. - exp(-0.45*lai)    ! calculate fAPAR using the Lambert-Beer law, Benjamin Smith et al., 2008, &
! & Forest Ecology and Management, @Mousong.Wu, 201905
!          write(*,*) 'lai = ', mid_res%lai_old
!          write(*,*) 'fAPAR = ', mid_res%fAPAR
  END IF
!lai = mid_res%lai_new 
! calculate fAPAR using the Lambert-Beer law, Benjamin Smith et al., 2008, &
  mid_res%fapar = 1. - EXP(-(0.45*lai))
! & Forest Ecology and Management, @Mousong.Wu, 201905
  CALL COS_GRND_CDV(soilp, cos_soil)
! pmol/m2/s
  mid_res%cos_grnd = cos_soil
  RETURN
END SUBROUTINE INTER_PRG_CDV

SUBROUTINE COS_GRND_CDV(soilp, cos_soil)
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE BEPS_SOILMOD_DIFFV
  IMPLICIT NONE
!Input Variables
  TYPE(SOIL), INTENT(IN) :: soilp
!Local Variables
! local ground COS flux (pmol/m2/sec)
  REAL(r8) :: cos_soil
  REAL(r8) :: f_opt, s_opt, f_g, s_g, a
  REAL(r8), PARAMETER :: k_cos_soil=1.2e-4
!Misc Variables
  INTEGER :: j
  REAL(r8) :: soil_t, soil_s, dsoil, soil_ice
  REAL(r8) :: cos_soil_abiotic, cos_soil_biotic
  INTRINSIC LOG, DBLE, EXP
  REAL(r8) :: arg1
  REAL(r8) :: arg2
  soil_t = 0.
  soil_s = 0.
  soil_ice = 0.
  dsoil = 0.
!...ground uptake of COS, calculated from Whelan et al., 2016, ACP. calculate the abiotic and biotic part of ground uptake separa
!tely.
  DO j=1,3
    soil_t = soil_t + soilp%temp_soil_c(j-1)*soilp%d_soil(j-1)
    soil_s = soil_s + soilp%thetam(j-1)*soilp%d_soil(j-1)
    soil_ice = soil_ice + soilp%ice_ratio(j-1)*soilp%d_soil(j-1)
    dsoil = dsoil + soilp%d_soil(j-1)
  END DO
  soil_t = soil_t/dsoil
  soil_ice = soil_ice/dsoil
  arg1 = 0.0984*soil_t
  cos_soil_abiotic = 0.437*EXP(arg1)
  f_opt = -(0.00986*soil_t*soil_t) + 0.197*soil_t - 9.32
  s_opt = 0.28*soil_t + 14.5
  f_g = -(0.0119*soil_t*soil_t) + 0.110*soil_t - 1.18
  s_g = 35.0
  arg1 = f_opt/f_g
  arg2 = s_opt/s_g
  a = LOG(arg1)*(LOG(arg2)+(s_g/s_opt-1.))**(-1)
  arg1 = -(a*(soil_s/s_opt-1.))
  cos_soil_biotic = f_opt*(soil_s/s_opt)**a*EXP(arg1)
  cos_soil = -(cos_soil_abiotic + cos_soil_biotic)
END SUBROUTINE COS_GRND_CDV

SUBROUTINE BEPS_PHENOLOGY_CDV(lc, daylen, dt, theta, trans, lai)
!***********************************************************
!* WOK, 2008-07-30
!* IMPLIFIED PHENOLOGY MODEL
!* simplified phenology model
!***********************************************************
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE MO_HELPER_DIFFV, ONLY : errf, mins, maxs, minx, maxx, fominef_ss, &
& fomaxef_ss
  IMPLICIT NONE
!  REAL, ALLOCATABLE, DIMENSION (:,:,:) :: mlai ! monthly LAI fields from external data
  INTEGER, INTENT(IN) :: lc
  REAL, INTENT(IN) :: daylen
  REAL, INTENT(IN) :: dt
  REAL, INTENT(IN) :: theta
  REAL, INTENT(IN) :: trans
  REAL, INTENT(INOUT) :: lai
! air-temperature memory [deg C]
  REAL :: tmpm
! water limited LAI memory
  REAL :: laim
! highest recorded LAI (with a decay rate, for setting 'zfc')
  REAL :: laihi
! WOK-ADD-070723 litter production to be calculated directly in phenology (not in cbalance indirectly)
! auxiliary fields
  REAL :: tmpmmult, laimmult
! output field
  REAL :: leafshed
  REAL :: laihimult
! memory time for updating fractional cover
  REAL, PARAMETER :: taulaihi=5.0
!  REAL, PARAMETER :: laimin = 1e-6            ! minimum LAI for pot. transpiration per LAI estimates
! curvature parameter for mins/maxs
  REAL, PARAMETER :: eta=0.99999
! WOK-ADD-070723 the list of controlling parameters
! FREE PARAMETERS
! maximum LAI
  REAL :: plaimax(10)
! rootdepth
  REAL :: rootdepth(10)
! leaf onset temperature [deg C]
  REAL :: ptphen(10)
! range of leaf onset temperature [1/deg C]
  REAL :: ptphenr(10)
! leaf shedding daylength [hours]
  REAL :: pdphen
! range of leaf shedding daylength [hours]
  REAL :: pdphenr
!  REAL, ALLOCATABLE, DIMENSION (:) :: PTSHD   ! leaf shedding temperature [deg C]
!  REAL, ALLOCATABLE, DIMENSION (:) :: PTSHDS  ! spread of leaf shedding temperature [1/deg C]
! leaf growth factor [1/days]
  REAL :: plgr
! inverse leaf longevity from start of senescense [1/days]
  REAL :: pkl(10)
! target survival time at current soil moisture [days]
  REAL :: ptauw(10)
! PARAMETERS LEFT FIXED
! inverse memory time for soil moisture-limited LAI [1/days]
  REAL :: pks
! inverse memory time for air temperature [1/days]
  REAL :: pkm
  REAL :: pasm
  REAL :: zfc, zlai
  REAL :: fcmax0, lailim0, cdrm
  REAL :: xdtmp, lait, laiw, fx, t0, ts, ft, fd, fg
  REAL :: lailast
  REAL :: laimaxw, laimax, r, lailim, wai
  REAL :: dptrp
  INTEGER :: plt
! WOK-090309 'ph' is now only used in nscale
! xph     1: warm-evergreen; 2: cold-evergreen; 3: summergreen; 4: raingreen; 5: grass; 6: annual crop;
! INTEGER, DIMENSION (0:13), PARAMETER :: xph= &
!PFT:0  1  2  3  4  5  6  7  8  9 10 11 12 13
!  (/5, 1, 4, 1, 3, 2, 3, 1, 4, 5, 5, 2, 5, 6/)
  REAL :: sla(10)
  INTRINSIC EXP
  REAL :: arg1
  REAL :: result1
  REAL :: arg2
  SELECT CASE  (lc) 
  CASE (1) 
!conifer evergreen
    plt = 1
  CASE (2) 
!conifer decidous
    plt = 2
  CASE (6) 
!broadleaf decidous
    plt = 3
  CASE (9) 
!broadleaf evergreen
    plt = 4
  CASE (10) 
!mix
    plt = 5
  CASE (13) 
!shrub
    plt = 6
  CASE (14) 
! grass
    plt = 7
  CASE (15) 
! crop
    plt = 8
  CASE (40) 
! C4 grass
    plt = 9
  CASE (41) 
! C4 crop
    plt = 10
  END SELECT
  sla = (/4.1, 11.3, 12.8, 7.8, 9.0, 9.2, 16.9, 25.3, 16.9, 16.9/)
!sla(0:13)=(/0., 9.9, 14.1, 5.7, 11.5, 4.1, 11.3, 6.9, &
!		& 11.5, 16.9, 16.9, 6.9, 16.9, 25.3/)
  ptphen = (/10.0, 10.0, 5.0, 0., 5., 4.0, 2.0, 15.0, 2.0, 2.0/)
!  ptphen(0:13)=(/0.,0.,0., 0., 10.0, 10.0, 10.0, 0., 8.0, &
!       & 2.0, 2.0, 2.0, 2.0, 15.0/)
  ptphenr = (/2.0, 2.0, 2., 2., 2., 2.0, 2., 2., 2., 2./)
!  ptphenr(0:13)=(/0.,0., 0., 0., 2.0, 2.0, 2.0, 0., 2.0, &
!        & 2.0, 2.0, 2.0, 2.0, 2.0/)
  pdphen = 10.5
  pdphenr = 0.5
  plgr = 0.5
  pkl = (/0.1, 0., 5.e-3, 0.1, 0.1, 0.1, 5.e-3, 0.1, 5.e-3, 5.e-3/)
! pkl(0:13) = (/0.,0.1, 0., 0.1, 5.e-3, 0.1, 0., 0.1, &
!       & 0.1, 0.1, 5.e-3, 0.1, 0.1, 0.1/)
  ptauw = (/30., 30., 30., 30., 30., 30., 30., 30., 30., 30./)
!  ptauw(1:13) = (/0., 30., 30., 30., 30., 30., 30., &
!        & 30., 30., 30., 30., 30., 30./)
!  LIST OF PFTs in BETHY:
!  1:  tropical broadleaf evergreen tree
!  2:  tropical broadleaf deciduous tree
!  3:  temperate broadleaf evergreen tree
!  4:  temperate broadleaf deciduous tree
!  5:  evergreen coniferous tree
!  6:  deciduous coniferous tree
!  7:  evergreen shrub
!  8:  deciduous shrub
!  9:  C3 grass
! 10:  C4 grass
! 11:  tundra
! 12:  swamp
! 13:  arable crop
  rootdepth = (/0.6, 0.6, 0.8, 0.8, 0.7, 0.5, 0.3, 0.3, 0.3, 0.3/)
  plaimax = (/4.5, 4.5, 4.5, 4.5, 4.5, 3.3, 3.0, 4.5, 3.0, 3.0/)
  fcmax0 = 1.0
  lailim0 = 3.0
  cdrm = 0.45
  pkm = 1./30.
  pks = 1./30.
!   multiplier for advancing temperature memory by one day
  tmpmmult = EXP(-pkm)
!   multiplier for advancing soil-water limited LAI memory by one day
  laimmult = EXP(-pks)
!   decay multiplier for evergreen LAI
!    laimult = exp (-pkl)
!   the air-temperature memory
  tmpm = 0.
!   the water stress index memory
  laim = 0.
  lai = plaimax(plt)
!   decay multiplier for maximum LAI used to set fractional cover
  arg1 = -(1./(taulaihi*365.))
  laihimult = EXP(arg1)
!   control for fractional cover 'zfc'
  laihi = 0.
  zfc = fcmax0
!   output field
  leafshed = 0.
!   spin-up of temperature memory
  tmpm = dt*(1.-tmpmmult) + tmpm*tmpmmult
!   calculate plant available soil moisture and daily potential transpiration, @MOUSONG.WU, 201905
! convert from m3/m3 to mm
  pasm = theta*rootdepth(plt)*1000.
! convert from m/s to mm
  dptrp = trans*86400.*1000.
  lailast = lai
!------------------------------------------------------------------
! advances LAI and fractional cover by one day
! from its current state to the state at day 'iday'
!------------------------------------------------------------------
  DO plt=1,9
!      IF (ph(k)==1.or.ph(k)==4) THEN ! warm-evergreen and warm-deciduous phenology
    IF (((plt .EQ. 3 .OR. plt .EQ. 4) .OR. plt .EQ. 5) .OR. plt .EQ. 6) &
&   THEN
! warm-evergreen and warm-deciduous phenology
! effective maximum LAI, taking into account structural limiations
!        laimax = plaimax(k) * (1. - exp(-laimaxw/plaimax(k)))
!   initialize LAI
      result1 = MAXX(dptrp, 1.e-3, 2.e-2)
      laimax = pasm*lailast/ptauw(plt)/result1
!        laimax = mins (laimax, plaimax(k), 0.9)
!snb, test
      result1 = FOMINEF_SS(laimax, plaimax(plt), 2.e-1)
      laimax = result1 + 1.e-1
! update water limited LAI memory
      laim = laimax*(1.-laimmult) + laim*laimmult
! rate of change of LAI towards limit
      r = plgr
! limit LAI
      lailim = laim
! update LAI
!        lai(k) = lailim - (lailim - lai(k)) * exp (-r)
!      ELSE IF (ph(k)==2.or.ph(k)==3) THEN ! cold-evergreen and cold-deciduous phenology
    ELSE IF (plt .EQ. 1 .OR. plt .EQ. 2) THEN
! cold-evergreen and cold-deciduous phenology
! update memory of daily mean temperature
      tmpm = dt*(1.-tmpmmult) + tmpm*tmpmmult
! fraction of vegetation above temperature threshold
      arg1 = (tmpm-ptphen(plt))/ptphenr(plt)
      ft = ERRF(arg1)
! fraction of vegetation above daylength threshold
      arg1 = (daylen-pdphen)/pdphenr
      fd = ERRF(arg1)
      r = ft*fd*plgr + (1.-ft*fd)*pkl(plt) + 1.e-9
      arg1 = ft*fd*plgr*plaimax(plt)/r
      lailim = MAXX(arg1, 1.e-9, 5.e-3)
!        lai(k) = plaimax(k) - (plaimax(k) - lai(k)) * exp (-r)
!        lai(k) = lailim - (lailim - lai(k)) * exp (-r)
    ELSE
! grass and annual crop phenology
      tmpm = dt*(1.-tmpmmult) + tmpm*tmpmmult
      arg1 = (tmpm-ptphen(plt))/ptphenr(plt)
      ft = ERRF(arg1)
      result1 = MAXX(dptrp, 1.e-3, 2.e-2)
      laimax = pasm*lailast/ptauw(plt)/result1
!        laimax = mins (laimax, plaimax(k), 0.9)
!        if(pft(k)==9) print '(a,8g30.14)','PFT9-a: iday,tmpm(k),ft,laimax,pasm(k),zlai(k),dptrp(k),lai(k)',iday,tmpm(k),ft,laima
!x,pasm(k),zlai(k),dptrp(k),lai(k)
!snb, test
      result1 = FOMINEF_SS(laimax, plaimax(plt), 2.e-1)
      laimax = result1 + 1.e-1
      laim = laimax*(1.-laimmult) + laim*laimmult
      r = ft*plgr + (1.-ft)*pkl(plt) + 1.e-9
      arg1 = ft*plgr*laim/r
      lailim = MAXX(arg1, 1.e-9, 5.e-3)
!        lai(k) = lailim - (lailim - lai(k)) * exp (-r)
    END IF
!      leafshed(k) = maxx (lailast - lai(k), 0., 1e-3) / sla(k) * 1000. * cdrm
    arg1 = (lailim-lai)*(1.-EXP(-r))
    result1 = MAXX(arg1, 0., 1.e-3)
    leafshed = result1/sla(plt)*1000.*cdrm
    lai = lailim - (lailim-lai)*EXP(-r)
  END DO
!      if(pft(k)==9) print '(a,8g30.14)','PFT9-b: lai(k),r,lailim',lai(k),r,lailim
! set fractional cover
!      laihi(k) = maxs (lai(k), laihi(k), eta) * laihimult
  result1 = FOMAXEF_SS(lai, laihi, 2.e-6)
  laihi = result1*laihimult
!      zfc(k) = maxs (laihi(k) / lailim0, lai(k) / lailim0, eta)
  arg1 = laihi/lailim0
  arg2 = lai/lailim0
  zfc = FOMAXEF_SS(arg1, arg2, 2.e-6)
!      zfc(k) = mins ( zfc(k), 1., eta) * fcmax0
! snb, test
  result1 = MINX(zfc, 1., 2.e-6)
  zfc = result1*fcmax0
END SUBROUTINE BEPS_PHENOLOGY_CDV

! This module calculate net radiation at both canopy level and leaf level XZ luo may23 2015
! output: net radiation for canopy,over/under storey and ground
!         ............. on sunlit/shaded leaves of over/understorey
!
! inputs: global solar radiation,cosine value for solar zenith angle,albedo of leaves
!         albedo of snow,percentage of snow cover
!         leaf area index 
!         temperature of over/under storey and ground
!         temperature of air/rh
SUBROUTINE NETRADIATION_CDV(shortrad_df, shortrad_dir, coszs, temp_o, &
& temp_u, temp_g, lai_o, lai_u, lai_os, lai_us, lai_o_sunlit, &
& lai_o_shaded, lai_u_sunlit, lai_u_shaded, clumping, temp_air, rh, &
& albedo_snow_v, albedo_snow_n, percentarea_snow_o, percentarea_snow_u, &
& percent_snow_g, albedo_v_o, albedo_n_o, albedo_v_u, albedo_n_u, &
& albedo_v_g, albedo_n_g, netrad_o, netrad_u, netrad_g, &
& netradleaf_o_sunlit, netradleaf_o_shaded, netradleaf_u_sunlit, &
& netradleaf_u_shaded, netshortradleaf_o_sunlit, &
& netshortradleaf_o_shaded, netshortradleaf_u_sunlit, &
& netshortradleaf_u_shaded)
  USE METEOMOD_DIFFV
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE BEPS_CON, ONLY : zero, sb_constant => sigma
  IMPLICIT NONE
  REAL(r8), INTENT(IN) :: shortrad_df, shortrad_dir, coszs, temp_o, &
& temp_u, temp_g
! LAI of over/understorey with or without stem
  REAL(r8), INTENT(IN) :: lai_o, lai_u, lai_os, lai_us
! sunlit/shaded leaves with consideration of stem
  REAL(r8), INTENT(IN) :: lai_o_sunlit, lai_o_shaded, lai_u_sunlit, &
& lai_u_shaded
  REAL(r8), INTENT(IN) :: clumping
  REAL(r8), INTENT(IN) :: temp_air, rh
! albedo of snow in this step
  REAL(r8), INTENT(IN) :: albedo_snow_v, albedo_snow_n
  REAL(r8), INTENT(IN) :: percentarea_snow_o, percentarea_snow_u, &
& percent_snow_g
  REAL(r8), INTENT(IN) :: albedo_v_o, albedo_n_o, albedo_v_u, albedo_n_u&
& , albedo_v_g, albedo_n_g
! net Radiation on over/understorey and ground
  REAL(r8), INTENT(OUT) :: netrad_o, netrad_u, netrad_g
!leaf levels for ET
  REAL(r8), INTENT(OUT) :: netradleaf_o_sunlit, netradleaf_o_shaded, &
& netradleaf_u_sunlit, netradleaf_u_shaded
  REAL(r8), INTENT(OUT) :: netshortradleaf_o_sunlit, &
& netshortradleaf_o_shaded, netshortradleaf_u_sunlit, &
& netshortradleaf_u_shaded
!! net shortwave radiation at leaf level for GPP. 
! net short wave radiation
  REAL(r8) :: shortrad_global, netshortrad_o, netshortrad_u, &
& netshortrad_g
  REAL(r8) :: netshortrad_o_dir, netshortrad_o_df, netshortrad_u_dir, &
& netshortrad_u_df, netshortrad_g_dir, netshortrad_g_df
!real(r8) :: shortRad_dir,shortRad_df
  REAL(r8) :: netlongradleaf_o_sunlit, netlongradleaf_o_shaded, &
& netlongradleaf_u_sunlit, netlongradleaf_u_shaded
  REAL(r8) :: netlongrad_o, netlongrad_u, netlongrad_g
  REAL(r8) :: shortradleaf_o_dir, shortradleaf_u_dir, shortradleaf_o_df&
& , shortradleaf_u_df
!albedo of overstorey/understorey/groudn(considering snow)
  REAL(r8) :: albedo_o, albedo_u, albedo_g
! albedo of three parts in visible and NIR band (considering snow)
  REAL(r8) :: albedo_v_os, albedo_n_os, albedo_v_us, albedo_n_us, &
& albedo_v_gs, albedo_n_gs
!emissivity of air,over/understorey, and ground
  REAL(r8) :: emissivity_air, emissivity_o, emissivity_u, emissivity_g
! longwave radiation emissted by different parts
  REAL(r8) :: longrad_air, longrad_o, longrad_u, longrad_g
! indicators to describe leaf distribution angles in canopy. slightly related with LAI
  REAL(r8) :: cosq_o, cosq_u
!gap fraction of direct and diffuse radiation for over/unerstory (diffuse used for diffuse solar radiation and longwave radiation
  REAL(r8) :: gap_o_dir, gap_u_dir, gap_o_df, gap_u_df
! considering stem
  REAL(r8) :: gap_os_dir, gap_us_dir, gap_os_df, gap_us_df
  INTRINSIC EXP
  INTRINSIC MIN
  INTRINSIC MAX
  REAL(r8) :: arg1
!calculate albedo of canopy in this step
  albedo_v_os = albedo_v_o*(1.-percentarea_snow_o) + albedo_snow_v*&
&   percentarea_snow_o
  albedo_n_os = albedo_n_o*(1.-percentarea_snow_o) + albedo_snow_n*&
&   percentarea_snow_o
  albedo_v_us = albedo_v_u*(1.-percentarea_snow_u) + albedo_snow_v*&
&   percentarea_snow_u
  albedo_n_us = albedo_n_u*(1.-percentarea_snow_u) + albedo_snow_n*&
&   percentarea_snow_u
  albedo_o = 0.5*(albedo_v_os+albedo_n_os)
  albedo_u = 0.5*(albedo_v_us+albedo_n_us)
! calculate albedo of ground 
  albedo_v_gs = albedo_v_g*(1.-percent_snow_g) + albedo_snow_v*&
&   percent_snow_g
  albedo_n_gs = albedo_n_g*(1.-percent_snow_g) + albedo_snow_n*&
&   percent_snow_g
  albedo_g = 0.5*(albedo_v_gs+albedo_n_gs)
! separate global solar radiation into df and dir  @orgin
!      Here we input df/dir directly               @J.Wang
! @J.Wang
  shortrad_global = shortrad_df + shortrad_dir
! fraction at each layer of canopy,df/dir, use LAI here
  IF (coszs .GT. zero) THEN
    IF (-(0.5*clumping*lai_o/coszs) .LT. -10.) THEN
      gap_o_dir = 0.
    ELSE
      arg1 = -(0.5*clumping*lai_o/coszs)
      gap_o_dir = EXP(arg1)
    END IF
    IF (-(0.5*clumping*lai_u/coszs) .LT. -10.) THEN
      gap_u_dir = 0.
    ELSE
      arg1 = -(0.5*clumping*lai_u/coszs)
      gap_u_dir = EXP(arg1)
    END IF
    IF (-(0.5*clumping*lai_os/coszs) .LT. -10.) THEN
      gap_os_dir = 0.
    ELSE
!considering stem
      arg1 = -(0.5*clumping*lai_os/coszs)
      gap_os_dir = EXP(arg1)
    END IF
    IF (-(0.5*clumping*lai_us/coszs) .LT. -10.) THEN
      gap_us_dir = 0.
    ELSE
      arg1 = -(0.5*clumping*lai_us/coszs)
      gap_us_dir = EXP(arg1)
    END IF
  END IF
!leaf distribution angles
  cosq_o = 0.537 + 0.025*lai_o
  cosq_u = 0.537 + 0.025*lai_u
  arg1 = -(0.5*clumping*lai_o/cosq_o)
  gap_o_df = EXP(arg1)
  arg1 = -(0.5*clumping*lai_u/cosq_u)
  gap_u_df = EXP(arg1)
  arg1 = -(0.5*clumping*lai_os/cosq_o)
  gap_os_df = EXP(arg1)
  arg1 = -(0.5*clumping*lai_us/cosq_u)
  gap_us_df = EXP(arg1)
!emissivity of each part
  CALL METEO_PACK(temp_air, rh)
  arg1 = -((e_actual*10.0)**((temp_air+273.15)/1200.0))
  emissivity_air = 1. - EXP(arg1)
  IF (1. .GT. emissivity_air) THEN
    emissivity_air = emissivity_air
  ELSE
    emissivity_air = 1.
  END IF
  IF (0.7 .LT. emissivity_air) THEN
    emissivity_air = emissivity_air
  ELSE
    emissivity_air = 0.7
  END IF
  emissivity_o = 0.98
  emissivity_u = 0.98
  emissivity_g = 0.96
!net short direct radiation on canopy and ground
  IF (shortrad_global .GT. zero .AND. coszs .GT. zero) THEN
! day time
    netshortrad_o_dir = shortrad_dir*(1.-albedo_o-(1.-albedo_u)*&
&     gap_o_dir)
    netshortrad_u_dir = shortrad_dir*gap_o_dir*(1.-albedo_u-(1.-albedo_g&
&     )*gap_u_dir)
    netshortrad_g_dir = shortrad_dir*gap_o_dir*gap_u_dir*(1.-albedo_g)
  ELSE
    netshortrad_o_dir = 0.
    netshortrad_u_dir = 0
    netshortrad_g_dir = 0
  END IF
!net short diffuse radiation on canopy and ground
  IF (shortrad_global .GT. zero .AND. coszs .GT. zero) THEN
! day time
    arg1 = -(1.*coszs)
    netshortrad_o_df = shortrad_df*(1.-albedo_o-(1.-albedo_u)*gap_o_df) &
&     + 0.21*clumping*shortrad_dir*(1.1-0.1*lai_o)*EXP(arg1)
    arg1 = -(1.*coszs)
    netshortrad_u_df = shortrad_df*gap_o_df*(1.-albedo_u-(1.-albedo_g)*&
&     gap_u_df) + 0.21*clumping*shortrad_dir*gap_o_dir*(1.1-0.1*lai_u)*&
&     EXP(arg1)
    netshortrad_g_df = shortrad_df*gap_o_df*gap_u_df*(1.-albedo_g)
  ELSE
    netshortrad_o_df = 0.
    netshortrad_u_df = 0.
    netshortrad_g_df = 0.
  END IF
!total net shortwave radiation at canopy level
  netshortrad_o = netshortrad_o_dir + netshortrad_o_df
  netshortrad_u = netshortrad_u_dir + netshortrad_u_df
  netshortrad_g = netshortrad_g_dir + netshortrad_g_df
!net longwave radiation on canopy and ground
  longrad_air = emissivity_air*sb_constant*(temp_air+273.15)**4
  longrad_o = emissivity_o*sb_constant*(temp_o+273.15)**4
  longrad_u = emissivity_u*sb_constant*(temp_u+273.15)**4
  longrad_g = emissivity_g*sb_constant*(temp_g+273.15)**4
  netlongrad_o = (emissivity_o*(longrad_air+longrad_u*(1.-gap_u_df)+&
&   longrad_g*gap_u_df)-2.*longrad_o)*(1.-gap_o_df) + emissivity_o*(1.-&
&   emissivity_u)*(1.-gap_u_df)*(longrad_air*gap_o_df+longrad_o*(1.-&
&   gap_o_df))
  netlongrad_u = (emissivity_u*(longrad_air*gap_o_df+longrad_o*(1.-&
&   gap_o_df)+longrad_g)-2.*longrad_u)*(1.-gap_u_df) + (1.-emissivity_g)&
&   *((longrad_air*gap_o_df+longrad_o*(1.-gap_o_df))*gap_u_df+longrad_u*&
&   (1.-gap_u_df)) + emissivity_u*(1.-emissivity_o)*(longrad_u*(1.-&
&   gap_u_df)+longrad_g*gap_u_df)*(1.-gap_o_df)
  netlongrad_g = emissivity_g*((longrad_air*gap_o_df+longrad_o*(1.-&
&   gap_o_df))*gap_u_df+longrad_u*(1.-gap_u_df)) - longrad_g + (1.-&
&   emissivity_u)*longrad_g*(1.-gap_u_df)
!total net radiation for overstorey/understorey/ground
  netrad_o = netshortrad_o + netlongrad_o
  netrad_u = netshortrad_u + netlongrad_u
  netrad_g = netshortrad_g + netlongrad_g
!leaf level net radiation updated way
! reference Chen2012 clumping index paper
  IF (shortrad_global .GT. zero .AND. coszs .GT. zero) THEN
    shortradleaf_o_dir = 0.5*shortrad_dir/coszs
    IF (shortradleaf_o_dir .GT. 0.7*1362.) THEN
      shortradleaf_o_dir = 0.7*1362.
    ELSE
      shortradleaf_o_dir = shortradleaf_o_dir
    END IF
    shortradleaf_u_dir = shortradleaf_o_dir
    shortradleaf_o_df = (shortrad_df-shortrad_df*gap_os_df)/lai_os + &
&     0.07*shortrad_dir*(1.1-0.1*lai_os)*EXP(-coszs)
    shortradleaf_u_df = (shortrad_df*gap_o_df-shortrad_df*gap_o_df*&
&     gap_us_df)/lai_us + 0.05*shortrad_dir*gap_o_dir*(1.1-0.1*lai_us)*&
&     EXP(-coszs)
  ELSE
    shortradleaf_o_dir = 0.
    shortradleaf_u_dir = 0.
    shortradleaf_o_df = 0.
    shortradleaf_u_df = 0.
  END IF
!overstorey sunlit leaves
  IF (lai_o_sunlit .GT. 0.) THEN
    netshortradleaf_o_sunlit = (shortradleaf_o_dir+shortradleaf_o_df)*(&
&     1.-albedo_o)
!leaf level net long
    netlongradleaf_o_sunlit = netlongrad_o/lai_os
    netradleaf_o_sunlit = netshortradleaf_o_sunlit + &
&     netlongradleaf_o_sunlit
  ELSE
    netshortradleaf_o_sunlit = (shortradleaf_o_dir+shortradleaf_o_df)*(&
&     1.-albedo_o)
    netlongradleaf_o_sunlit = netlongrad_o
    netradleaf_o_sunlit = netshortradleaf_o_sunlit + &
&     netlongradleaf_o_sunlit
  END IF
!overstorey shaded leaves
  IF (lai_o_shaded .GT. 0.) THEN
    netshortradleaf_o_shaded = shortradleaf_o_df*(1.-albedo_o)
    netlongradleaf_o_shaded = netlongrad_o/lai_os
    netradleaf_o_shaded = netshortradleaf_o_shaded + &
&     netlongradleaf_o_shaded
  ELSE
    netshortradleaf_o_shaded = shortradleaf_o_df*(1.-albedo_o)
    netlongradleaf_o_shaded = netlongrad_o
    netradleaf_o_shaded = netshortradleaf_o_shaded + &
&     netlongradleaf_o_shaded
  END IF
!understorey sunlit leaf
  IF (lai_u_sunlit .GT. 0.) THEN
    netshortradleaf_u_sunlit = (shortradleaf_u_dir+shortradleaf_u_df)*(&
&     1.-albedo_u)
    netlongradleaf_u_sunlit = netlongrad_u/lai_us
    netradleaf_u_sunlit = netshortradleaf_u_sunlit + &
&     netlongradleaf_u_sunlit
  ELSE
    netshortradleaf_u_sunlit = (shortradleaf_u_dir+shortradleaf_u_df)*(&
&     1.-albedo_u)
    netlongradleaf_u_sunlit = netlongrad_u
    netradleaf_u_sunlit = netshortradleaf_u_sunlit + &
&     netlongradleaf_u_sunlit
  END IF
!understorey shaded leaf
  IF (lai_u_shaded .GT. 0.) THEN
    netshortradleaf_u_shaded = shortradleaf_u_df*(1.-albedo_u)
    netlongradleaf_u_shaded = netlongrad_u/lai_us
    netradleaf_u_shaded = netshortradleaf_u_shaded + &
&     netlongradleaf_u_shaded
  ELSE
    netshortradleaf_u_shaded = shortradleaf_u_df*(1.-albedo_u)
    netlongradleaf_u_shaded = netlongrad_u
    netradleaf_u_shaded = netshortradleaf_u_shaded + &
&     netlongradleaf_u_shaded
  END IF
END SUBROUTINE NETRADIATION_CDV

! this module will calculate sensible heat from overstorey,understorey, and ground editted by XZ Luo, May23,2015
! inputs: 
! temperature of sunlit and shaded leaves from other storey (leaf temperature module)
! temperature of air,relative humidity
! temperature of ground (soil heat flux module)
! aerodynamic heat conductance of sunlit shaded leaves from over/understorey
! aerodynamic heat conductance of ground
! lAI sunlit and shaded, over/understorey (LAI module)
! Outputs:
! sensible heat from over/understorey and ground
SUBROUTINE SENSIBLEHEAT_CDV(templ_o_sunlit, templ_o_shaded, &
& templ_u_sunlit, templ_u_shaded, temp_g, temp_air, rh_air, &
& gheat_o_sunlit, gheat_o_shaded, gheat_u_sunlit, gheat_u_shaded, &
& gheat_g, lai_o_sunlit, lai_o_shaded, lai_u_sunlit, lai_u_shaded, sh_o&
& , sh_u, sh_g)
  USE METEOMOD_DIFFV
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  IMPLICIT NONE
  REAL(r8), INTENT(IN) :: templ_o_sunlit, templ_o_shaded, templ_u_sunlit&
& , templ_u_shaded, temp_g, temp_air, rh_air
  REAL(r8), INTENT(IN) :: gheat_o_sunlit, gheat_o_shaded, gheat_u_sunlit&
& , gheat_u_shaded, gheat_g
  REAL(r8), INTENT(IN) :: lai_o_sunlit, lai_o_shaded, lai_u_sunlit, &
& lai_u_shaded
  REAL(r8), INTENT(OUT) :: sh_o, sh_u, sh_g
  REAL(r8) :: sh_o_sunlit, sh_o_shaded, sh_u_sunlit, sh_u_shaded
  INTRINSIC MAX
  CALL METEO_PACK(temp_air, rh_air)
  sh_o_sunlit = (templ_o_sunlit-temp_air)*density_air*cp_air*&
&   gheat_o_sunlit
  sh_o_shaded = (templ_o_shaded-temp_air)*density_air*cp_air*&
&   gheat_o_shaded
  sh_u_sunlit = (templ_u_sunlit-temp_air)*density_air*cp_air*&
&   gheat_u_sunlit
  sh_u_shaded = (templ_u_shaded-temp_air)*density_air*cp_air*&
&   gheat_u_shaded
  sh_o = sh_o_sunlit*lai_o_sunlit + sh_o_shaded*lai_o_shaded
  sh_u = sh_u_sunlit*lai_u_sunlit + sh_u_shaded*lai_u_shaded
  IF (-200. .LT. sh_o) THEN
    sh_o = sh_o
  ELSE
    sh_o = -200.
  END IF
  IF (-200. .LT. sh_u) THEN
    sh_u = sh_u
  ELSE
    sh_u = -200.
  END IF
  sh_g = (temp_g-temp_air)*density_air*cp_air*gheat_g
  RETURN
END SUBROUTINE SENSIBLEHEAT_CDV

!!*******************************************
!! This module is used to get/put soilp data at single point
!! from global datasets
!! flag =0: get from ; flag=1: put into
!! Created by J.Wang
!!*******************************************
SUBROUTINE RETRIVE_SOILP_CDV(soilp, i, j, flag)
  USE BEPSTYPE_DIFFV
  USE BEPS_SOILMOD_DIFFV
  IMPLICIT NONE
  TYPE(SOIL) :: soilp
  INTEGER :: i, j, flag
  TYPE(SOILS), POINTER :: p
  INTERFACE 
      SUBROUTINE ENDRUN(msg)
        IMPLICIT NONE
        CHARACTER(len=*), INTENT(IN), OPTIONAL :: msg
      END SUBROUTINE ENDRUN
  END INTERFACE

  p => soilstat
  IF (i .GT. npoints .OR. j .GT. pft) CALL ENDRUN(&
&                           'out of the range of spatial points or PFTs'&
&                                          )
  IF (flag .EQ. 0) THEN
! getting data
    soilp%n_layer = p%n_layer(i)
    soilp%zp = p%zp(i, j)
    soilp%zsp = p%zsp(i, j)
    soilp%r_rain_g = p%r_rain_g(i, j)
    soilp%r_drainage = p%r_drainage(i, j)
    soilp%r_root_decay = p%r_root_decay(i, j)
    soilp%psi_min = p%psi_min(i, j)
    soilp%alpha = p%alpha(i, j)
    soilp%f_soilwater = p%f_soilwater(i, j)
    soilp%d_soil(:) = p%d_soil(i, :)
    soilp%f_root(:) = p%f_root(i, :, j)
    soilp%dt(:) = p%dt(i, :, j)
    soilp%thermal_cond(:) = p%thermal_cond(i, :, j)
    soilp%theta_vfc(:) = p%theta_vfc(i, :, j)
    soilp%theta_vwp(:) = p%theta_vwp(i, :, j)
    soilp%fei(:) = p%fei(i, :, j)
    soilp%ksat(:) = p%ksat(i, :, j)
    soilp%psi_sat(:) = p%psi_sat(i, :, j)
    soilp%b(:) = p%b(i, :, j)
    soilp%density_soil(:) = p%density_soil(i, :)
    soilp%f_org(:) = p%f_org(i, :, j)
    soilp%ice_ratio(:) = p%ice_ratio(i, :, j)
    soilp%thetam(:) = p%thetam(i, :, j)
    soilp%thetam_prev(:) = p%thetam_prev(i, :, j)
    soilp%temp_soil_p(:) = p%temp_soil_p(i, :, j)
    soilp%temp_soil_c(:) = p%temp_soil_c(i, :, j)
    soilp%f_ice(:) = p%f_ice(i, :, j)
    soilp%psim(:) = p%psim(i, :, j)
    soilp%thetab(:) = p%thetab(i, :, j)
    soilp%psib(:) = p%psib(i, :, j)
    soilp%r_waterflow(:) = p%r_waterflow(i, :, j)
    soilp%km(:) = p%km(i, :, j)
    soilp%kb(:) = p%kb(i, :, j)
    soilp%kk(:) = p%kk(i, :, j)
    soilp%cs(:) = p%cs(i, :, j)
    soilp%lambda(:) = p%lambda(i, :, j)
    soilp%ett(:) = p%ett(i, :, j)
    soilp%g(:) = p%g(i, :, j)
  ELSE IF (flag .EQ. 1) THEN
!! storing data
    p%n_layer(i) = soilp%n_layer
    p%zp(i, j) = soilp%zp
    p%zsp(i, j) = soilp%zsp
    p%r_rain_g(i, j) = soilp%r_rain_g
    p%r_drainage(i, j) = soilp%r_drainage
    p%r_root_decay(i, j) = soilp%r_root_decay
    p%psi_min(i, j) = soilp%psi_min
    p%alpha(i, j) = soilp%alpha
    p%f_soilwater(i, j) = soilp%f_soilwater
    p%d_soil(i, :) = soilp%d_soil(:)
    p%f_root(i, :, j) = soilp%f_root(:)
    p%dt(i, :, j) = soilp%dt(:)
    p%thermal_cond(i, :, j) = soilp%thermal_cond(:)
    p%theta_vfc(i, :, j) = soilp%theta_vfc(:)
    p%theta_vwp(i, :, j) = soilp%theta_vwp(:)
    p%fei(i, :, j) = soilp%fei(:)
    p%ksat(i, :, j) = soilp%ksat(:)
    p%psi_sat(i, :, j) = soilp%psi_sat(:)
    p%b(i, :, j) = soilp%b(:)
    p%density_soil(i, :) = soilp%density_soil(:)
    p%f_org(i, :, j) = soilp%f_org(:)
    p%ice_ratio(i, :, j) = soilp%ice_ratio(:)
    p%thetam(i, :, j) = soilp%thetam(:)
    p%thetam_prev(i, :, j) = soilp%thetam_prev(:)
    p%temp_soil_p(i, :, j) = soilp%temp_soil_p(:)
    p%temp_soil_c(i, :, j) = soilp%temp_soil_c(:)
    p%f_ice(i, :, j) = soilp%f_ice(:)
    p%psim(i, :, j) = soilp%psim(:)
    p%thetab(i, :, j) = soilp%thetab(:)
    p%psib(i, :, j) = soilp%psib(:)
    p%r_waterflow(i, :, j) = soilp%r_waterflow(:)
    p%km(i, :, j) = soilp%km(:)
    p%kb(i, :, j) = soilp%kb(:)
    p%kk(i, :, j) = soilp%kk(:)
    p%cs(i, :, j) = soilp%cs(:)
    p%lambda(i, :, j) = soilp%lambda(:)
    p%ett(i, :, j) = soilp%ett(:)
    p%g(i, :, j) = soilp%g(:)
  END IF
END SUBROUTINE RETRIVE_SOILP_CDV

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!> \file bepsfunc_setup.F90
!> \brief provides interfaces for setup and configuration of running
!>        the functional implementation of BEPS as
!>        suitable for use within sensitivity and optimisation framework.
!>
!> \authors The Inversion Lab (Michael Vossbeck, Thomas Kaminski) 
!> \date  January 2020
!> \last  June 2022
!                               
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!***********************************************************
!     initf
!
!> @brief determines sizes of control vector (n) and overall size of
!>        simulation vector (m)
!>        In addition necessary initialisations to actually run selected observational operator(s)
!>        need to be performed.
!
!> @details 
!
!> @param[out]  n  overall length of control vector
!> @param[out]  m  overall length of simulation vector
!
!> \authors Michael Vossbeck, The Inversion Lab
!> \date    January 2020
SUBROUTINE INITF_CDV(n, m)
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE CONTROLINPUT_MOD_DIFFV
  USE BEPS_TIME_MANAGER, ONLY : set_timemgr_init, timemgr_init, &
& get_curr_date, advance_timestep, is_last_step, get_doys, &
& get_curr_calday, get_nstep, get_start_date, timemgr_diff_secs
  USE BEPSTYPE_DIFFV
  USE BEPSTYPEINIT_DIFFV
  USE RESTART_DIFFV
  USE ESMF, ONLY : esmf_initialize
  USE MO_BEPSFUNC_CTL
  IMPLICIT NONE
!- arguments
  INTEGER, INTENT(OUT) :: n, m
!-local variables
  CHARACTER(len=*), PARAMETER :: sub='initf_cdv::'
  LOGICAL :: ldebug
  CHARACTER(len=32) :: fmt
  INTRINSIC TRIM
  EXTERNAL NCREADOBS
  CHARACTER(len=4) :: result1
!-- init
  ldebug = .false.
  n = -1
  m = -1
!! setting up MPI enviroments with the namelists
!   call Initmpi()
  CALL RDNAMELIST()
  IF (nscale .EQ. 1) THEN
    nlp = n_site
    npoints = nlp
    WRITE(*, '(a,2(a,i3,1x))') ' INFO::'//sub, 'nlp=', nlp, 'npoints=', &
&   npoints
    WRITE(*, *) 'site points check', npoints
  END IF
!! Initialize the beps types
  CALL INITBEPSTYPE()
!! Initialize output
  CALL INIT_OUTPUT()
!--------------------------------------------------------------------------
! Initialize ESMF.  This is done outside of the ESMF_INTERFACE ifdef
! because it is needed for the time manager, even if the ESMF_INTERFACE
! is not used.
!--------------------------------------------------------------------------
  CALL ESMF_INITIALIZE()
!! setting time manager
  IF (nsrest .EQ. nsrstartup) THEN
!!! calling time_manager set init
    CALL SET_TIMEMGR_INIT(calendar_in=calendar, start_ymd_in=icdate, &
&                   start_tod_in=icsec, nelapse_in=sim_duration, &
&                   dtime_in=step)
  ELSE IF (nsrest .EQ. nsrcontinue) THEN
    CALL RESTART_IO('read')
    CALL SET_TIMEMGR_INIT(calendar_in=calendar, start_ymd_in=rst_icdate&
&                   , start_tod_in=rst_icsec, nelapse_in=sim_duration, &
&                   dtime_in=step)
  END IF
  CALL TIMEMGR_INIT()
  IF (nscale .EQ. 0) THEN
! nscale = 0 for global simulation, 1 for site simulation
    WRITE(*, '(a)') ' INFO::'//sub//'BEPS run at global scale!'
!! Reading boundary fields, yearly data,and soil Cpools for BEPS @J.Wang (note: if yearly and C pools data fields will change yea
!r by year, these datasets should be read in the time looping
    CALL READ_BOUNDARY()
    CALL READ_YRDATA()
    CALL READ_CPOOLS()
  ELSE
    WRITE(*, '(a)') ' INFO::'//sub//&
&   'BEPS run at site / multiple-point scale!'
! read site data, including yrdata, boundary data, and carbon pools
    CALL READ_BOUNDARY_SITE()
  END IF
!-- get number of time steps
  CALL BEPS_TIME_SETUP(ntp)
!-- iLab::we do have 'nsimvar' simulated variables,
!         'ntp' timesteps and 'nlp' land points (i.e. sites)
!         toplevel function 'bepsf_timesum' (see bepsfunc.F90) build temporal sum over
!         variables:
  m = ntp*nlp*nsimvar
!
  result1 = IFMT(ntp)
  fmt = '(a,'//TRIM(result1)//')'
  WRITE(*, fmt) ' INFO::'//sub//' ntp=', ntp
  result1 = IFMT(nlp)
  fmt = '(a,'//TRIM(result1)//')'
  WRITE(*, fmt) ' INFO::'//sub//' nlp=', nlp
  result1 = IFMT(nsimvar)
  fmt = '(a,'//TRIM(result1)//')'
  WRITE(*, fmt) ' INFO::'//sub//' nsimvar=', nsimvar
  result1 = IFMT(m)
  fmt = '(a,1(a,'//TRIM(result1)//'),a)'
  WRITE(*, fmt) ' INFO::'//sub//' ...dependents DONE. (', 'm=', m, ')'
!MOUSONG WU,2020-09-21
! 1. the parameters to be optimized have been modified, thes parameters include p_Ksat,p_b,these two are soil texture differentia
!ted, in total 2*11,
! p_Vcmax,p_VJ_slope,sif_alpha,sif_beta,p_q10,p_D0,p_taueff, these are PFT differentiated, in total 7*9
! p_f_leaf,p_kc25,p_ko25,p_tau25,p_agbvod, in total 5*1
! Totally, 90 parameters are optimized in this new version. In practice, when we only focus on carbon fluxes, there might not be 
!so many parameters to be optimized, for example,
! the parameters related to SIF, VOD will not be optimized. this means that we have a maximum of 90 parameters to be optimized in
! this model.
! these parameters have been assigned with prior values and uncertainties.
!-- iLab::**7** PFT differentiated parameter (Vcmax,VJ_slope,Q10,sif_alpha,sif_beta,D0,taueff)
!         **2** texture differentiated parameter (Ksat, b)
!         **5** global parameter (f_leaf,kc25,ko25,tau25,agb2vod)
!-- CHANGED 06/2022: since VOD will not be assimilated, we can skip the respective parameters
!                    D0, taueff, agb2vod
!-- iLab::**5** PFT differentiated parameter (Vcmax,VJ_slope,Q10,sif_alpha,sif_beta)
!         **2** texture differentiated parameter (Ksat, b)
!         **4** global parameter (f_leaf,kc25,ko25,tau25)
  WRITE(*, '(a)') ' INFO::'//sub//&
& ' start determining number of parameter...'
  n = 5*pft + 2*texture + 4
!
  result1 = IFMT(n)
  fmt = '(a,1(a,'//TRIM(result1)//'),a)'
  WRITE(*, fmt) ' INFO::'//sub//' ...parameter DONE. (', 'n=', n, ')'
  CALL NCREADOBS(m, 'obs.nc')

CONTAINS
  FUNCTION IFMT(n) RESULT (fmt)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: n
    CHARACTER(len=4) :: fmt
    IF (n .LT. 10) THEN
      fmt = 'i1'
    ELSE IF (n .LT. 100) THEN
      fmt = 'i2'
    ELSE IF (n .LT. 1000) THEN
      fmt = 'i3'
    ELSE IF (n .LT. 10000) THEN
      fmt = 'i4'
    ELSE IF (n .LT. 100000) THEN
      fmt = 'i5'
    ELSE IF (n .LT. 1000000) THEN
      fmt = 'i6'
    ELSE IF (n .LT. 10000000) THEN
      fmt = 'i7'
    ELSE
      fmt = 'i15'
    END IF
  END FUNCTION IFMT

  SUBROUTINE BEPS_TIME_SETUP(nt)
    IMPLICIT NONE
! local declarations
    INTEGER, INTENT(OUT) :: nt
    INTEGER :: yr, mn, dy, tod
    INTEGER :: yr_ref, mn_ref, dy_ref, tod_ref
    INTEGER, ALLOCATABLE :: ymds(:, :)
    INTEGER :: it
    INTEGER :: caldy, doys, kount
    CHARACTER(len=*), PARAMETER :: sub='beps_time_setup'
    INTEGER :: arg1
    INTEGER :: arg2
!-- set timer to startup (very likely not necessary here)
    CALL TIMEMGR_INIT()
    IF (ldebug) OPEN(1, file='beps_times_1.asc', form='formatted', &
&              action='write') 
!-- take the first
!-- determine number of time-steps
    nt = 0
!! end time loop
timeloop:DO 
      nt = nt + 1
      CALL GET_CURR_DATE(yr, mn, dy, tod)
!-- take the first date as reference time/date
      IF (nt .EQ. 1) THEN
        IF (tod .NE. 0) THEN
          WRITE(*, '(1x,a)') 'FATAL::'//sub//&
&         'tod was expected to be zero for reference date!'
          STOP
        ELSE
          yr_ref = yr
          mn_ref = mn
          dy_ref = dy
          tod_ref = tod
          WRITE(ref_date(1:4), '(i4.4)') yr_ref
          WRITE(ref_date(5:5), '(a)') '-'
          WRITE(ref_date(6:7), '(i2.2)') mn_ref
          WRITE(ref_date(8:8), '(a)') '-'
          WRITE(ref_date(9:10), '(i2.2)') dy_ref
          WRITE(ref_date(11:19), '(a)') 'T00:00:00'
        END IF
      END IF
      IF (ldebug) THEN
        caldy = GET_CURR_CALDAY()
        doys = GET_DOYS(yr)
        kount = GET_NSTEP()
        WRITE(1, '(a,i3,1x,a,i4,1x,2(a,i2,1x),a,i5,1x,2(a,i3,1x),a,i3)')&
&       'nt=', nt, 'yr=', yr, 'mn=', mn, 'dy=', dy, 'tod=', tod, &
&       'caldy=', caldy, 'doys=', doys, 'kount=', kount
      END IF
!! advance time
      CALL ADVANCE_TIMESTEP()
      IF (IS_LAST_STEP()) THEN
        IF (ldebug) CLOSE(1) 
!-- allocate time-point array
!   NOTE:we store one time-point more for restart purpose
        ALLOCATE(time_points(6, nt+1))
        ALLOCATE(seconds_since_ref(nt))
!-- reset timer to first time-step
        CALL TIMEMGR_INIT()
        IF (ldebug) OPEN(1, file='beps_times_2.asc', form='formatted', &
&                  action='write') 
        it = 0
 ttloop:DO 
          it = it + 1
          CALL GET_CURR_DATE(yr, mn, dy, tod)
          IF (ldebug) THEN
            caldy = GET_CURR_CALDAY()
            doys = GET_DOYS(yr)
            kount = GET_NSTEP()
            WRITE(1, &
&           '(a,i3,1x,a,i4,1x,2(a,i2,1x),a,i5,1x,2(a,i3,1x),a,i3)') &
&           'nt=', it, 'yr=', yr, 'mn=', mn, 'dy=', dy, 'tod=', tod, &
&           'caldy=', caldy, 'doys=', doys, 'kount=', kount
          END IF
          time_points(1, it) = yr
          time_points(2, it) = mn
          time_points(3, it) = dy
          time_points(4, it) = tod
          time_points(5, it) = GET_CURR_CALDAY()
          time_points(6, it) = GET_DOYS(yr)
!-- seconds elapsed since reference date/time
          arg1 = yr_ref*10000 + mn_ref*100 + dy_ref
          arg2 = yr*10000 + mn*100 + dy
          CALL TIMEMGR_DIFF_SECS(arg1, tod_ref, arg2, tod, &
&                          seconds_since_ref(it))
!! advance time
          CALL ADVANCE_TIMESTEP()
          IF (IS_LAST_STEP()) THEN
!-- save first time-point *after* simulation period (restart)
            CALL GET_CURR_DATE(yr, mn, dy, tod)
            time_points(1, it+1) = yr
            time_points(2, it+1) = mn
            time_points(3, it+1) = dy
            time_points(4, it+1) = tod
            time_points(5, it+1) = GET_CURR_CALDAY()
            time_points(6, it+1) = GET_DOYS(yr)
            IF (ldebug) CLOSE(1) 
!-- reset timer to first time-step
            CALL TIMEMGR_INIT()
            GOTO 100
          END IF
        END DO ttloop
      END IF
    END DO timeloop
 100 CONTINUE
  END SUBROUTINE BEPS_TIME_SETUP

END SUBROUTINE INITF_CDV

!***********************************************************
!     x2beps
!
!> @brief maps one-dimensional (normalised) control vector
!>        to the respective physical BEPS parameter(s)
!>
!> @param[in]   n   length of control vector
!> @param[in]   x   control vector (in normalised units)
!
!> \authors Michael Vossbeck, The Inversion Lab
!> \date    February 2020
!>
SUBROUTINE X2BEPS_CDV(n, x)
  USE MO_PRIOR
  USE BEPSTYPE_DIFFV, ONLY : assim
  USE BEPS_PAR, ONLY : pft, texture
  IMPLICIT NONE
!-- iLab::CHANGED 06/2022: D0,TAWEFF not required since VOD is not assimilated
! !-- agb2vod
! !   (...)
! i1 = i1+1
! assim%p_agb2vod = xphys(i1)
! arguments
  INTEGER, INTENT(IN) :: n
  REAL(kind=8), INTENT(IN) :: x(n)
! local declarations
  REAL(kind=8) :: xphys(n)
  INTEGER :: i1, i2
!-- convert to phyiscal units
  xphys = x*x_sigma
!-- Vcmax
!   (for the 'Vcmax' parameter)
  i1 = 1
  i2 = i1 + pft - 1
  assim%p_vcmax = xphys(i1:i2)
!-- VJ_slope
!   (...)
  i1 = i2 + 1
  i2 = i1 + pft - 1
  assim%p_vj_slope = xphys(i1:i2)
!-- Q10
!   (parameter to adjust 'q10' in calculation plant respiration)
  i1 = i2 + 1
  i2 = i1 + pft - 1
  assim%p_q10 = xphys(i1:i2)
!-- SIF alpha
!   (...)
  i1 = i2 + 1
  i2 = i1 + pft - 1
  assim%p_sif_alpha = xphys(i1:i2)
!-- SIF beta
!   (...)
  i1 = i2 + 1
  i2 = i1 + pft - 1
  assim%p_sif_beta = xphys(i1:i2)
!-- iLab::CHANGED 06/2022: D0,TAWEFF not required since VOD is not assimilated
! !-- D0
! !   (...)
! i1 = i2+1
! i2 = i1+PFT-1
! assim%p_D0     = xphys(i1:i2)
! !-- taueff
! !   (...)
! i1 = i2+1
! i2 = i1+PFT-1
! assim%p_taweff = xphys(i1:i2)
!-- Ksat
!   (parameter to adjust 'Ksat', the saturated hydraulic conductivity, in beps_soilMod.F90)
  i1 = i2 + 1
  i2 = i1 + texture - 1
  assim%p_ksat_scalar = xphys(i1:i2)
!-- b
!   (parameter to adjust 'b', the parameters for calculating soil water characteristic, in beps_soilMode.F90)
  i1 = i2 + 1
  i2 = i1 + texture - 1
  assim%p_b_scalar = xphys(i1:i2)
!-- f_leaf
!   (...)
  i1 = i2 + 1
  assim%p_f_leaf = xphys(i1)
!-- kc25
!   (...)
  i1 = i1 + 1
  assim%p_kc25 = xphys(i1)
!-- ko25
!   (...)
  i1 = i1 + 1
  assim%p_ko25 = xphys(i1)
!-- tau25
!   (...)
  i1 = i1 + 1
  assim%p_tau25 = xphys(i1)
END SUBROUTINE X2BEPS_CDV

!  Differentiation of cost in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: f
!   with respect to varying inputs: x
!   RW status of diff variables: f:out x:in (global)bound_layer_res.vapor:(loc)
!                (global)fact.latent:(loc) (global)e_actual:(loc)
!                (global)cp_air:(loc) (global)e_saturate:(loc)
!                (global)sp_humidity:(loc) (global)vpd:(loc) (global)slope_vapor:(loc)
!       module to compute cost function
!       ilab march 2021
SUBROUTINE COST_FWV(n, x, x_fw, m, f, f_fw, nbdirs)
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
! arguments
  INTEGER(kind=4), INTENT(IN) :: n, m
  REAL(kind=8), INTENT(IN) :: x(n)
  REAL(kind=8), INTENT(IN) :: x_fw(nbdirsmax, n)
  REAL(kind=8), INTENT(OUT) :: f
  REAL(kind=8), DIMENSION(nbdirsmax), INTENT(OUT) :: f_fw
! local
  REAL(kind=8) :: obsdiff(m), priordiff(n)
  REAL(kind=8) :: obsdiff_fw(nbdirsmax, m), priordiff_fw(nbdirsmax, n)
  INTRINSIC SUM
  REAL(kind=8), DIMENSION(m) :: arg1
  REAL(kind=8), DIMENSION(nbdirsmax, m) :: arg1_fw
  REAL(kind=8), DIMENSION(n) :: arg2
  REAL(kind=8), DIMENSION(nbdirsmax, n) :: arg2_fw
  INTEGER :: nd
  INTEGER :: nbdirs
  CALL MISFIT_FWV(n, x, x_fw, m, obsdiff, obsdiff_fw, nbdirs)
  CALL DEVPRIOR_FWV(n, x, x_fw, priordiff, priordiff_fw, nbdirs)
  DO nd=1,nbdirs
    arg1_fw(nd, :) = 2*obsdiff*obsdiff_fw(nd, :)
    arg2_fw(nd, :) = 2*priordiff*priordiff_fw(nd, :)
    f_fw(nd) = 0.5*(SUM(arg1_fw(nd, :))+SUM(arg2_fw(nd, :)))
  END DO
  arg1(:) = obsdiff**2
  arg2(:) = priordiff**2
  f = 0.5*(SUM(arg1(:))+SUM(arg2(:)))
END SUBROUTINE COST_FWV

!  Differentiation of misfit in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: obsdiff
!   with respect to varying inputs: x
!       module to compute model-data misfit
!       ilab march 2021
!       last: 06/2022
SUBROUTINE MISFIT_FWV(n, x, x_fw, m, obsdiff, obsdiff_fw, nbdirs)
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
! arguments
  INTEGER(kind=4), INTENT(IN) :: n, m
  REAL(kind=8), INTENT(IN) :: x(n)
  REAL(kind=8), INTENT(IN) :: x_fw(nbdirsmax, n)
  REAL(kind=8), INTENT(OUT) :: obsdiff(m)
  REAL(kind=8), INTENT(OUT) :: obsdiff_fw(nbdirsmax, m)
! local
  REAL(kind=8) :: y(m), yobs(m), syobs(m), obs_missing_value
  REAL(kind=8) :: y_fw(nbdirsmax, m)
  INTEGER :: nd
  INTEGER :: nbdirs
! read obs
  CALL GETOBS(m, yobs, syobs, obs_missing_value)
! simulate obs
  CALL EVALF_FWV(n, x, x_fw, m, y, y_fw, nbdirs)
  obsdiff_fw(:, :) = 0.0_8
  DO nd=1,nbdirs
    WHERE (yobs .NE. obs_missing_value) obsdiff_fw(nd, :) = y_fw(nd, :)/&
&       syobs
  END DO
  WHERE (yobs .NE. obs_missing_value) obsdiff = (y-yobs)/syobs
  DO nd=1,nbdirs
    WHERE (.NOT.yobs .NE. obs_missing_value) obsdiff_fw(nd, :) = 0.0_8
  END DO
  WHERE (.NOT.yobs .NE. obs_missing_value) obsdiff = 0.
END SUBROUTINE MISFIT_FWV

!  Differentiation of evalf in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: y
!   with respect to varying inputs: x
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!> \file bepsfunc.F90
!> \brief defines a functional implementation for running BEPS model,
!>        and defines the interface for using BEPS within
!>        a sensitivity and/or optimisation framework.
!>        It defines the top-level interface 'evalf' that maps
!>        a one-dimensional control vector (normalised coordinates)
!>        to a one-dimensional simulation vector.
!>        Please note, that the implementation core of this routine
!>        was taken/transferrred from the original BEPS driver.
!>
!> \authors The Inversion Lab (Michael Vossbeck, Thomas Kaminski) 
!> \date  January 2020 (with several updates applied thereafter)
!                               
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!***********************************************************
!     evalf
!
!> @brief function like BEPS model evaluation (or simulation)
!>        that maps a given one-dimensional control vector x ("independents")
!>        in normalised units to a one-dimensional simulation vector y ("dependents")
!>        The 1D control vector captures 3 BEPS quantities (SIF, Thetam, COSflux),
!>        ordering in the 1D vector is (varying slowest to fastest)
!>        time (hourly), site, BEPS-quantity.
!>
!> @param[in]   n   length of control vector
!> @param[in]   x   control vector (in normalised units)
!> @param[in]   m   length of simulation vector
!> @param[out]  y   simulation vector
!
!> \authors Michael Vossbeck, The Inversion Lab
!> \date    January 2020
!> \last    June 2022
!>
SUBROUTINE EVALF_FWV(n, x, x_fw, m, y, y_fw, nbdirs)
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE BEPS_CON, ONLY : pi
  USE CONTROLINPUT_MOD_DIFFV, ONLY : lai_input, meteo_input, &
& sim_duration, restart_frq, nscale, read_meteo_site, read_meteo_daily, &
& read_meteo_hourly, read_lai_site, read_lai
! use controlInput_mod
  USE BEPSTYPE_DIFFV, ONLY : bound, clim, assim, assim_fw
  USE ECORESPMOD_DIFFV, ONLY : plant_resp, soil_resp
  USE MID_RESULTS_DIFFV
  USE BEPS_SOILMOD_DIFFV, ONLY : soil, soil_diffv, init_soil_parameters,&
& init_soil_parameters_fwv, init_soil_status, init_soil_status_fwv
  USE BEPS_PAR
  USE OUTPUTMOD_DIFFV, ONLY : output, output_fw, av_output
  USE RESTART_DIFFV, ONLY : v2last, v2last_fw, restart_io
  USE MO_BEPSFUNC_CTL
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
! arguments
  INTEGER, INTENT(IN) :: n, m
  REAL(kind=8), INTENT(IN) :: x(n)
  REAL(kind=8), INTENT(IN) :: x_fw(nbdirsmax, n)
  REAL(kind=8), INTENT(OUT) :: y(m)
  REAL(kind=8), INTENT(OUT) :: y_fw(nbdirsmax, m)
! local declarations
  CHARACTER(len=*), PARAMETER :: sub='evalf_fwv'
  TYPE(CLIMATEDATA) :: meteo
  TYPE(RESULTS) :: mid_res
  TYPE(RESULTS_DIFFV) :: mid_res_fw
!! solar zenith angle, local time, local time arc
  REAL(r8) :: coszs, hr_loc, hr_arc
  INTEGER :: i, j, k, jj, ii, kk
!! at single point
  TYPE(SOIL) :: soilp
  TYPE(SOIL_DIFFV) :: soilp_fw
  REAL(r8) :: ccd(0:4), cssd(0:4), csmd(0:4), cfsd(0:4), cfmd(0:4), csm(&
& 0:4), cm(0:4), cs(0:4), cp(0:4)
  REAL(r8) :: param(0:49), var_o(0:40), var_n(0:40), coef(0:49)
  REAL(r8) :: var_o_fw(nbdirsmax, 0:40), var_n_fw(nbdirsmax, 0:40)
  REAL(r8) :: lai
  REAL(r8), DIMENSION(nbdirsmax) :: lai_fw
  REAL(r8) :: ratio_cloud, shortrad_df, shortrad_dir
!-- iLab::similar changes as in driver.F90 by MSWU@2020-09-21
! real(r8)             :: NPP_yr_acc           !! for storing yearly accumulated NPP, Mh/ha/s
! real(r8)             :: agb2vod
! real(r8)             :: D0(1:9)
! real(r8)             :: taweff(1:9)
  INTEGER :: kount, rst_nstep
  INTEGER :: yr, mn, dy, tod, caldy
  INTEGER :: yr_next, mn_next, dy_next, tod_next
  REAL(r8) :: daylen
! .. Parameters for model-internal use
  REAL(r8), SAVE :: pio180=pi/180.
! variables for daily input, used in climin and getmonth
  REAL(r8) :: spds, cpds
! .. Local Arrays
  REAL(r8) :: atmean, atrange
! .. Local Scalars ..
! real(r8)             :: r
  REAL(r8) :: rdaymid, delta, arg, h0, h1, sd, sd1, dhour, tmin, tmp1
  REAL(r8) :: a, b, sunset_arc
!! for counting the time-step number, i.e. ith step
  INTEGER :: nd
!-- iLab::ported from MSWU changes () in driver.f90
!-- index being passed to read_meteo_site
  INTEGER :: n_meteo
! .. Intrinsic Functions ..
  INTRINSIC ACOS, COS, SIN, MOD, ATAN, REAL
!-- counter for 1D simulation vector
  INTEGER :: jcnt
!-- number of days in (actual) year
  INTEGER :: doys
  LOGICAL :: is_end_curr_year, is_end_curr_month, is_end_curr_day, &
& is_first_step
  LOGICAL, SAVE :: bepsf_debug=.false.
  INTRINSIC MIN
  INTRINSIC MAX
  INTRINSIC SUM
  REAL(r8) :: arg1
  REAL(r8) :: arg2
  REAL(r8) :: result1
  INTEGER :: nd0
  INTEGER :: nbdirs
!-- consistency
  IF (nscale .NE. 1) THEN
    WRITE(*, '(a)') ' FATAL::'//sub//&
&   ':setup was *not* set for site-level!'
    STOP
  ELSE IF (meteo_input .LT. 0) THEN
    WRITE(*, '(a)') ' FATAL::'//sub//&
&   ':for site-level only hourly meteorological input'//' is supported.'
    STOP
  ELSE IF (lai_input .LT. 0) THEN
    WRITE(*, '(a)') ' FATAL::'//sub//&
&   ':for site-level LAI is expected to be forcing input.'
    STOP
  ELSE
! parameters used for calculating VOD,@MOUSONG.WU,2019-11
!-- iLab::similar changes as in driver.F90 by MSWU@2020-09-21
! NPP_yr_acc = 0.
! agb2vod = 0.9517
! D0 = (/0.05,0.05,0.05,0.05,0.05,0.05,0.05,0.05,0.05/)
! taweff = (/15.0, 15.0, 0., 0., 0., 15., 0., 0., 15./)
    output%npp_yr_acc = 0._r8
!-- initialise simulation vector
    y = fillval_r8
!-- map actual control vector to model parameter
    CALL X2BEPS_FWV(n, x, x_fw, nbdirs)
    jcnt = 1
    y_fw(:, :) = 0.0_8
    var_n_fw(:, :) = 0.0_8
    var_o_fw(:, :) = 0.0_8
    mid_res_fw%lai_old(:) = 0.0_8
    mid_res_fw%lai_new(:) = 0.0_8
    soilp_fw%dt(:, :) = 0.0_8
    soilp_fw%ksat(:, :) = 0.0_8
    soilp_fw%b(:, :) = 0.0_8
    soilp_fw%ice_ratio(:, :) = 0.0_8
    soilp_fw%thetam(:, :) = 0.0_8
    soilp_fw%thetam_prev(:, :) = 0.0_8
    soilp_fw%temp_soil_p(:, :) = 0.0_8
    soilp_fw%temp_soil_c(:, :) = 0.0_8
    soilp_fw%f_ice(:, :) = 0.0_8
    soilp_fw%psim(:, :) = 0.0_8
    soilp_fw%thetab(:, :) = 0.0_8
    soilp_fw%psib(:, :) = 0.0_8
    soilp_fw%r_waterflow(:, :) = 0.0_8
    soilp_fw%km(:, :) = 0.0_8
    soilp_fw%kb(:, :) = 0.0_8
    soilp_fw%kk(:, :) = 0.0_8
    soilp_fw%cs(:, :) = 0.0_8
    soilp_fw%lambda(:, :) = 0.0_8
    soilp_fw%ett(:, :) = 0.0_8
    soilp_fw%g(:, :) = 0.0_8
!! end time loop
!! start time looping
timeloop:DO nd=1,ntp
      yr = time_points(1, nd)
      mn = time_points(2, nd)
      dy = time_points(3, nd)
      tod = time_points(4, nd)
      caldy = time_points(5, nd)
      doys = time_points(6, nd)
      is_first_step = nd .EQ. 1
!--iLab::equations taken from beps_time_manager
      is_end_curr_year = mn .EQ. 1 .AND. dy .EQ. 1 .AND. tod .EQ. 0
      is_end_curr_month = dy .EQ. 1 .AND. tod .EQ. 0
      is_end_curr_day = tod .EQ. 0
      CALL GET_CO2_CONCENTRATION(yr, co2_air)
      CALL GET_COS_CONCENTRATION(yr, cos_air)
!! change hourly input into daily input for further using model for long-term simulations, @MOUSONG.WU, 201905
      IF (meteo_input .GE. 0) THEN
! call hourly meteo. input
        IF (nscale .EQ. 0) THEN
          CALL READ_METEO_HOURLY(yr, mn, dy, tod)
        ELSE
!-- iLab::adapted index (similar to changes in driver.f90 by MSWU,bepspkg_2020-09-21_essi)
          CALL GET_NMETEO_CDV(yr, mn, dy, tod, n_meteo)
          CALL READ_METEO_SITE(n_meteo)
        END IF
      ELSE IF (is_first_step .OR. is_end_curr_day) THEN
        CALL READ_METEO_DAILY(yr, mn, dy, tod)
      END IF
      IF (lai_input .GE. 0) THEN
! print *, 'lai is input!'
        IF (is_first_step .OR. is_end_curr_day) THEN
          IF (nscale .EQ. 0) THEN
            CALL READ_LAI(yr, mn, dy, tod, caldy)
          ELSE
            CALL READ_LAI_SITE(caldy)
          END IF
        END IF
      END IF
! print *, 'lai is simulated with phenology scheme!'
!! end spatial loop
! Reading the Vcmax here for assimilation usage @J.Wang
!if(is_first_step() .or. is_end_curr_month()) then
!   if (nscale == 0) then
!    call read_Vcmax(yr, mn, dy, tod)
!   else
!    call read_Vcmax_site(yr, mn, dy, tod)
!   end if
!end if
!    call mpi_barrier(mpi_comm_world,ierr)
!! spatial iteration
pointloop:DO i=1,npoints
!! calculate the solar zenith
        CALL S_COSZS(yr, mn, dy, tod, caldy, doys, bound%latitude(i), &
&              bound%longitude(i), coszs, hr_loc, hr_arc)
!!if(myid == 0) write(*,*) "hr_loc=",hr_loc
!! retrieve meteo for this point
        meteo%srad = clim%srad(i)
        meteo%wind = clim%wind(i)
        meteo%rainfall = clim%rain(i)
        meteo%snow = clim%snow(i)
        meteo%rh = clim%rh(i)
        IF (meteo_input .LT. 0) THEN
! read daily max and min temperatures instead
          meteo%tempmx = clim%tempmx(i)
          meteo%tempmn = clim%tempmn(i)
        ELSE
          meteo%temp = clim%temp(i)
        END IF
! .. compute daily course of temperature and daylength
        rdaymid = REAL(sim_duration+1)/2.
        arg1 = 2.*pi*(rdaymid+10.)/365.
        delta = -(23.4*COS(arg1))
        arg1 = bound%latitude(i)*pio180
        arg2 = delta*pio180
        spds = SIN(arg1)*SIN(arg2)
        arg1 = bound%latitude(i)*pio180
        arg2 = delta*pio180
        cpds = COS(arg1)*COS(arg2)
        arg = -(spds/cpds)
        IF (arg .GT. 1.) THEN
!        polar night:
          daylen = 0.
        ELSE IF (arg .LT. -1) THEN
!        polar day:
          daylen = 24.
        ELSE
!        normal day / night:
          result1 = ACOS(arg)
          daylen = result1/pi*24.
        END IF
!###########Compute subdaily temperature based on daily input,@MOUSONG.WU,201905#####################
        IF (meteo_input .LT. 0) THEN
! .. compute average conditions
          atmean = (meteo%tempmx+meteo%tempmn)/2.
          atrange = meteo%tempmx - meteo%tempmn
!  hour angle at sunset, added by MOUSONG.WU, 201905
          sunset_arc = daylen/2.*2.0*pi/24.0
          IF (daylen .GE. 4. .AND. daylen .LE. 20.) THEN
!        sunrise
            h0 = 12. - daylen/2.
!        sundown
            h1 = 12. + daylen/2.
!        at sundown:
            arg1 = pi*(2.*h1+(daylen-52.)/2.)/(daylen+4.)
            sd1 = SIN(arg1)
!! unroll zum vektorisieren
            IF (hr_loc .GT. h0 .AND. hr_loc .LT. h1) THEN
              arg1 = pi*(2.*hr_loc+(daylen-52.)/2.)/(daylen+4.)
              sd = SIN(arg1)
              meteo%temp = atmean + atrange/2.*sd
            ELSE
! temperature at sundown
              tmp1 = atmean + atrange/2.*sd1
! hours since sundown
              arg1 = hr_loc - h1 + 24.
              dhour = MOD(arg1, 24.)
              tmin = atmean - atrange/2.
              meteo%temp = tmp1 - (tmp1-tmin)*(dhour/(24.-daylen))
            END IF
          ELSE IF (daylen .GT. 20.) THEN
            arg1 = pi*(hr_loc-14.)/(daylen/2.+2.)
            sd = COS(arg1)
            meteo%temp = atmean + atrange/2.*sd
          ELSE
            meteo%temp = atmean
          END IF
          clim%temp(i) = meteo%temp
! convert daily solar radiation into hourly using the method by M. Collares-Pereira and A. Rabl,
! The average distribution of solar radiation-correlations between diffuse and hemispherical
!and between daily and hourly insolation values, Solar Energy,vol. 22, no. 2, pp. 155164, 1979.
          a = 0.409 + 0.5016*SIN(sunset_arc-60.)
          b = 0.6609 - 0.4767*SIN(sunset_arc-60.)
          meteo%srad = meteo%srad*(a+b*COS(hr_arc))*(pi/24.)*(COS(hr_arc&
&           )-COS(sunset_arc))/(SIN(sunset_arc)-2*pi*sunset_arc/360.*COS&
&           (sunset_arc))
        END IF
! Calculate cloud fraction, separate shortwave radiation
        IF (coszs .LT. 0.001) THEN
          ratio_cloud = 0.
        ELSE
          ratio_cloud = meteo%srad/(1367.*coszs)
        END IF
        IF (ratio_cloud .GT. 0.8) THEN
          shortrad_df = 0.13*meteo%srad
        ELSE
          shortrad_df = (0.943+0.734*ratio_cloud-4.9*ratio_cloud**2+&
&           1.796*ratio_cloud**3+2.058*ratio_cloud**4)*meteo%srad
        END IF
        IF (shortrad_df .GT. meteo%srad) THEN
          shortrad_df = meteo%srad
        ELSE
          shortrad_df = shortrad_df
        END IF
        IF (shortrad_df .LT. 0.) THEN
          shortrad_df = 0.
        ELSE
          shortrad_df = shortrad_df
        END IF
        shortrad_dir = meteo%srad - shortrad_df
        meteo%s_dff = shortrad_df
        meteo%s_dir = shortrad_dir
        clim%swdr(i) = shortrad_dir
        clim%swdf(i) = shortrad_df
!! end PFT loop
!! PFT iteration
pftloop:DO j=1,pft
          IF (bound%lcno(i, j) .GT. 0 .AND. bound%sw(i) .GT. 0. .AND. &
&             bound%stext(i) .GT. 0 .AND. bound%clumping(i) .GT. 0.5) &
&         THEN
            CALL READPARAM(bound%lcno(i, j), param)
            IF (lai_input .GE. 0) THEN
              lai = bound%lai(i, j)
              lai_fw(:) = 0.0_8
            ELSE IF (is_first_step) THEN
              lai = bound%laiyr(i, j)
              mid_res%lai_old = lai
              lai_fw(:) = 0.0_8
              mid_res_fw%lai_old(:) = 0.0_8
            ELSE
              DO nd0=1,nbdirs
                lai_fw(nd0) = mid_res_fw%lai_new(nd0)
              END DO
              lai = mid_res%lai_new
            END IF
            DO nd0=1,nbdirs
              lai_fw(nd0) = param(2)*lai_fw(nd0)/bound%clumping(i)
            END DO
            lai = lai*param(2)/bound%clumping(i)
            CALL READCOEF(bound%lcno(i, j), bound%stext(i), coef)
            IF (nsrest .EQ. nsrstartup .AND. is_first_step) THEN
              CALL INIT_SOIL_PARAMETERS_FWV(bound%lcno(i, j), bound%&
&                                     stext(i), param(27), soilp, &
&                                     soilp_fw, nbdirs)
!-- iLab::applied similar changes as in driver.F90 (MSWU@2020-09-21)
              soilp%r_drainage = param(26)
! soilp%r_drainage = assim%p_drainage(j)            ! read this
!para from NC file,@MOUSONG.WU,2019-11
              ii = bound%stext(i)
! write(*,*) 'p_Ksat = ',assim%p_Ksat(ii) 
! write(*,*) 'Ksat_old = ',soilp%Ksat(0)
              DO kk=0,4
                DO nd0=1,nbdirs
                  soilp_fw%ksat(nd0, kk) = soilp%ksat(kk)*assim_fw%&
&                   p_ksat_scalar(nd0, ii) + assim%p_ksat_scalar(ii)*&
&                   soilp_fw%ksat(nd0, kk)
                  soilp_fw%b(nd0, kk) = soilp%b(kk)*assim_fw%p_b_scalar(&
&                   nd0, ii) + assim%p_b_scalar(ii)*soilp_fw%b(nd0, kk)
                END DO
                soilp%ksat(kk) = assim%p_ksat_scalar(ii)*soilp%ksat(kk)
                soilp%b(kk) = assim%p_b_scalar(ii)*soilp%b(kk)
              END DO
! replace these three para. above with values from nc
! file,@MOUSONG.WU,2019-11
              CALL INIT_SOIL_STATUS_FWV(soilp, soilp_fw, bound%st(i), &
&                                 clim%temp(i), bound%sw(i), bound%sdp(i&
&                                 ), nbdirs)
              DO k=0,40
                DO nd0=1,nbdirs
                  var_o_fw(nd0, k) = 0.0_8
                END DO
                var_o(k) = 0.
              END DO
              DO k=3,8
                DO nd0=1,nbdirs
                  var_o_fw(nd0, k) = 0.0_8
                END DO
                var_o(k) = clim%temp(i)
              END DO
              DO k=9,14
                DO nd0=1,nbdirs
                  var_o_fw(nd0, k) = soilp_fw%temp_soil_p(nd0, k-9)
                END DO
                var_o(k) = soilp%temp_soil_p(k-9)
              END DO
              DO k=21,26
                DO nd0=1,nbdirs
                  var_o_fw(nd0, k) = soilp_fw%thetam_prev(nd0, k-21)
                END DO
                var_o(k) = soilp%thetam_prev(k-21)
              END DO
              DO k=27,32
                DO nd0=1,nbdirs
                  var_o_fw(nd0, k) = soilp_fw%ice_ratio(nd0, k-27)
                END DO
                var_o(k) = soilp%ice_ratio(k-27)
              END DO
            ELSE IF (nsrest .EQ. nsrcontinue .AND. is_first_step) THEN
              CALL INIT_SOIL_PARAMETERS_FWV(bound%lcno(i, j), bound%&
&                                     stext(i), param(27), soilp, &
&                                     soilp_fw, nbdirs)
!-- iLab::applied similar changes as in driver.F90 (MSWU@2020-09-21)
              soilp%r_drainage = param(26)
! soilp%r_drainage = assim%p_drainage(j)  ! read from nc
!                                         ! file,MOUSONG.WU@2019-11
              ii = bound%stext(i)
              DO kk=0,4
                DO nd0=1,nbdirs
                  soilp_fw%ksat(nd0, kk) = soilp%ksat(kk)*assim_fw%&
&                   p_ksat_scalar(nd0, ii) + assim%p_ksat_scalar(ii)*&
&                   soilp_fw%ksat(nd0, kk)
                  soilp_fw%b(nd0, kk) = soilp%b(kk)*assim_fw%p_b_scalar(&
&                   nd0, ii) + assim%p_b_scalar(ii)*soilp_fw%b(nd0, kk)
                END DO
                soilp%ksat(kk) = assim%p_ksat_scalar(ii)*soilp%ksat(kk)
                soilp%b(kk) = assim%p_b_scalar(ii)*soilp%b(kk)
              END DO
!Replace with NC values,for optimization
!purpose,@MOUSONG.WU,2019-11
              DO nd0=1,nbdirs
                var_o_fw(nd0, :) = v2last_fw(nd0, i, :, j)
              END DO
              var_o(:) = v2last(i, :, j)
              DO k=9,14
                DO nd0=1,nbdirs
                  soilp_fw%temp_soil_c(nd0, k-9) = var_o_fw(nd0, k)
                END DO
                soilp%temp_soil_c(k-9) = var_o(k)
              END DO
              DO k=21,26
                DO nd0=1,nbdirs
                  soilp_fw%thetam(nd0, k-21) = var_o_fw(nd0, k)
                END DO
                soilp%thetam(k-21) = var_o(k)
              END DO
            ELSE
!                 do k = 27,32
!                    soilp%ice_ratio(k-27)   = var_o(k)
!                 end do
              DO nd0=1,nbdirs
                var_o_fw(nd0, :) = v2last_fw(nd0, i, :, j)
              END DO
              var_o(:) = v2last(i, :, j)
              CALL RETRIVE_SOILP_FWV(soilp, soilp_fw, i, j, 0, nbdirs)
            END IF
!!! simulating photosynthesis
!              do llll = 0,40
!                 write(*,*)  "DG004: Var_o = ",llll, var_o(llll)
!              end do
            CALL INTER_PRG_FWV(yr, mn, dy, tod, lai, lai_fw, lai_input, &
&                        bound%lcno(i, j), bound%clumping(i), assim%&
&                        p_vcmax(j), assim_fw%p_vcmax(:, j), assim%&
&                        p_vj_slope(j), assim_fw%p_vj_slope(:, j), assim&
&                        %p_f_leaf, assim_fw%p_f_leaf, assim%p_kc25, &
&                        assim%p_ko25, assim%p_tau25, assim%p_sif_alpha(&
&                        j), assim_fw%p_sif_alpha(:, j), assim%&
&                        p_sif_beta(j), assim_fw%p_sif_beta(:, j), param&
&                        , meteo, coszs, var_o, var_o_fw, var_n, &
&                        var_n_fw, soilp, soilp_fw, mid_res, mid_res_fw&
&                        , daylen, nbdirs)
            CALL RETRIVE_SOILP_FWV(soilp, soilp_fw, i, j, 1, nbdirs)
!!! simluating Ra
            CALL PLANT_RESP(assim%p_q10(j), bound%lcno(i, j), mid_res, &
&                     bound%laiyr(i, j), lai, meteo%temp, soilp%&
&                     temp_soil_c(1), coszs)
!USE p_q10 here to adjust q10,p_q10 is read from initial para. NC file, for
!optimization purpose,@MOUSONG.WU,2019-11
!!! simulating Rh
            ccd(0) = bound%ccd(i, j)
            cssd(0) = bound%cssd(i, j)
            csmd(0) = bound%csmd(i, j)
            cfsd(0) = bound%cfsd(i, j)
            cfmd(0) = bound%cfmd(i, j)
            csm(0) = bound%csm(i, j)
            cm(0) = bound%cm(i, j)
            cs(0) = bound%cm(i, j)
            cp(0) = bound%cp(i, j)
!-- iLab::similar changes as in driver.F90 (MSWU@2020-09-21),
!         'beta' no longer parameter
            CALL SOIL_RESP(ccd, cssd, csmd, cfsd, cfmd, csm, cm, cs, cp&
&                    , bound%nppyr(i, j), coef, bound%stext(i), soilp, &
&                    mid_res)
            DO nd0=1,nbdirs
! CHANGE Vcmax read from Vcmax file with the Vcmax read from initial para. NC
! file, for optimization purpose,@MOUSONG.WU,2019-11
!              do llll =0,40
!                write(*,*)  "DG004: Var_n = ",llll,var_n(llll)
!             end do
              v2last_fw(nd0, i, :, j) = var_n_fw(nd0, :)
              output_fw%sifpft(nd0, i, j) = bound%pct_pft(i, j)*&
&               mid_res_fw%sif(nd0)/100.
              output_fw%thetampft(nd0, i, j) = bound%pct_pft(i, j)*&
&               mid_res_fw%thetam_surf(nd0)/100.
!-- iLab::COS_flux computation now similar as in driver.F90 (MSWU@2020-09-21)
              output_fw%cos_fluxpft(nd0, i, j) = bound%pct_pft(i, j)*(&
&               mid_res_fw%cos_plant(nd0)+mid_res_fw%cos_grnd(nd0))/100.
            END DO
            v2last(i, :, j) = var_n(:)
! to get soil texture for this point,@MOUSONG.WU,2019-11
            jj = bound%stext(i)
! call soil_resp(Ccd,Cssd,Csmd,Cfsd,Cfmd,Csm,Cm,Cs,&
!      Cp,bound%nppyr(i,j),coef,bound%stext(i),assim%p_beta(jj),soilp,mid_res)
! !! use p_beta read from initial para. NC file, to adjust slow
! !carbon pool, for optimization purpose,@MOUSONG.WU,2019-11
! mid_res%COS_grnd2 = mid_res%COS_grnd2 * (mid_res%NPP - mid_res%NEP)
! ! COS_flux_buf = mid_res%COS_plant + max(mid_res%COS_grnd1,mid_res%COS_grnd2)
! mid_res%COS_flux  = mid_res%COS_plant + max(mid_res%COS_grnd1,mid_res%COS_grnd2)
!! for output variables
! remove 100. for site since the PCT_PFT is fraction, @MOUSONG.WU,2019-11
            output%gpppft(i, j) = mid_res%gpp*bound%pct_pft(i, j)/100.
            output%sifpft(i, j) = mid_res%sif*bound%pct_pft(i, j)/100.
            output%npppft(i, j) = mid_res%npp*bound%pct_pft(i, j)/100.
            output%neppft(i, j) = mid_res%nep*bound%pct_pft(i, j)/100.
            output%shpft(i, j) = mid_res%sh*bound%pct_pft(i, j)/100.
            output%lhpft(i, j) = mid_res%lh*bound%pct_pft(i, j)/100.
            output%transpft(i, j) = mid_res%trans*bound%pct_pft(i, j)/&
&             100.
            output%evappft(i, j) = mid_res%evap*bound%pct_pft(i, j)/100.
            output%net_radpft(i, j) = mid_res%net_rad*bound%pct_pft(i, j&
&             )/100.
            output%laipft(i, j) = lai*bound%pct_pft(i, j)/100.
            output%thetampft(i, j) = mid_res%thetam_surf*bound%pct_pft(i&
&             , j)/100.
            output%faparpft(i, j) = mid_res%fapar*bound%pct_pft(i, j)/&
&             100.
            output%cos_fluxpft(i, j) = (mid_res%cos_plant+mid_res%&
&             cos_grnd)*bound%pct_pft(i, j)/100.
!-- iLab::annual NPP, VOD computation now similar as in driver.F90 (MSWU@2020-09-21)
! convert NPP to Mg/ha for calculation of VOD
            output%npp_yr_acc(i, j) = output%npp_yr_acc(i, j) + mid_res%&
&             npp*bound%pct_pft(i, j)/100.*1.e-2*step
            IF (is_end_curr_year) THEN
! calculate VOD (vegetation optical depth) with results derived from SMOS-IC product, @Mousong.Wu, 201905,taweff is a PFT specifi
!c parameter
              arg1 = assim%p_taweff(j)*output%npp_yr_acc(i, j)
              output%vodpft(i, j) = assim%p_agb2vod*ATAN(arg1) + assim%&
&               p_d0(j)*lai
              output%npp_yr_acc(i, j) = 0.
!                  write(*,*) 'VOD= ',output%VODpft(i,j)
            ELSE
              output%vodpft(i, j) = 0.
            END IF
! write(*,*) 'hr_loc = ', hr_loc
!! calculate the OCO-2 SIF   across at 1:30pm
!write(*,*) 'SIFpft= ',mid_res%SIF*bound%PCT_PFT(i,j)/100. 
            IF (hr_loc .GE. 13. .AND. hr_loc .LT. 14.) THEN
              output%sifpft_sat(i, j) = mid_res%sif*bound%pct_pft(i, j)/&
&               100.
            ELSE
              output%sifpft_sat(i, j) = 0.
            END IF
          END IF
        END DO pftloop
!output%SIFpft_sat(i,j) = max(output%SIFpft_sat(i,j),0.)
!write(*,*) 'SIFpft_sat = ', output%SIFpft_sat(i,j)
        output%gpp(i) = SUM(output%gpppft(i, :))
        DO nd0=1,nbdirs
          output_fw%sif(nd0, i) = SUM(output_fw%sifpft(nd0, i, :))
          output_fw%thetam(nd0, i) = SUM(output_fw%thetampft(nd0, i, :))
          output_fw%cos_flux(nd0, i) = SUM(output_fw%cos_fluxpft(nd0, i&
&           , :))
!--iLab::mapping to target vector:SIF/Thetam/COSflux ->per time ->per point
!        (see mo_bepsfunc_ctl.f90 for order of simulated BEPS quantities)
          y_fw(nd0, jcnt) = output_fw%sif(nd0, i)
          y_fw(nd0, jcnt+1) = output_fw%thetam(nd0, i)
          y_fw(nd0, jcnt+2) = output_fw%cos_flux(nd0, i)
        END DO
        output%sif(i) = SUM(output%sifpft(i, :))
        output%sif_sat(i) = SUM(output%sifpft_sat(i, :))
        output%npp(i) = SUM(output%npppft(i, :))
        output%nep(i) = SUM(output%neppft(i, :))
        output%sh(i) = SUM(output%shpft(i, :))
        output%lh(i) = SUM(output%lhpft(i, :))
        output%trans(i) = SUM(output%transpft(i, :))
        output%evap(i) = SUM(output%evappft(i, :))
        output%net_rad(i) = SUM(output%net_radpft(i, :))
        output%lai(i) = SUM(output%laipft(i, :))
        output%thetam(i) = SUM(output%thetampft(i, :))
        output%fapar(i) = SUM(output%faparpft(i, :))
        output%vod(i) = SUM(output%vodpft(i, :))
        output%cos_flux(i) = SUM(output%cos_fluxpft(i, :))
        y(jcnt) = output%sif(i)
        y(jcnt+1) = output%thetam(i)
        y(jcnt+2) = output%cos_flux(i)
        jcnt = jcnt + 3
      END DO pointloop
    END DO timeloop
!          call mpi_barrier(mpi_comm_world,ierr)
!--iLab::target vector should have been written completely (dimension consistency)!
    IF (jcnt - 1 .NE. m) WRITE(*, '(a,2(a,i4,1x))') &
&                   ' FATAL::dimension inconsistency for target mapping'&
&                        , 'expected m=', m, 'got jcnt=', jcnt
  END IF
END SUBROUTINE EVALF_FWV

!  Differentiation of inter_prg in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: var_n mid_res.sif mid_res.thetam_surf
!                mid_res.lai_old mid_res.lai_new mid_res.cos_plant
!                mid_res.cos_grnd soilp.dt soilp.ice_ratio soilp.thetam
!                soilp.thetam_prev soilp.temp_soil_p soilp.temp_soil_c
!                soilp.f_ice soilp.psim soilp.thetab soilp.psib
!                soilp.r_waterflow soilp.km soilp.kb soilp.kk soilp.cs
!                soilp.lambda soilp.ett soilp.g
!   with respect to varying inputs: lai vcmax0 var_n var_o sif_alpha
!                mid_res.lai_old mid_res.lai_new vj_slope sif_beta
!                soilp.dt soilp.ksat soilp.b soilp.ice_ratio soilp.thetam
!                soilp.thetam_prev soilp.temp_soil_p soilp.temp_soil_c
!                soilp.f_ice soilp.psim soilp.thetab soilp.psib
!                soilp.r_waterflow soilp.km soilp.kb soilp.kk soilp.cs
!                soilp.lambda soilp.ett soilp.g f_leaf
!! Last update: July,2015
!! Fortran version: 3/5/2017 @J.Wang
SUBROUTINE INTER_PRG_FWV(yr, mn, dy, tod, lai, lai_fw, lai_input, lc, &
& clumping, vcmax0, vcmax0_fw, vj_slope, vj_slope_fw, f_leaf, f_leaf_fw&
& , p_kc25, p_ko25, p_tau25, sif_alpha, sif_alpha_fw, sif_beta, &
& sif_beta_fw, param, meteo, coszs, var_o, var_o_fw, var_n, var_n_fw, &
& soilp, soilp_fw, mid_res, mid_res_fw, daylen, nbdirs)
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
!--iLab::restrict use of beps_time_manager to required entities  
!--iLab-update::extended arguments to avoid time manager completely
! use beps_time_manager, only:is_end_curr_day, get_curr_date
  USE BEPS_SOILMOD_DIFFV
  USE BEPSTYPE_DIFFV
  USE MID_RESULTS_DIFFV
  USE BEPS_PAR
  USE ANGSMOD_DIFFV
  USE RAINSNOWMOD_DIFFV
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
!--iLab::added date-elements as argument to avoid 'call get_curr_date' further below
  INTEGER, INTENT(IN) :: yr, mn, dy, tod
  INTEGER, INTENT(IN) :: lc
!!J.Wang
  REAL(r8), INTENT(IN) :: clumping, vcmax0, vj_slope, f_leaf, p_ko25, &
& p_kc25, p_tau25, sif_alpha, sif_beta, coszs, daylen
  REAL(r8), DIMENSION(nbdirsmax), INTENT(IN) :: vcmax0_fw, vj_slope_fw, &
& f_leaf_fw, sif_alpha_fw, sif_beta_fw
  REAL(r8), INTENT(IN) :: param(0:49)
  TYPE(CLIMATEDATA), INTENT(IN) :: meteo
  REAL(r8), INTENT(IN) :: var_o(0:40)
  REAL(r8), INTENT(IN) :: var_o_fw(nbdirsmax, 0:40)
  REAL(r8), INTENT(OUT) :: var_n(0:40)
  REAL(r8), INTENT(OUT) :: var_n_fw(nbdirsmax, 0:40)
  REAL(r8), INTENT(INOUT) :: lai
  REAL(r8), DIMENSION(nbdirsmax), INTENT(INOUT) :: lai_fw
  TYPE(SOIL) :: soilp
  TYPE(SOIL_DIFFV) :: soilp_fw
  TYPE(RESULTS) :: mid_res
  TYPE(RESULTS_DIFFV) :: mid_res_fw
  INTEGER, INTENT(IN) :: lai_input
!real(r8),intent(out) :: gs_h2o,G_o_b
  INTEGER :: num, kkk, i, j
  INTEGER, PARAMETER :: iter_max=20
  INTEGER :: landcover
  REAL(r8) :: lai_o, lai_u, stem_o, stem_u
  REAL(r8), DIMENSION(nbdirsmax) :: lai_o_fw, lai_u_fw
  REAL(r8) :: d_soil(0:layer)
!the depth of snow on the surface
  REAL(r8) :: zsp
  REAL(r8), DIMENSION(nbdirsmax) :: zsp_fw
!depth of pounded water on the surface
  REAL(r8) :: zp
  REAL(r8), DIMENSION(nbdirsmax) :: zp_fw
  REAL(r8), SAVE :: zp1=0.
  REAL(r8), SAVE :: zp2=0.
!height of the Va measured for calculation of L
  REAL(r8) :: height_wind_sp
!sensible heating
  REAL(r8) :: qhc_o(0:iter_max), qhc_u(0:iter_max), qhg(0:iter_max)
  REAL(r8) :: qhc_o_fw(nbdirsmax, 0:iter_max)
!the heat flux into the canopy of over story --in W/m^2
  REAL(r8) :: g(0:layer+1, 0:iter_max)
  REAL(r8) :: g_fw(nbdirsmax, 0:layer+1, 0:iter_max)
!the masses od rain and snow on the canopy
  REAL(r8) :: wcl_o(0:iter_max), wcs_o(0:iter_max)
  REAL(r8) :: wcl_o_fw(nbdirsmax, 0:iter_max), wcs_o_fw(nbdirsmax, 0:&
& iter_max)
!the fractoion of canopy coverd by liquid water and snow
  REAL(r8) :: xcl_o(0:iter_max), xcs_o(0:iter_max)
  REAL(r8) :: xcl_o_fw(nbdirsmax, 0:iter_max), xcs_o_fw(nbdirsmax, 0:&
& iter_max)
  REAL(r8) :: wcl_u(0:iter_max), wcs_u(0:iter_max)
  REAL(r8) :: wcl_u_fw(nbdirsmax, 0:iter_max), wcs_u_fw(nbdirsmax, 0:&
& iter_max)
  REAL(r8) :: xcl_u(0:iter_max), xcs_u(0:iter_max)
  REAL(r8) :: xcl_u_fw(nbdirsmax, 0:iter_max), xcs_u_fw(nbdirsmax, 0:&
& iter_max)
!the rainfall rate on ground surface m/s
  REAL(r8) :: r_rain_g(0:iter_max)
  REAL(r8) :: r_rain_g_fw(nbdirsmax, 0:iter_max)
!density of snow
  REAL(r8) :: rho_snow(0:iter_max)
  REAL(r8) :: rho_snow_fw(nbdirsmax, 0:iter_max)
!albedo of snow
  REAL(r8) :: alpha_v_sw(0:iter_max), alpha_n_sw(0:iter_max)
  REAL(r8) :: alpha_v_sw_fw(nbdirsmax, 0:iter_max), alpha_n_sw_fw(&
& nbdirsmax, 0:iter_max)
! amount of snow on ground
  REAL(r8) :: wg_snow(0:iter_max)
  REAL(r8) :: wg_snow_fw(nbdirsmax, 0:iter_max)
! fraction of the ground surface overed by snow
  REAL(r8) :: xg_snow(0:iter_max)
  REAL(r8) :: xg_snow_fw(nbdirsmax, 0:iter_max)
! area of canopy covered by snow
  REAL(r8) :: ac_snow_o(0:iter_max), ac_snow_u(0:iter_max)
  REAL(r8) :: ac_snow_o_fw(nbdirsmax, 0:iter_max), ac_snow_u_fw(&
& nbdirsmax, 0:iter_max)
!surface temperature
  REAL(r8) :: ts0(0:iter_max), tsn0(0:iter_max), tsm0(0:iter_max), tsn1(&
& 0:iter_max), tsn2(0:iter_max)
  REAL(r8) :: ts0_fw(nbdirsmax, 0:iter_max), tsn0_fw(nbdirsmax, 0:&
& iter_max), tsm0_fw(nbdirsmax, 0:iter_max), tsn1_fw(nbdirsmax, 0:&
& iter_max), tsn2_fw(nbdirsmax, 0:iter_max)
!effective canopy temperature in K
  REAL(r8) :: tc_u(0:iter_max)
  REAL(r8) :: tc_u_fw(nbdirsmax, 0:iter_max)
!soil temperature at the bottom and middle of each layer
  REAL(r8) :: tm(0:layer+1, 0:iter_max)
  REAL(r8) :: tm_fw(nbdirsmax, 0:layer+1, 0:iter_max)
!thermal conductivity of each soil layer
  REAL(r8) :: lambda_soil(0:layer+1)
  REAL(r8) :: lambda_soil_fw(nbdirsmax, 0:layer+1)
! soil volumetric hear capacity of each soil layer J/m3/K
  REAL(r8) :: cs(0:layer+1, 0:iter_max)
  REAL(r8) :: cs_fw(nbdirsmax, 0:layer+1, 0:iter_max)
  REAL(r8) :: temp_air, temp_grd
!%,m/s,m/s @J.Wang  make original precipitation into rainfall and snow
  REAL(r8) :: rh_air, wind_sp, snow, rainfall
!the evaporation rate of intercepted water of overstory--in kg/m^2/s
  REAL(r8) :: eil_o(0:iter_max), eis_o(0:iter_max)
  REAL(r8) :: eil_o_fw(nbdirsmax, 0:iter_max), eis_o_fw(nbdirsmax, 0:&
& iter_max)
  REAL(r8) :: eil_u(0:iter_max), eis_u(0:iter_max)
  REAL(r8) :: eil_u_fw(nbdirsmax, 0:iter_max), eis_u_fw(nbdirsmax, 0:&
& iter_max)
!transpiration
  REAL(r8) :: trans_o(0:iter_max), trans_u(0:iter_max)
  REAL(r8) :: trans_o_fw(nbdirsmax, 0:iter_max), trans_u_fw(nbdirsmax, 0&
& :iter_max)
  REAL(r8) :: evap_soil(0:iter_max)
  REAL(r8) :: evap_soil_fw(nbdirsmax, 0:iter_max)
!evaporation from water pond
  REAL(r8) :: evap_sw(0:iter_max)
  REAL(r8) :: evap_sw_fw(nbdirsmax, 0:iter_max)
!evaporation from snow pack
  REAL(r8) :: evap_ss(0:iter_max)
  REAL(r8) :: evap_ss_fw(nbdirsmax, 0:iter_max)
!effective thermal conductivity of snow in m2/s
  REAL(r8) :: lambda_snow(0:iter_max)
! vapour partial pressure of water in kPa
  REAL(r8) :: e_a10
! the latent heat of vaporation from liquid at air temperature=Ta
  REAL(r8) :: lv_liquid
! the latent heat of vaporation from solid (snow/ice) at air temperature
  REAL(r8), SAVE :: lv_solid=2.83*1e6
! instantaneous total short wave radiation (Global radiation)
  REAL(r8) :: ks
  REAL(r8) :: alpha_sat, alpha_dry
!visible albedo of overstory,  o--overstory, u--understory
  REAL(r8) :: alpha_v_o, alpha_v_u
!near_infrared albedo
  REAL(r8) :: alpha_n_o, alpha_n_u
! all-wave ground surface albedo
  REAL(r8) :: alpha_g
  REAL(r8), DIMENSION(nbdirsmax) :: alpha_g_fw
  REAL(r8) :: alpha_v_g, alpha_n_g
  REAL(r8), DIMENSION(nbdirsmax) :: alpha_v_g_fw, alpha_n_g_fw
! specific heat of moist air above the canopy
  REAL(r8) :: cp_ca
! the aerodynamic resistance of overstory, understory and ground surface
  REAL(r8) :: ra_o, ra_u, ra_g
  REAL(r8), DIMENSION(nbdirsmax) :: ra_g_fw
! actural canopy stomatal resistance  --in s/m
  REAL(r8) :: q_ca
  REAL(r8) :: radiation_o, radiation_u, radiation_g
  REAL(r8), DIMENSION(nbdirsmax) :: radiation_g_fw
!the cumulative infiltration at the time of ponding   --in m/s
  REAL(r8), SAVE :: ip=0.
  REAL(r8), SAVE :: infil=0.
  REAL(r8), SAVE :: zr=0.8
  REAL(r8), SAVE :: cpd=1004.65
  REAL(r8) :: cs_o_sunlit_old, cs_o_shaded_old, cs_u_sunlit_old, &
& cs_u_shaded_old
! CO2 concentration on the surfaces of leaves
  REAL(r8) :: coss_o_sunlit_old, coss_o_shaded_old, coss_u_sunlit_old, &
& coss_u_shaded_old
! COS concentration on the surfaces of leaves
  REAL(r8) :: tc_o_sunlit_old, tc_o_shaded_old, tc_u_sunlit_old, &
& tc_u_shaded_old
  REAL(r8), DIMENSION(nbdirsmax) :: tc_o_sunlit_old_fw, &
& tc_o_shaded_old_fw, tc_u_sunlit_old_fw, tc_u_shaded_old_fw
! the effective canopy temperature in K
  REAL(r8) :: gs_o_sunlit_new, gs_o_shaded_new, gs_u_sunlit_new, &
& gs_u_shaded_new
  REAL(r8), DIMENSION(nbdirsmax) :: gs_o_sunlit_new_fw, &
& gs_o_shaded_new_fw, gs_u_sunlit_new_fw, gs_u_shaded_new_fw
!stomatal conductance of the big leaf     for water
  REAL(r8) :: gs_o_sunlit_old, gs_o_shaded_old, gs_u_sunlit_old, &
& gs_u_shaded_old
  REAL(r8), DIMENSION(nbdirsmax) :: gs_o_sunlit_old_fw, &
& gs_o_shaded_old_fw, gs_u_sunlit_old_fw, gs_u_shaded_old_fw
! net photosynthesis rate
  REAL(r8) :: ac_o_sunlit, ac_o_shaded, ac_u_sunlit, ac_u_shaded
  REAL(r8), DIMENSION(nbdirsmax) :: ac_o_sunlit_fw, ac_o_shaded_fw, &
& ac_u_sunlit_fw, ac_u_shaded_fw
  REAL(r8) :: cs_o_sunlit_new, cs_o_shaded_new, cs_u_sunlit_new, &
& cs_u_shaded_new
! CO2 concentration on the surfaces of     leaves
  REAL(r8) :: coss_o_sunlit_new, coss_o_shaded_new, coss_u_sunlit_new, &
& coss_u_shaded_new
! COS concentration on the surfaces of     leaves
  REAL(r8) :: ci_o_sunlit_new, ci_o_shaded_new, ci_u_sunlit_new, &
& ci_u_shaded_new
! intercellular CO2 concentration pn th    e leaf
  REAL(r8) :: cosi_o_sunlit_new, cosi_o_shaded_new, cosi_u_sunlit_new, &
& cosi_u_shaded_new
  REAL(r8), DIMENSION(nbdirsmax) :: cosi_o_sunlit_new_fw, &
& cosi_o_shaded_new_fw, cosi_u_sunlit_new_fw, cosi_u_shaded_new_fw
! intercellular COS concentration pn the leaf
  REAL(r8) :: ci_o_sunlit_old, ci_o_shaded_old, ci_u_sunlit_old, &
& ci_u_shaded_old
  REAL(r8) :: cosi_o_sunlit_old, cosi_o_shaded_old, cosi_u_sunlit_old, &
& cosi_u_shaded_old
  REAL(r8), DIMENSION(nbdirsmax) :: cosi_o_sunlit_old_fw, &
& cosi_o_shaded_old_fw, cosi_u_sunlit_old_fw, cosi_u_shaded_old_fw
  REAL(r8) :: cc_o_sunlit_new, cc_o_shaded_new, cc_u_sunlit_new, &
& cc_u_shaded_new
! CO2 concentration in the chloroplast
  REAL(r8) :: cosc_o_sunlit_new, cosc_o_shaded_new, cosc_u_sunlit_new, &
& cosc_u_shaded_new
! COS concentration in the chloroplast
  REAL(r8) :: tc_o_sunlit_new, tc_o_shaded_new, tc_u_sunlit_new, &
& tc_u_shaded_new
  REAL(r8), DIMENSION(nbdirsmax) :: tc_o_sunlit_new_fw, &
& tc_o_shaded_new_fw, tc_u_sunlit_new_fw, tc_u_shaded_new_fw
! the effective canopy temperature in K
! an emperical parameter describin    g the relative availability of soil water for plants
  REAL(r8) :: f_soilwater
  REAL(r8), DIMENSION(nbdirsmax) :: f_soilwater_fw
! the total conductance for water from     the intercellular space of the leaves to the reference height above the canopy
  REAL(r8) :: gw_o_sunlit, gw_o_shaded, gw_u_sunlit, gw_u_shaded
  REAL(r8), DIMENSION(nbdirsmax) :: gw_o_sunlit_fw, gw_o_shaded_fw, &
& gw_u_sunlit_fw, gw_u_shaded_fw
! the total conductance for CO2 from th    e intercellular space of the leaves to the reference height above the canopy
  REAL(r8) :: gc_o_sunlit, gc_o_shaded, gc_u_sunlit, gc_u_shaded
! the total conductance for water from     the surface of the leaves to the reference height above the canopy
  REAL(r8) :: gww_o_sunlit, gww_o_shaded, gww_u_sunlit, gww_u_shaded
  REAL(r8), DIMENSION(nbdirsmax) :: gww_o_sunlit_fw, gww_o_shaded_fw, &
& gww_u_sunlit_fw, gww_u_shaded_fw
!total conductance for heat transfer f    rom the leaf surface to the reference height above the canopy
  REAL(r8) :: gh_o_sunlit, gh_o_shaded, gh_u_sunlit, gh_u_shaded
  REAL(r8), DIMENSION(nbdirsmax) :: gh_o_sunlit_fw, gh_o_shaded_fw, &
& gh_u_sunlit_fw, gh_u_shaded_fw
  REAL(r8) :: psychrometer
!solar radiation absorbed by sunlit, s    haded leaves
  REAL(r8) :: r_o_sunlit, r_o_shaded, r_u_sunlit, r_u_shaded
  REAL(r8), DIMENSION(nbdirsmax) :: r_o_sunlit_fw, r_o_shaded_fw, &
& r_u_sunlit_fw, r_u_shaded_fw
  REAL(r8) :: tco, tcu, slope
  REAL(r8), DIMENSION(nbdirsmax) :: tco_fw, tcu_fw
!sensible heat flux from leaves
  REAL(r8) :: h_o_sunlit, h_o_shaded
  REAL(r8), DIMENSION(nbdirsmax) :: h_o_sunlit_fw, h_o_shaded_fw
  REAL(r8) :: lai_o_sunlit, lai_o_shaded, lai_u_sunlit, lai_u_shaded
  REAL(r8), DIMENSION(nbdirsmax) :: lai_o_sunlit_fw, lai_o_shaded_fw, &
& lai_u_sunlit_fw, lai_u_shaded_fw
  REAL(r8) :: laio_sunlit, laio_shaded, laiu_sunlit, laiu_shaded
  REAL(r8), DIMENSION(nbdirsmax) :: laio_sunlit_fw, laio_shaded_fw, &
& laiu_sunlit_fw, laiu_shaded_fw
! net radiation of leaves
  REAL(r8) :: radiation_o_sun, radiation_o_shaded, radiation_u_sun, &
& radiation_u_shaded
  REAL(r8), DIMENSION(nbdirsmax) :: radiation_o_sun_fw, &
& radiation_o_shaded_fw, radiation_u_sun_fw, radiation_u_shaded_fw
  REAL(r8) :: gpp_o_sunlit, gpp_o_shaded, gpp_u_sunlit, gpp_u_shaded
!canopy level
  REAL(r8) :: sif_o_sunlit, sif_o_shaded, sif_u_sunlit, sif_u_shaded
  REAL(r8), DIMENSION(nbdirsmax) :: sif_o_sunlit_fw, sif_o_shaded_fw, &
& sif_u_sunlit_fw, sif_u_shaded_fw
!leaf level
  REAL(r8) :: lsif_o_sunlit, lsif_o_shaded, lsif_u_sunlit, lsif_u_shaded
  REAL(r8), DIMENSION(nbdirsmax) :: lsif_o_sunlit_fw, lsif_o_shaded_fw, &
& lsif_u_sunlit_fw, lsif_u_shaded_fw
!scat
  REAL(r8) :: stsif_o_sunlit, stsif_o_shaded, stsif_u_sunlit, &
& stsif_u_shaded
  REAL(r8), DIMENSION(nbdirsmax) :: stsif_o_sunlit_fw, stsif_o_shaded_fw&
& , stsif_u_sunlit_fw, stsif_u_shaded_fw
  REAL(r8) :: cos_o_sunlit, cos_o_shaded, cos_u_sunlit, cos_u_shaded
  REAL(r8), DIMENSION(nbdirsmax) :: cos_o_sunlit_fw, cos_o_shaded_fw, &
& cos_u_sunlit_fw, cos_u_shaded_fw
  REAL(r8) :: lcos_o_sunlit, lcos_o_shaded, lcos_u_sunlit, lcos_u_shaded
  REAL(r8), DIMENSION(nbdirsmax) :: lcos_o_sunlit_fw, lcos_o_shaded_fw, &
& lcos_u_sunlit_fw, lcos_u_shaded_fw
  REAL(r8) :: vps_air
  REAL(r8) :: gs_h2o
  REAL(r8) :: gh_o, g_o_a, g_o_b, g_u_a, g_u_b
  REAL(r8), DIMENSION(nbdirsmax) :: gh_o_fw, g_o_a_fw, g_o_b_fw, &
& g_u_a_fw, g_u_b_fw
  REAL(r8) :: canopyh_o, canopyh_u
  REAL(r8) :: vpd_air
  REAL(r8) :: mass_water_g
  REAL(r8), DIMENSION(nbdirsmax) :: mass_water_g_fw
  REAL(r8) :: percentarea_snow_o, percentarea_snow_u
  REAL(r8), DIMENSION(nbdirsmax) :: percentarea_snow_o_fw, &
& percentarea_snow_u_fw
  REAL(r8) :: gheat_g
  REAL(r8), DIMENSION(nbdirsmax) :: gheat_g_fw
!the intercept term in BWB model (mol H2O m-2 s-1)
  REAL(r8) :: b_h2o
! the slope in BWB model
  REAL(r8) :: m_h2o
!leaf latent heat flux (mol/m2/s)
  REAL(r8) :: leleaf_o_sunlit, leleaf_o_shaded, leleaf_u_sunlit, &
& leleaf_u_shaded
  REAL(r8), DIMENSION(nbdirsmax) :: leleaf_o_sunlit_fw, &
& leleaf_o_shaded_fw, leleaf_u_sunlit_fw, leleaf_u_shaded_fw
!for the Vcmax-Nitrogen calculation
  REAL(r8), SAVE :: kn=0.3
  REAL(r8), SAVE :: g_theta=0.5
!real(r8)             :: K,Vcmax0,Vcmax_sunlit,Vcmax_shaded,expr1,expr2,expr3
!Vcmax0 as an input from outside
  REAL(r8) :: k, vcmax_sunlit, vcmax_shaded, expr1, expr2, expr3
  REAL(r8), DIMENSION(nbdirsmax) :: vcmax_sunlit_fw, vcmax_shaded_fw
  REAL(r8) :: slope_vcmax_n, leaf_n, jmax_sunlit, jmax_shaded
! for SIF simulation @JWang
  REAL(r8) :: ffpa
  REAL(r8), DIMENSION(nbdirsmax) :: ffpa_fw
! for storing daily mean temperature
  REAL(r8) :: temp_day
! for storing daily mean surface soil moisture
  REAL(r8) :: theta_day
! for storing daily mean transpiration
  REAL(r8) :: trans_day
  REAL(r8), DIMENSION(nbdirsmax) :: trans_day_fw
  REAL(r8) :: cosa
  REAL(r8) :: cos_soil
  REAL(r8), DIMENSION(nbdirsmax) :: cos_soil_fw
!--iLab::introduced to avoid calling is_end_curr_day() from beps_time_manager
  LOGICAL :: is_end_curr_day
  INTRINSIC EXP
  INTRINSIC INT
  INTRINSIC MAX
  INTRINSIC MIN
  INTRINSIC ABS
  REAL(r8) :: abs0
  REAL(r8) :: abs1
  REAL(r8) :: abs2
  REAL(r8) :: abs3
  REAL(r8) :: arg1
  REAL(r8), DIMENSION(nbdirsmax) :: arg1_fw
  REAL(r8) :: arg2
  REAL(r8), DIMENSION(nbdirsmax) :: arg2_fw
  INTEGER :: nd
  REAL(r8) :: temp
  INTEGER :: nbdirs
!--iLab: taken from BEPS time manager
  is_end_curr_day = tod .EQ. 0
  temp_day = 0.
  theta_day = 0.
  trans_day = 0.
  psychrometer = 0.066
  alpha_sat = param(24)
  alpha_dry = param(25)
! to be used for module aerodynamic_conductance
  canopyh_o = param(29)
  canopyh_u = param(30)
  height_wind_sp = param(31)
!height_wind_sp   = 30.
! used for photosynthesis
  m_h2o = param(33)
  b_h2o = param(34)
!-- iLab::g2_h2o is *only* set from other routines in case 'CosZs>0.',
!         so we *must* initialise it and have uncommented the initialiser
!         that was already present.
  gs_h2o = 0.
!gs_h2o      = 0.
! Vcmax-Nitrogen calculations by G,Mo 2011.04
  IF (coszs .GT. 0.) THEN
    k = g_theta*clumping/coszs
!   Vcmax0  = param(36)    !an input from outside @J.Wang
    IF (k .GT. 10.) THEN
!! adjust K range here to get rid of floating-point exceptions,@MOUSONG.WU
      expr1 = 1.
      expr2 = 1.
    ELSE
      arg1 = -(k*lai)
      expr1 = 1. - EXP(arg1)
      arg1 = -(lai*(kn+k))
      expr2 = 1. - EXP(arg1)
    END IF
    arg1 = -(kn*lai)
    expr3 = 1. - EXP(arg1)
    IF (expr1 .GT. 0.) THEN
      vcmax_sunlit = vcmax0*param(47)*param(46)*k*expr2/(kn+k)/expr1
    ELSE
      vcmax_sunlit = vcmax0
    END IF
    IF (k .GT. 0 .AND. lai .GT. expr1/k) THEN
      vcmax_shaded = vcmax0*param(47)*param(46)*(expr3/kn-expr2/(kn+k))/&
&       (lai-expr1/k)
    ELSE
      vcmax_shaded = vcmax0
    END IF
  END IF
!! LAI calculation module by B.Chen
  DO nd=1,nbdirs
    lai_o_fw(nd) = lai_fw(nd)
  END DO
  lai_o = lai
  IF (lai .LT. 0.1) THEN
    lai_o = 0.1
    lai_o_fw(:) = 0.0_8
  END IF
  landcover = INT(param(4))
! Calculate ffpa as a function of lai, this makes the ffpa vary with time, instead of being a constant as below,@MOUSONG WU, 2020
!-09-14
  DO nd=1,nbdirs
    ffpa_fw(nd) = EXP(-(0.45*lai))*0.45*lai_fw(nd)
  END DO
  ffpa = 1. - EXP(-(0.45*lai))
  IF (1.e-2 .LT. ffpa) THEN
    ffpa = ffpa
  ELSE
    ffpa = 1.e-2
    ffpa_fw(:) = 0.0_8
  END IF
  IF (1.0 .GT. ffpa) THEN
    ffpa = ffpa
  ELSE
    ffpa = 1.0
    ffpa_fw(:) = 0.0_8
  END IF
! added for sif simulation @J. Wang
!select case (landcover)
!   case (1)    !conifer evergreen
!    ffpa = 0.6
!   case(2)      !conifer decidous
!    ffpa = 0.6
!   case(6)      !broadleaf decidous
!    ffpa = 0.8
!   case(9)      !broadleaf evergreen
!    ffpa = 0.8
!   case(10)     !mix
!    ffpa = 0.4
!   case(13)     !shrub
!    ffpa = 0.8
!   case(14)     ! grass
!    ffpa = 0.8
!   case(15)     ! crop
!    ffpa = 0.6
!   case(40)     ! c4 grass
!    ffpa = 0.6  
!   case(41)     ! C4 crop
!    ffpa = 0.6
!end select
!if(landcover == 25 .or. landcover ==40) then
  IF (((landcover .EQ. 14 .OR. landcover .EQ. 15) .OR. landcover .EQ. 40&
&     ) .OR. landcover .EQ. 41) THEN
!14->grass 15->crop @JWang
    lai_u = 0.01
    lai_u_fw(:) = 0.0_8
  ELSE
    arg1 = -(0.99*lai_o)
    DO nd=1,nbdirs
      arg1_fw(nd) = -(0.99*lai_o_fw(nd))
      lai_u_fw(nd) = 1.18*EXP(arg1)*arg1_fw(nd)
    END DO
    lai_u = 1.18*EXP(arg1)
  END IF
  IF (lai_u .GT. lai_o) THEN
    lai_u = 0.01
    lai_u_fw(:) = 0.0_8
  END IF
  stem_o = param(8)*0.2
  stem_u = param(9)*0.2
!Bing Chen
  CALL LAI_CAL_FWV(stem_o, stem_u, landcover, coszs, lai_o, lai_o_fw, &
&            clumping, lai_u, lai_u_fw, laio_sunlit, laio_sunlit_fw, &
&            laio_shaded, laio_shaded_fw, laiu_sunlit, laiu_sunlit_fw, &
&            laiu_shaded, laiu_shaded_fw, lai_o_sunlit, lai_o_sunlit_fw&
&            , lai_o_shaded, lai_o_shaded_fw, lai_u_sunlit, &
&            lai_u_sunlit_fw, lai_u_shaded, lai_u_shaded_fw, nbdirs)
!-------initalization of this time step
  ks = meteo%srad
  rh_air = meteo%rh
  wind_sp = meteo%wind
!m/s   liquid water
  rainfall = meteo%rainfall
!m/s   snow
  snow = meteo%snow
  temp_air = meteo%temp
  IF (ks .LE. 0) THEN
    alpha_v_o = 0.
    alpha_n_o = 0.
    alpha_v_u = 0.
    alpha_n_u = 0.
  ELSE
    alpha_v_o = param(22)
    alpha_n_o = param(23)
    alpha_v_u = param(22)
    alpha_n_u = param(23)
  END IF
  qhc_o_fw(:, :) = 0.0_8
  ts0_fw(:, :) = 0.0_8
  DO nd=1,nbdirs
    qhc_o_fw(nd, 0) = var_o_fw(nd, 1)
    ts0_fw(nd, 0) = var_o_fw(nd, 3)
  END DO
  qhc_o(0) = var_o(1)
  ts0(0) = var_o(3)
  IF (ts0(0) - temp_air .GT. 2.0) THEN
    DO nd=1,nbdirs
      ts0_fw(nd, 0) = 0.0_8
    END DO
    ts0(0) = temp_air + 2.0
  END IF
  IF (ts0(0) - temp_air .LT. -2.0) THEN
    DO nd=1,nbdirs
      ts0_fw(nd, 0) = 0.0_8
    END DO
    ts0(0) = temp_air - 2.0
  END IF
  tsn0_fw(:, :) = 0.0_8
  DO nd=1,nbdirs
    tsn0_fw(nd, 0) = var_o_fw(nd, 4)
  END DO
  tsn0(0) = var_o(4)
  IF (tsn0(0) - temp_air .GT. 2.0) THEN
    DO nd=1,nbdirs
      tsn0_fw(nd, 0) = 0.0_8
    END DO
    tsn0(0) = temp_air + 2.0
  END IF
  IF (tsn0(0) - temp_air .LT. -2.0) THEN
    DO nd=1,nbdirs
      tsn0_fw(nd, 0) = 0.0_8
    END DO
    tsn0(0) = temp_air - 2.0
  END IF
  tsm0_fw(:, :) = 0.0_8
  DO nd=1,nbdirs
    tsm0_fw(nd, 0) = var_o_fw(nd, 5)
  END DO
  tsm0(0) = var_o(5)
  IF (tsm0(0) - temp_air .GT. 2.) THEN
    DO nd=1,nbdirs
      tsm0_fw(nd, 0) = 0.0_8
    END DO
    tsm0(0) = temp_air + 2.0
  END IF
  IF (tsm0(0) - temp_air .LT. -2.) THEN
    DO nd=1,nbdirs
      tsm0_fw(nd, 0) = 0.0_8
    END DO
    tsm0(0) = temp_air - 2.0
  END IF
  tsn1_fw(:, :) = 0.0_8
  DO nd=1,nbdirs
    tsn1_fw(nd, 0) = var_o_fw(nd, 6)
  END DO
  tsn1(0) = var_o(6)
  IF (tsn1(0) - temp_air .GT. 2.0) THEN
    DO nd=1,nbdirs
      tsn1_fw(nd, 0) = 0.0_8
    END DO
    tsn1(0) = temp_air + 2.0
  END IF
  IF (tsn1(0) - temp_air .LT. -2.) THEN
    DO nd=1,nbdirs
      tsn1_fw(nd, 0) = 0.0_8
    END DO
    tsn1(0) = temp_air - 2.0
  END IF
  tsn2_fw(:, :) = 0.0_8
  DO nd=1,nbdirs
    tsn2_fw(nd, 0) = var_o_fw(nd, 7)
  END DO
  tsn2(0) = var_o(7)
  IF (tsn2(0) - temp_air .GT. 2.0) THEN
    DO nd=1,nbdirs
      tsn2_fw(nd, 0) = 0.0_8
    END DO
    tsn2(0) = temp_air + 2.0
  END IF
  IF (tsn2(0) - temp_air .LT. -2.) THEN
    DO nd=1,nbdirs
      tsn2_fw(nd, 0) = 0.0_8
    END DO
    tsn2(0) = temp_air - 2.0
  END IF
!the mass of intercepted liquid water and snow, overstory
  wcl_o_fw(:, :) = 0.0_8
  wcs_o_fw(:, :) = 0.0_8
  wcl_u_fw(:, :) = 0.0_8
  wcs_u_fw(:, :) = 0.0_8
!  fraction of ground surface covered by snow and snow mass
  wg_snow_fw(:, :) = 0.0_8
!-- iLab::*must* at least initialise arrays for complete number of iterations
!          (and not only the first element),
!         since elements are input/output(!) arguments to called routines
!         (snowpack_stage1,netRadiation)
  ac_snow_o_fw(:, :) = 0.0_8
  ac_snow_u_fw(:, :) = 0.0_8
  rho_snow_fw(:, :) = 0.0_8
  alpha_v_sw_fw(:, :) = 0.0_8
  alpha_n_sw_fw(:, :) = 0.0_8
  DO nd=1,nbdirs
    wcl_o_fw(nd, 0) = var_o_fw(nd, 15)
    wcs_o_fw(nd, 0) = var_o_fw(nd, 16)
    wcl_u_fw(nd, 0) = var_o_fw(nd, 18)
    wcs_u_fw(nd, 0) = var_o_fw(nd, 19)
    wg_snow_fw(nd, 0) = var_o_fw(nd, 20)
    soilp_fw%zsp(nd) = var_o_fw(nd, 33)
    ac_snow_o_fw(nd, 0:iter_max) = var_o_fw(nd, 36)
    ac_snow_u_fw(nd, 0:iter_max) = var_o_fw(nd, 37)
    rho_snow_fw(nd, 0:iter_max) = var_o_fw(nd, 38)
    alpha_v_sw_fw(nd, 0:iter_max) = var_o_fw(nd, 39)
    alpha_n_sw_fw(nd, 0:iter_max) = var_o_fw(nd, 40)
  END DO
  wcl_o(0) = var_o(15)
  wcs_o(0) = var_o(16)
  wcl_u(0) = var_o(18)
  wcs_u(0) = var_o(19)
  wg_snow(0) = var_o(20)
  soilp%zsp = var_o(33)
  DO nd=1,nbdirs
    soilp_fw%zp(nd) = var_o_fw(nd, 34)
  END DO
  soilp%zp = var_o(34)
  DO nd=1,nbdirs
    soilp_fw%r_rain_g(nd) = var_o_fw(nd, 35)
  END DO
  soilp%r_rain_g = var_o(35)
  ac_snow_o(0:iter_max) = var_o(36)
  ac_snow_u(0:iter_max) = var_o(37)
  rho_snow(0:iter_max) = var_o(38)
  alpha_v_sw(0:iter_max) = var_o(39)
  alpha_n_sw(0:iter_max) = var_o(40)
  DO nd=1,nbdirs
! Ac_snow_o(0)    = var_o(36)
! Ac_snow_u(0)    = var_o(37)
! rho_snow(0)     = var_o(38)
! alpha_v_sw(0)   = var_o(39)
! alpha_n_sw(0)   = var_o(40)
    zsp_fw(nd) = soilp_fw%zsp(nd)
    zp_fw(nd) = soilp_fw%zp(nd)
  END DO
  zsp = soilp%zsp
  zp = soilp%zp
  IF (zp .LT. 0.001) THEN
    zp = 0.
    zp_fw(:) = 0.0_8
  END IF
!if(Zp < 1.e-6) Zp = 0.
  DO i=9,14
    DO nd=1,nbdirs
      soilp_fw%temp_soil_p(nd, i-9) = var_o_fw(nd, i)
    END DO
    soilp%temp_soil_p(i-9) = var_o(i)
  END DO
  DO i=21,26
    DO nd=1,nbdirs
      soilp_fw%thetam_prev(nd, i-21) = var_o_fw(nd, i)
    END DO
    soilp%thetam_prev(i-21) = var_o(i)
  END DO
  DO i=27,32
    DO nd=1,nbdirs
      soilp_fw%ice_ratio(nd, i-27) = var_o_fw(nd, i)
    END DO
    soilp%ice_ratio(i-27) = var_o(i)
  END DO
! vcmax jmax module  by L. He
  slope_vcmax_n = param(47)
  leaf_n = param(46)
  CALL VCMAX_JMAX_FWV(lai_o, lai_o_fw, clumping, vcmax0, vcmax0_fw, &
&               vj_slope, slope_vcmax_n, leaf_n, coszs, vcmax_sunlit, &
&               vcmax_sunlit_fw, vcmax_shaded, vcmax_shaded_fw, &
&               jmax_sunlit, jmax_shaded, nbdirs)
! temperatures of overstorey and understorey canopies
  tc_o_sunlit_old = temp_air - 0.5
  tc_o_shaded_old = temp_air - 0.5
  tc_u_sunlit_old = temp_air - 0.5
  tc_u_shaded_old = temp_air - 0.5
  xcs_o_fw(:, :) = 0.0_8
  lcos_u_shaded_fw(:) = 0.0_8
  gh_o_sunlit_fw(:) = 0.0_8
  lsif_o_sunlit_fw(:) = 0.0_8
  sif_o_shaded_fw(:) = 0.0_8
  g_fw(:, :, :) = 0.0_8
  ac_o_shaded_fw(:) = 0.0_8
  tm_fw(:, :, :) = 0.0_8
  xcs_u_fw(:, :) = 0.0_8
  xg_snow_fw(:, :) = 0.0_8
  sif_u_sunlit_fw(:) = 0.0_8
  ac_u_sunlit_fw(:) = 0.0_8
  tc_o_sunlit_old_fw(:) = 0.0_8
  lambda_soil_fw(:, :) = 0.0_8
  gh_o_shaded_fw(:) = 0.0_8
  r_rain_g_fw(:, :) = 0.0_8
  lsif_o_shaded_fw(:) = 0.0_8
  gww_o_sunlit_fw(:) = 0.0_8
  lsif_u_sunlit_fw(:) = 0.0_8
  eil_o_fw(:, :) = 0.0_8
  gw_o_sunlit_fw(:) = 0.0_8
  sif_u_shaded_fw(:) = 0.0_8
  tc_o_shaded_new_fw(:) = 0.0_8
  ac_u_shaded_fw(:) = 0.0_8
  eil_u_fw(:, :) = 0.0_8
  trans_o_fw(:, :) = 0.0_8
  tc_u_sunlit_old_fw(:) = 0.0_8
  evap_soil_fw(:, :) = 0.0_8
  trans_u_fw(:, :) = 0.0_8
  gww_o_shaded_fw(:) = 0.0_8
  lsif_u_shaded_fw(:) = 0.0_8
  gw_o_shaded_fw(:) = 0.0_8
  tc_u_shaded_new_fw(:) = 0.0_8
  ra_g_fw(:) = 0.0_8
  gw_u_sunlit_fw(:) = 0.0_8
  gww_u_sunlit_fw(:) = 0.0_8
  eis_o_fw(:, :) = 0.0_8
  cos_o_sunlit_fw(:) = 0.0_8
  tc_o_sunlit_new_fw(:) = 0.0_8
  eis_u_fw(:, :) = 0.0_8
  gw_u_shaded_fw(:) = 0.0_8
  gww_u_shaded_fw(:) = 0.0_8
  tc_u_fw(:, :) = 0.0_8
  tcu_fw(:) = 0.0_8
  lcos_o_sunlit_fw(:) = 0.0_8
  cos_o_shaded_fw(:) = 0.0_8
  cos_u_sunlit_fw(:) = 0.0_8
  tc_u_sunlit_new_fw(:) = 0.0_8
  xcl_o_fw(:, :) = 0.0_8
  radiation_g_fw(:) = 0.0_8
  lcos_o_shaded_fw(:) = 0.0_8
  xcl_u_fw(:, :) = 0.0_8
  tc_o_shaded_old_fw(:) = 0.0_8
  cs_fw(:, :, :) = 0.0_8
  lcos_u_sunlit_fw(:) = 0.0_8
  cos_u_shaded_fw(:) = 0.0_8
  sif_o_sunlit_fw(:) = 0.0_8
  ac_o_sunlit_fw(:) = 0.0_8
  evap_ss_fw(:, :) = 0.0_8
  evap_sw_fw(:, :) = 0.0_8
  tc_u_shaded_old_fw(:) = 0.0_8
!sub-time iteration @J.Wang
  DO kkk=1,kloop
! Snow pack stage 1  by R.Luo
    CALL SNOWPACK_STAGE1_FWV(temp_air, snow, wcs_o(kkk-1), wcs_o_fw(:, &
&                      kkk-1), wcs_u(kkk-1), wcs_u_fw(:, kkk-1), wg_snow&
&                      (kkk-1), wg_snow_fw(:, kkk-1), rho_snow(kkk-1), &
&                      rho_snow_fw(:, kkk-1), ac_snow_o(kkk-1), &
&                      ac_snow_o_fw(:, kkk-1), ac_snow_u(kkk-1), &
&                      ac_snow_u_fw(:, kkk-1), wcs_o(kkk), wcs_o_fw(:, &
&                      kkk), wcs_u(kkk), wcs_u_fw(:, kkk), wg_snow(kkk)&
&                      , wg_snow_fw(:, kkk), lai_o, lai_o_fw, lai_u, &
&                      lai_u_fw, clumping, ac_snow_o(kkk), ac_snow_o_fw(&
&                      :, kkk), ac_snow_u(kkk), ac_snow_u_fw(:, kkk), &
&                      xcs_o(kkk), xcs_o_fw(:, kkk), xcs_u(kkk), &
&                      xcs_u_fw(:, kkk), xg_snow(kkk), xg_snow_fw(:, kkk&
&                      ), rho_snow(kkk), rho_snow_fw(:, kkk), zsp, &
&                      zsp_fw, alpha_v_sw(kkk), alpha_v_sw_fw(:, kkk), &
&                      alpha_n_sw(kkk), alpha_n_sw_fw(:, kkk), nbdirs)
!    write(*,*) "DG01: Ac_snow_o(kkk) =",Ac_snow_o(kkk)
! rainfall stag 1
    CALL RAINFALL_STAGE1_FWV(temp_air, rainfall, wcl_o(kkk-1), wcl_o_fw(&
&                      :, kkk-1), wcl_u(kkk-1), wcl_u_fw(:, kkk-1), &
&                      lai_o, lai_o_fw, lai_u, lai_u_fw, clumping, wcl_o&
&                      (kkk), wcl_o_fw(:, kkk), wcl_u(kkk), wcl_u_fw(:, &
&                      kkk), xcl_o(kkk), xcl_o_fw(:, kkk), xcl_u(kkk), &
&                      xcl_u_fw(:, kkk), r_rain_g(kkk), r_rain_g_fw(:, &
&                      kkk), nbdirs)
    IF (soilp%thetam_prev(1) .LT. soilp%theta_vwp(1)*0.5) THEN
      alpha_g = alpha_dry
      alpha_g_fw(:) = 0.0_8
    ELSE
      temp = soilp%fei(1) - 0.5*soilp%theta_vwp(1)
      DO nd=1,nbdirs
        alpha_g_fw(nd) = (alpha_sat-alpha_dry)*soilp_fw%thetam_prev(nd, &
&         1)/temp
      END DO
      alpha_g = alpha_dry + (alpha_sat-alpha_dry)*((soilp%thetam_prev(1)&
&       -soilp%theta_vwp(1)*0.5)/temp)
    END IF
! soil water factor module
    CALL SOIL_WATER_FACTOR_V2_FWV(soilp, soilp_fw, nbdirs)
    DO nd=1,nbdirs
      alpha_v_g_fw(nd) = 2.*alpha_g_fw(nd)/3.
      alpha_n_g_fw(nd) = 4.*alpha_g_fw(nd)/3.
      f_soilwater_fw(nd) = soilp_fw%f_soilwater(nd)
    END DO
    alpha_v_g = 2./3.*alpha_g
    alpha_n_g = 4./3.*alpha_g
    f_soilwater = soilp%f_soilwater
    IF (f_soilwater .GT. 1.0) THEN
      f_soilwater = 1.0
      f_soilwater_fw(:) = 0.0_8
    END IF
    temp = ac_snow_o(kkk)/(2.*lai_o)
    DO nd=1,nbdirs
!used as the init. for module aerodynamic_conductance
      gh_o_fw(nd) = qhc_o_fw(nd, kkk-1)
      percentarea_snow_o_fw(nd) = (ac_snow_o_fw(nd, kkk)-temp*2.*&
&       lai_o_fw(nd))/(2.*lai_o)
    END DO
    gh_o = qhc_o(kkk-1)
    arg1 = 17.3*temp_air/(237.3+temp_air)
    vps_air = 0.61078*EXP(arg1)
    e_a10 = vps_air*rh_air/100.
!water vapor deficit at the reference height @J.Wang maybe directly use meteo_pack
    vpd_air = vps_air - e_a10
!g/g  no dimention
    q_ca = 0.622*e_a10/(101.35-0.378*e_a10)
    cp_ca = cpd*(1.+0.84*q_ca)
    arg1 = 17.27*temp_air/(temp_air+237.3)
    slope = 2503.0/(temp_air+237.3)**2*EXP(arg1)
    gs_o_sunlit_old = 1./200.0
    ci_o_sunlit_old = 0.7*co2_air
    gs_o_shaded_old = 1./200.0
    ci_o_shaded_old = 0.7*co2_air
    gs_u_sunlit_old = 1./300.0
    ci_u_sunlit_old = 0.7*co2_air
    gs_u_shaded_old = 1./300.0
    ci_u_shaded_old = 0.7*co2_air
    cosi_o_sunlit_old = 0.7*cos_air
    cosi_o_shaded_old = 0.7*cos_air
    cosi_u_sunlit_old = 0.7*cos_air
    cosi_u_shaded_old = 0.7*cos_air
    percentarea_snow_o = temp
    temp = ac_snow_u(kkk)/(2.*lai_u)
    DO nd=1,nbdirs
      percentarea_snow_u_fw(nd) = (ac_snow_u_fw(nd, kkk)-temp*2.*&
&       lai_u_fw(nd))/(2.*lai_u)
    END DO
    percentarea_snow_u = temp
!ground temperature substituted by air temperature
    temp_grd = temp_air
    num = 0
    gs_o_shaded_old_fw(:) = 0.0_8
    cosi_o_shaded_old_fw(:) = 0.0_8
    gs_u_shaded_old_fw(:) = 0.0_8
    cosi_u_shaded_old_fw(:) = 0.0_8
    gs_o_sunlit_old_fw(:) = 0.0_8
    cosi_o_sunlit_old_fw(:) = 0.0_8
    gs_u_sunlit_old_fw(:) = 0.0_8
    cosi_u_sunlit_old_fw(:) = 0.0_8
    DO WHILE (.true.)
      num = num + 1
      DO nd=1,nbdirs
! aerodynamic_conductance module by G.Mo
        arg1_fw(nd) = lai_o_fw(nd)
        arg2_fw(nd) = lai_u_fw(nd)
      END DO
      arg1 = lai_o + stem_o
      arg2 = lai_u + stem_u
      CALL AERODYNAMIC_CONDUCTANCE_FWV(canopyh_o, canopyh_u, &
&                                height_wind_sp, clumping, temp_air, &
&                                wind_sp, gh_o, gh_o_fw, arg1, arg1_fw, &
&                                arg2, ra_o, ra_u, ra_g, ra_g_fw, g_o_a&
&                                , g_o_a_fw, g_o_b, g_o_b_fw, g_u_a, &
&                                g_u_a_fw, g_u_b, g_u_b_fw, nbdirs)
!heat conductance of sunlit leaves of overstorey
      temp = 1.0/(1.0/g_o_a+0.5/g_o_b)
      DO nd=1,nbdirs
        gh_o_sunlit_fw(nd) = -(temp*(-(g_o_a_fw(nd)/g_o_a**2)-0.5*&
&         g_o_b_fw(nd)/g_o_b**2)/(1.0/g_o_a+0.5/g_o_b))
! net Radiation at canopy and leaf level module by X.Luo
        arg1_fw(nd) = lai_o_fw(nd)
      END DO
      gh_o_sunlit = temp
      temp = 1.0/(1.0/g_o_a+0.5/g_o_b)
      DO nd=1,nbdirs
        gh_o_shaded_fw(nd) = -(temp*(-(g_o_a_fw(nd)/g_o_a**2)-0.5*&
&         g_o_b_fw(nd)/g_o_b**2)/(1.0/g_o_a+0.5/g_o_b))
      END DO
      gh_o_shaded = temp
      temp = 1.0/(1.0/g_u_a+0.5/g_u_b)
      DO nd=1,nbdirs
        gh_u_sunlit_fw(nd) = -(temp*(-(g_u_a_fw(nd)/g_u_a**2)-0.5*&
&         g_u_b_fw(nd)/g_u_b**2)/(1.0/g_u_a+0.5/g_u_b))
      END DO
      gh_u_sunlit = temp
      temp = 1.0/(1.0/g_u_a+0.5/g_u_b)
      DO nd=1,nbdirs
        gh_u_shaded_fw(nd) = -(temp*(-(g_u_a_fw(nd)/g_u_a**2)-0.5*&
&         g_u_b_fw(nd)/g_u_b**2)/(1.0/g_u_a+0.5/g_u_b))
      END DO
      gh_u_shaded = temp
! conductance for intercepted water of sunlit leaves of overstorey
      temp = 1.0/(1.0/g_o_a+1.0/g_o_b+100.)
      DO nd=1,nbdirs
        gww_o_sunlit_fw(nd) = -(temp*(-(g_o_a_fw(nd)/g_o_a**2)-g_o_b_fw(&
&         nd)/g_o_b**2)/(1.0/g_o_a+1.0/g_o_b+100.))
      END DO
      gww_o_sunlit = temp
      temp = 1.0/(1.0/g_o_a+1.0/g_o_b+100.)
      DO nd=1,nbdirs
        gww_o_shaded_fw(nd) = -(temp*(-(g_o_a_fw(nd)/g_o_a**2)-g_o_b_fw(&
&         nd)/g_o_b**2)/(1.0/g_o_a+1.0/g_o_b+100.))
      END DO
      gww_o_shaded = temp
      temp = 1.0/(1.0/g_u_a+1.0/g_u_b+100.)
      DO nd=1,nbdirs
        gww_u_sunlit_fw(nd) = -(temp*(-(g_u_a_fw(nd)/g_u_a**2)-g_u_b_fw(&
&         nd)/g_u_b**2)/(1.0/g_u_a+1.0/g_u_b+100.))
      END DO
      gww_u_sunlit = temp
      temp = 1.0/(1.0/g_u_a+1.0/g_u_b+100.)
      DO nd=1,nbdirs
        gww_u_shaded_fw(nd) = -(temp*(-(g_u_a_fw(nd)/g_u_a**2)-g_u_b_fw(&
&         nd)/g_u_b**2)/(1.0/g_u_a+1.0/g_u_b+100.))
      END DO
      gww_u_shaded = temp
! temperatures of overstorey and understorey canopies
      temp = (tc_o_sunlit_old*lai_o_sunlit+tc_o_shaded_old*lai_o_shaded)&
&       /(lai_o_sunlit+lai_o_shaded)
      DO nd=1,nbdirs
        tco_fw(nd) = (lai_o_sunlit*tc_o_sunlit_old_fw(nd)+&
&         tc_o_sunlit_old*lai_o_sunlit_fw(nd)+lai_o_shaded*&
&         tc_o_shaded_old_fw(nd)+tc_o_shaded_old*lai_o_shaded_fw(nd)-&
&         temp*(lai_o_sunlit_fw(nd)+lai_o_shaded_fw(nd)))/(lai_o_sunlit+&
&         lai_o_shaded)
      END DO
      tco = temp
      temp = (tc_u_sunlit_old*lai_u_sunlit+tc_u_shaded_old*lai_u_shaded)&
&       /(lai_u_sunlit+lai_u_shaded)
      DO nd=1,nbdirs
        tcu_fw(nd) = (lai_u_sunlit*tc_u_sunlit_old_fw(nd)+&
&         tc_u_sunlit_old*lai_u_sunlit_fw(nd)+lai_u_shaded*&
&         tc_u_shaded_old_fw(nd)+tc_u_shaded_old*lai_u_shaded_fw(nd)-&
&         temp*(lai_u_sunlit_fw(nd)+lai_u_shaded_fw(nd)))/(lai_u_sunlit+&
&         lai_u_shaded)
      END DO
      tcu = temp
      arg1 = lai_o + stem_o
      arg2 = lai_u + stem_u
      CALL NETRADIATION_FWV(meteo%s_dff, meteo%s_dir, coszs, tco, tco_fw&
&                     , tcu, tcu_fw, temp_grd, lai_o, lai_o_fw, lai_u, &
&                     lai_u_fw, arg1, arg1_fw, arg2, arg2_fw, &
&                     lai_o_sunlit, lai_o_shaded, lai_u_sunlit, &
&                     lai_u_shaded, clumping, temp_air, rh_air, &
&                     alpha_v_sw(kkk), alpha_v_sw_fw(:, kkk), alpha_n_sw&
&                     (kkk), alpha_n_sw_fw(:, kkk), percentarea_snow_o, &
&                     percentarea_snow_o_fw, percentarea_snow_u, &
&                     percentarea_snow_u_fw, xg_snow(kkk), xg_snow_fw(:&
&                     , kkk), alpha_v_o, alpha_n_o, alpha_v_u, alpha_n_u&
&                     , alpha_v_g, alpha_v_g_fw, alpha_n_g, alpha_n_g_fw&
&                     , radiation_o, radiation_u, radiation_g, &
&                     radiation_g_fw, radiation_o_sun, &
&                     radiation_o_sun_fw, radiation_o_shaded, &
&                     radiation_o_shaded_fw, radiation_u_sun, &
&                     radiation_u_sun_fw, radiation_u_shaded, &
&                     radiation_u_shaded_fw, r_o_sunlit, r_o_sunlit_fw, &
&                     r_o_shaded, r_o_shaded_fw, r_u_sunlit, &
&                     r_u_sunlit_fw, r_u_shaded, r_u_shaded_fw, nbdirs)
! photosynthesis module by B. Chen
!conductance of sunlit leaves of overstorey for water
      temp = 1.0/(1.0/g_o_a+1.0/g_o_b+1.0/gs_o_sunlit_old)
      DO nd=1,nbdirs
        gw_o_sunlit_fw(nd) = -(temp*(-(g_o_a_fw(nd)/g_o_a**2)-g_o_b_fw(&
&         nd)/g_o_b**2-gs_o_sunlit_old_fw(nd)/gs_o_sunlit_old**2)/(1.0/&
&         g_o_a+1.0/g_o_b+1.0/gs_o_sunlit_old))
      END DO
      gw_o_sunlit = temp
      temp = 1.0/(1.0/g_o_a+1.0/g_o_b+1.0/gs_o_shaded_old)
      DO nd=1,nbdirs
        gw_o_shaded_fw(nd) = -(temp*(-(g_o_a_fw(nd)/g_o_a**2)-g_o_b_fw(&
&         nd)/g_o_b**2-gs_o_shaded_old_fw(nd)/gs_o_shaded_old**2)/(1.0/&
&         g_o_a+1.0/g_o_b+1.0/gs_o_shaded_old))
      END DO
      gw_o_shaded = temp
      temp = 1.0/(1.0/g_u_a+1.0/g_u_b+1.0/gs_u_sunlit_old)
      DO nd=1,nbdirs
        gw_u_sunlit_fw(nd) = -(temp*(-(g_u_a_fw(nd)/g_u_a**2)-g_u_b_fw(&
&         nd)/g_u_b**2-gs_u_sunlit_old_fw(nd)/gs_u_sunlit_old**2)/(1.0/&
&         g_u_a+1.0/g_u_b+1.0/gs_u_sunlit_old))
      END DO
      gw_u_sunlit = temp
      temp = 1.0/(1.0/g_u_a+1.0/g_u_b+1.0/gs_u_shaded_old)
      DO nd=1,nbdirs
        gw_u_shaded_fw(nd) = -(temp*(-(g_u_a_fw(nd)/g_u_a**2)-g_u_b_fw(&
&         nd)/g_u_b**2-gs_u_shaded_old_fw(nd)/gs_u_shaded_old**2)/(1.0/&
&         g_u_a+1.0/g_u_b+1.0/gs_u_shaded_old))
      END DO
      gw_u_shaded = temp
      temp = vpd_air + slope*(tc_o_sunlit_old-temp_air)
      DO nd=1,nbdirs
        leleaf_o_sunlit_fw(nd) = rho_a*cp_ca*(gw_o_sunlit*slope*&
&         tc_o_sunlit_old_fw(nd)/psychrometer+temp*gw_o_sunlit_fw(nd)/&
&         psychrometer)
      END DO
      leleaf_o_sunlit = rho_a*cp_ca*(temp*(gw_o_sunlit/psychrometer))
      temp = vpd_air + slope*(tc_o_shaded_old-temp_air)
      DO nd=1,nbdirs
        leleaf_o_shaded_fw(nd) = rho_a*cp_ca*(gw_o_shaded*slope*&
&         tc_o_shaded_old_fw(nd)/psychrometer+temp*gw_o_shaded_fw(nd)/&
&         psychrometer)
      END DO
      leleaf_o_shaded = rho_a*cp_ca*(temp*(gw_o_shaded/psychrometer))
      temp = vpd_air + slope*(tc_u_sunlit_old-temp_air)
      DO nd=1,nbdirs
        leleaf_u_sunlit_fw(nd) = rho_a*cp_ca*(gw_u_sunlit*slope*&
&         tc_u_sunlit_old_fw(nd)/psychrometer+temp*gw_u_sunlit_fw(nd)/&
&         psychrometer)
      END DO
      leleaf_u_sunlit = rho_a*cp_ca*(temp*(gw_u_sunlit/psychrometer))
      temp = vpd_air + slope*(tc_u_shaded_old-temp_air)
      DO nd=1,nbdirs
        leleaf_u_shaded_fw(nd) = rho_a*cp_ca*(gw_u_shaded*slope*&
&         tc_u_shaded_old_fw(nd)/psychrometer+temp*gw_u_shaded_fw(nd)/&
&         psychrometer)
      END DO
      leleaf_u_shaded = rho_a*cp_ca*(temp*(gw_u_shaded/psychrometer))
      IF (coszs .GT. 0.) THEN
        CALL PHOTOSYNTHESIS_FWV(landcover, tc_o_sunlit_old, &
&                         tc_o_sunlit_old_fw, f_leaf, f_leaf_fw, p_kc25&
&                         , p_ko25, p_tau25, r_o_sunlit, r_o_sunlit_fw, &
&                         e_a10, g_o_b, g_o_b_fw, vcmax_sunlit, &
&                         vcmax_sunlit_fw, vj_slope, vj_slope_fw, &
&                         f_soilwater, f_soilwater_fw, b_h2o, m_h2o, &
&                         ci_o_sunlit_old, temp_air, leleaf_o_sunlit, &
&                         leleaf_o_sunlit_fw, gs_o_sunlit_new, &
&                         gs_o_sunlit_new_fw, gs_h2o, ac_o_sunlit, &
&                         ac_o_sunlit_fw, ci_o_sunlit_new, ffpa, ffpa_fw&
&                         , sif_alpha, sif_alpha_fw, sif_beta, &
&                         sif_beta_fw, lsif_o_sunlit, lsif_o_sunlit_fw, &
&                         cosi_o_sunlit_old, cosi_o_sunlit_old_fw, &
&                         cosi_o_sunlit_new, cosi_o_sunlit_new_fw, &
&                         lcos_o_sunlit, lcos_o_sunlit_fw, nbdirs)
        CALL PHOTOSYNTHESIS_FWV(landcover, tc_o_shaded_old, &
&                         tc_o_shaded_old_fw, f_leaf, f_leaf_fw, p_kc25&
&                         , p_ko25, p_tau25, r_o_shaded, r_o_shaded_fw, &
&                         e_a10, g_o_b, g_o_b_fw, vcmax_shaded, &
&                         vcmax_shaded_fw, vj_slope, vj_slope_fw, &
&                         f_soilwater, f_soilwater_fw, b_h2o, m_h2o, &
&                         ci_o_shaded_old, temp_air, leleaf_o_shaded, &
&                         leleaf_o_shaded_fw, gs_o_shaded_new, &
&                         gs_o_shaded_new_fw, gs_h2o, ac_o_shaded, &
&                         ac_o_shaded_fw, ci_o_shaded_new, ffpa, ffpa_fw&
&                         , sif_alpha, sif_alpha_fw, sif_beta, &
&                         sif_beta_fw, lsif_o_shaded, lsif_o_shaded_fw, &
&                         cosi_o_shaded_old, cosi_o_shaded_old_fw, &
&                         cosi_o_shaded_new, cosi_o_shaded_new_fw, &
&                         lcos_o_shaded, lcos_o_shaded_fw, nbdirs)
        CALL PHOTOSYNTHESIS_FWV(landcover, tc_u_sunlit_old, &
&                         tc_u_sunlit_old_fw, f_leaf, f_leaf_fw, p_kc25&
&                         , p_ko25, p_tau25, r_u_sunlit, r_u_sunlit_fw, &
&                         e_a10, g_u_b, g_u_b_fw, vcmax_sunlit, &
&                         vcmax_sunlit_fw, vj_slope, vj_slope_fw, &
&                         f_soilwater, f_soilwater_fw, b_h2o, m_h2o, &
&                         ci_u_sunlit_old, temp_air, leleaf_u_sunlit, &
&                         leleaf_u_sunlit_fw, gs_u_sunlit_new, &
&                         gs_u_sunlit_new_fw, gs_h2o, ac_u_sunlit, &
&                         ac_u_sunlit_fw, ci_u_sunlit_new, ffpa, ffpa_fw&
&                         , sif_alpha, sif_alpha_fw, sif_beta, &
&                         sif_beta_fw, lsif_u_sunlit, lsif_u_sunlit_fw, &
&                         cosi_u_sunlit_old, cosi_u_sunlit_old_fw, &
&                         cosi_u_sunlit_new, cosi_u_sunlit_new_fw, &
&                         lcos_u_sunlit, lcos_u_sunlit_fw, nbdirs)
        CALL PHOTOSYNTHESIS_FWV(landcover, tc_u_shaded_old, &
&                         tc_u_shaded_old_fw, f_leaf, f_leaf_fw, p_kc25&
&                         , p_ko25, p_tau25, r_u_shaded, r_u_shaded_fw, &
&                         e_a10, g_u_b, g_u_b_fw, vcmax_shaded, &
&                         vcmax_shaded_fw, vj_slope, vj_slope_fw, &
&                         f_soilwater, f_soilwater_fw, b_h2o, m_h2o, &
&                         ci_u_shaded_old, temp_air, leleaf_u_shaded, &
&                         leleaf_u_shaded_fw, gs_u_shaded_new, &
&                         gs_u_shaded_new_fw, gs_h2o, ac_u_shaded, &
&                         ac_u_shaded_fw, ci_u_shaded_new, ffpa, ffpa_fw&
&                         , sif_alpha, sif_alpha_fw, sif_beta, &
&                         sif_beta_fw, lsif_u_shaded, lsif_u_shaded_fw, &
&                         cosi_u_shaded_old, cosi_u_shaded_old_fw, &
&                         cosi_u_shaded_new, cosi_u_shaded_new_fw, &
&                         lcos_u_shaded, lcos_u_shaded_fw, nbdirs)
      ELSE
        gs_o_sunlit_new = 0.0001
        ac_o_sunlit = 0.0
        lsif_o_sunlit = 0.0
        lcos_o_sunlit = 0.0
        ci_o_sunlit_new = co2_air*0.7
        cs_o_sunlit_new = co2_air
        cc_o_sunlit_new = co2_air*0.7*0.8
        cosi_o_sunlit_new = cos_air*0.7
        coss_o_sunlit_new = cos_air
        cosc_o_sunlit_new = cos_air*0.7*0.8
        gs_o_shaded_new = 0.0001
        ac_o_shaded = 0.0
        lsif_o_shaded = 0.0
        lcos_o_shaded = 0.0
        ci_o_shaded_new = co2_air*0.7
        cs_o_shaded_new = co2_air
        cc_o_shaded_new = co2_air*0.7*0.8
        cosi_o_shaded_new = cos_air*0.7
        coss_o_shaded_new = cos_air
        cosc_o_shaded_new = cos_air*0.7*0.8
        gs_u_sunlit_new = 0.0001
        ac_u_sunlit = 0.0
        lsif_u_sunlit = 0.
        lcos_u_sunlit = 0.
        ci_u_sunlit_new = co2_air*0.7
        cs_u_sunlit_new = co2_air
        cc_u_sunlit_new = co2_air*0.7*0.8
        cosi_u_sunlit_new = cos_air*0.7
        coss_u_sunlit_new = cos_air
        cosc_u_sunlit_new = cos_air*0.7*0.8
        gs_u_shaded_new = 0.0001
        ac_u_shaded = 0.0
        lsif_u_shaded = 0.
        lcos_u_shaded = 0.
        ci_u_shaded_new = co2_air*0.7
        cs_u_shaded_new = co2_air
        cc_u_shaded_new = co2_air*0.7*0.8
        cosi_u_shaded_new = cos_air*0.7
        coss_u_shaded_new = cos_air
        cosc_u_shaded_new = cos_air*0.7*0.8
        lcos_u_shaded_fw(:) = 0.0_8
        lsif_o_sunlit_fw(:) = 0.0_8
        cosi_u_shaded_new_fw(:) = 0.0_8
        ac_o_shaded_fw(:) = 0.0_8
        ac_u_sunlit_fw(:) = 0.0_8
        gs_o_sunlit_new_fw(:) = 0.0_8
        cosi_o_sunlit_new_fw(:) = 0.0_8
        lsif_o_shaded_fw(:) = 0.0_8
        lsif_u_sunlit_fw(:) = 0.0_8
        gs_u_sunlit_new_fw(:) = 0.0_8
        ac_u_shaded_fw(:) = 0.0_8
        lsif_u_shaded_fw(:) = 0.0_8
        lcos_o_sunlit_fw(:) = 0.0_8
        lcos_o_shaded_fw(:) = 0.0_8
        gs_o_shaded_new_fw(:) = 0.0_8
        lcos_u_sunlit_fw(:) = 0.0_8
        ac_o_sunlit_fw(:) = 0.0_8
        cosi_o_shaded_new_fw(:) = 0.0_8
        gs_u_shaded_new_fw(:) = 0.0_8
      END IF
!       write(*,*) G_o_b,gs_h2o
      ci_o_sunlit_old = ci_o_sunlit_new
      cs_o_sunlit_old = cs_o_sunlit_new
!conductance of sunlit leaves of overstorey for water
      temp = 1.0/(1.0/g_o_a+1.0/g_o_b+1.0/gs_o_sunlit_new)
      DO nd=1,nbdirs
        cosi_o_sunlit_old_fw(nd) = cosi_o_sunlit_new_fw(nd)
        gs_o_sunlit_old_fw(nd) = gs_o_sunlit_new_fw(nd)
        gw_o_sunlit_fw(nd) = -(temp*(-(g_o_a_fw(nd)/g_o_a**2)-g_o_b_fw(&
&         nd)/g_o_b**2-gs_o_sunlit_new_fw(nd)/gs_o_sunlit_new**2)/(1.0/&
&         g_o_a+1.0/g_o_b+1.0/gs_o_sunlit_new))
        cosi_o_shaded_old_fw(nd) = cosi_o_shaded_new_fw(nd)
        gs_o_shaded_old_fw(nd) = gs_o_shaded_new_fw(nd)
        cosi_u_sunlit_old_fw(nd) = cosi_o_sunlit_new_fw(nd)
        gs_u_sunlit_old_fw(nd) = gs_o_sunlit_new_fw(nd)
        cosi_u_shaded_old_fw(nd) = cosi_u_shaded_new_fw(nd)
        gs_u_shaded_old_fw(nd) = gs_u_shaded_new_fw(nd)
      END DO
      cosi_o_sunlit_old = cosi_o_sunlit_new
      coss_o_sunlit_old = coss_o_sunlit_new
      gs_o_sunlit_old = gs_o_sunlit_new
      gw_o_sunlit = temp
!conductance of sunlit leaves of overstorey for CO2
      gc_o_sunlit = 1.0/(1.0/g_o_a+1.4/g_o_b+1.6/gs_o_sunlit_new)
      ci_o_shaded_old = ci_o_shaded_new
      cs_o_shaded_old = cs_o_shaded_new
      cosi_o_shaded_old = cosi_o_shaded_new
      coss_o_shaded_old = coss_o_shaded_new
      gs_o_shaded_old = gs_o_shaded_new
      temp = 1.0/(1.0/g_o_a+1.0/g_o_b+1.0/gs_o_shaded_new)
      DO nd=1,nbdirs
        gw_o_shaded_fw(nd) = -(temp*(-(g_o_a_fw(nd)/g_o_a**2)-g_o_b_fw(&
&         nd)/g_o_b**2-gs_o_shaded_new_fw(nd)/gs_o_shaded_new**2)/(1.0/&
&         g_o_a+1.0/g_o_b+1.0/gs_o_shaded_new))
      END DO
      gw_o_shaded = temp
      gc_o_shaded = 1.0/(1.0/g_o_a+1.4/g_o_b+1.6/gs_o_shaded_new)
      ci_u_sunlit_old = ci_o_sunlit_new
      cs_u_sunlit_old = cs_u_sunlit_new
      cosi_u_sunlit_old = cosi_o_sunlit_new
      coss_u_sunlit_old = coss_u_sunlit_new
      gs_u_sunlit_old = gs_o_sunlit_new
      temp = 1.0/(1.0/g_u_a+1.0/g_u_b+1.0/gs_u_sunlit_new)
      DO nd=1,nbdirs
        gw_u_sunlit_fw(nd) = -(temp*(-(g_u_a_fw(nd)/g_u_a**2)-g_u_b_fw(&
&         nd)/g_u_b**2-gs_u_sunlit_new_fw(nd)/gs_u_sunlit_new**2)/(1.0/&
&         g_u_a+1.0/g_u_b+1.0/gs_u_sunlit_new))
      END DO
      gw_u_sunlit = temp
      gc_u_sunlit = 1.0/(1.0/g_u_a+1.4/g_u_b+1.6/gs_u_sunlit_new)
      ci_u_shaded_old = ci_u_shaded_new
      cs_u_shaded_old = cs_u_shaded_new
      cosi_u_shaded_old = cosi_u_shaded_new
      coss_u_shaded_old = coss_u_shaded_new
      gs_u_shaded_old = gs_u_shaded_new
      temp = 1.0/(1.0/g_u_a+1.0/g_u_b+1.0/gs_u_shaded_new)
      DO nd=1,nbdirs
        gw_u_shaded_fw(nd) = -(temp*(-(g_u_a_fw(nd)/g_u_a**2)-g_u_b_fw(&
&         nd)/g_u_b**2-gs_u_shaded_new_fw(nd)/gs_u_shaded_new**2)/(1.0/&
&         g_u_a+1.0/g_u_b+1.0/gs_u_shaded_new))
      END DO
      gw_u_shaded = temp
      gc_u_shaded = 1.0/(1.0/g_u_a+1.4/g_u_b+1.6/gs_u_shaded_new)
! leaf tempratures module by L. He
      CALL LEAF_TEMPERATURES_FWV(temp_air, slope, psychrometer, vpd_air&
&                          , cp_ca, gw_o_sunlit, gw_o_sunlit_fw, &
&                          gw_o_shaded, gw_o_shaded_fw, gw_u_sunlit, &
&                          gw_u_sunlit_fw, gw_u_shaded, gw_u_shaded_fw, &
&                          gww_o_sunlit, gww_o_sunlit_fw, gww_o_shaded, &
&                          gww_o_shaded_fw, gww_u_sunlit, &
&                          gww_u_sunlit_fw, gww_u_shaded, &
&                          gww_u_shaded_fw, gh_o_sunlit, gh_o_sunlit_fw&
&                          , gh_o_shaded, gh_o_shaded_fw, gh_u_sunlit, &
&                          gh_u_sunlit_fw, gh_u_shaded, gh_u_shaded_fw, &
&                          xcs_o(kkk), xcs_o_fw(:, kkk), xcl_o(kkk), &
&                          xcl_o_fw(:, kkk), xcs_u(kkk), xcs_u_fw(:, kkk&
&                          ), xcl_u(kkk), xcl_u_fw(:, kkk), &
&                          radiation_o_sun, radiation_o_sun_fw, &
&                          radiation_o_shaded, radiation_o_shaded_fw, &
&                          radiation_u_sun, radiation_u_sun_fw, &
&                          radiation_u_shaded, radiation_u_shaded_fw, &
&                          tc_o_sunlit_new, tc_o_sunlit_new_fw, &
&                          tc_o_shaded_new, tc_o_shaded_new_fw, &
&                          tc_u_sunlit_new, tc_u_sunlit_new_fw, &
&                          tc_u_shaded_new, tc_u_shaded_new_fw, nbdirs)
      h_o_sunlit = (tc_o_sunlit_new-temp_air)*rho_a*cp_ca*gh_o_sunlit
      h_o_shaded = (tc_o_shaded_new-temp_air)*rho_a*cp_ca*gh_o_shaded
      DO nd=1,nbdirs
        h_o_sunlit_fw(nd) = rho_a*cp_ca*(gh_o_sunlit*tc_o_sunlit_new_fw(&
&         nd)+(tc_o_sunlit_new-temp_air)*gh_o_sunlit_fw(nd))
        h_o_shaded_fw(nd) = rho_a*cp_ca*(gh_o_shaded*tc_o_shaded_new_fw(&
&         nd)+(tc_o_shaded_new-temp_air)*gh_o_shaded_fw(nd))
!for next num aerodynamic conductance calculation
        gh_o_fw(nd) = lai_o_sunlit*h_o_sunlit_fw(nd) + h_o_sunlit*&
&         lai_o_sunlit_fw(nd) + lai_o_shaded*h_o_shaded_fw(nd) + &
&         h_o_shaded*lai_o_shaded_fw(nd)
      END DO
      gh_o = h_o_sunlit*lai_o_sunlit + h_o_shaded*lai_o_shaded
      IF (tc_o_sunlit_new - tc_o_sunlit_old .GE. 0.) THEN
        abs0 = tc_o_sunlit_new - tc_o_sunlit_old
      ELSE
        abs0 = -(tc_o_sunlit_new-tc_o_sunlit_old)
      END IF
      IF (tc_o_shaded_new - tc_o_shaded_old .GE. 0.) THEN
        abs1 = tc_o_shaded_new - tc_o_shaded_old
      ELSE
        abs1 = -(tc_o_shaded_new-tc_o_shaded_old)
      END IF
      IF (tc_u_sunlit_new - tc_u_sunlit_old .GE. 0.) THEN
        abs2 = tc_u_sunlit_new - tc_u_sunlit_old
      ELSE
        abs2 = -(tc_u_sunlit_new-tc_u_sunlit_old)
      END IF
      IF (tc_u_shaded_new - tc_u_shaded_old .GE. 0.) THEN
        abs3 = tc_u_shaded_new - tc_u_shaded_old
      ELSE
        abs3 = -(tc_u_shaded_new-tc_u_shaded_old)
      END IF
      IF (abs0 .LT. 0.02 .AND. abs1 .LT. 0.02 .AND. abs2 .LT. 0.02 .AND.&
&         abs3 .LT. 0.02) THEN
        GOTO 110
      ELSE IF (num .GT. 22) THEN
        GOTO 100
      ELSE
        DO nd=1,nbdirs
          tc_o_sunlit_old_fw(nd) = tc_o_sunlit_new_fw(nd)
          tc_o_shaded_old_fw(nd) = tc_o_shaded_new_fw(nd)
          tc_u_sunlit_old_fw(nd) = tc_u_sunlit_new_fw(nd)
          tc_u_shaded_old_fw(nd) = tc_u_shaded_new_fw(nd)
        END DO
        tc_o_sunlit_old = tc_o_sunlit_new
        tc_o_shaded_old = tc_o_shaded_new
        tc_u_sunlit_old = tc_u_sunlit_new
        tc_u_shaded_old = tc_u_shaded_new
      END IF
    END DO
    GOTO 110
!iteration does not converge.
 100 tc_o_sunlit_old = temp_air
    tc_o_shaded_old = temp_air
    tc_u_sunlit_old = temp_air
    tc_u_shaded_old = temp_air
    tc_o_sunlit_old_fw(:) = 0.0_8
    tc_u_sunlit_old_fw(:) = 0.0_8
    tc_o_shaded_old_fw(:) = 0.0_8
    tc_u_shaded_old_fw(:) = 0.0_8
! end do while
!    write(*,*) G_o_b,gs_h2o
 110 gpp_o_sunlit = ac_o_sunlit*laio_sunlit
    gpp_o_shaded = ac_o_shaded*laio_shaded
    gpp_u_sunlit = ac_u_sunlit*laiu_sunlit
    gpp_u_shaded = ac_u_shaded*laiu_shaded
!    stSIF_o_sunlit=lSIF_o_sunlit*0.5*clumping*(1.1-0.1*LAIo_sunlit)*exp(-CosZs)*LAIo_sunlit
!    stSIF_o_shaded=lSIF_o_shaded*0.5*clumping*(1.1-0.1*LAIo_shaded)*exp(-CosZs)*LAIo_shaded
!    stSIF_u_sunlit=lSIF_u_sunlit*0.5*clumping*(1.1-0.1*LAIu_sunlit)*exp(-CosZs)*LAIu_sunlit
!    stSIF_u_shaded=lSIF_u_shaded*0.5*clumping*(1.1-0.1*LAIu_shaded)*exp(-CosZs)*LAIu_shaded
!    SIF_o_sunlit=lSIF_o_sunlit*exp(-0.5*clumping*LAIo_sunlit/CosZs)*LAIo_sunlit+stSIF_o_sunlit
!    SIF_o_shaded=lSIF_o_shaded*exp(-0.5*clumping*LAIo_shaded/CosZs)*LAIo_shaded+stSIF_o_shaded
!    SIF_u_sunlit=lSIF_u_sunlit*exp(-0.5*clumping*LAIu_sunlit/CosZs)*LAIu_sunlit+stSIF_u_sunlit
!    SIF_u_shaded=lSIF_u_shaded*exp(-0.5*clumping*LAIu_shaded/CosZs)*LAIu_shaded+stSIF_u_shaded
    temp = EXP(-coszs)
    stsif_o_sunlit = temp*(clumping*0.3*(lsif_o_sunlit*(1.1-0.1*&
&     laio_sunlit)))
!Transpiration module by X. Luo
    CALL TRANSPIRATION_FWV(tc_o_sunlit_new, tc_o_sunlit_new_fw, &
&                    tc_o_shaded_new, tc_o_shaded_new_fw, &
&                    tc_u_sunlit_new, tc_u_sunlit_new_fw, &
&                    tc_u_shaded_new, tc_u_shaded_new_fw, temp_air, &
&                    rh_air, gw_o_sunlit, gw_o_sunlit_fw, gw_o_shaded, &
&                    gw_o_shaded_fw, gw_u_sunlit, gw_u_sunlit_fw, &
&                    gw_u_shaded, gw_u_shaded_fw, lai_o_sunlit, &
&                    lai_o_sunlit_fw, lai_o_shaded, lai_o_shaded_fw, &
&                    lai_u_sunlit, lai_u_sunlit_fw, lai_u_shaded, &
&                    lai_u_shaded_fw, trans_o(kkk), trans_o_fw(:, kkk), &
&                    trans_u(kkk), trans_u_fw(:, kkk), nbdirs)
! Evaporation and sublimation from canopy by X. Luo
    CALL EVAPORATION_CANOPY_FWV(tc_o_sunlit_new, tc_o_sunlit_new_fw, &
&                         tc_o_shaded_new, tc_o_shaded_new_fw, &
&                         tc_u_sunlit_new, tc_u_sunlit_new_fw, &
&                         tc_u_shaded_new, tc_u_shaded_new_fw, temp_air&
&                         , rh_air, gww_o_sunlit, gww_o_sunlit_fw, &
&                         gww_o_shaded, gww_o_shaded_fw, gww_u_sunlit, &
&                         gww_u_sunlit_fw, gww_u_shaded, gww_u_shaded_fw&
&                         , lai_o_sunlit, lai_o_sunlit_fw, lai_o_shaded&
&                         , lai_o_shaded_fw, lai_u_sunlit, &
&                         lai_u_sunlit_fw, lai_u_shaded, lai_u_shaded_fw&
&                         , xcl_o(kkk), xcl_o_fw(:, kkk), xcl_u(kkk), &
&                         xcl_u_fw(:, kkk), xcs_o(kkk), xcs_o_fw(:, kkk)&
&                         , xcs_u(kkk), xcs_u_fw(:, kkk), eil_o(kkk), &
&                         eil_o_fw(:, kkk), eil_u(kkk), eil_u_fw(:, kkk)&
&                         , eis_o(kkk), eis_o_fw(:, kkk), eis_u(kkk), &
&                         eis_u_fw(:, kkk), nbdirs)
! Rainfall stage 2 by X. Luo
    CALL RAINFALL_STAGE2_FWV(eil_o(kkk), eil_o_fw(:, kkk), eil_u(kkk), &
&                      eil_u_fw(:, kkk), wcl_o(kkk), wcl_o_fw(:, kkk), &
&                      wcl_u(kkk), wcl_u_fw(:, kkk), nbdirs)
! Snow pack stage2
    CALL SNOWPACK_STAGE2_FWV(eis_o(kkk), eis_o_fw(:, kkk), eis_u(kkk), &
&                      eis_u_fw(:, kkk), wcs_o(kkk), wcs_o_fw(:, kkk), &
&                      wcs_u(kkk), wcs_u_fw(:, kkk), nbdirs)
    DO nd=1,nbdirs
      cos_o_sunlit_fw(nd) = laio_sunlit*lcos_o_sunlit_fw(nd) + &
&       lcos_o_sunlit*laio_sunlit_fw(nd)
      cos_o_shaded_fw(nd) = laio_shaded*lcos_o_shaded_fw(nd) + &
&       lcos_o_shaded*laio_shaded_fw(nd)
      cos_u_sunlit_fw(nd) = laiu_sunlit*lcos_u_sunlit_fw(nd) + &
&       lcos_u_sunlit*laiu_sunlit_fw(nd)
      cos_u_shaded_fw(nd) = laiu_shaded*lcos_u_shaded_fw(nd) + &
&       lcos_u_shaded*laiu_shaded_fw(nd)
      stsif_o_sunlit_fw(nd) = temp*clumping*0.3*((1.1-0.1*laio_sunlit)*&
&       lsif_o_sunlit_fw(nd)-lsif_o_sunlit*0.1*laio_sunlit_fw(nd))
!    stSIF_o_sunlit = 0.0   !!@JWang  for scattering correction,@MOUSONG,make sure this is correct???
!    stSIF_o_shaded = 0.0
!    stSIF_u_sunlit = 0.0
!    stSIF_u_shaded = 0.0
      sif_o_sunlit_fw(nd) = 0.1*(laio_sunlit*(lsif_o_sunlit_fw(nd)+&
&       stsif_o_sunlit_fw(nd))+(lsif_o_sunlit+stsif_o_sunlit)*&
&       laio_sunlit_fw(nd))
! Evaporation from soil module
      gheat_g_fw(nd) = -(ra_g_fw(nd)/ra_g**2)
      mass_water_g_fw(nd) = rho_w*zp_fw(nd)
! to be checked later:  why set these 4 to 0
      eil_o_fw(nd, kkk) = 0.0_8
      eis_o_fw(nd, kkk) = 0.0_8
      eil_u_fw(nd, kkk) = 0.0_8
      eis_u_fw(nd, kkk) = 0.0_8
      tc_u_fw(nd, kkk) = tcu_fw(nd)
    END DO
    cos_o_sunlit = lcos_o_sunlit*laio_sunlit
    cos_o_shaded = lcos_o_shaded*laio_shaded
    cos_u_sunlit = lcos_u_sunlit*laiu_sunlit
    cos_u_shaded = lcos_u_shaded*laiu_shaded
    temp = EXP(-coszs)
    stsif_o_shaded = temp*(clumping*0.3*(lsif_o_shaded*(1.1-0.1*&
&     laio_shaded)))
    gheat_g = 1./ra_g
    mass_water_g = rho_w*zp
    CALL SOIL_EVAPORATION_FWV(temp_grd, ts0(kkk-1), ts0_fw(:, kkk-1), &
&                       rh_air, radiation_g, radiation_g_fw, gheat_g, &
&                       gheat_g_fw, xg_snow(kkk), xg_snow_fw(:, kkk), zp&
&                       , zp_fw, zsp, mass_water_g, mass_water_g_fw, &
&                       wg_snow(kkk), wg_snow_fw(:, kkk), rho_snow(kkk)&
&                       , rho_snow_fw(:, kkk), soilp%thetam_prev(0), &
&                       soilp_fw%thetam_prev(:, 0), soilp%fei(0), &
&                       evap_soil(kkk), evap_soil_fw(:, kkk), evap_sw(&
&                       kkk), evap_sw_fw(:, kkk), evap_ss(kkk), &
&                       evap_ss_fw(:, kkk), nbdirs)
! soil Thermal Conductivity module by L. He
    CALL UPDATESOILTHERMALCONDUCTIVITY_FWV(soilp, soilp_fw, nbdirs)
    CALL UPDATE_CS_FWV(soilp, soilp_fw, nbdirs)
    DO nd=1,nbdirs
      stsif_o_shaded_fw(nd) = temp*clumping*0.3*((1.1-0.1*laio_shaded)*&
&       lsif_o_shaded_fw(nd)-lsif_o_shaded*0.1*laio_shaded_fw(nd))
      sif_o_shaded_fw(nd) = 0.1*(laio_shaded*(lsif_o_shaded_fw(nd)+&
&       stsif_o_shaded_fw(nd))+(lsif_o_shaded+stsif_o_shaded)*&
&       laio_shaded_fw(nd))
! update surface ponding after ponding evaporation calculation
      zp_fw(nd) = mass_water_g_fw(nd)/rho_w
! Surface temperature
      cs_fw(nd, 0, kkk) = soilp_fw%cs(nd, 0)
      cs_fw(nd, 1, kkk) = soilp_fw%cs(nd, 0)
      lambda_soil_fw(nd, 1) = soilp_fw%lambda(nd, 0)
      tm_fw(nd, 1, kkk-1) = soilp_fw%temp_soil_p(nd, 1)
      tm_fw(nd, 0, kkk-1) = soilp_fw%temp_soil_p(nd, 0)
      g_fw(nd, 1, kkk) = soilp_fw%g(nd, 0)
    END DO
    temp = EXP(-coszs)
    stsif_u_sunlit = temp*(clumping*0.3*(lsif_u_sunlit*(1.1-0.1*&
&     laiu_sunlit)))
    DO nd=1,nbdirs
      stsif_u_sunlit_fw(nd) = temp*clumping*0.3*((1.1-0.1*laiu_sunlit)*&
&       lsif_u_sunlit_fw(nd)-lsif_u_sunlit*0.1*laiu_sunlit_fw(nd))
      sif_u_sunlit_fw(nd) = 0.1*(laiu_sunlit*(lsif_u_sunlit_fw(nd)+&
&       stsif_u_sunlit_fw(nd))+(lsif_u_sunlit+stsif_u_sunlit)*&
&       laiu_sunlit_fw(nd))
    END DO
    temp = EXP(-coszs)
    stsif_u_shaded = temp*(clumping*0.3*(lsif_u_shaded*(1.1-0.1*&
&     laiu_shaded)))
    DO nd=1,nbdirs
      stsif_u_shaded_fw(nd) = temp*clumping*0.3*((1.1-0.1*laiu_shaded)*&
&       lsif_u_shaded_fw(nd)-lsif_u_shaded*0.1*laiu_shaded_fw(nd))
      sif_u_shaded_fw(nd) = 0.1*(laiu_shaded*(lsif_u_shaded_fw(nd)+&
&       stsif_u_shaded_fw(nd))+(lsif_u_shaded+stsif_u_shaded)*&
&       laiu_shaded_fw(nd))
    END DO
    sif_o_sunlit = (lsif_o_sunlit+stsif_o_sunlit)*laio_sunlit*0.1
    sif_o_shaded = (lsif_o_shaded+stsif_o_shaded)*laio_shaded*0.1
    sif_u_sunlit = (lsif_u_sunlit+stsif_u_sunlit)*laiu_sunlit*0.1
    sif_u_shaded = (lsif_u_shaded+stsif_u_shaded)*laiu_shaded*0.1
    zp = mass_water_g/rho_w
! update snow depth as well after snow evaporation calculation
    temp = wg_snow(kkk)/rho_snow(kkk)
    DO nd=1,nbdirs
      zsp_fw(nd) = (wg_snow_fw(nd, kkk)-temp*rho_snow_fw(nd, kkk))/&
&       rho_snow(kkk)
    END DO
    zsp = temp
    eil_o(kkk) = 0.
    eis_o(kkk) = 0.
    eil_u(kkk) = 0.
    eis_u(kkk) = 0.
    cs(0, kkk) = soilp%cs(0)
    cs(1, kkk) = soilp%cs(0)
    tc_u(kkk) = tcu
    lambda_soil(1) = soilp%lambda(0)
    d_soil(1) = soilp%d_soil(0)
    tm(1, kkk-1) = soilp%temp_soil_p(1)
    tm(0, kkk-1) = soilp%temp_soil_p(0)
    g(1, kkk) = soilp%g(0)
    CALL SURFACETEMPERATURE_FWV(temp_air, rh_air, zsp, zsp_fw, zp, cs(1&
&                         , kkk), cs_fw(:, 1, kkk), cs(0, kkk), cs_fw(:&
&                         , 0, kkk), gheat_g, gheat_g_fw, d_soil(1), &
&                         rho_snow(kkk), rho_snow_fw(:, kkk), tc_u(kkk)&
&                         , tc_u_fw(:, kkk), radiation_g, radiation_g_fw&
&                         , evap_soil(kkk), evap_soil_fw(:, kkk), &
&                         evap_sw(kkk), evap_sw_fw(:, kkk), evap_ss(kkk)&
&                         , evap_ss_fw(:, kkk), lambda_soil(1), &
&                         lambda_soil_fw(:, 1), xg_snow(kkk), xg_snow_fw&
&                         (:, kkk), g(1, kkk), g_fw(:, 1, kkk), ts0(kkk-&
&                         1), ts0_fw(:, kkk-1), tm(1, kkk-1), tm_fw(:, 1&
&                         , kkk-1), tm(0, kkk-1), tm_fw(:, 0, kkk-1), &
&                         tsn0(kkk-1), tsn0_fw(:, kkk-1), tsm0(kkk-1), &
&                         tsm0_fw(:, kkk-1), tsn1(kkk-1), tsn1_fw(:, kkk&
&                         -1), tsn2(kkk-1), tsn2_fw(:, kkk-1), ts0(kkk)&
&                         , ts0_fw(:, kkk), tm(0, kkk), tm_fw(:, 0, kkk)&
&                         , tsn0(kkk), tsn0_fw(:, kkk), tsm0(kkk), &
&                         tsm0_fw(:, kkk), tsn1(kkk), tsn1_fw(:, kkk), &
&                         tsn2(kkk), tsn2_fw(:, kkk), g(0, kkk), g_fw(:&
&                         , 0, kkk), nbdirs)
    soilp%temp_soil_c(0) = tm(0, kkk)
! Snow pack stage3 module
    CALL SNOWPACK_STAGE3_FWV(temp_air, tsn0(kkk), tsn0_fw(:, kkk), tsn0(&
&                      kkk-1), rho_snow(kkk), rho_snow_fw(:, kkk), zsp, &
&                      zsp_fw, zp, zp_fw, wg_snow(kkk), wg_snow_fw(:, &
&                      kkk), nbdirs)
    DO nd=1,nbdirs
      soilp_fw%temp_soil_c(nd, 0) = tm_fw(nd, 0, kkk)
! soil water module
      soilp_fw%zsp(nd) = zsp_fw(nd)
      soilp_fw%g(nd, 0) = g_fw(nd, 0, kkk)
    END DO
    CALL SENSIBLEHEAT_FWV(tc_o_sunlit_new, tc_o_sunlit_new_fw, &
&                   tc_o_shaded_new, tc_o_shaded_new_fw, tc_u_sunlit_new&
&                   , tc_u_shaded_new, ts0(kkk), temp_air, rh_air, &
&                   gh_o_sunlit, gh_o_sunlit_fw, gh_o_shaded, &
&                   gh_o_shaded_fw, gh_u_sunlit, gh_u_shaded, gheat_g, &
&                   lai_o_sunlit, lai_o_sunlit_fw, lai_o_shaded, &
&                   lai_o_shaded_fw, lai_u_sunlit, lai_u_shaded, qhc_o(&
&                   kkk), qhc_o_fw(:, kkk), qhc_u(kkk), qhg(kkk), nbdirs&
&                  )
    soilp%zsp = zsp
    soilp%g(0) = g(0, kkk)
    CALL UPDATEHEATFLUX_FWV(soilp, soilp_fw, xg_snow(kkk), lambda_snow(&
&                     kkk), tsn0(kkk), temp_air, kstep, nbdirs)
    CALL SOIL_WATER_UPTAKE_FWV(soilp, soilp_fw, trans_o(kkk), trans_o_fw&
&                        (:, kkk), trans_u(kkk), trans_u_fw(:, kkk), &
&                        evap_soil(kkk), evap_soil_fw(:, kkk), nbdirs)
    DO nd=1,nbdirs
      soilp_fw%r_rain_g(nd) = r_rain_g_fw(nd, kkk)
    END DO
    soilp%r_rain_g = r_rain_g(kkk)
    DO nd=1,nbdirs
      soilp_fw%zp(nd) = zp_fw(nd)
    END DO
    soilp%zp = zp
    CALL UPDATESOILMOISTURE_FWV(soilp, soilp_fw, nbdirs)
    DO nd=1,nbdirs
      zp_fw(nd) = soilp_fw%zp(nd)
    END DO
    zp = soilp%zp
  END DO
!END kkk iteration
!    write(*,*) G_o_b,gs_h2o
  kkk = kloop
!True? or Tsn1 @J.Wang
  IF (tsn1(kkk) .GT. 40.) THEN
    DO nd=1,nbdirs
      tsn2_fw(nd, kkk) = 0.0_8
    END DO
    tsn2(kkk) = 40.
  END IF
  IF (tsn1(kkk) .LT. -40.) THEN
    DO nd=1,nbdirs
      tsn2_fw(nd, kkk) = 0.0_8
    END DO
    tsn2(kkk) = -40.
  END IF
  IF (tsn2(kkk) .GT. 40.) THEN
    DO nd=1,nbdirs
      tsn2_fw(nd, kkk) = 0.0_8
    END DO
    tsn2(kkk) = 40.
  END IF
  IF (tsn2(kkk) .LT. -40.) THEN
    DO nd=1,nbdirs
      tsn2_fw(nd, kkk) = 0.0_8
    END DO
    tsn2(kkk) = -40.
  END IF
  DO nd=1,nbdirs
! SH
    var_n_fw(nd, 1) = qhc_o_fw(nd, kkk)
! The temperature of ground surface
    var_n_fw(nd, 3) = ts0_fw(nd, kkk)
!The temperature of ground surface
    var_n_fw(nd, 4) = tsn0_fw(nd, kkk)
    var_n_fw(nd, 5) = tsm0_fw(nd, kkk)
    var_n_fw(nd, 6) = tsn1_fw(nd, kkk)
    var_n_fw(nd, 7) = tsn2_fw(nd, kkk)
  END DO
  var_n(1) = qhc_o(kkk)
  var_n(3) = ts0(kkk)
  var_n(4) = tsn0(kkk)
  var_n(5) = tsm0(kkk)
  var_n(6) = tsn1(kkk)
  var_n(7) = tsn2(kkk)
  DO i=9,14
    DO nd=1,nbdirs
      var_n_fw(nd, i) = soilp_fw%temp_soil_c(nd, i-9)
    END DO
    var_n(i) = soilp%temp_soil_c(i-9)
  END DO
  DO i=21,26
    DO nd=1,nbdirs
      var_n_fw(nd, i) = soilp_fw%thetam(nd, i-21)
    END DO
    var_n(i) = soilp%thetam(i-21)
  END DO
  DO i=27,32
    DO nd=1,nbdirs
      var_n_fw(nd, i) = soilp_fw%ice_ratio(nd, i-27)
    END DO
    var_n(i) = soilp%ice_ratio(i-27)
  END DO
!laten heat of water vaporization in j/kg
  lv_liquid = (2.501-0.00237*temp_air)*1000000.
!for output
  mid_res%net_rad = radiation_o + radiation_u + radiation_g
  mid_res%lh = lv_liquid*(trans_o(kkk)+eil_o(kkk)+trans_u(kkk)+eil_u(kkk&
&   )+evap_soil(kkk)+evap_sw(kkk)) + lv_solid*(eis_o(kkk)+eis_u(kkk)+&
&   evap_ss(kkk))
  mid_res%sh = qhc_o(kkk) + qhc_u(kkk) + qhg(kkk)
  DO nd=1,nbdirs
    var_n_fw(nd, 15) = wcl_o_fw(nd, kkk)
!the mass of intercepted liquid water and snow, overstory
    var_n_fw(nd, 16) = wcs_o_fw(nd, kkk)
    var_n_fw(nd, 18) = wcl_u_fw(nd, kkk)
    var_n_fw(nd, 19) = wcs_u_fw(nd, kkk)
! fraction of ground surface covered by snow and snow mass
    var_n_fw(nd, 20) = wg_snow_fw(nd, kkk)
    var_n_fw(nd, 33) = soilp_fw%zsp(nd)
    var_n_fw(nd, 34) = soilp_fw%zp(nd)
    var_n_fw(nd, 35) = soilp_fw%r_rain_g(nd)
    var_n_fw(nd, 36) = ac_snow_o_fw(nd, kkk)
    var_n_fw(nd, 37) = ac_snow_u_fw(nd, kkk)
    var_n_fw(nd, 38) = rho_snow_fw(nd, kkk)
    var_n_fw(nd, 39) = alpha_v_sw_fw(nd, kkk)
    var_n_fw(nd, 40) = alpha_n_sw_fw(nd, kkk)
    mid_res_fw%trans(nd) = (trans_o_fw(nd, kkk)+trans_u_fw(nd, kkk))/&
&     rho_w
  END DO
  var_n(15) = wcl_o(kkk)
  var_n(16) = wcs_o(kkk)
  var_n(18) = wcl_u(kkk)
  var_n(19) = wcs_u(kkk)
  var_n(20) = wg_snow(kkk)
  var_n(33) = soilp%zsp
  var_n(34) = soilp%zp
  var_n(35) = soilp%r_rain_g
  var_n(36) = ac_snow_o(kkk)
  var_n(37) = ac_snow_u(kkk)
  var_n(38) = rho_snow(kkk)
  var_n(39) = alpha_v_sw(kkk)
  var_n(40) = alpha_n_sw(kkk)
  mid_res%trans = (trans_o(kkk)+trans_u(kkk))/rho_w
  mid_res%evap = (eil_o(kkk)+eil_u(kkk)+evap_soil(kkk)+evap_sw(kkk))/&
&   rho_w + (eis_o(kkk)+eis_u(kkk)+evap_ss(kkk))/rho_snow(kkk)
!J.Wang kg/m2/s// umol C/m2/s
  mid_res%gpp_o_sunlit = gpp_o_sunlit*12.*1.e-6*1.e-3
  mid_res%gpp_u_sunlit = gpp_u_sunlit*12.*1.e-6*1.e-3
  mid_res%gpp_o_shaded = gpp_o_shaded*12.*1.e-6*1.e-3
  mid_res%gpp_u_shaded = gpp_u_shaded*12.*1.e-6*1.e-3
  mid_res%gpp = mid_res%gpp_o_sunlit + mid_res%gpp_u_sunlit + mid_res%&
&   gpp_o_shaded + mid_res%gpp_u_shaded
  DO nd=1,nbdirs
    mid_res_fw%sif(nd) = sif_o_sunlit_fw(nd) + sif_o_shaded_fw(nd) + &
&     sif_u_sunlit_fw(nd) + sif_u_shaded_fw(nd)
  END DO
  mid_res%sif = sif_o_sunlit + sif_o_shaded + sif_u_sunlit + &
&   sif_u_shaded
  DO nd=1,nbdirs
    mid_res_fw%thetam_surf(nd) = soilp_fw%thetam(nd, 0)
  END DO
  mid_res%thetam_surf = soilp%thetam(0)
! pmol/m2/s
  DO nd=1,nbdirs
    mid_res_fw%cos_plant(nd) = cos_o_sunlit_fw(nd) + cos_o_shaded_fw(nd)&
&     + cos_u_sunlit_fw(nd) + cos_u_shaded_fw(nd)
  END DO
  mid_res%cos_plant = cos_o_sunlit + cos_o_shaded + cos_u_sunlit + &
&   cos_u_shaded
!    write(*,*) "thetam_surf = ", mid_res%thetam_surf
  IF (lai_input .LT. 0) THEN
    temp_day = temp_day + meteo%temp
    theta_day = theta_day + (soilp%theta_vfc(0)-soilp%theta_vwp(0))
    DO nd=1,nbdirs
      trans_day_fw(nd) = mid_res_fw%trans(nd)
    END DO
    trans_day = trans_day + mid_res%trans
    IF (is_end_curr_day) THEN
      temp_day = temp_day/24.
      theta_day = theta_day/24.
      DO nd=1,nbdirs
        trans_day_fw(nd) = trans_day_fw(nd)/24.
      END DO
      trans_day = trans_day/24.
! use the method in BETHY to calculate phenology, with a little modification, @Mousong.Wu,201905
      CALL BEPS_PHENOLOGY_FWV(lc, daylen, temp_day, theta_day, trans_day&
&                       , trans_day_fw, mid_res%lai_old, mid_res_fw%&
&                       lai_old, nbdirs)
      temp_day = 0.
      theta_day = 0.
      trans_day = 0.
      DO nd=1,nbdirs
        mid_res_fw%lai_new(nd) = mid_res_fw%lai_old(nd)
      END DO
      mid_res%lai_new = mid_res%lai_old
    ELSE
      DO nd=1,nbdirs
        mid_res_fw%lai_new(nd) = mid_res_fw%lai_old(nd)
      END DO
      mid_res%lai_new = mid_res%lai_old
    END IF
    lai = mid_res%lai_new
!mid_res%fAPAR = 1. - exp(-0.45*lai)    ! calculate fAPAR using the Lambert-Beer law, Benjamin Smith et al., 2008, &
! & Forest Ecology and Management, @Mousong.Wu, 201905
!          write(*,*) 'lai = ', mid_res%lai_old
!          write(*,*) 'fAPAR = ', mid_res%fAPAR
  END IF
!lai = mid_res%lai_new 
! calculate fAPAR using the Lambert-Beer law, Benjamin Smith et al., 2008, &
  mid_res%fapar = 1. - EXP(-(0.45*lai))
! & Forest Ecology and Management, @Mousong.Wu, 201905
  CALL COS_GRND_FWV(soilp, soilp_fw, cos_soil, cos_soil_fw, nbdirs)
! pmol/m2/s
  DO nd=1,nbdirs
    mid_res_fw%cos_grnd(nd) = cos_soil_fw(nd)
  END DO
  mid_res%cos_grnd = cos_soil
  RETURN
END SUBROUTINE INTER_PRG_FWV

!  Differentiation of aerodynamic_conductance in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: g_o_a g_o_b ra_g g_u_a g_u_b
!   with respect to varying inputs: sh_o_p lai_o
!! calculate aerodynamic resistance/conductance
!! Written by: J. Liu, and W. Ju, Modified by G. MO
!! Last update : May 2015
SUBROUTINE AERODYNAMIC_CONDUCTANCE_FWV(canopy_height_o, canopy_height_u&
& , zz, clumping, temp_air, wind_sp, sh_o_p, sh_o_p_fw, lai_o, lai_o_fw&
& , lai_u, rm, ra_u, ra_g, ra_g_fw, g_o_a, g_o_a_fw, g_o_b, g_o_b_fw, &
& g_u_a, g_u_a_fw, g_u_b, g_u_b_fw, nbdirs)
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
  REAL(r8), INTENT(IN) :: canopy_height_o, canopy_height_u, zz, clumping&
& , temp_air, wind_sp
  REAL(r8), INTENT(IN) :: sh_o_p, lai_o, lai_u
  REAL(r8), DIMENSION(nbdirsmax), INTENT(IN) :: sh_o_p_fw, lai_o_fw
  REAL(r8), INTENT(OUT) :: rm, ra_u, ra_g, g_o_a, g_o_b, g_u_a, g_u_b
  REAL(r8), DIMENSION(nbdirsmax), INTENT(OUT) :: ra_g_fw, g_o_a_fw, &
& g_o_b_fw, g_u_a_fw, g_u_b_fw
  REAL(r8) :: kh_o
  REAL(r8), DIMENSION(nbdirsmax) :: kh_o_fw
!leaf characteristic width  = 0.3 for BS
  REAL(r8), SAVE :: lw=0.3
!shelter factor = 5 for BS
  REAL(r8), SAVE :: sigma=5
  REAL(r8) :: rb_o, rb_u
  REAL(r8), DIMENSION(nbdirsmax) :: rb_o_fw, rb_u_fw
! von Karman's constant
  REAL(r8), SAVE :: k=0.4
! Bowen's ratio
  REAL(r8), SAVE :: beta=0.5
!specific heat of air  J/kg/K
  REAL(r8), SAVE :: cp=1010
  REAL(r8), SAVE :: density_air=1.225
  REAL(r8), SAVE :: gg=9.8
  REAL(r8), SAVE :: n=5.0
! viscosity (cm2/s)
  REAL(r8) :: nu_lower
  REAL(r8) :: uf, psi
  REAL(r8), DIMENSION(nbdirsmax) :: psi_fw
!displacement height (m)
  REAL(r8) :: d
!roughness length    (m)
  REAL(r8) :: z0
!friction velocity (m/s)
  REAL(r8) :: ustar
  REAL(r8) :: l, le
  REAL(r8), DIMENSION(nbdirsmax) :: l_fw, le_fw
!wind speed at height h
  REAL(r8) :: uh
!wind speed at height d
  REAL(r8) :: ud
  REAL(r8), DIMENSION(nbdirsmax) :: ud_fw
! wind speed at height 50 m, @mousong.wu, to correct the calculation of ustar 
  REAL(r8) :: u_50
! from 2 m wind speed but the canopy height is around 30 m,which leads to negative value in log function.
  REAL(r8) :: gamma1, re, nu, alfac, alfaw, ram, un_d, un_t, kh_u, z_50
  REAL(r8), DIMENSION(nbdirsmax) :: gamma1_fw, re_fw, nu_fw, ram_fw, &
& un_d_fw
  INTRINSIC LOG
  INTRINSIC MAX
  INTRINSIC MIN
  INTRINSIC EXP
  REAL(r8) :: arg1
  REAL(r8), DIMENSION(nbdirsmax) :: arg1_fw
  REAL(r8) :: arg2
  REAL(r8), DIMENSION(nbdirsmax) :: ra_u_fw
  INTEGER :: nd
  REAL(r8) :: temp
  REAL(r8), DIMENSION(nbdirsmax) :: temp_fw
  REAL(r8) :: temp0
  INTEGER :: nbdirs
  nu_lower = (13.3+temp_air*0.07)/1000000.
! for CO2
  alfac = 0.15
  alfaw = (18.9+temp_air*0.07)/1000000.
! for calculation of windspeed at 50 m height
  z_50 = 50.
  IF (wind_sp .EQ. 0.) THEN
    uh = 0.
    uf = 0.
    psi = 6.
    g_o_a = 1./200.0
    g_o_b = 1./200.0
    g_u_a = 1./200.0
    g_u_b = 1./200.0
    ra_g = 300.
    g_o_a_fw(:) = 0.0_8
    g_o_b_fw(:) = 0.0_8
    ra_g_fw(:) = 0.0_8
    g_u_a_fw(:) = 0.0_8
    g_u_b_fw(:) = 0.0_8
  ELSE
    d = 0.8*canopy_height_o
    z0 = 0.08*canopy_height_o
    arg1 = (z_50-zz)/z0
    u_50 = wind_sp*LOG(arg1)
    arg1 = (z_50-d)/z0
    ustar = u_50*k/LOG(arg1)
    temp = density_air*cp*(temp_air+273.3)*(ustar*ustar*ustar)
    DO nd=1,nbdirs
      l_fw(nd) = -(k*gg*sh_o_p_fw(nd)/temp)
    END DO
    l = -(k*gg*(sh_o_p/temp))
    IF (-2. .LT. l) THEN
      l = l
    ELSE
      l = -2.
      l_fw(:) = 0.0_8
    END IF
    arg1 = (z_50-d)/z0
    DO nd=1,nbdirs
      ram_fw(nd) = (z_50-d)*n*l_fw(nd)/(k*ustar)
    END DO
    ram = 1./(k*ustar)*(LOG(arg1)+n*(z_50-d)*l)
    IF (2. .LT. ram) THEN
      ram = ram
    ELSE
      ram = 2.
      ram_fw(:) = 0.0_8
    END IF
    IF (100. .GT. ram) THEN
      ram = ram
    ELSE
      ram = 100.
      ram_fw(:) = 0.0_8
    END IF
    IF (l .GT. 0.) THEN
      DO nd=1,nbdirs
        psi_fw(nd) = (z_50-d)*5.*l_fw(nd)
      END DO
      psi = 1. + 5.*(z_50-d)*l
    ELSE
      temp = -(16.*(z_50-d)*l) + 1.
      DO nd=1,nbdirs
        psi_fw(nd) = 0.5*temp**(-1.5)*(z_50-d)*16.*l_fw(nd)
      END DO
      psi = temp**(-0.5)
    END IF
    IF (10.0 .GT. psi) THEN
      psi = psi
    ELSE
      psi = 10.0
      psi_fw(:) = 0.0_8
    END IF
!! Leaf boundary layer resistance
!! wind speed at tree top
    uh = 1.1*ustar/k
    le = lai_o*clumping
    gamma1 = (0.167+0.179*uh)*le**(1./3.)
!! wind speed at d ,taking as the mean wind speed inside a stand
    temp = -(d/canopy_height_o) + 1.
    arg1 = -(temp*gamma1)
    ud = uh*EXP(arg1)
    re = ud*0.1/nu_lower
    DO nd=1,nbdirs
      le_fw(nd) = clumping*lai_o_fw(nd)
      IF (le .LE. 0.0_8 .AND. (1.0/3. .EQ. 0.0_8 .OR. 1.0/3. .NE. INT(&
&         1.0/3.))) THEN
        temp_fw(nd) = 0.0_8
      ELSE
        temp_fw(nd) = le**(1.0/3.-1)*le_fw(nd)/3.
      END IF
      gamma1_fw(nd) = (uh*0.179+0.167)*temp_fw(nd)
      arg1_fw(nd) = -(temp*gamma1_fw(nd))
      ud_fw(nd) = uh*EXP(arg1)*arg1_fw(nd)
!! Reynold's number
      re_fw(nd) = 0.1*ud_fw(nd)/nu_lower
!!Nusselt number
      nu_fw(nd) = 0.5*re**(-0.5)*re_fw(nd)
    END DO
    nu = 1.0*re**0.5
    IF (40. .GT. 0.5*0.1/(alfaw*nu)) THEN
      temp = 0.1*0.5/(alfaw*nu)
      DO nd=1,nbdirs
        rb_o_fw(nd) = -(temp*nu_fw(nd)/nu)
      END DO
      rb_o = temp
    ELSE
      rb_o = 40.
      rb_o_fw(:) = 0.0_8
    END IF
    uf = ustar
    rm = ram
    temp = 0.41*ustar/psi
    DO nd=1,nbdirs
      g_o_a_fw(nd) = -(ram_fw(nd)/ram**2)
      g_o_b_fw(nd) = -(rb_o_fw(nd)/rb_o**2)
      kh_o_fw(nd) = -((canopy_height_o-canopy_height_o*0.8)*temp*psi_fw(&
&       nd)/psi)
      gamma1_fw(nd) = 0.75*lai_o**(-0.25)*lai_o_fw(nd)
    END DO
    g_o_a = 1./ram
    g_o_b = 1./rb_o
    kh_o = temp*(canopy_height_o-canopy_height_o*0.8)
    gamma1 = 0.1 + lai_o**0.75
!!wind speed at the zero displancement of canopy
    temp = -(0.8*canopy_height_u/canopy_height_o) + 1.
    arg1 = -(temp*gamma1)
    un_d = uh*EXP(arg1)
    re = un_d*0.1/nu_lower
    DO nd=1,nbdirs
      arg1_fw(nd) = -(temp*gamma1_fw(nd))
      un_d_fw(nd) = uh*EXP(arg1)*arg1_fw(nd)
      re_fw(nd) = 0.1*un_d_fw(nd)/nu_lower
      nu_fw(nd) = 0.5*re**(-0.5)*re_fw(nd)
    END DO
    arg1 = -(gamma1*(1.-canopy_height_u/canopy_height_o))
    un_t = uh*EXP(arg1)
    nu = 1.0*re**0.5
    temp = 0.1*0.5/(alfaw*nu)
    DO nd=1,nbdirs
      rb_u_fw(nd) = -(temp*nu_fw(nd)/nu)
    END DO
    rb_u = temp
    IF (40. .GT. rb_u) THEN
      rb_u = rb_u
    ELSE
      rb_u = 40.
      rb_u_fw(:) = 0.0_8
    END IF
    temp = -(canopy_height_u/canopy_height_o) + 1.
    DO nd=1,nbdirs
      g_u_b_fw(nd) = -(rb_u_fw(nd)/rb_u**2)
      arg1_fw(nd) = temp*gamma1_fw(nd)
    END DO
    g_u_b = 1./rb_u
    arg1 = temp*gamma1
    temp = (EXP(arg1)-1.)/(gamma1*kh_o)
    DO nd=1,nbdirs
      ra_u_fw(nd) = canopy_height_o*(EXP(arg1)*arg1_fw(nd)-temp*(kh_o*&
&       gamma1_fw(nd)+gamma1*kh_o_fw(nd)))/(gamma1*kh_o)
    END DO
    ra_u = canopy_height_o*temp
    temp = 1.0/(ram+ra_u)
    DO nd=1,nbdirs
      g_u_a_fw(nd) = -(temp*(ram_fw(nd)+ra_u_fw(nd))/(ram+ra_u))
    END DO
    g_u_a = temp
    gamma1 = 4.0
    arg1 = -(gamma1*(1.-canopy_height_u/canopy_height_o))
    kh_u = kh_o*EXP(arg1)
    arg1 = gamma1*(1.-canopy_height_o)
    arg2 = gamma1*(1.-canopy_height_u/canopy_height_o)
    temp = EXP(arg1) - EXP(arg2)
    temp0 = canopy_height_o/(gamma1*kh_o)
    DO nd=1,nbdirs
      ra_g_fw(nd) = -(temp*temp0*kh_o_fw(nd)/kh_o)
      ra_g_fw(nd) = ra_g_fw(nd) + ra_u_fw(nd) + ram_fw(nd)
    END DO
    ra_g = temp*temp0
    ra_g = ra_g + ra_u + ram
    IF (120. .LT. ra_g) THEN
      ra_g = ra_g
    ELSE
      ra_g = 120.
      ra_g_fw(:) = 0.0_8
    END IF
  END IF
  RETURN
END SUBROUTINE AERODYNAMIC_CONDUCTANCE_FWV

!  Differentiation of cos_grnd in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: cos_soil
!   with respect to varying inputs: soilp.thetam soilp.temp_soil_c
SUBROUTINE COS_GRND_FWV(soilp, soilp_fw, cos_soil, cos_soil_fw, nbdirs)
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE BEPS_SOILMOD_DIFFV
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
!Input Variables
  TYPE(SOIL), INTENT(IN) :: soilp
  TYPE(SOIL_DIFFV), INTENT(IN) :: soilp_fw
!Local Variables
! local ground COS flux (pmol/m2/sec)
  REAL(r8) :: cos_soil
  REAL(r8), DIMENSION(nbdirsmax) :: cos_soil_fw
  REAL(r8) :: f_opt, s_opt, f_g, s_g, a
  REAL(r8), DIMENSION(nbdirsmax) :: f_opt_fw, s_opt_fw, f_g_fw, a_fw
  REAL(r8), PARAMETER :: k_cos_soil=1.2e-4
!Misc Variables
  INTEGER :: j
  REAL(r8) :: soil_t, soil_s, dsoil, soil_ice
  REAL(r8), DIMENSION(nbdirsmax) :: soil_t_fw, soil_s_fw
  REAL(r8) :: cos_soil_abiotic, cos_soil_biotic
  REAL(r8), DIMENSION(nbdirsmax) :: cos_soil_abiotic_fw, &
& cos_soil_biotic_fw
  INTRINSIC LOG, DBLE, EXP
  REAL(r8) :: arg1
  REAL(r8), DIMENSION(nbdirsmax) :: arg1_fw
  REAL(r8) :: arg2
  REAL(r8), DIMENSION(nbdirsmax) :: arg2_fw
  INTEGER :: nd
  REAL(r8) :: temp
  REAL(r8) :: temp0
  REAL(r8), DIMENSION(nbdirsmax) :: temp_fw
  REAL(r8) :: temp1
  INTEGER :: nbdirs
  soil_t = 0.
  soil_s = 0.
  soil_ice = 0.
  dsoil = 0.
  soil_s_fw(:) = 0.0_8
  soil_t_fw(:) = 0.0_8
!...ground uptake of COS, calculated from Whelan et al., 2016, ACP. calculate the abiotic and biotic part of ground uptake separa
!tely.
  DO j=1,3
    DO nd=1,nbdirs
      soil_t_fw(nd) = soil_t_fw(nd) + soilp%d_soil(j-1)*soilp_fw%&
&       temp_soil_c(nd, j-1)
      soil_s_fw(nd) = soil_s_fw(nd) + soilp%d_soil(j-1)*soilp_fw%thetam(&
&       nd, j-1)
    END DO
    soil_t = soil_t + soilp%temp_soil_c(j-1)*soilp%d_soil(j-1)
    soil_s = soil_s + soilp%thetam(j-1)*soilp%d_soil(j-1)
    soil_ice = soil_ice + soilp%ice_ratio(j-1)*soilp%d_soil(j-1)
    dsoil = dsoil + soilp%d_soil(j-1)
  END DO
  soil_t = soil_t/dsoil
  arg1 = 0.0984*soil_t
  f_opt = -(0.00986*soil_t*soil_t) + 0.197*soil_t - 9.32
  f_g = -(0.0119*soil_t*soil_t) + 0.110*soil_t - 1.18
  s_g = 35.0
  DO nd=1,nbdirs
    soil_t_fw(nd) = soil_t_fw(nd)/dsoil
    arg1_fw(nd) = 0.0984*soil_t_fw(nd)
    cos_soil_abiotic_fw(nd) = 0.437*EXP(arg1)*arg1_fw(nd)
    f_opt_fw(nd) = (0.197-0.00986*2*soil_t)*soil_t_fw(nd)
    s_opt_fw(nd) = 0.28*soil_t_fw(nd)
    f_g_fw(nd) = (0.110-0.0119*2*soil_t)*soil_t_fw(nd)
    arg1_fw(nd) = (f_opt_fw(nd)-f_opt*f_g_fw(nd)/f_g)/f_g
    arg2_fw(nd) = s_opt_fw(nd)/s_g
  END DO
  soil_ice = soil_ice/dsoil
  cos_soil_abiotic = 0.437*EXP(arg1)
  s_opt = 0.28*soil_t + 14.5
  arg1 = f_opt/f_g
  arg2 = s_opt/s_g
  temp = LOG(arg2) + s_g/s_opt - 1.
  temp0 = LOG(arg1)/temp
  DO nd=1,nbdirs
    a_fw(nd) = (arg1_fw(nd)/arg1-temp0*(arg2_fw(nd)/arg2-s_g*s_opt_fw(nd&
&     )/s_opt**2))/temp
  END DO
  a = temp0
  temp0 = soil_s/s_opt
  temp1 = soil_s/s_opt
  temp = temp1**a
  DO nd=1,nbdirs
    arg1_fw(nd) = -((temp0-1.)*a_fw(nd)+a*(soil_s_fw(nd)-temp0*s_opt_fw(&
&     nd))/s_opt)
    IF (temp1 .LE. 0.0_8 .AND. (a .EQ. 0.0_8 .OR. a .NE. INT(a))) THEN
      temp_fw(nd) = 0.0_8
    ELSE IF (temp1 .LE. 0.0_8) THEN
      temp_fw(nd) = a*temp1**(a-1)*(soil_s_fw(nd)-temp1*s_opt_fw(nd))/&
&       s_opt
    ELSE
      temp_fw(nd) = a*temp1**(a-1)*(soil_s_fw(nd)-temp1*s_opt_fw(nd))/&
&       s_opt + temp*LOG(temp1)*a_fw(nd)
    END IF
  END DO
  arg1 = -(a*(temp0-1.))
  temp0 = EXP(arg1)
  DO nd=1,nbdirs
    cos_soil_biotic_fw(nd) = f_opt*temp0*temp_fw(nd) + temp*(temp0*&
&     f_opt_fw(nd)+f_opt*EXP(arg1)*arg1_fw(nd))
    cos_soil_fw(nd) = -(cos_soil_abiotic_fw(nd) + cos_soil_biotic_fw(nd))
  END DO
  cos_soil_biotic = temp*(f_opt*temp0)
  cos_soil = -(cos_soil_abiotic + cos_soil_biotic)
END SUBROUTINE COS_GRND_FWV

!  Differentiation of beps_phenology in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: lai
!   with respect to varying inputs: trans
SUBROUTINE BEPS_PHENOLOGY_FWV(lc, daylen, dt, theta, trans, trans_fw, &
& lai, lai_fw, nbdirs)
!***********************************************************
!* WOK, 2008-07-30
!* IMPLIFIED PHENOLOGY MODEL
!* simplified phenology model
!***********************************************************
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE MO_HELPER_DIFFV, ONLY : errf, mins, maxs, minx, maxx, maxx_fwv, &
& fominef_ss, fominef_ss_fwv, fomaxef_ss
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
!  REAL, ALLOCATABLE, DIMENSION (:,:,:) :: mlai ! monthly LAI fields from external data
  INTEGER, INTENT(IN) :: lc
  REAL, INTENT(IN) :: daylen
  REAL, INTENT(IN) :: dt
  REAL, INTENT(IN) :: theta
  REAL, INTENT(IN) :: trans
  REAL, DIMENSION(nbdirsmax), INTENT(IN) :: trans_fw
  REAL, INTENT(INOUT) :: lai
  REAL, DIMENSION(nbdirsmax), INTENT(INOUT) :: lai_fw
! air-temperature memory [deg C]
  REAL :: tmpm
! water limited LAI memory
  REAL :: laim
  REAL, DIMENSION(nbdirsmax) :: laim_fw
! highest recorded LAI (with a decay rate, for setting 'zfc')
  REAL :: laihi
! WOK-ADD-070723 litter production to be calculated directly in phenology (not in cbalance indirectly)
! auxiliary fields
  REAL :: tmpmmult, laimmult
! output field
  REAL :: leafshed
  REAL :: laihimult
! memory time for updating fractional cover
  REAL, PARAMETER :: taulaihi=5.0
!  REAL, PARAMETER :: laimin = 1e-6            ! minimum LAI for pot. transpiration per LAI estimates
! curvature parameter for mins/maxs
  REAL, PARAMETER :: eta=0.99999
! WOK-ADD-070723 the list of controlling parameters
! FREE PARAMETERS
! maximum LAI
  REAL :: plaimax(10)
! rootdepth
  REAL :: rootdepth(10)
! leaf onset temperature [deg C]
  REAL :: ptphen(10)
! range of leaf onset temperature [1/deg C]
  REAL :: ptphenr(10)
! leaf shedding daylength [hours]
  REAL :: pdphen
! range of leaf shedding daylength [hours]
  REAL :: pdphenr
!  REAL, ALLOCATABLE, DIMENSION (:) :: PTSHD   ! leaf shedding temperature [deg C]
!  REAL, ALLOCATABLE, DIMENSION (:) :: PTSHDS  ! spread of leaf shedding temperature [1/deg C]
! leaf growth factor [1/days]
  REAL :: plgr
! inverse leaf longevity from start of senescense [1/days]
  REAL :: pkl(10)
! target survival time at current soil moisture [days]
  REAL :: ptauw(10)
! PARAMETERS LEFT FIXED
! inverse memory time for soil moisture-limited LAI [1/days]
  REAL :: pks
! inverse memory time for air temperature [1/days]
  REAL :: pkm
  REAL :: pasm
  REAL :: zfc, zlai
  REAL :: fcmax0, lailim0, cdrm
  REAL :: xdtmp, lait, laiw, fx, t0, ts, ft, fd, fg
  REAL :: lailast
  REAL :: laimaxw, laimax, r, lailim, wai
  REAL, DIMENSION(nbdirsmax) :: laimax_fw, lailim_fw
  REAL :: dptrp
  REAL, DIMENSION(nbdirsmax) :: dptrp_fw
  INTEGER :: plt
! WOK-090309 'ph' is now only used in nscale
! xph     1: warm-evergreen; 2: cold-evergreen; 3: summergreen; 4: raingreen; 5: grass; 6: annual crop;
! INTEGER, DIMENSION (0:13), PARAMETER :: xph= &
!PFT:0  1  2  3  4  5  6  7  8  9 10 11 12 13
!  (/5, 1, 4, 1, 3, 2, 3, 1, 4, 5, 5, 2, 5, 6/)
  REAL :: sla(10)
  INTRINSIC EXP
  REAL :: arg1
  REAL, DIMENSION(nbdirsmax) :: arg1_fw
  REAL :: result1
  REAL, DIMENSION(nbdirsmax) :: result1_fw
  REAL :: arg2
  INTEGER :: nd
  REAL :: temp
  INTEGER :: nbdirs
  SELECT CASE  (lc) 
  CASE (1) 
!conifer evergreen
    plt = 1
  CASE (2) 
!conifer decidous
    plt = 2
  CASE (6) 
!broadleaf decidous
    plt = 3
  CASE (9) 
!broadleaf evergreen
    plt = 4
  CASE (10) 
!mix
    plt = 5
  CASE (13) 
!shrub
    plt = 6
  CASE (14) 
! grass
    plt = 7
  CASE (15) 
! crop
    plt = 8
  CASE (40) 
! C4 grass
    plt = 9
  CASE (41) 
! C4 crop
    plt = 10
  END SELECT
  sla = (/4.1, 11.3, 12.8, 7.8, 9.0, 9.2, 16.9, 25.3, 16.9, 16.9/)
!sla(0:13)=(/0., 9.9, 14.1, 5.7, 11.5, 4.1, 11.3, 6.9, &
!		& 11.5, 16.9, 16.9, 6.9, 16.9, 25.3/)
  ptphen = (/10.0, 10.0, 5.0, 0., 5., 4.0, 2.0, 15.0, 2.0, 2.0/)
!  ptphen(0:13)=(/0.,0.,0., 0., 10.0, 10.0, 10.0, 0., 8.0, &
!       & 2.0, 2.0, 2.0, 2.0, 15.0/)
  ptphenr = (/2.0, 2.0, 2., 2., 2., 2.0, 2., 2., 2., 2./)
!  ptphenr(0:13)=(/0.,0., 0., 0., 2.0, 2.0, 2.0, 0., 2.0, &
!        & 2.0, 2.0, 2.0, 2.0, 2.0/)
  pdphen = 10.5
  pdphenr = 0.5
  plgr = 0.5
  pkl = (/0.1, 0., 5.e-3, 0.1, 0.1, 0.1, 5.e-3, 0.1, 5.e-3, 5.e-3/)
! pkl(0:13) = (/0.,0.1, 0., 0.1, 5.e-3, 0.1, 0., 0.1, &
!       & 0.1, 0.1, 5.e-3, 0.1, 0.1, 0.1/)
  ptauw = (/30., 30., 30., 30., 30., 30., 30., 30., 30., 30./)
!  ptauw(1:13) = (/0., 30., 30., 30., 30., 30., 30., &
!        & 30., 30., 30., 30., 30., 30./)
!  LIST OF PFTs in BETHY:
!  1:  tropical broadleaf evergreen tree
!  2:  tropical broadleaf deciduous tree
!  3:  temperate broadleaf evergreen tree
!  4:  temperate broadleaf deciduous tree
!  5:  evergreen coniferous tree
!  6:  deciduous coniferous tree
!  7:  evergreen shrub
!  8:  deciduous shrub
!  9:  C3 grass
! 10:  C4 grass
! 11:  tundra
! 12:  swamp
! 13:  arable crop
  rootdepth = (/0.6, 0.6, 0.8, 0.8, 0.7, 0.5, 0.3, 0.3, 0.3, 0.3/)
  plaimax = (/4.5, 4.5, 4.5, 4.5, 4.5, 3.3, 3.0, 4.5, 3.0, 3.0/)
  fcmax0 = 1.0
  lailim0 = 3.0
  cdrm = 0.45
  pkm = 1./30.
  pks = 1./30.
!   multiplier for advancing temperature memory by one day
  tmpmmult = EXP(-pkm)
!   multiplier for advancing soil-water limited LAI memory by one day
  laimmult = EXP(-pks)
!   decay multiplier for evergreen LAI
!    laimult = exp (-pkl)
!   the air-temperature memory
  tmpm = 0.
!   the water stress index memory
  laim = 0.
  lai = plaimax(plt)
!   decay multiplier for maximum LAI used to set fractional cover
  arg1 = -(1./(taulaihi*365.))
  laihimult = EXP(arg1)
!   control for fractional cover 'zfc'
  laihi = 0.
  zfc = fcmax0
!   output field
  leafshed = 0.
!   spin-up of temperature memory
  tmpm = dt*(1.-tmpmmult) + tmpm*tmpmmult
!   calculate plant available soil moisture and daily potential transpiration, @MOUSONG.WU, 201905
! convert from m3/m3 to mm
  pasm = theta*rootdepth(plt)*1000.
! convert from m/s to mm
  DO nd=1,nbdirs
    dptrp_fw(nd) = 1000.*86400.*trans_fw(nd)
  END DO
  dptrp = trans*86400.*1000.
  lailast = lai
  lai_fw(:) = 0.0_8
  laim_fw(:) = 0.0_8
!------------------------------------------------------------------
! advances LAI and fractional cover by one day
! from its current state to the state at day 'iday'
!------------------------------------------------------------------
  DO plt=1,9
!      IF (ph(k)==1.or.ph(k)==4) THEN ! warm-evergreen and warm-deciduous phenology
    IF (((plt .EQ. 3 .OR. plt .EQ. 4) .OR. plt .EQ. 5) .OR. plt .EQ. 6) &
&   THEN
! warm-evergreen and warm-deciduous phenology
! effective maximum LAI, taking into account structural limiations
!        laimax = plaimax(k) * (1. - exp(-laimaxw/plaimax(k)))
!   initialize LAI
      CALL MAXX_FWV(dptrp, dptrp_fw, 1.e-3, 2.e-2, result1, result1_fw, &
&             nbdirs)
      temp = pasm*lailast/(ptauw(plt)*result1)
      DO nd=1,nbdirs
        laimax_fw(nd) = -(temp*result1_fw(nd)/result1)
      END DO
      laimax = temp
!        laimax = mins (laimax, plaimax(k), 0.9)
!snb, test
      CALL FOMINEF_SS_FWV(laimax, laimax_fw, plaimax(plt), 2.e-1, &
&                   result1, result1_fw, nbdirs)
      DO nd=1,nbdirs
        laimax_fw(nd) = result1_fw(nd)
! update water limited LAI memory
        laim_fw(nd) = (1.-laimmult)*laimax_fw(nd) + laimmult*laim_fw(nd)
! limit LAI
        lailim_fw(nd) = laim_fw(nd)
      END DO
      laimax = result1 + 1.e-1
      laim = laimax*(1.-laimmult) + laim*laimmult
! rate of change of LAI towards limit
      r = plgr
      lailim = laim
! update LAI
!        lai(k) = lailim - (lailim - lai(k)) * exp (-r)
!      ELSE IF (ph(k)==2.or.ph(k)==3) THEN ! cold-evergreen and cold-deciduous phenology
    ELSE IF (plt .EQ. 1 .OR. plt .EQ. 2) THEN
! cold-evergreen and cold-deciduous phenology
! update memory of daily mean temperature
      tmpm = dt*(1.-tmpmmult) + tmpm*tmpmmult
! fraction of vegetation above temperature threshold
      arg1 = (tmpm-ptphen(plt))/ptphenr(plt)
      ft = ERRF(arg1)
! fraction of vegetation above daylength threshold
      arg1 = (daylen-pdphen)/pdphenr
      fd = ERRF(arg1)
      r = ft*fd*plgr + (1.-ft*fd)*pkl(plt) + 1.e-9
      arg1 = ft*fd*plgr*plaimax(plt)/r
      lailim = MAXX(arg1, 1.e-9, 5.e-3)
!        lai(k) = plaimax(k) - (plaimax(k) - lai(k)) * exp (-r)
!        lai(k) = lailim - (lailim - lai(k)) * exp (-r)
      lailim_fw(:) = 0.0_8
    ELSE
! grass and annual crop phenology
      tmpm = dt*(1.-tmpmmult) + tmpm*tmpmmult
      arg1 = (tmpm-ptphen(plt))/ptphenr(plt)
      ft = ERRF(arg1)
      CALL MAXX_FWV(dptrp, dptrp_fw, 1.e-3, 2.e-2, result1, result1_fw, &
&             nbdirs)
      temp = pasm*lailast/(ptauw(plt)*result1)
      DO nd=1,nbdirs
        laimax_fw(nd) = -(temp*result1_fw(nd)/result1)
      END DO
      laimax = temp
!        laimax = mins (laimax, plaimax(k), 0.9)
!        if(pft(k)==9) print '(a,8g30.14)','PFT9-a: iday,tmpm(k),ft,laimax,pasm(k),zlai(k),dptrp(k),lai(k)',iday,tmpm(k),ft,laima
!x,pasm(k),zlai(k),dptrp(k),lai(k)
!snb, test
      CALL FOMINEF_SS_FWV(laimax, laimax_fw, plaimax(plt), 2.e-1, &
&                   result1, result1_fw, nbdirs)
      r = ft*plgr + (1.-ft)*pkl(plt) + 1.e-9
      DO nd=1,nbdirs
        laimax_fw(nd) = result1_fw(nd)
        laim_fw(nd) = (1.-laimmult)*laimax_fw(nd) + laimmult*laim_fw(nd)
        arg1_fw(nd) = ft*plgr*laim_fw(nd)/r
      END DO
      laimax = result1 + 1.e-1
      laim = laimax*(1.-laimmult) + laim*laimmult
      arg1 = ft*plgr*laim/r
      CALL MAXX_FWV(arg1, arg1_fw, 1.e-9, 5.e-3, lailim, lailim_fw, &
&             nbdirs)
!        lai(k) = lailim - (lailim - lai(k)) * exp (-r)
    END IF
!      leafshed(k) = maxx (lailast - lai(k), 0., 1e-3) / sla(k) * 1000. * cdrm
    arg1 = (lailim-lai)*(1.-EXP(-r))
    result1 = MAXX(arg1, 0., 1.e-3)
    leafshed = result1/sla(plt)*1000.*cdrm
    temp = EXP(-r)
    DO nd=1,nbdirs
      lai_fw(nd) = lailim_fw(nd) - temp*(lailim_fw(nd)-lai_fw(nd))
    END DO
    lai = lailim - temp*(lailim-lai)
  END DO
!      if(pft(k)==9) print '(a,8g30.14)','PFT9-b: lai(k),r,lailim',lai(k),r,lailim
! set fractional cover
!      laihi(k) = maxs (lai(k), laihi(k), eta) * laihimult
  result1 = FOMAXEF_SS(lai, laihi, 2.e-6)
  laihi = result1*laihimult
!      zfc(k) = maxs (laihi(k) / lailim0, lai(k) / lailim0, eta)
  arg1 = laihi/lailim0
  arg2 = lai/lailim0
  zfc = FOMAXEF_SS(arg1, arg2, 2.e-6)
!      zfc(k) = mins ( zfc(k), 1., eta) * fcmax0
! snb, test
  result1 = MINX(zfc, 1., 2.e-6)
  zfc = result1*fcmax0
END SUBROUTINE BEPS_PHENOLOGY_FWV

!  Differentiation of netradiation in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: netradleaf_o_sunlit netradleaf_o_shaded
!                netshortradleaf_o_sunlit netradleaf_u_sunlit netshortradleaf_o_shaded
!                netradleaf_u_shaded netshortradleaf_u_sunlit netshortradleaf_u_shaded
!                netrad_g
!   with respect to varying inputs: albedo_n_g percentarea_snow_o
!                lai_us percentarea_snow_u temp_o albedo_snow_n
!                temp_u lai_os lai_o percent_snow_g albedo_snow_v
!                lai_u albedo_v_g
! This module calculate net radiation at both canopy level and leaf level XZ luo may23 2015
! output: net radiation for canopy,over/under storey and ground
!         ............. on sunlit/shaded leaves of over/understorey
!
! inputs: global solar radiation,cosine value for solar zenith angle,albedo of leaves
!         albedo of snow,percentage of snow cover
!         leaf area index 
!         temperature of over/under storey and ground
!         temperature of air/rh
SUBROUTINE NETRADIATION_FWV(shortrad_df, shortrad_dir, coszs, temp_o, &
& temp_o_fw, temp_u, temp_u_fw, temp_g, lai_o, lai_o_fw, lai_u, lai_u_fw&
& , lai_os, lai_os_fw, lai_us, lai_us_fw, lai_o_sunlit, lai_o_shaded, &
& lai_u_sunlit, lai_u_shaded, clumping, temp_air, rh, albedo_snow_v, &
& albedo_snow_v_fw, albedo_snow_n, albedo_snow_n_fw, percentarea_snow_o&
& , percentarea_snow_o_fw, percentarea_snow_u, percentarea_snow_u_fw, &
& percent_snow_g, percent_snow_g_fw, albedo_v_o, albedo_n_o, albedo_v_u&
& , albedo_n_u, albedo_v_g, albedo_v_g_fw, albedo_n_g, albedo_n_g_fw, &
& netrad_o, netrad_u, netrad_g, netrad_g_fw, netradleaf_o_sunlit, &
& netradleaf_o_sunlit_fw, netradleaf_o_shaded, netradleaf_o_shaded_fw, &
& netradleaf_u_sunlit, netradleaf_u_sunlit_fw, netradleaf_u_shaded, &
& netradleaf_u_shaded_fw, netshortradleaf_o_sunlit, &
& netshortradleaf_o_sunlit_fw, netshortradleaf_o_shaded, &
& netshortradleaf_o_shaded_fw, netshortradleaf_u_sunlit, &
& netshortradleaf_u_sunlit_fw, netshortradleaf_u_shaded, &
& netshortradleaf_u_shaded_fw, nbdirs)
  USE METEOMOD_DIFFV
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE BEPS_CON, ONLY : zero, sb_constant => sigma
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
  REAL(r8), INTENT(IN) :: shortrad_df, shortrad_dir, coszs, temp_o, &
& temp_u, temp_g
  REAL(r8), DIMENSION(nbdirsmax), INTENT(IN) :: temp_o_fw, temp_u_fw
! LAI of over/understorey with or without stem
  REAL(r8), INTENT(IN) :: lai_o, lai_u, lai_os, lai_us
  REAL(r8), DIMENSION(nbdirsmax), INTENT(IN) :: lai_o_fw, lai_u_fw, &
& lai_os_fw, lai_us_fw
! sunlit/shaded leaves with consideration of stem
  REAL(r8), INTENT(IN) :: lai_o_sunlit, lai_o_shaded, lai_u_sunlit, &
& lai_u_shaded
  REAL(r8), INTENT(IN) :: clumping
  REAL(r8), INTENT(IN) :: temp_air, rh
! albedo of snow in this step
  REAL(r8), INTENT(IN) :: albedo_snow_v, albedo_snow_n
  REAL(r8), DIMENSION(nbdirsmax), INTENT(IN) :: albedo_snow_v_fw, &
& albedo_snow_n_fw
  REAL(r8), INTENT(IN) :: percentarea_snow_o, percentarea_snow_u, &
& percent_snow_g
  REAL(r8), DIMENSION(nbdirsmax), INTENT(IN) :: percentarea_snow_o_fw, &
& percentarea_snow_u_fw, percent_snow_g_fw
  REAL(r8), INTENT(IN) :: albedo_v_o, albedo_n_o, albedo_v_u, albedo_n_u&
& , albedo_v_g, albedo_n_g
  REAL(r8), DIMENSION(nbdirsmax), INTENT(IN) :: albedo_v_g_fw, &
& albedo_n_g_fw
! net Radiation on over/understorey and ground
  REAL(r8), INTENT(OUT) :: netrad_o, netrad_u, netrad_g
  REAL(r8), DIMENSION(nbdirsmax), INTENT(OUT) :: netrad_g_fw
!leaf levels for ET
  REAL(r8), INTENT(OUT) :: netradleaf_o_sunlit, netradleaf_o_shaded, &
& netradleaf_u_sunlit, netradleaf_u_shaded
  REAL(r8), DIMENSION(nbdirsmax), INTENT(OUT) :: netradleaf_o_sunlit_fw&
& , netradleaf_o_shaded_fw, netradleaf_u_sunlit_fw, &
& netradleaf_u_shaded_fw
  REAL(r8), INTENT(OUT) :: netshortradleaf_o_sunlit, &
& netshortradleaf_o_shaded, netshortradleaf_u_sunlit, &
& netshortradleaf_u_shaded
  REAL(r8), DIMENSION(nbdirsmax), INTENT(OUT) :: &
& netshortradleaf_o_sunlit_fw, netshortradleaf_o_shaded_fw, &
& netshortradleaf_u_sunlit_fw, netshortradleaf_u_shaded_fw
!! net shortwave radiation at leaf level for GPP. 
! net short wave radiation
  REAL(r8) :: shortrad_global, netshortrad_o, netshortrad_u, &
& netshortrad_g
  REAL(r8), DIMENSION(nbdirsmax) :: netshortrad_g_fw
  REAL(r8) :: netshortrad_o_dir, netshortrad_o_df, netshortrad_u_dir, &
& netshortrad_u_df, netshortrad_g_dir, netshortrad_g_df
  REAL(r8), DIMENSION(nbdirsmax) :: netshortrad_g_dir_fw, &
& netshortrad_g_df_fw
!real(r8) :: shortRad_dir,shortRad_df
  REAL(r8) :: netlongradleaf_o_sunlit, netlongradleaf_o_shaded, &
& netlongradleaf_u_sunlit, netlongradleaf_u_shaded
  REAL(r8), DIMENSION(nbdirsmax) :: netlongradleaf_o_sunlit_fw, &
& netlongradleaf_o_shaded_fw, netlongradleaf_u_sunlit_fw, &
& netlongradleaf_u_shaded_fw
  REAL(r8) :: netlongrad_o, netlongrad_u, netlongrad_g
  REAL(r8), DIMENSION(nbdirsmax) :: netlongrad_o_fw, netlongrad_u_fw, &
& netlongrad_g_fw
  REAL(r8) :: shortradleaf_o_dir, shortradleaf_u_dir, shortradleaf_o_df&
& , shortradleaf_u_df
  REAL(r8), DIMENSION(nbdirsmax) :: shortradleaf_o_df_fw, &
& shortradleaf_u_df_fw
!albedo of overstorey/understorey/groudn(considering snow)
  REAL(r8) :: albedo_o, albedo_u, albedo_g
  REAL(r8), DIMENSION(nbdirsmax) :: albedo_o_fw, albedo_u_fw, &
& albedo_g_fw
! albedo of three parts in visible and NIR band (considering snow)
  REAL(r8) :: albedo_v_os, albedo_n_os, albedo_v_us, albedo_n_us, &
& albedo_v_gs, albedo_n_gs
  REAL(r8), DIMENSION(nbdirsmax) :: albedo_v_os_fw, albedo_n_os_fw, &
& albedo_v_us_fw, albedo_n_us_fw, albedo_v_gs_fw, albedo_n_gs_fw
!emissivity of air,over/understorey, and ground
  REAL(r8) :: emissivity_air, emissivity_o, emissivity_u, emissivity_g
! longwave radiation emissted by different parts
  REAL(r8) :: longrad_air, longrad_o, longrad_u, longrad_g
  REAL(r8), DIMENSION(nbdirsmax) :: longrad_o_fw, longrad_u_fw
! indicators to describe leaf distribution angles in canopy. slightly related with LAI
  REAL(r8) :: cosq_o, cosq_u
  REAL(r8), DIMENSION(nbdirsmax) :: cosq_o_fw, cosq_u_fw
!gap fraction of direct and diffuse radiation for over/unerstory (diffuse used for diffuse solar radiation and longwave radiation
  REAL(r8) :: gap_o_dir, gap_u_dir, gap_o_df, gap_u_df
  REAL(r8), DIMENSION(nbdirsmax) :: gap_o_dir_fw, gap_u_dir_fw, &
& gap_o_df_fw, gap_u_df_fw
! considering stem
  REAL(r8) :: gap_os_dir, gap_us_dir, gap_os_df, gap_us_df
  REAL(r8), DIMENSION(nbdirsmax) :: gap_os_df_fw, gap_us_df_fw
  INTRINSIC EXP
  INTRINSIC MIN
  INTRINSIC MAX
  REAL(r8) :: arg1
  REAL(r8), DIMENSION(nbdirsmax) :: arg1_fw
  INTEGER :: nd
  REAL(r8) :: temp
  REAL(r8) :: temp0
  REAL(r8) :: temp1
  INTEGER :: nbdirs
  DO nd=1,nbdirs
!calculate albedo of canopy in this step
    albedo_v_os_fw(nd) = percentarea_snow_o*albedo_snow_v_fw(nd) - (&
&     albedo_v_o-albedo_snow_v)*percentarea_snow_o_fw(nd)
    albedo_n_os_fw(nd) = percentarea_snow_o*albedo_snow_n_fw(nd) - (&
&     albedo_n_o-albedo_snow_n)*percentarea_snow_o_fw(nd)
    albedo_v_us_fw(nd) = percentarea_snow_u*albedo_snow_v_fw(nd) - (&
&     albedo_v_u-albedo_snow_v)*percentarea_snow_u_fw(nd)
    albedo_n_us_fw(nd) = percentarea_snow_u*albedo_snow_n_fw(nd) - (&
&     albedo_n_u-albedo_snow_n)*percentarea_snow_u_fw(nd)
    albedo_o_fw(nd) = 0.5*(albedo_v_os_fw(nd)+albedo_n_os_fw(nd))
    albedo_u_fw(nd) = 0.5*(albedo_v_us_fw(nd)+albedo_n_us_fw(nd))
! calculate albedo of ground 
    albedo_v_gs_fw(nd) = (1.-percent_snow_g)*albedo_v_g_fw(nd) - (&
&     albedo_v_g-albedo_snow_v)*percent_snow_g_fw(nd) + percent_snow_g*&
&     albedo_snow_v_fw(nd)
    albedo_n_gs_fw(nd) = (1.-percent_snow_g)*albedo_n_g_fw(nd) - (&
&     albedo_n_g-albedo_snow_n)*percent_snow_g_fw(nd) + percent_snow_g*&
&     albedo_snow_n_fw(nd)
    albedo_g_fw(nd) = 0.5*(albedo_v_gs_fw(nd)+albedo_n_gs_fw(nd))
  END DO
  albedo_v_os = albedo_v_o*(1.-percentarea_snow_o) + albedo_snow_v*&
&   percentarea_snow_o
  albedo_n_os = albedo_n_o*(1.-percentarea_snow_o) + albedo_snow_n*&
&   percentarea_snow_o
  albedo_v_us = albedo_v_u*(1.-percentarea_snow_u) + albedo_snow_v*&
&   percentarea_snow_u
  albedo_n_us = albedo_n_u*(1.-percentarea_snow_u) + albedo_snow_n*&
&   percentarea_snow_u
  albedo_o = 0.5*(albedo_v_os+albedo_n_os)
  albedo_u = 0.5*(albedo_v_us+albedo_n_us)
  albedo_v_gs = albedo_v_g*(1.-percent_snow_g) + albedo_snow_v*&
&   percent_snow_g
  albedo_n_gs = albedo_n_g*(1.-percent_snow_g) + albedo_snow_n*&
&   percent_snow_g
  albedo_g = 0.5*(albedo_v_gs+albedo_n_gs)
! separate global solar radiation into df and dir  @orgin
!      Here we input df/dir directly               @J.Wang
! @J.Wang
  shortrad_global = shortrad_df + shortrad_dir
! fraction at each layer of canopy,df/dir, use LAI here
  IF (coszs .GT. zero) THEN
    IF (-(0.5*clumping*lai_o/coszs) .LT. -10.) THEN
      gap_o_dir = 0.
      gap_o_dir_fw(:) = 0.0_8
    ELSE
      arg1 = -(0.5*clumping*lai_o/coszs)
      DO nd=1,nbdirs
        arg1_fw(nd) = -(clumping*0.5*lai_o_fw(nd)/coszs)
        gap_o_dir_fw(nd) = EXP(arg1)*arg1_fw(nd)
      END DO
      gap_o_dir = EXP(arg1)
    END IF
    IF (-(0.5*clumping*lai_u/coszs) .LT. -10.) THEN
      gap_u_dir = 0.
      gap_u_dir_fw(:) = 0.0_8
    ELSE
      arg1 = -(0.5*clumping*lai_u/coszs)
      DO nd=1,nbdirs
        arg1_fw(nd) = -(clumping*0.5*lai_u_fw(nd)/coszs)
        gap_u_dir_fw(nd) = EXP(arg1)*arg1_fw(nd)
      END DO
      gap_u_dir = EXP(arg1)
    END IF
    IF (-(0.5*clumping*lai_os/coszs) .LT. -10.) THEN
      gap_os_dir = 0.
    ELSE
!considering stem
      arg1 = -(0.5*clumping*lai_os/coszs)
      gap_os_dir = EXP(arg1)
    END IF
    IF (-(0.5*clumping*lai_us/coszs) .LT. -10.) THEN
      gap_us_dir = 0.
    ELSE
      arg1 = -(0.5*clumping*lai_us/coszs)
      gap_us_dir = EXP(arg1)
    END IF
  ELSE
    gap_o_dir_fw(:) = 0.0_8
    gap_u_dir_fw(:) = 0.0_8
  END IF
  cosq_o = 0.537 + 0.025*lai_o
  cosq_u = 0.537 + 0.025*lai_u
  arg1 = -(0.5*clumping*lai_o/cosq_o)
  DO nd=1,nbdirs
!leaf distribution angles
    cosq_o_fw(nd) = 0.025*lai_o_fw(nd)
    cosq_u_fw(nd) = 0.025*lai_u_fw(nd)
    arg1_fw(nd) = -(clumping*0.5*(lai_o_fw(nd)-lai_o*cosq_o_fw(nd)/&
&     cosq_o)/cosq_o)
    gap_o_df_fw(nd) = EXP(arg1)*arg1_fw(nd)
    arg1_fw(nd) = -(clumping*0.5*(lai_u_fw(nd)-lai_u*cosq_u_fw(nd)/&
&     cosq_u)/cosq_u)
  END DO
  gap_o_df = EXP(arg1)
  arg1 = -(0.5*clumping*lai_u/cosq_u)
  DO nd=1,nbdirs
    gap_u_df_fw(nd) = EXP(arg1)*arg1_fw(nd)
    arg1_fw(nd) = -(clumping*0.5*(lai_os_fw(nd)-lai_os*cosq_o_fw(nd)/&
&     cosq_o)/cosq_o)
  END DO
  gap_u_df = EXP(arg1)
  arg1 = -(0.5*clumping*lai_os/cosq_o)
  DO nd=1,nbdirs
    gap_os_df_fw(nd) = EXP(arg1)*arg1_fw(nd)
    arg1_fw(nd) = -(clumping*0.5*(lai_us_fw(nd)-lai_us*cosq_u_fw(nd)/&
&     cosq_u)/cosq_u)
  END DO
  gap_os_df = EXP(arg1)
  arg1 = -(0.5*clumping*lai_us/cosq_u)
  DO nd=1,nbdirs
    gap_us_df_fw(nd) = EXP(arg1)*arg1_fw(nd)
  END DO
  gap_us_df = EXP(arg1)
!emissivity of each part
  CALL METEO_PACK(temp_air, rh)
  arg1 = -((e_actual*10.0)**((temp_air+273.15)/1200.0))
  emissivity_air = 1. - EXP(arg1)
  IF (1. .GT. emissivity_air) THEN
    emissivity_air = emissivity_air
  ELSE
    emissivity_air = 1.
  END IF
  IF (0.7 .LT. emissivity_air) THEN
    emissivity_air = emissivity_air
  ELSE
    emissivity_air = 0.7
  END IF
  emissivity_o = 0.98
  emissivity_u = 0.98
  emissivity_g = 0.96
!net short direct radiation on canopy and ground
  IF (shortrad_global .GT. zero .AND. coszs .GT. zero) THEN
! day time
    netshortrad_o_dir = shortrad_dir*(1.-albedo_o-(1.-albedo_u)*&
&     gap_o_dir)
    netshortrad_u_dir = shortrad_dir*gap_o_dir*(1.-albedo_u-(1.-albedo_g&
&     )*gap_u_dir)
    DO nd=1,nbdirs
      netshortrad_g_dir_fw(nd) = shortrad_dir*((1.-albedo_g)*(gap_u_dir*&
&       gap_o_dir_fw(nd)+gap_o_dir*gap_u_dir_fw(nd))-gap_o_dir*gap_u_dir&
&       *albedo_g_fw(nd))
    END DO
    netshortrad_g_dir = shortrad_dir*gap_o_dir*gap_u_dir*(1.-albedo_g)
  ELSE
    netshortrad_o_dir = 0.
    netshortrad_u_dir = 0
    netshortrad_g_dir = 0
    netshortrad_g_dir_fw(:) = 0.0_8
  END IF
!net short diffuse radiation on canopy and ground
  IF (shortrad_global .GT. zero .AND. coszs .GT. zero) THEN
! day time
    arg1 = -(1.*coszs)
    netshortrad_o_df = shortrad_df*(1.-albedo_o-(1.-albedo_u)*gap_o_df) &
&     + 0.21*clumping*shortrad_dir*(1.1-0.1*lai_o)*EXP(arg1)
    arg1 = -(1.*coszs)
    netshortrad_u_df = shortrad_df*gap_o_df*(1.-albedo_u-(1.-albedo_g)*&
&     gap_u_df) + 0.21*clumping*shortrad_dir*gap_o_dir*(1.1-0.1*lai_u)*&
&     EXP(arg1)
    DO nd=1,nbdirs
      netshortrad_g_df_fw(nd) = shortrad_df*((1.-albedo_g)*(gap_u_df*&
&       gap_o_df_fw(nd)+gap_o_df*gap_u_df_fw(nd))-gap_o_df*gap_u_df*&
&       albedo_g_fw(nd))
    END DO
    netshortrad_g_df = shortrad_df*gap_o_df*gap_u_df*(1.-albedo_g)
  ELSE
    netshortrad_o_df = 0.
    netshortrad_u_df = 0.
    netshortrad_g_df = 0.
    netshortrad_g_df_fw(:) = 0.0_8
  END IF
!total net shortwave radiation at canopy level
  netshortrad_o = netshortrad_o_dir + netshortrad_o_df
  netshortrad_u = netshortrad_u_dir + netshortrad_u_df
!net longwave radiation on canopy and ground
  longrad_air = emissivity_air*sb_constant*(temp_air+273.15)**4
  longrad_o = emissivity_o*sb_constant*(temp_o+273.15)**4
  longrad_u = emissivity_u*sb_constant*(temp_u+273.15)**4
  longrad_g = emissivity_g*sb_constant*(temp_g+273.15)**4
  temp = emissivity_o*(longrad_air+longrad_u*(-gap_u_df+1.)+longrad_g*&
&   gap_u_df) - 2.*longrad_o
  temp0 = longrad_air*gap_o_df + longrad_o*(-gap_o_df+1.)
  DO nd=1,nbdirs
    netshortrad_g_fw(nd) = netshortrad_g_dir_fw(nd) + &
&     netshortrad_g_df_fw(nd)
    longrad_o_fw(nd) = emissivity_o*sb_constant*4*(temp_o+273.15)**3*&
&     temp_o_fw(nd)
    longrad_u_fw(nd) = emissivity_u*sb_constant*4*(temp_u+273.15)**3*&
&     temp_u_fw(nd)
    netlongrad_o_fw(nd) = (1.-gap_o_df)*(emissivity_o*((1.-gap_u_df)*&
&     longrad_u_fw(nd)-(longrad_u-longrad_g)*gap_u_df_fw(nd))-2.*&
&     longrad_o_fw(nd)) - temp*gap_o_df_fw(nd) + emissivity_o*(1.-&
&     emissivity_u)*((1.-gap_u_df)*((longrad_air-longrad_o)*gap_o_df_fw(&
&     nd)+(1.-gap_o_df)*longrad_o_fw(nd))-temp0*gap_u_df_fw(nd))
  END DO
  netshortrad_g = netshortrad_g_dir + netshortrad_g_df
  netlongrad_o = temp*(1.-gap_o_df) + emissivity_o*(1.-emissivity_u)*((&
&   1.-gap_u_df)*temp0)
  temp0 = emissivity_u*(longrad_g+longrad_air*gap_o_df+longrad_o*(-&
&   gap_o_df+1.)) - 2.*longrad_u
  temp = longrad_air*gap_o_df + longrad_o*(-gap_o_df+1.)
  temp1 = longrad_u*(-gap_u_df+1.) + longrad_g*gap_u_df
  DO nd=1,nbdirs
    netlongrad_u_fw(nd) = (1.-gap_u_df)*(emissivity_u*((longrad_air-&
&     longrad_o)*gap_o_df_fw(nd)+(1.-gap_o_df)*longrad_o_fw(nd))-2.*&
&     longrad_u_fw(nd)) - temp0*gap_u_df_fw(nd) + (1.-emissivity_g)*(&
&     gap_u_df*((longrad_air-longrad_o)*gap_o_df_fw(nd)+(1.-gap_o_df)*&
&     longrad_o_fw(nd))+(temp-longrad_u)*gap_u_df_fw(nd)+(1.-gap_u_df)*&
&     longrad_u_fw(nd)) + emissivity_u*(1.-emissivity_o)*((1.-gap_o_df)*&
&     ((1.-gap_u_df)*longrad_u_fw(nd)-(longrad_u-longrad_g)*gap_u_df_fw(&
&     nd))-temp1*gap_o_df_fw(nd))
  END DO
  netlongrad_u = temp0*(1.-gap_u_df) + (1.-emissivity_g)*(temp*gap_u_df+&
&   longrad_u*(1.-gap_u_df)) + emissivity_u*(1.-emissivity_o)*(temp1*(1.&
&   -gap_o_df))
  temp1 = longrad_air*gap_o_df + longrad_o*(-gap_o_df+1.)
  DO nd=1,nbdirs
    netlongrad_g_fw(nd) = emissivity_g*(gap_u_df*((longrad_air-longrad_o&
&     )*gap_o_df_fw(nd)+(1.-gap_o_df)*longrad_o_fw(nd))+(temp1-longrad_u&
&     )*gap_u_df_fw(nd)+(1.-gap_u_df)*longrad_u_fw(nd)) - (1.-&
&     emissivity_u)*longrad_g*gap_u_df_fw(nd)
    netrad_g_fw(nd) = netshortrad_g_fw(nd) + netlongrad_g_fw(nd)
  END DO
  netlongrad_g = emissivity_g*(temp1*gap_u_df+longrad_u*(1.-gap_u_df)) -&
&   longrad_g + (1.-emissivity_u)*longrad_g*(1.-gap_u_df)
!total net radiation for overstorey/understorey/ground
  netrad_o = netshortrad_o + netlongrad_o
  netrad_u = netshortrad_u + netlongrad_u
  netrad_g = netshortrad_g + netlongrad_g
!leaf level net radiation updated way
! reference Chen2012 clumping index paper
  IF (shortrad_global .GT. zero .AND. coszs .GT. zero) THEN
    shortradleaf_o_dir = 0.5*shortrad_dir/coszs
    IF (shortradleaf_o_dir .GT. 0.7*1362.) THEN
      shortradleaf_o_dir = 0.7*1362.
    ELSE
      shortradleaf_o_dir = shortradleaf_o_dir
    END IF
    shortradleaf_u_dir = shortradleaf_o_dir
    temp1 = (shortrad_df-shortrad_df*gap_os_df)/lai_os
    temp0 = EXP(-coszs)
    DO nd=1,nbdirs
      shortradleaf_o_df_fw(nd) = (-(shortrad_df*gap_os_df_fw(nd))-temp1*&
&       lai_os_fw(nd))/lai_os - temp0*shortrad_dir*0.07*0.1*lai_os_fw(nd&
&       )
    END DO
    shortradleaf_o_df = temp1 + temp0*(shortrad_dir*0.07*(1.1-0.1*lai_os&
&     ))
    temp1 = (shortrad_df*gap_o_df-shortrad_df*gap_o_df*gap_us_df)/lai_us
    temp0 = EXP(-coszs)
    DO nd=1,nbdirs
      shortradleaf_u_df_fw(nd) = (shortrad_df*gap_o_df_fw(nd)-&
&       shortrad_df*(gap_us_df*gap_o_df_fw(nd)+gap_o_df*gap_us_df_fw(nd)&
&       )-temp1*lai_us_fw(nd))/lai_us + temp0*shortrad_dir*0.05*((1.1-&
&       0.1*lai_us)*gap_o_dir_fw(nd)-gap_o_dir*0.1*lai_us_fw(nd))
    END DO
    shortradleaf_u_df = temp1 + temp0*(shortrad_dir*0.05*(gap_o_dir*(1.1&
&     -0.1*lai_us)))
  ELSE
    shortradleaf_o_dir = 0.
    shortradleaf_u_dir = 0.
    shortradleaf_o_df = 0.
    shortradleaf_u_df = 0.
    shortradleaf_u_df_fw(:) = 0.0_8
    shortradleaf_o_df_fw(:) = 0.0_8
  END IF
!overstorey sunlit leaves
  IF (lai_o_sunlit .GT. 0.) THEN
    DO nd=1,nbdirs
      netshortradleaf_o_sunlit_fw(nd) = (1.-albedo_o)*&
&       shortradleaf_o_df_fw(nd) - (shortradleaf_o_dir+shortradleaf_o_df&
&       )*albedo_o_fw(nd)
!leaf level net long
      netlongradleaf_o_sunlit_fw(nd) = (netlongrad_o_fw(nd)-netlongrad_o&
&       *lai_os_fw(nd)/lai_os)/lai_os
      netradleaf_o_sunlit_fw(nd) = netshortradleaf_o_sunlit_fw(nd) + &
&       netlongradleaf_o_sunlit_fw(nd)
    END DO
    netshortradleaf_o_sunlit = (shortradleaf_o_dir+shortradleaf_o_df)*(&
&     1.-albedo_o)
    netlongradleaf_o_sunlit = netlongrad_o/lai_os
    netradleaf_o_sunlit = netshortradleaf_o_sunlit + &
&     netlongradleaf_o_sunlit
  ELSE
    DO nd=1,nbdirs
      netshortradleaf_o_sunlit_fw(nd) = (1.-albedo_o)*&
&       shortradleaf_o_df_fw(nd) - (shortradleaf_o_dir+shortradleaf_o_df&
&       )*albedo_o_fw(nd)
      netlongradleaf_o_sunlit_fw(nd) = netlongrad_o_fw(nd)
      netradleaf_o_sunlit_fw(nd) = netshortradleaf_o_sunlit_fw(nd) + &
&       netlongradleaf_o_sunlit_fw(nd)
    END DO
    netshortradleaf_o_sunlit = (shortradleaf_o_dir+shortradleaf_o_df)*(&
&     1.-albedo_o)
    netlongradleaf_o_sunlit = netlongrad_o
    netradleaf_o_sunlit = netshortradleaf_o_sunlit + &
&     netlongradleaf_o_sunlit
  END IF
!overstorey shaded leaves
  IF (lai_o_shaded .GT. 0.) THEN
    DO nd=1,nbdirs
      netshortradleaf_o_shaded_fw(nd) = (1.-albedo_o)*&
&       shortradleaf_o_df_fw(nd) - shortradleaf_o_df*albedo_o_fw(nd)
      netlongradleaf_o_shaded_fw(nd) = (netlongrad_o_fw(nd)-netlongrad_o&
&       *lai_os_fw(nd)/lai_os)/lai_os
      netradleaf_o_shaded_fw(nd) = netshortradleaf_o_shaded_fw(nd) + &
&       netlongradleaf_o_shaded_fw(nd)
    END DO
    netshortradleaf_o_shaded = shortradleaf_o_df*(1.-albedo_o)
    netlongradleaf_o_shaded = netlongrad_o/lai_os
    netradleaf_o_shaded = netshortradleaf_o_shaded + &
&     netlongradleaf_o_shaded
  ELSE
    DO nd=1,nbdirs
      netshortradleaf_o_shaded_fw(nd) = (1.-albedo_o)*&
&       shortradleaf_o_df_fw(nd) - shortradleaf_o_df*albedo_o_fw(nd)
      netlongradleaf_o_shaded_fw(nd) = netlongrad_o_fw(nd)
      netradleaf_o_shaded_fw(nd) = netshortradleaf_o_shaded_fw(nd) + &
&       netlongradleaf_o_shaded_fw(nd)
    END DO
    netshortradleaf_o_shaded = shortradleaf_o_df*(1.-albedo_o)
    netlongradleaf_o_shaded = netlongrad_o
    netradleaf_o_shaded = netshortradleaf_o_shaded + &
&     netlongradleaf_o_shaded
  END IF
!understorey sunlit leaf
  IF (lai_u_sunlit .GT. 0.) THEN
    DO nd=1,nbdirs
      netshortradleaf_u_sunlit_fw(nd) = (1.-albedo_u)*&
&       shortradleaf_u_df_fw(nd) - (shortradleaf_u_dir+shortradleaf_u_df&
&       )*albedo_u_fw(nd)
      netlongradleaf_u_sunlit_fw(nd) = (netlongrad_u_fw(nd)-netlongrad_u&
&       *lai_us_fw(nd)/lai_us)/lai_us
      netradleaf_u_sunlit_fw(nd) = netshortradleaf_u_sunlit_fw(nd) + &
&       netlongradleaf_u_sunlit_fw(nd)
    END DO
    netshortradleaf_u_sunlit = (shortradleaf_u_dir+shortradleaf_u_df)*(&
&     1.-albedo_u)
    netlongradleaf_u_sunlit = netlongrad_u/lai_us
    netradleaf_u_sunlit = netshortradleaf_u_sunlit + &
&     netlongradleaf_u_sunlit
  ELSE
    DO nd=1,nbdirs
      netshortradleaf_u_sunlit_fw(nd) = (1.-albedo_u)*&
&       shortradleaf_u_df_fw(nd) - (shortradleaf_u_dir+shortradleaf_u_df&
&       )*albedo_u_fw(nd)
      netlongradleaf_u_sunlit_fw(nd) = netlongrad_u_fw(nd)
      netradleaf_u_sunlit_fw(nd) = netshortradleaf_u_sunlit_fw(nd) + &
&       netlongradleaf_u_sunlit_fw(nd)
    END DO
    netshortradleaf_u_sunlit = (shortradleaf_u_dir+shortradleaf_u_df)*(&
&     1.-albedo_u)
    netlongradleaf_u_sunlit = netlongrad_u
    netradleaf_u_sunlit = netshortradleaf_u_sunlit + &
&     netlongradleaf_u_sunlit
  END IF
!understorey shaded leaf
  IF (lai_u_shaded .GT. 0.) THEN
    DO nd=1,nbdirs
      netshortradleaf_u_shaded_fw(nd) = (1.-albedo_u)*&
&       shortradleaf_u_df_fw(nd) - shortradleaf_u_df*albedo_u_fw(nd)
      netlongradleaf_u_shaded_fw(nd) = (netlongrad_u_fw(nd)-netlongrad_u&
&       *lai_us_fw(nd)/lai_us)/lai_us
      netradleaf_u_shaded_fw(nd) = netshortradleaf_u_shaded_fw(nd) + &
&       netlongradleaf_u_shaded_fw(nd)
    END DO
    netshortradleaf_u_shaded = shortradleaf_u_df*(1.-albedo_u)
    netlongradleaf_u_shaded = netlongrad_u/lai_us
    netradleaf_u_shaded = netshortradleaf_u_shaded + &
&     netlongradleaf_u_shaded
  ELSE
    DO nd=1,nbdirs
      netshortradleaf_u_shaded_fw(nd) = (1.-albedo_u)*&
&       shortradleaf_u_df_fw(nd) - shortradleaf_u_df*albedo_u_fw(nd)
      netlongradleaf_u_shaded_fw(nd) = netlongrad_u_fw(nd)
      netradleaf_u_shaded_fw(nd) = netshortradleaf_u_shaded_fw(nd) + &
&       netlongradleaf_u_shaded_fw(nd)
    END DO
    netshortradleaf_u_shaded = shortradleaf_u_df*(1.-albedo_u)
    netlongradleaf_u_shaded = netlongrad_u
    netradleaf_u_shaded = netshortradleaf_u_shaded + &
&     netlongradleaf_u_shaded
  END IF
END SUBROUTINE NETRADIATION_FWV

!  Differentiation of sensibleheat in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: sh_o
!   with respect to varying inputs: lai_o_sunlit templ_o_sunlit
!                lai_o_shaded templ_o_shaded gheat_o_sunlit gheat_o_shaded
! this module will calculate sensible heat from overstorey,understorey, and ground editted by XZ Luo, May23,2015
! inputs: 
! temperature of sunlit and shaded leaves from other storey (leaf temperature module)
! temperature of air,relative humidity
! temperature of ground (soil heat flux module)
! aerodynamic heat conductance of sunlit shaded leaves from over/understorey
! aerodynamic heat conductance of ground
! lAI sunlit and shaded, over/understorey (LAI module)
! Outputs:
! sensible heat from over/understorey and ground
SUBROUTINE SENSIBLEHEAT_FWV(templ_o_sunlit, templ_o_sunlit_fw, &
& templ_o_shaded, templ_o_shaded_fw, templ_u_sunlit, templ_u_shaded, &
& temp_g, temp_air, rh_air, gheat_o_sunlit, gheat_o_sunlit_fw, &
& gheat_o_shaded, gheat_o_shaded_fw, gheat_u_sunlit, gheat_u_shaded, &
& gheat_g, lai_o_sunlit, lai_o_sunlit_fw, lai_o_shaded, lai_o_shaded_fw&
& , lai_u_sunlit, lai_u_shaded, sh_o, sh_o_fw, sh_u, sh_g, nbdirs)
  USE METEOMOD_DIFFV
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
  REAL(r8), INTENT(IN) :: templ_o_sunlit, templ_o_shaded, templ_u_sunlit&
& , templ_u_shaded, temp_g, temp_air, rh_air
  REAL(r8), DIMENSION(nbdirsmax), INTENT(IN) :: templ_o_sunlit_fw, &
& templ_o_shaded_fw
  REAL(r8), INTENT(IN) :: gheat_o_sunlit, gheat_o_shaded, gheat_u_sunlit&
& , gheat_u_shaded, gheat_g
  REAL(r8), DIMENSION(nbdirsmax), INTENT(IN) :: gheat_o_sunlit_fw, &
& gheat_o_shaded_fw
  REAL(r8), INTENT(IN) :: lai_o_sunlit, lai_o_shaded, lai_u_sunlit, &
& lai_u_shaded
  REAL(r8), DIMENSION(nbdirsmax), INTENT(IN) :: lai_o_sunlit_fw, &
& lai_o_shaded_fw
  REAL(r8), INTENT(OUT) :: sh_o, sh_u, sh_g
  REAL(r8), DIMENSION(nbdirsmax), INTENT(OUT) :: sh_o_fw
  REAL(r8) :: sh_o_sunlit, sh_o_shaded, sh_u_sunlit, sh_u_shaded
  REAL(r8), DIMENSION(nbdirsmax) :: sh_o_sunlit_fw, sh_o_shaded_fw
  INTRINSIC MAX
  INTEGER :: nd
  INTEGER :: nbdirs
  CALL METEO_PACK(temp_air, rh_air)
  sh_o_sunlit = (templ_o_sunlit-temp_air)*density_air*cp_air*&
&   gheat_o_sunlit
  sh_o_shaded = (templ_o_shaded-temp_air)*density_air*cp_air*&
&   gheat_o_shaded
  DO nd=1,nbdirs
    sh_o_sunlit_fw(nd) = density_air*cp_air*(gheat_o_sunlit*&
&     templ_o_sunlit_fw(nd)+(templ_o_sunlit-temp_air)*gheat_o_sunlit_fw(&
&     nd))
    sh_o_shaded_fw(nd) = density_air*cp_air*(gheat_o_shaded*&
&     templ_o_shaded_fw(nd)+(templ_o_shaded-temp_air)*gheat_o_shaded_fw(&
&     nd))
    sh_o_fw(nd) = lai_o_sunlit*sh_o_sunlit_fw(nd) + sh_o_sunlit*&
&     lai_o_sunlit_fw(nd) + lai_o_shaded*sh_o_shaded_fw(nd) + &
&     sh_o_shaded*lai_o_shaded_fw(nd)
  END DO
  sh_u_sunlit = (templ_u_sunlit-temp_air)*density_air*cp_air*&
&   gheat_u_sunlit
  sh_u_shaded = (templ_u_shaded-temp_air)*density_air*cp_air*&
&   gheat_u_shaded
  sh_o = sh_o_sunlit*lai_o_sunlit + sh_o_shaded*lai_o_shaded
  sh_u = sh_u_sunlit*lai_u_sunlit + sh_u_shaded*lai_u_shaded
  IF (-200. .LT. sh_o) THEN
    sh_o = sh_o
  ELSE
    sh_o = -200.
    sh_o_fw(:) = 0.0_8
  END IF
  IF (-200. .LT. sh_u) THEN
    sh_u = sh_u
  ELSE
    sh_u = -200.
  END IF
  sh_g = (temp_g-temp_air)*density_air*cp_air*gheat_g
  RETURN
END SUBROUTINE SENSIBLEHEAT_FWV

!  Differentiation of retrive_soilp in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: *(soilstat.dt) *(soilstat.ksat)
!                *(soilstat.b) *(soilstat.ice_ratio) *(soilstat.thetam)
!                *(soilstat.thetam_prev) *(soilstat.temp_soil_p)
!                *(soilstat.temp_soil_c) *(soilstat.f_ice) *(soilstat.psim)
!                *(soilstat.thetab) *(soilstat.psib) *(soilstat.r_waterflow)
!                *(soilstat.km) *(soilstat.kb) *(soilstat.kk) *(soilstat.cs)
!                *(soilstat.lambda) *(soilstat.ett) *(soilstat.g)
!                soilp.dt soilp.ksat soilp.b soilp.ice_ratio soilp.thetam
!                soilp.thetam_prev soilp.temp_soil_p soilp.temp_soil_c
!                soilp.f_ice soilp.psim soilp.thetab soilp.psib
!                soilp.r_waterflow soilp.km soilp.kb soilp.kk soilp.cs
!                soilp.lambda soilp.ett soilp.g
!   with respect to varying inputs: *(soilstat.dt) *(soilstat.ksat)
!                *(soilstat.b) *(soilstat.ice_ratio) *(soilstat.thetam)
!                *(soilstat.thetam_prev) *(soilstat.temp_soil_p)
!                *(soilstat.temp_soil_c) *(soilstat.f_ice) *(soilstat.psim)
!                *(soilstat.thetab) *(soilstat.psib) *(soilstat.r_waterflow)
!                *(soilstat.km) *(soilstat.kb) *(soilstat.kk) *(soilstat.cs)
!                *(soilstat.lambda) *(soilstat.ett) *(soilstat.g)
!                soilp.dt soilp.ksat soilp.b soilp.ice_ratio soilp.thetam
!                soilp.thetam_prev soilp.temp_soil_p soilp.temp_soil_c
!                soilp.f_ice soilp.psim soilp.thetab soilp.psib
!                soilp.r_waterflow soilp.km soilp.kb soilp.kk soilp.cs
!                soilp.lambda soilp.ett soilp.g
!   Plus diff mem management of: soilstat.zp:in soilstat.zsp:in
!                soilstat.r_rain_g:in soilstat.r_drainage:in soilstat.r_root_decay:in
!                soilstat.psi_min:in soilstat.alpha:in soilstat.f_soilwater:in
!                soilstat.d_soil:in soilstat.f_root:in soilstat.dt:in
!                soilstat.thermal_cond:in soilstat.theta_vfc:in
!                soilstat.theta_vwp:in soilstat.fei:in soilstat.ksat:in
!                soilstat.psi_sat:in soilstat.b:in soilstat.density_soil:in
!                soilstat.f_org:in soilstat.ice_ratio:in soilstat.thetam:in
!                soilstat.thetam_prev:in soilstat.temp_soil_p:in
!                soilstat.temp_soil_c:in soilstat.f_ice:in soilstat.psim:in
!                soilstat.thetab:in soilstat.psib:in soilstat.r_waterflow:in
!                soilstat.km:in soilstat.kb:in soilstat.kk:in soilstat.cs:in
!                soilstat.lambda:in soilstat.ett:in soilstat.g:in
!!*******************************************
!! This module is used to get/put soilp data at single point
!! from global datasets
!! flag =0: get from ; flag=1: put into
!! Created by J.Wang
!!*******************************************
SUBROUTINE RETRIVE_SOILP_FWV(soilp, soilp_fw, i, j, flag, nbdirs)
  USE BEPSTYPE_DIFFV
  USE BEPS_SOILMOD_DIFFV
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
  TYPE(SOIL) :: soilp
  TYPE(SOIL_DIFFV) :: soilp_fw
  INTEGER :: i, j, flag
  TYPE(SOILS), POINTER :: p
  TYPE(SOILS_DIFFV), POINTER :: p_fw
  INTERFACE 
      SUBROUTINE ENDRUN(msg)
        IMPLICIT NONE
        CHARACTER(len=*), INTENT(IN), OPTIONAL :: msg
      END SUBROUTINE ENDRUN
  END INTERFACE

  INTEGER :: nd
  INTEGER :: nbdirs
  p_fw => soilstat_fw
  p => soilstat
  IF (i .GT. npoints .OR. j .GT. pft) CALL ENDRUN(&
&                           'out of the range of spatial points or PFTs'&
&                                          )
  IF (flag .EQ. 0) THEN
! getting data
    soilp%n_layer = p%n_layer(i)
    soilp%zp = p%zp(i, j)
    soilp%zsp = p%zsp(i, j)
    soilp%r_rain_g = p%r_rain_g(i, j)
    soilp%r_drainage = p%r_drainage(i, j)
    soilp%r_root_decay = p%r_root_decay(i, j)
    soilp%psi_min = p%psi_min(i, j)
    soilp%alpha = p%alpha(i, j)
    soilp%f_soilwater = p%f_soilwater(i, j)
    soilp%d_soil(:) = p%d_soil(i, :)
    soilp%f_root(:) = p%f_root(i, :, j)
    DO nd=1,nbdirs
      soilp_fw%dt(nd, :) = p_fw%dt(nd, i, :, j)
      soilp_fw%ksat(nd, :) = p_fw%ksat(nd, i, :, j)
      soilp_fw%b(nd, :) = p_fw%b(nd, i, :, j)
      soilp_fw%ice_ratio(nd, :) = p_fw%ice_ratio(nd, i, :, j)
      soilp_fw%thetam(nd, :) = p_fw%thetam(nd, i, :, j)
      soilp_fw%thetam_prev(nd, :) = p_fw%thetam_prev(nd, i, :, j)
      soilp_fw%temp_soil_p(nd, :) = p_fw%temp_soil_p(nd, i, :, j)
      soilp_fw%temp_soil_c(nd, :) = p_fw%temp_soil_c(nd, i, :, j)
      soilp_fw%f_ice(nd, :) = p_fw%f_ice(nd, i, :, j)
      soilp_fw%psim(nd, :) = p_fw%psim(nd, i, :, j)
      soilp_fw%thetab(nd, :) = p_fw%thetab(nd, i, :, j)
      soilp_fw%psib(nd, :) = p_fw%psib(nd, i, :, j)
      soilp_fw%r_waterflow(nd, :) = p_fw%r_waterflow(nd, i, :, j)
      soilp_fw%km(nd, :) = p_fw%km(nd, i, :, j)
      soilp_fw%kb(nd, :) = p_fw%kb(nd, i, :, j)
      soilp_fw%kk(nd, :) = p_fw%kk(nd, i, :, j)
      soilp_fw%cs(nd, :) = p_fw%cs(nd, i, :, j)
      soilp_fw%lambda(nd, :) = p_fw%lambda(nd, i, :, j)
      soilp_fw%ett(nd, :) = p_fw%ett(nd, i, :, j)
      soilp_fw%g(nd, :) = p_fw%g(nd, i, :, j)
    END DO
    soilp%dt(:) = p%dt(i, :, j)
    soilp%thermal_cond(:) = p%thermal_cond(i, :, j)
    soilp%theta_vfc(:) = p%theta_vfc(i, :, j)
    soilp%theta_vwp(:) = p%theta_vwp(i, :, j)
    soilp%fei(:) = p%fei(i, :, j)
    soilp%ksat(:) = p%ksat(i, :, j)
    soilp%psi_sat(:) = p%psi_sat(i, :, j)
    soilp%b(:) = p%b(i, :, j)
    soilp%density_soil(:) = p%density_soil(i, :)
    soilp%f_org(:) = p%f_org(i, :, j)
    soilp%ice_ratio(:) = p%ice_ratio(i, :, j)
    soilp%thetam(:) = p%thetam(i, :, j)
    soilp%thetam_prev(:) = p%thetam_prev(i, :, j)
    soilp%temp_soil_p(:) = p%temp_soil_p(i, :, j)
    soilp%temp_soil_c(:) = p%temp_soil_c(i, :, j)
    soilp%f_ice(:) = p%f_ice(i, :, j)
    soilp%psim(:) = p%psim(i, :, j)
    soilp%thetab(:) = p%thetab(i, :, j)
    soilp%psib(:) = p%psib(i, :, j)
    soilp%r_waterflow(:) = p%r_waterflow(i, :, j)
    soilp%km(:) = p%km(i, :, j)
    soilp%kb(:) = p%kb(i, :, j)
    soilp%kk(:) = p%kk(i, :, j)
    soilp%cs(:) = p%cs(i, :, j)
    soilp%lambda(:) = p%lambda(i, :, j)
    soilp%ett(:) = p%ett(i, :, j)
    soilp%g(:) = p%g(i, :, j)
  ELSE IF (flag .EQ. 1) THEN
!! storing data
    p%n_layer(i) = soilp%n_layer
    p%zp(i, j) = soilp%zp
    p%zsp(i, j) = soilp%zsp
    p%r_rain_g(i, j) = soilp%r_rain_g
    p%r_drainage(i, j) = soilp%r_drainage
    p%r_root_decay(i, j) = soilp%r_root_decay
    p%psi_min(i, j) = soilp%psi_min
    p%alpha(i, j) = soilp%alpha
    p%f_soilwater(i, j) = soilp%f_soilwater
    p%d_soil(i, :) = soilp%d_soil(:)
    p%f_root(i, :, j) = soilp%f_root(:)
    DO nd=1,nbdirs
      p_fw%dt(nd, i, :, j) = soilp_fw%dt(nd, :)
      p_fw%ksat(nd, i, :, j) = soilp_fw%ksat(nd, :)
      p_fw%b(nd, i, :, j) = soilp_fw%b(nd, :)
      p_fw%ice_ratio(nd, i, :, j) = soilp_fw%ice_ratio(nd, :)
      p_fw%thetam(nd, i, :, j) = soilp_fw%thetam(nd, :)
      p_fw%thetam_prev(nd, i, :, j) = soilp_fw%thetam_prev(nd, :)
      p_fw%temp_soil_p(nd, i, :, j) = soilp_fw%temp_soil_p(nd, :)
      p_fw%temp_soil_c(nd, i, :, j) = soilp_fw%temp_soil_c(nd, :)
      p_fw%f_ice(nd, i, :, j) = soilp_fw%f_ice(nd, :)
      p_fw%psim(nd, i, :, j) = soilp_fw%psim(nd, :)
      p_fw%thetab(nd, i, :, j) = soilp_fw%thetab(nd, :)
      p_fw%psib(nd, i, :, j) = soilp_fw%psib(nd, :)
      p_fw%r_waterflow(nd, i, :, j) = soilp_fw%r_waterflow(nd, :)
      p_fw%km(nd, i, :, j) = soilp_fw%km(nd, :)
      p_fw%kb(nd, i, :, j) = soilp_fw%kb(nd, :)
      p_fw%kk(nd, i, :, j) = soilp_fw%kk(nd, :)
      p_fw%cs(nd, i, :, j) = soilp_fw%cs(nd, :)
      p_fw%lambda(nd, i, :, j) = soilp_fw%lambda(nd, :)
      p_fw%ett(nd, i, :, j) = soilp_fw%ett(nd, :)
      p_fw%g(nd, i, :, j) = soilp_fw%g(nd, :)
    END DO
    p%dt(i, :, j) = soilp%dt(:)
    p%thermal_cond(i, :, j) = soilp%thermal_cond(:)
    p%theta_vfc(i, :, j) = soilp%theta_vfc(:)
    p%theta_vwp(i, :, j) = soilp%theta_vwp(:)
    p%fei(i, :, j) = soilp%fei(:)
    p%ksat(i, :, j) = soilp%ksat(:)
    p%psi_sat(i, :, j) = soilp%psi_sat(:)
    p%b(i, :, j) = soilp%b(:)
    p%density_soil(i, :) = soilp%density_soil(:)
    p%f_org(i, :, j) = soilp%f_org(:)
    p%ice_ratio(i, :, j) = soilp%ice_ratio(:)
    p%thetam(i, :, j) = soilp%thetam(:)
    p%thetam_prev(i, :, j) = soilp%thetam_prev(:)
    p%temp_soil_p(i, :, j) = soilp%temp_soil_p(:)
    p%temp_soil_c(i, :, j) = soilp%temp_soil_c(:)
    p%f_ice(i, :, j) = soilp%f_ice(:)
    p%psim(i, :, j) = soilp%psim(:)
    p%thetab(i, :, j) = soilp%thetab(:)
    p%psib(i, :, j) = soilp%psib(:)
    p%r_waterflow(i, :, j) = soilp%r_waterflow(:)
    p%km(i, :, j) = soilp%km(:)
    p%kb(i, :, j) = soilp%kb(:)
    p%kk(i, :, j) = soilp%kk(:)
    p%cs(i, :, j) = soilp%cs(:)
    p%lambda(i, :, j) = soilp%lambda(:)
    p%ett(i, :, j) = soilp%ett(:)
    p%g(i, :, j) = soilp%g(:)
  END IF
END SUBROUTINE RETRIVE_SOILP_FWV

!  Differentiation of initf in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   Plus diff mem management of: output.gpppft:out output.sifpft:out
!                output.sifpft_sat:out output.npppft:out output.neppft:out
!                output.shpft:out output.lhpft:out output.transpft:out
!                output.evappft:out output.net_radpft:out output.sif:out
!                output.laipft:out output.thetampft:out output.thetam:out
!                output.faparpft:out output.vodpft:out output.cos_fluxpft:out
!                output.cos_flux:out assim.p_vcmax:out assim.p_vj_slope:out
!                assim.p_sif_alpha:out assim.p_sif_beta:out assim.p_ksat_scalar:out
!                assim.p_b_scalar:out assim.p_f_leaf:out soilstat.zp:out
!                soilstat.zsp:out soilstat.r_rain_g:out soilstat.r_drainage:out
!                soilstat.r_root_decay:out soilstat.psi_min:out
!                soilstat.alpha:out soilstat.f_soilwater:out soilstat.d_soil:out
!                soilstat.f_root:out soilstat.dt:out soilstat.thermal_cond:out
!                soilstat.theta_vfc:out soilstat.theta_vwp:out
!                soilstat.fei:out soilstat.ksat:out soilstat.psi_sat:out
!                soilstat.b:out soilstat.density_soil:out soilstat.f_org:out
!                soilstat.ice_ratio:out soilstat.thetam:out soilstat.thetam_prev:out
!                soilstat.temp_soil_p:out soilstat.temp_soil_c:out
!                soilstat.f_ice:out soilstat.psim:out soilstat.thetab:out
!                soilstat.psib:out soilstat.r_waterflow:out soilstat.km:out
!                soilstat.kb:out soilstat.kk:out soilstat.cs:out
!                soilstat.lambda:out soilstat.ett:out soilstat.g:out
!                v2last:out
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!> \file bepsfunc_setup.F90
!> \brief provides interfaces for setup and configuration of running
!>        the functional implementation of BEPS as
!>        suitable for use within sensitivity and optimisation framework.
!>
!> \authors The Inversion Lab (Michael Vossbeck, Thomas Kaminski) 
!> \date  January 2020
!> \last  June 2022
!                               
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!***********************************************************
!     initf
!
!> @brief determines sizes of control vector (n) and overall size of
!>        simulation vector (m)
!>        In addition necessary initialisations to actually run selected observational operator(s)
!>        need to be performed.
!
!> @details 
!
!> @param[out]  n  overall length of control vector
!> @param[out]  m  overall length of simulation vector
!
!> \authors Michael Vossbeck, The Inversion Lab
!> \date    January 2020
SUBROUTINE INITF_FWV(n, m, nbdirs)
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE CONTROLINPUT_MOD_DIFFV
  USE BEPS_TIME_MANAGER, ONLY : set_timemgr_init, timemgr_init, &
& get_curr_date, advance_timestep, is_last_step, get_doys, &
& get_curr_calday, get_nstep, get_start_date, timemgr_diff_secs
  USE BEPSTYPE_DIFFV
  USE BEPSTYPEINIT_DIFFV
  USE RESTART_DIFFV
  USE ESMF, ONLY : esmf_initialize
  USE MO_BEPSFUNC_CTL
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
!- arguments
  INTEGER, INTENT(OUT) :: n, m
!-local variables
  CHARACTER(len=*), PARAMETER :: sub='initf_fwv::'
  LOGICAL :: ldebug
  CHARACTER(len=32) :: fmt
  INTRINSIC TRIM
  EXTERNAL NCREADOBS
  CHARACTER(len=4) :: result1
  INTEGER :: nbdirs
!-- init
  ldebug = .false.
  n = -1
  m = -1
!! setting up MPI enviroments with the namelists
!   call Initmpi()
  CALL RDNAMELIST()
  IF (nscale .EQ. 1) THEN
    nlp = n_site
    npoints = nlp
    WRITE(*, '(a,2(a,i3,1x))') ' INFO::'//sub, 'nlp=', nlp, 'npoints=', &
&   npoints
    WRITE(*, *) 'site points check', npoints
  END IF
!! Initialize the beps types
  CALL INITBEPSTYPE_FWV(nbdirs)
!! Initialize output
  CALL INIT_OUTPUT()
!--------------------------------------------------------------------------
! Initialize ESMF.  This is done outside of the ESMF_INTERFACE ifdef
! because it is needed for the time manager, even if the ESMF_INTERFACE
! is not used.
!--------------------------------------------------------------------------
  CALL ESMF_INITIALIZE()
!! setting time manager
  IF (nsrest .EQ. nsrstartup) THEN
!!! calling time_manager set init
    CALL SET_TIMEMGR_INIT(calendar_in=calendar, start_ymd_in=icdate, &
&                   start_tod_in=icsec, nelapse_in=sim_duration, &
&                   dtime_in=step)
  ELSE IF (nsrest .EQ. nsrcontinue) THEN
    CALL RESTART_IO('read')
    CALL SET_TIMEMGR_INIT(calendar_in=calendar, start_ymd_in=rst_icdate&
&                   , start_tod_in=rst_icsec, nelapse_in=sim_duration, &
&                   dtime_in=step)
  END IF
  CALL TIMEMGR_INIT()
  IF (nscale .EQ. 0) THEN
! nscale = 0 for global simulation, 1 for site simulation
    WRITE(*, '(a)') ' INFO::'//sub//'BEPS run at global scale!'
!! Reading boundary fields, yearly data,and soil Cpools for BEPS @J.Wang (note: if yearly and C pools data fields will change yea
!r by year, these datasets should be read in the time looping
    CALL READ_BOUNDARY()
    CALL READ_YRDATA()
    CALL READ_CPOOLS()
  ELSE
    WRITE(*, '(a)') ' INFO::'//sub//&
&   'BEPS run at site / multiple-point scale!'
! read site data, including yrdata, boundary data, and carbon pools
    CALL READ_BOUNDARY_SITE()
  END IF
!-- get number of time steps
  CALL BEPS_TIME_SETUP(ntp)
!-- iLab::we do have 'nsimvar' simulated variables,
!         'ntp' timesteps and 'nlp' land points (i.e. sites)
!         toplevel function 'bepsf_timesum' (see bepsfunc.F90) build temporal sum over
!         variables:
  m = ntp*nlp*nsimvar
!
  result1 = IFMT(ntp)
  fmt = '(a,'//TRIM(result1)//')'
  WRITE(*, fmt) ' INFO::'//sub//' ntp=', ntp
  result1 = IFMT(nlp)
  fmt = '(a,'//TRIM(result1)//')'
  WRITE(*, fmt) ' INFO::'//sub//' nlp=', nlp
  result1 = IFMT(nsimvar)
  fmt = '(a,'//TRIM(result1)//')'
  WRITE(*, fmt) ' INFO::'//sub//' nsimvar=', nsimvar
  result1 = IFMT(m)
  fmt = '(a,1(a,'//TRIM(result1)//'),a)'
  WRITE(*, fmt) ' INFO::'//sub//' ...dependents DONE. (', 'm=', m, ')'
!MOUSONG WU,2020-09-21
! 1. the parameters to be optimized have been modified, thes parameters include p_Ksat,p_b,these two are soil texture differentia
!ted, in total 2*11,
! p_Vcmax,p_VJ_slope,sif_alpha,sif_beta,p_q10,p_D0,p_taueff, these are PFT differentiated, in total 7*9
! p_f_leaf,p_kc25,p_ko25,p_tau25,p_agbvod, in total 5*1
! Totally, 90 parameters are optimized in this new version. In practice, when we only focus on carbon fluxes, there might not be 
!so many parameters to be optimized, for example,
! the parameters related to SIF, VOD will not be optimized. this means that we have a maximum of 90 parameters to be optimized in
! this model.
! these parameters have been assigned with prior values and uncertainties.
!-- iLab::**7** PFT differentiated parameter (Vcmax,VJ_slope,Q10,sif_alpha,sif_beta,D0,taueff)
!         **2** texture differentiated parameter (Ksat, b)
!         **5** global parameter (f_leaf,kc25,ko25,tau25,agb2vod)
!-- CHANGED 06/2022: since VOD will not be assimilated, we can skip the respective parameters
!                    D0, taueff, agb2vod
!-- iLab::**5** PFT differentiated parameter (Vcmax,VJ_slope,Q10,sif_alpha,sif_beta)
!         **2** texture differentiated parameter (Ksat, b)
!         **4** global parameter (f_leaf,kc25,ko25,tau25)
  WRITE(*, '(a)') ' INFO::'//sub//&
& ' start determining number of parameter...'
  n = 5*pft + 2*texture + 4
!
  result1 = IFMT(n)
  fmt = '(a,1(a,'//TRIM(result1)//'),a)'
  WRITE(*, fmt) ' INFO::'//sub//' ...parameter DONE. (', 'n=', n, ')'
  CALL NCREADOBS(m, 'obs.nc')

CONTAINS
  FUNCTION IFMT(n) RESULT (fmt)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: n
    CHARACTER(len=4) :: fmt
    IF (n .LT. 10) THEN
      fmt = 'i1'
    ELSE IF (n .LT. 100) THEN
      fmt = 'i2'
    ELSE IF (n .LT. 1000) THEN
      fmt = 'i3'
    ELSE IF (n .LT. 10000) THEN
      fmt = 'i4'
    ELSE IF (n .LT. 100000) THEN
      fmt = 'i5'
    ELSE IF (n .LT. 1000000) THEN
      fmt = 'i6'
    ELSE IF (n .LT. 10000000) THEN
      fmt = 'i7'
    ELSE
      fmt = 'i15'
    END IF
  END FUNCTION IFMT

  SUBROUTINE BEPS_TIME_SETUP(nt)
    IMPLICIT NONE
! local declarations
    INTEGER, INTENT(OUT) :: nt
    INTEGER :: yr, mn, dy, tod
    INTEGER :: yr_ref, mn_ref, dy_ref, tod_ref
    INTEGER, ALLOCATABLE :: ymds(:, :)
    INTEGER :: it
    INTEGER :: caldy, doys, kount
    CHARACTER(len=*), PARAMETER :: sub='beps_time_setup'
    INTEGER :: arg1
    INTEGER :: arg2
!-- set timer to startup (very likely not necessary here)
    CALL TIMEMGR_INIT()
    IF (ldebug) OPEN(1, file='beps_times_1.asc', form='formatted', &
&              action='write') 
!-- take the first
!-- determine number of time-steps
    nt = 0
!! end time loop
timeloop:DO 
      nt = nt + 1
      CALL GET_CURR_DATE(yr, mn, dy, tod)
!-- take the first date as reference time/date
      IF (nt .EQ. 1) THEN
        IF (tod .NE. 0) THEN
          WRITE(*, '(1x,a)') 'FATAL::'//sub//&
&         'tod was expected to be zero for reference date!'
          STOP
        ELSE
          yr_ref = yr
          mn_ref = mn
          dy_ref = dy
          tod_ref = tod
          WRITE(ref_date(1:4), '(i4.4)') yr_ref
          WRITE(ref_date(5:5), '(a)') '-'
          WRITE(ref_date(6:7), '(i2.2)') mn_ref
          WRITE(ref_date(8:8), '(a)') '-'
          WRITE(ref_date(9:10), '(i2.2)') dy_ref
          WRITE(ref_date(11:19), '(a)') 'T00:00:00'
        END IF
      END IF
      IF (ldebug) THEN
        caldy = GET_CURR_CALDAY()
        doys = GET_DOYS(yr)
        kount = GET_NSTEP()
        WRITE(1, '(a,i3,1x,a,i4,1x,2(a,i2,1x),a,i5,1x,2(a,i3,1x),a,i3)')&
&       'nt=', nt, 'yr=', yr, 'mn=', mn, 'dy=', dy, 'tod=', tod, &
&       'caldy=', caldy, 'doys=', doys, 'kount=', kount
      END IF
!! advance time
      CALL ADVANCE_TIMESTEP()
      IF (IS_LAST_STEP()) THEN
        IF (ldebug) CLOSE(1) 
!-- allocate time-point array
!   NOTE:we store one time-point more for restart purpose
        ALLOCATE(time_points(6, nt+1))
        ALLOCATE(seconds_since_ref(nt))
!-- reset timer to first time-step
        CALL TIMEMGR_INIT()
        IF (ldebug) OPEN(1, file='beps_times_2.asc', form='formatted', &
&                  action='write') 
        it = 0
 ttloop:DO 
          it = it + 1
          CALL GET_CURR_DATE(yr, mn, dy, tod)
          IF (ldebug) THEN
            caldy = GET_CURR_CALDAY()
            doys = GET_DOYS(yr)
            kount = GET_NSTEP()
            WRITE(1, &
&           '(a,i3,1x,a,i4,1x,2(a,i2,1x),a,i5,1x,2(a,i3,1x),a,i3)') &
&           'nt=', it, 'yr=', yr, 'mn=', mn, 'dy=', dy, 'tod=', tod, &
&           'caldy=', caldy, 'doys=', doys, 'kount=', kount
          END IF
          time_points(1, it) = yr
          time_points(2, it) = mn
          time_points(3, it) = dy
          time_points(4, it) = tod
          time_points(5, it) = GET_CURR_CALDAY()
          time_points(6, it) = GET_DOYS(yr)
!-- seconds elapsed since reference date/time
          arg1 = yr_ref*10000 + mn_ref*100 + dy_ref
          arg2 = yr*10000 + mn*100 + dy
          CALL TIMEMGR_DIFF_SECS(arg1, tod_ref, arg2, tod, &
&                          seconds_since_ref(it))
!! advance time
          CALL ADVANCE_TIMESTEP()
          IF (IS_LAST_STEP()) THEN
!-- save first time-point *after* simulation period (restart)
            CALL GET_CURR_DATE(yr, mn, dy, tod)
            time_points(1, it+1) = yr
            time_points(2, it+1) = mn
            time_points(3, it+1) = dy
            time_points(4, it+1) = tod
            time_points(5, it+1) = GET_CURR_CALDAY()
            time_points(6, it+1) = GET_DOYS(yr)
            IF (ldebug) CLOSE(1) 
!-- reset timer to first time-step
            CALL TIMEMGR_INIT()
            GOTO 100
          END IF
        END DO ttloop
      END IF
    END DO timeloop
 100 CONTINUE
  END SUBROUTINE BEPS_TIME_SETUP

END SUBROUTINE INITF_FWV

!***********************************************************
!     get_nmeteo
!
!> @brief procedure to determine for a given point in time
!         (yr,mn,dy,tod) the corresponding index in the
!         meteorological forcing file.
!         The implementation to determine the index applies the
!         approach made by MSWU in driver.f90 (bepspkg_2020-09-21_essi)
!
!         ATTENTION::in the actual implementation the reference time
!                    is hard-coded to '2010-01-01' which equals the
!                    reference time of the meteorological forcing data
!                    (inputdata/beps_site/Site_meteo_2010_2015_hourly.nc)
!
!> \authors Michael Vossbeck, The Inversion Lab
!> \date    April 2021
!> \last    June 2022
SUBROUTINE GET_NMETEO_CDV(yr, mn, dy, tod, n_meteo)
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE BEPS_TIME_MANAGER, ONLY : timemgr_diff_secs
  USE CONTROLINPUT_MOD_DIFFV, ONLY : read_meteo_site_reftime
  USE BEPSTYPE_DIFFV, ONLY : clim
  IMPLICIT NONE
!-- arguments
  INTEGER, INTENT(IN) :: yr, mn, dy, tod
  INTEGER, INTENT(OUT) :: n_meteo
!-- local
  REAL(r8) :: secs_meteo
  INTEGER :: metyr, metmn, metdy
  INTEGER :: iostat
  INTRINSIC INT
  INTEGER :: arg1
  INTEGER :: arg2
  REAL(r8) :: arg10
!-- ensure reference time of meteorological forcing is available
  CALL READ_METEO_SITE_REFTIME()
!-- get year/month/day from reference date
  CALL STR2INT(clim%meteo_ref_yyyymmdd(1:4), metyr, iostat)
  CALL STR2INT(clim%meteo_ref_yyyymmdd(6:7), metmn, iostat)
  CALL STR2INT(clim%meteo_ref_yyyymmdd(9:10), metdy, iostat)
  arg1 = metyr*10000 + metmn*100 + metdy
  arg2 = yr*10000 + mn*100 + dy
  CALL TIMEMGR_DIFF_SECS(arg1, 0, arg2, tod, secs_meteo)
  arg10 = secs_meteo/3600 + 1
  n_meteo = INT(arg10)

CONTAINS
  ELEMENTAL SUBROUTINE STR2INT(str, int, iostat)
    IMPLICIT NONE
!-- arguments
    CHARACTER(len=*), INTENT(IN) :: str
    INTEGER, INTENT(OUT) :: int
    INTEGER, INTENT(OUT) :: iostat
    READ(str, *, iostat=iostat) int
  END SUBROUTINE STR2INT

END SUBROUTINE GET_NMETEO_CDV

!  Differentiation of x2beps in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: *(assim.p_vcmax) *(assim.p_vj_slope)
!                *(assim.p_sif_alpha) *(assim.p_sif_beta) *(assim.p_ksat_scalar)
!                *(assim.p_b_scalar) *(assim.p_f_leaf)
!   with respect to varying inputs: x
!   Plus diff mem management of: assim.p_vcmax:in assim.p_vj_slope:in
!                assim.p_sif_alpha:in assim.p_sif_beta:in assim.p_ksat_scalar:in
!                assim.p_b_scalar:in assim.p_f_leaf:in
!***********************************************************
!     x2beps
!
!> @brief maps one-dimensional (normalised) control vector
!>        to the respective physical BEPS parameter(s)
!>
!> @param[in]   n   length of control vector
!> @param[in]   x   control vector (in normalised units)
!
!> \authors Michael Vossbeck, The Inversion Lab
!> \date    February 2020
!>
SUBROUTINE X2BEPS_FWV(n, x, x_fw, nbdirs)
  USE MO_PRIOR
  USE BEPSTYPE_DIFFV, ONLY : assim, assim_fw
  USE BEPS_PAR, ONLY : pft, texture
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
!-- iLab::CHANGED 06/2022: D0,TAWEFF not required since VOD is not assimilated
! !-- agb2vod
! !   (...)
! i1 = i1+1
! assim%p_agb2vod = xphys(i1)
! arguments
  INTEGER, INTENT(IN) :: n
  REAL(kind=8), INTENT(IN) :: x(n)
  REAL(kind=8), INTENT(IN) :: x_fw(nbdirsmax, n)
! local declarations
  REAL(kind=8) :: xphys(n)
  REAL(kind=8) :: xphys_fw(nbdirsmax, n)
  INTEGER :: i1, i2
  INTEGER :: nd
  INTEGER :: nbdirs
!-- Vcmax
!   (for the 'Vcmax' parameter)
  i1 = 1
  i2 = i1 + pft - 1
  assim_fw%p_vcmax(:, :) = 0.0_8
  DO nd=1,nbdirs
!-- convert to phyiscal units
    xphys_fw(nd, :) = x_sigma*x_fw(nd, :)
    assim_fw%p_vcmax(nd, :) = xphys_fw(nd, i1:i2)
  END DO
  xphys = x*x_sigma
  assim%p_vcmax = xphys(i1:i2)
!-- VJ_slope
!   (...)
  i1 = i2 + 1
  i2 = i1 + pft - 1
  assim_fw%p_vj_slope(:, :) = 0.0_8
  DO nd=1,nbdirs
    assim_fw%p_vj_slope(nd, :) = xphys_fw(nd, i1:i2)
  END DO
  assim%p_vj_slope = xphys(i1:i2)
!-- Q10
!   (parameter to adjust 'q10' in calculation plant respiration)
  i1 = i2 + 1
  i2 = i1 + pft - 1
  assim%p_q10 = xphys(i1:i2)
!-- SIF alpha
!   (...)
  i1 = i2 + 1
  i2 = i1 + pft - 1
  assim_fw%p_sif_alpha(:, :) = 0.0_8
  DO nd=1,nbdirs
    assim_fw%p_sif_alpha(nd, :) = xphys_fw(nd, i1:i2)
  END DO
  assim%p_sif_alpha = xphys(i1:i2)
!-- SIF beta
!   (...)
  i1 = i2 + 1
  i2 = i1 + pft - 1
  assim_fw%p_sif_beta(:, :) = 0.0_8
  DO nd=1,nbdirs
    assim_fw%p_sif_beta(nd, :) = xphys_fw(nd, i1:i2)
  END DO
  assim%p_sif_beta = xphys(i1:i2)
!-- iLab::CHANGED 06/2022: D0,TAWEFF not required since VOD is not assimilated
! !-- D0
! !   (...)
! i1 = i2+1
! i2 = i1+PFT-1
! assim%p_D0     = xphys(i1:i2)
! !-- taueff
! !   (...)
! i1 = i2+1
! i2 = i1+PFT-1
! assim%p_taweff = xphys(i1:i2)
!-- Ksat
!   (parameter to adjust 'Ksat', the saturated hydraulic conductivity, in beps_soilMod.F90)
  i1 = i2 + 1
  i2 = i1 + texture - 1
  assim_fw%p_ksat_scalar(:, :) = 0.0_8
  DO nd=1,nbdirs
    assim_fw%p_ksat_scalar(nd, :) = xphys_fw(nd, i1:i2)
  END DO
  assim%p_ksat_scalar = xphys(i1:i2)
!-- b
!   (parameter to adjust 'b', the parameters for calculating soil water characteristic, in beps_soilMode.F90)
  i1 = i2 + 1
  i2 = i1 + texture - 1
  assim_fw%p_b_scalar(:, :) = 0.0_8
  DO nd=1,nbdirs
    assim_fw%p_b_scalar(nd, :) = xphys_fw(nd, i1:i2)
  END DO
  assim%p_b_scalar = xphys(i1:i2)
!-- f_leaf
!   (...)
  i1 = i2 + 1
  DO nd=1,nbdirs
    assim_fw%p_f_leaf(nd) = xphys_fw(nd, i1)
  END DO
  assim%p_f_leaf = xphys(i1)
!-- kc25
!   (...)
  i1 = i1 + 1
  assim%p_kc25 = xphys(i1)
!-- ko25
!   (...)
  i1 = i1 + 1
  assim%p_ko25 = xphys(i1)
!-- tau25
!   (...)
  i1 = i1 + 1
  assim%p_tau25 = xphys(i1)
END SUBROUTINE X2BEPS_FWV

!  Differentiation of devprior in forward (tangent) mode (with options noISIZE r8 multiDirectional):
!   variations   of useful results: priordiff
!   with respect to varying inputs: x
!       simple function
!       iLab
SUBROUTINE DEVPRIOR_FWV(n, x, x_fw, priordiff, priordiff_fw, nbdirs)
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
! arguments
  INTEGER(kind=4), INTENT(IN) :: n
  REAL(kind=8), INTENT(IN) :: x(n)
  REAL(kind=8), INTENT(IN) :: x_fw(nbdirsmax, n)
  REAL(kind=8), INTENT(OUT) :: priordiff(n)
  REAL(kind=8), INTENT(OUT) :: priordiff_fw(nbdirsmax, n)
! local
  REAL(kind=8) :: sx(n), x0(n)
  LOGICAL :: mask(n)
  INTEGER :: nd
  INTEGER :: nbdirs
! get prior
  CALL GETPRIOR(n, x0, sx, mask)
! x and x0 already normalised by sx
  priordiff_fw(:, :) = 0.0_8
  DO nd=1,nbdirs
    WHERE (mask) priordiff_fw(nd, :) = x_fw(nd, :)
  END DO
  WHERE (mask) priordiff = x - x0
  DO nd=1,nbdirs
    WHERE (.NOT.mask) priordiff_fw(nd, :) = 0.0_8
  END DO
  WHERE (.NOT.mask) priordiff = 0.
END SUBROUTINE DEVPRIOR_FWV

