!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!> \file runderiv.f90
!
!> DESCRIPTION: driver to test generated derivative codes of the BEPS model
!               generated by The Inversion Lab with AD tool Tapenade.
!
!               Depending on the preprocessor flag passed
!               (DERIV_FW,DERIV_BW,DERIV_FWV) this driver is capable to create
!               the Jacobian of the function 'evalf' based on
!               - scalar forward derivative
!               - scalar backward derivative
!               - vector forward deriative
!               code respectively.
!               
!
!> \date  March  2020
!> \last  April  2021
!                               
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!+++++++++++++++++++++++++++++++++++++++++++++++++
!
!                    main
!
!
program main
  use mo_bepsfunc_ctl, only:enable_netcdf_out
  implicit none

  !defaults
  ! handling cmdline
  integer::narg,cptArg !#of arg & counter of arg
  integer :: nconsumed
  character(len=32) :: argname !Arg name
  character(len=32) :: argval
  !--
  character(len=32) :: mode = 'jacfwv'

  !Check if any arguments are found
  narg=command_argument_count()
  !Loop over the arguments
  if(narg>0)then
     !loop across options
     nconsumed=0
     arg: do cptArg=1,narg
        if( nconsumed.gt.0 ) then
           nconsumed = nconsumed - 1
           cycle arg
        endif
        call get_command_argument(cptArg,argname)
        select case(adjustl(argname))
        case("--help","-h")
           write(*,'(/)')
           write(*,*)" This is program 'main'"
           call dump_options()
           stop 0
           exit arg
        case('--mode')
           call get_command_argument(cptArg+1, mode)
           nconsumed = 1
        case default
           write(*,*)"Option ",adjustl(argname),"unknown"
           write(*,'(a)') "Available options:"
           call dump_options()
           stop 0
        end select
     end do arg
  end if

  !-- disable NetCDF output generation when computing derivatives
  write(*, '(1x,a)') 'INFO::NetCDF output is disabled for derivative generation.'
  enable_netcdf_out = .false.
    
  select case( mode )
#ifdef DERIV_FW
  case ('jacfw')
     call jacobian_fw()
#endif
#ifdef DERIV_FWV
  case ('jacfwv')
     call jacobian_fwv()
#endif
#ifdef DERIV_BW
  case ('jacbw')
     call jacobian_bw()
#endif
  case default
     write(*,'(a)') ' FATAL::runbwcheck:unexpected mode ---'//trim(mode)//'---'
     stop 
  end select

contains

  subroutine dump_options()
    implicit none
    character(len=15) :: option
    write(*,'(a)') '=============================='
    write(*,*) " Options:"
    write(*,'(/)')
    option = "--mode"
    write(*,'(2x, a15,2x,a,a,a)') option,&
         &"which operation to apply "&
         &//"(default:",mode,")"
    write(*,'(2/)')
  end subroutine dump_options


#ifdef DERIV_FW
  !=================================================
  !
  !                    jacobian_fw
  !
  ! Purpose:
  ! - generate (small) Jacobian with tangent-linear derivative code
  !
  !=================================================
  subroutine jacobian_fw()
    implicit none
    ! local variables
    character(len=*), parameter :: method = 'jacobian_fw'
    character(len=*), parameter :: outname = 'jacobian.fw.asc'
    character(len=*), parameter :: boutname = 'jacobian.fw.b'
    integer :: n, m
    integer :: i
    real(kind=8), allocatable :: x(:), x0(:), sx(:), xfw(:)
    real(kind=8), allocatable :: y(:)
    real(kind=8), allocatable :: yjac(:,:) !-- holds derivative dy/dx
    real(kind=8) :: pert = 0._8
    integer :: iostat

    !-------------------
    !-- init model
    write(*, '(a)') ' INFO::'//method//':calling initf_fw...'
    call initf_fw(n, m)
    write(*, '(a,2(a,i5,1x),a)') ' INFO::'//method//':...initf_fw DONE. (',&
         'n=',n,'m=',m,')'

    !-------------------
    !     allocate arrays
    !
    allocate( x(n), x0(n), sx(n) )
    allocate( xfw(n), y(m), yjac(m,n) )

    !-------------------
    !     initialise control vector
    !
    call initx_cd(n, x0, sx)

    !-- controlvector for evaluation: either (potentially perturbed) prior or read from file 
    inquire(file='x-external.b', exist=exist)
    if( exist ) then
       write(*, '(a)') ' INFO::'//method//':reading parameter from file x-external.b'
       open(unit=1, file='x-external.b')
       read(1) x
       close(1)
    else
       x = x0*(1+pert)
    endif

    !-------------------
    !-- dump control vector
    !
    write(*, '(a,f5.2)' ) ' INFO::'//method//':'&
         'evaluating derivative at control vector:'
    write(*, '(2x,a2,1x,4(a25,1x))') 'i','x0', 'x', 'sx', 'xphys'
    ploop:do i=1,n
       write(*, '(2x,i2,1x,4(e25.16,1x))') i, x0(i), x(i), sx(i), x(i)*sx(i)
    enddo ploop  

    !
    ! Jacobian creation:
    !
    ! - running the forward-mode derivative
    !   for each independent (i.e. *column* of Jacobian)
    !
    do i=1,n
       xfw = 0._8
       xfw(i) = 1._8 !-- i-th direction only
       call evalf_fw(n, x, xfw, m, y, yjac(:,i))
    enddo

    !-------------------
    !-- write derivatives to file (ASCII and binary)
    write(*, '(a)')&
         ' INFO::'//method//'::writing derivatives to ASCII file ***'//trim(outname)//'***'
    open(1, file=outname, form='formatted', action='write')
    do i=1,m
       write(1, *) yjac(i,:)
    enddo
    close(1)
    write(*, '(a)')&
         ' INFO::'//method//'::writing derivatives to binary file ***'//trim(boutname)//'***'
    open(1, file=boutname, form='unformatted', action='write')
    write(1, iostat=iostat) yjac
    if( iostat.ne.0 ) then
       write(*, '(a)')&
         ' ERROR::'//method//'::I/O error when writing ***'//trim(boutname)//'***'
    else
       write(*, '(a)')&
         ' INFO::'//method//'::...writing DONE.'
    endif
    close(1)

    !-------------------
    !     deallocate arrays
    deallocate( x, x0, sx )
    deallocate( xfw, y, yjac)

  end subroutine jacobian_fw
#endif



#ifdef DERIV_FWV
  !=================================================
  !
  !                    jacobian_fwv
  !
  ! Purpose:
  ! - generate (small) Jacobian with vector tangent-linear derivative code
  !
  !=================================================
  subroutine jacobian_fwv()
    use diffsizes
    implicit none
    ! local variables
    character(len=*), parameter :: method = 'jacobian_fwv'
    character(len=*), parameter :: outname = 'jacobian.fwv.asc'
    character(len=*), parameter :: boutname = 'jacobian.fwv.b'
    integer :: n, m, nbdirs
    integer :: i
    real(kind=8), allocatable :: x(:), x0(:), sx(:), xfwv(:, :)
    real(kind=8), allocatable :: y(:)
    real(kind=8), allocatable :: yfwv(:,:), yjac(:,:) !-- holds derivative dy/dx
    real(kind=8) :: pert = 0._8
    integer :: iostat
    logical :: exist

    !-- we want the full Jacobian
    nbdirs = nbdirsmax
    
    !-------------------
    !-- init model
    write(*, '(a)') ' INFO::'//method//':calling initf_fwv...'
    call initf_fwv(n, m, nbdirs)
    write(*, '(a,3(a,i5,1x),a)') ' INFO::'//method//':...initf_fwv DONE. (',&
         'n=',n,'m=',m,'nbdirs=',nbdirs,')'
    !-- Expecting that derivative code is exactly prepared for size of Jacobian
    if( n.ne.nbdirsmax ) then
       write(*, '(a,2(a,i5,1x))') ' FATAL::'//method//':expecting nbdirsmax.eq.n, but got '//&
            'n=',n,'nbdirsmax=',nbdirsmax
    endif

    !-------------------
    !     allocate arrays
    !
    allocate( x(n), x0(n), sx(n) )
    allocate( y(m) )
    allocate( xfwv(nbdirsmax,n), yfwv(nbdirsmax,m), yjac(m,nbdirsmax) )

    !-------------------
    !     initialise control vector
    !
    call initx_cdv(n, x0, sx)

    !-- controlvector for evaluation: either (potentially perturbed) prior or read from file 
    inquire(file='x-external.b', exist=exist)
    if( exist ) then
       write(*, '(a)') ' INFO::'//method//':reading parameter from file x-external.b'
       open(unit=1, file='x-external.b')
       read(1) x
       close(1)
    else
       x = x0*(1+pert)
    endif

    !-------------------
    !-- dump control vector
    !
    !-- potentially don't evaluate at prior
    write(*, '(a,f5.2)' ) ' INFO::'//method//':'&
         'evaluating derivative at control vector:'
    write(*, '(2x,a2,1x,4(a25,1x))') 'i','x0', 'x', 'sx', 'xphys'
    ploop:do i=1,n
       write(*, '(2x,i2,1x,4(e25.16,1x))') i, x0(i), x(i), sx(i), x(i)*sx(i)
    enddo ploop  

    !
    ! Jacobian creation:
    !
    ! - running the vector forward-mode derivative
    !   yields *all columns* of Jacobian in single sweep
    !
    xfwv = 0._8
    do i=1,n
       xfwv(i,i) = 1._8
    enddo
    call evalf_fwv(n, x, xfwv, m, y, yfwv, nbdirs)
    yjac = transpose(yfwv)

    !-------------------
    !-- write derivatives to file (ASCII and binary)
    write(*, '(a)')&
         ' INFO::'//method//'::writing derivatives to ASCII file ***'//trim(outname)//'***'
    open(1, file=outname, form='formatted', action='write')
    do i=1,m
       write(1, *) yjac(i,:)
    enddo
    close(1)
    write(*, '(a)')&
         ' INFO::'//method//'::writing derivatives to binary file ***'//trim(boutname)//'***'
    open(1, file=boutname, form='unformatted', action='write')
    write(1, iostat=iostat) yjac
    if( iostat.ne.0 ) then
       write(*, '(a)')&
         ' ERROR::'//method//'::I/O error when writing ***'//trim(boutname)//'***'
    else
       write(*, '(a)')&
         ' INFO::'//method//'::...writing DONE.'
    endif
    close(1)

    !-------------------
    !     deallocate arrays
    deallocate( x, x0, sx )
    deallocate( xfwv, y, yfwv, yjac)

  end subroutine jacobian_fwv
#endif



#ifdef DERIV_BW
  subroutine jacobian_bw()
    implicit none
    ! local variables
    character(len=*), parameter :: method = 'jacobian_bw'
    character(len=*), parameter :: outname = 'jacobian.bw.asc'
    character(len=*), parameter :: boutname = 'jacobian.bw.b'
    integer :: n, m
    integer :: i,j
    real(kind=8), allocatable :: x(:), sx(:), x0(:)
    real(kind=8), allocatable :: y(:)
    !-- reverse-mode arrays
    real(kind=8), allocatable :: xbw(:), ybw(:)
    !-- for complete Jacobian
    real(kind=8), allocatable :: yjac(:,:)
    real(kind=8) :: pert = 0._8
    integer :: iostat

    !-------------------
    !-- init model
    write(*, '(a)') ' INFO::'//method//':calling initf_bw...'
    call initf_bw(n, m)
    write(*, '(a,2(a,i5,1x),a)') ' INFO::'//method//':...initf_bw DONE. (',&
         'n=',n,'m=',m,')'

    !-------------------
    !     allocate arrays
    !
    allocate( x(n), sx(n), x0(n) )
    allocate( y(m) )
    allocate( xbw(n), ybw(m))
    allocate( yjac(m,n) )

    !-------------------
    !     initialise control vector
    !
    call initx_cd(n,x0,sx)

    !-- controlvector for evaluation: either (potentially perturbed) prior or read from file 
    inquire(file='x-external.b', exist=exist)
    if( exist ) then
       write(*, '(a)') ' INFO::'//method//':reading parameter from file x-external.b'
       open(unit=1, file='x-external.b')
       read(1) x
       close(1)
    else
       x = x0*(1+pert)
    endif

    !-- dump control vector
    write(*, '(a,f5.2)' ) ' INFO::'//method//':'&
         'evaluating derivative at control vector:'
    write(*, '(2x,a2,1x,4(a25,1x))') 'i','x0', 'x', 'sx', 'xphys'
    ploop:do i=1,n
       write(*, '(2x,i2,1x,4(e25.16,1x))') i, x0(i), x(i), sx(i), x(i)*sx(i)
    enddo ploop  

    !
    ! Jacobian creation:
    !
    ! - running the reverse-mode derivative
    !   for each dependent (i.e. *row* of Jacobian)
    !
    do j=1,m
       xbw = 0._8
       ybw = 0._8
       ybw(j) = 1._8
       call evalf_bw(n, x, xbw, m, y, ybw)
       yjac(j,:) = xbw(:)
    enddo
    

    !-------------------
    !-- write derivatives to file (ASCII and binary)
    write(*, '(a)')&
         ' INFO::'//method//'::writing derivatives to ASCII file ***'//trim(outname)//'***'
    open(1, file=outname, form='formatted', action='write')
    do i=1,m
       write(1, *) yjac(i,:)
    enddo
    close(1)
    write(*, '(a)')&
         ' INFO::'//method//'::writing derivatives to binary file ***'//trim(boutname)//'***'
    open(1, file=boutname, form='unformatted', action='write')
    write(1, iostat=iostat) yjac
    if( iostat.ne.0 ) then
       write(*, '(a)')&
         ' ERROR::'//method//'::I/O error when writing ***'//trim(boutname)//'***'
    else
       write(*, '(a)')&
         ' INFO::'//method//'::...writing DONE.'
    endif
    close(1)

    !-------------------
    !     deallocate arrays
    deallocate( x, sx, x0, y )
    deallocate( xbw, ybw )
    deallocate( yjac )

  end subroutine jacobian_bw
#endif

end program main
