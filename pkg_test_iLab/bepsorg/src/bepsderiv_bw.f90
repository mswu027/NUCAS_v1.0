!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (develop) -  6 Oct 2021 16:40
!
!  Differentiation of cos_plant in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: cos_assim g_b g_sw ffpa f_soilwater
!   with respect to varying inputs: g_b cosa g_sw vcmax ffpa f_soilwater
!--iLab::convf no longer required
! subroutine cos_plant(lc,cosa,convf,g_sw,g_b,vcmax,ffpa,f_soilwater,cos_assim)
SUBROUTINE COS_PLANT_BW(lc, cosa, cosa_bw, g_sw, g_sw_bw, g_b, g_b_bw, &
& vcmax, vcmax_bw, ffpa, ffpa_bw, f_soilwater, f_soilwater_bw, cos_assim&
& , cos_assim_bw)
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  IMPLICIT NONE
!Input Variables
! real(r8) :: vcmax, g_sw, g_b,convf,f_soilwater,cos_assim
  REAL(r8) :: vcmax, g_sw, g_b, f_soilwater, cos_assim
  REAL(r8) :: vcmax_bw, g_sw_bw, g_b_bw, f_soilwater_bw, cos_assim_bw
  INTEGER :: lc
!Local Variables
  REAL(r8) :: c4flag, ffpa
  REAL(r8) :: ffpa_bw
! CAS COS concentration (pmol COS/mol air)
  REAL(r8) :: cosa
  REAL(r8) :: cosa_bw
  REAL(r8) :: gcosm
  REAL(r8) :: gcosm_bw
  REAL(r8) :: gtcos
  REAL(r8) :: gtcos_bw
  INTRINSIC MAX
  REAL(r8) :: temp
  REAL(r8) :: temp_bw
  INTEGER*4 :: branch
  c4flag = 0.
  IF (lc .EQ. 40 .OR. lc .EQ. 41) c4flag = 1.0
  IF (1.e-6 .LT. g_sw) THEN
    CALL PUSHCONTROL1B(0)
    g_sw = g_sw
  ELSE
    g_sw = 1.e-6
    CALL PUSHCONTROL1B(1)
  END IF
  IF (1.e-6 .LT. g_b) THEN
    CALL PUSHCONTROL1B(0)
    g_b = g_b
  ELSE
    g_b = 1.e-6
    CALL PUSHCONTROL1B(1)
  END IF
! mol/m2/s
  gcosm = 1.40e3*vcmax*1.0e-6*(1.0+5.33*c4flag)*ffpa*f_soilwater
  IF (gcosm .LT. 1.e-6) THEN
    gcosm = 1.e-6
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
    gcosm = gcosm
  END IF
!gtcos = 1.0/(1.94/(g_sw*convf) + 1.0/(g_b*convf) + 1.0/(gcosm*convf))  ! m/s
! mol/m2/s
  gtcos = 1.0/(1.94/g_sw+1.0/g_b+1.0/gcosm)
! pmol/m2/s
  gtcos_bw = cosa*cos_assim_bw
  cosa_bw = gtcos*cos_assim_bw
  temp = 1.94/g_sw + 1.0/g_b + 1.0/gcosm
  temp_bw = -(gtcos_bw/temp**2)
  g_sw_bw = g_sw_bw - 1.94*temp_bw/g_sw**2
  g_b_bw = g_b_bw - temp_bw/g_b**2
  gcosm_bw = -(temp_bw/gcosm**2)
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) gcosm_bw = 0.0_8
  temp_bw = (c4flag*5.33+1.0)*1.0e-6*1.40e3*gcosm_bw
  vcmax_bw = ffpa*f_soilwater*temp_bw
  ffpa_bw = ffpa_bw + vcmax*f_soilwater*temp_bw
  f_soilwater_bw = f_soilwater_bw + vcmax*ffpa*temp_bw
  CALL POPCONTROL1B(branch)
  IF (branch .NE. 0) g_b_bw = 0.0_8
  CALL POPCONTROL1B(branch)
  IF (branch .NE. 0) g_sw_bw = 0.0_8
END SUBROUTINE COS_PLANT_BW

MODULE MO_HELPER_DIFF
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  IMPLICIT NONE
! PARAMETERS FOR AUXILLIARY FUNCTIONS
  REAL, PARAMETER :: zmin=1.e-18

CONTAINS
!  REAL, PARAMETER :: eta = 0.99999            ! curvature parameter for mins/maxs
!*********************************************************
!* FUNCTION errf
!* the (cumulative) error function
!* numerical recipes in Fortran 77, Chapter 6.2
!*********************************************************
  REAL FUNCTION ERRF(x)
    IMPLICIT NONE
    REAL :: x, z, t
    INTRINSIC ABS
    INTRINSIC EXP
    IF (x .GE. 0.) THEN
      z = x
    ELSE
      z = -x
    END IF
    t = 1./(1.+0.5*z)
    errf = 1. - 0.5*t*EXP(-(z*z)-1.26551223+t*(1.00002368+t*(.37409196+t&
&     *(.09678418+t*(-.18628806+t*(.27886807+t*(-1.13520398+t*(&
&     1.48851587+t*(-.82215223+t*.17087277)))))))))
    IF (x .LT. 0) errf = 1. - errf
  END FUNCTION ERRF

!*********************************************************
!*  FUNCTION mins
!*  smoothed minimum function
!*********************************************************
!  REAL FUNCTION mins (x, y)
!    REAL :: x, y
!    REAL :: z
!    z = (x+y)**2 - 4.*eta*x*y
!    IF (z.GE.zmin) THEN
!       mins = (x + y - SQRT(z)) / (2.*eta)
!    ELSE
!       mins = 0.
!    ENDIF
!  END FUNCTION mins
  REAL FUNCTION MINS(x, y, eta)
    IMPLICIT NONE
    REAL :: x, y, eta
    REAL :: z
    INTRINSIC MAX
    INTRINSIC SQRT
    z = (x+y)**2 - 4.*eta*x*y
    IF (z .LT. zmin) THEN
      z = zmin
    ELSE
      z = z
    END IF
    mins = (x+y-SQRT(z))/(2.*eta)
  END FUNCTION MINS

!*********************************************************
!*  FUNCTION maxs
!*  smoothed maximum function
!*********************************************************
!  REAL FUNCTION maxs (x, y)
!    REAL :: x, y
!    REAL :: z
!    z = (x+y)**2 - 4.*eta*x*y
!    IF (z.GE.zmin) THEN
!       maxs = (x + y + SQRT(z)) / (2.*eta)
!    ELSE
!       maxs = 0.
!    ENDIF
!  END FUNCTION maxs
  REAL FUNCTION MAXS(x, y, eta)
    IMPLICIT NONE
    REAL :: x, y, eta
    REAL :: z
    INTRINSIC MAX
    INTRINSIC SQRT
    z = (x+y)**2 - 4.*eta*x*y
    IF (z .LT. zmin) THEN
      z = zmin
    ELSE
      z = z
    END IF
    maxs = (x+y+SQRT(z))/(2.*eta)
  END FUNCTION MAXS

!*********************************************************
!*  FUNCTION minx
!*  minimum function with exponential transition
!*********************************************************
  REAL FUNCTION MINX(x, y, x0)
    IMPLICIT NONE
    REAL :: x, y, x0
    INTRINSIC EXP
    IF (x .LE. y + x0) THEN
      minx = x - x0*EXP((x-y)/x0-1.)
    ELSE
      minx = y
    END IF
  END FUNCTION MINX

!  Differentiation of fominef_ss in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: fominef_ss
!   with respect to varying inputs: p1
  SUBROUTINE FOMINEF_SS_BW0(p1, p1_bw, p2, tune, fominef_ss_bw)
    IMPLICIT NONE
    REAL :: p1, p2
    REAL :: p1_bw
! tune/2 >= min(p1,p2) - fominef
    REAL :: tune
    INTRINSIC MIN
    INTRINSIC ABS
    INTRINSIC EXP
    REAL :: min1
    REAL :: min1_bw
    REAL :: abs0
    REAL :: abs0_bw
    INTEGER*4 :: branch
    REAL :: fominef_ss_bw
    REAL :: fominef_ss
    IF (p1 .GT. p2) THEN
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    IF (p1 - p2 .GE. 0.) THEN
      abs0 = p1 - p2
      CALL PUSHCONTROL1B(0)
    ELSE
      abs0 = -(p1-p2)
      CALL PUSHCONTROL1B(1)
    END IF
    min1_bw = fominef_ss_bw
    abs0_bw = EXP(-(abs0/tune))*0.5*fominef_ss_bw
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      p1_bw = abs0_bw
    ELSE
      p1_bw = -abs0_bw
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) p1_bw = p1_bw + min1_bw
  END SUBROUTINE FOMINEF_SS_BW0

  REAL FUNCTION FOMINEF_SS(p1, p2, tune)
    IMPLICIT NONE
    REAL :: p1, p2
! tune/2 >= min(p1,p2) - fominef
    REAL :: tune
    INTRINSIC MIN
    INTRINSIC ABS
    INTRINSIC EXP
    REAL :: min1
    REAL :: abs0
    IF (p1 .GT. p2) THEN
      min1 = p2
    ELSE
      min1 = p1
    END IF
    IF (p1 - p2 .GE. 0.) THEN
      abs0 = p1 - p2
    ELSE
      abs0 = -(p1-p2)
    END IF
    fominef_ss = min1 - 0.5*tune*EXP(-(abs0/tune))
  END FUNCTION FOMINEF_SS

  REAL FUNCTION FOMAXEF_SS(p1, p2, tune)
    IMPLICIT NONE
    REAL :: p1, p2
! tune/2 >= fomaxef - max(p1,p2)
    REAL :: tune
    INTRINSIC MAX
    INTRINSIC ABS
    INTRINSIC EXP
    REAL :: max1
    REAL :: abs0
    IF (p1 .LT. p2) THEN
      max1 = p2
    ELSE
      max1 = p1
    END IF
    IF (p1 - p2 .GE. 0.) THEN
      abs0 = p1 - p2
    ELSE
      abs0 = -(p1-p2)
    END IF
    fomaxef_ss = max1 + 0.5*tune*EXP(-(abs0/tune))
  END FUNCTION FOMAXEF_SS

!  Differentiation of maxx in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: x maxx
!   with respect to varying inputs: x
!*********************************************************
!*  FUNCTION maxx
!*  maximum function with exponential transition
!*********************************************************
  SUBROUTINE MAXX_BW0(x, x_bw, y, x0, maxx_bw)
    IMPLICIT NONE
! snb: to fix bug in lf95-optimisation (variable in function erroneously inherits intent(out) attribute from calling scope)
    REAL, INTENT(IN) :: x, y, x0
    REAL :: x_bw
    INTRINSIC EXP
    REAL :: maxx_bw
    REAL :: maxx
    IF (x .GE. y - x0) x_bw = x_bw + (1.0-EXP((-1.)-(x-y)/x0))*maxx_bw
  END SUBROUTINE MAXX_BW0

!*********************************************************
!*  FUNCTION maxx
!*  maximum function with exponential transition
!*********************************************************
  REAL FUNCTION MAXX(x, y, x0)
    IMPLICIT NONE
! snb: to fix bug in lf95-optimisation (variable in function erroneously inherits intent(out) attribute from calling scope)
    REAL, INTENT(IN) :: x, y, x0
    INTRINSIC EXP
    IF (x .GE. y - x0) THEN
      maxx = x + x0*EXP(-((x-y)/x0)-1.)
    ELSE
      maxx = y
    END IF
  END FUNCTION MAXX

!*********************************************************
!*  FUNCTION mmin
!*  maximum function with exponential transition
!*********************************************************
! maximum error is x0/e for x==y-x0
  REAL FUNCTION MMIN(x, y, x0)
    IMPLICIT NONE
! snb: to fix bug in lf95-optimisation (variable in function erroneously inherits intent(out) attribute from calling scope)
    REAL, INTENT(IN) :: x, y, x0
    INTRINSIC EXP
    IF (x .LT. y) THEN
      mmin = x + (y-x)*EXP((x-y)/x0)
    ELSE
! exact for (x.le.y):
      mmin = y
    END IF
  END FUNCTION MMIN

!*********************************************************
!*  FUNCTION mmax
!*  maximum function with exponential transition
!*********************************************************
! maximum error is -x0/e for x==y+x0
  REAL FUNCTION MMAX(x, y, x0)
    IMPLICIT NONE
! snb: to fix bug in lf95-optimisation (variable in function erroneously inherits intent(out) attribute from calling scope)
    REAL, INTENT(IN) :: x, y, x0
    INTRINSIC EXP
    IF (x .GT. y) THEN
      mmax = x + (y-x)*EXP((y-x)/x0)
    ELSE
! exact for (x.le.y):
      mmax = y
    END IF
  END FUNCTION MMAX

END MODULE MO_HELPER_DIFF


MODULE BEPSTYPE_DIFF
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  IMPLICIT NONE
! For restart
!-- iLab::module field should have save attribute
  REAL(r8), ALLOCATABLE, PUBLIC, SAVE :: v2last(:, :, :)
  REAL(r8), ALLOCATABLE, PUBLIC, SAVE :: v2last_bw(:, :, :)
!downward solar raditation
!relative humidity(%)
! liquid precipitation
! Snow rate
! SW direct radiation
! SW diffuse radiation
!--iLab::to consistenly handle tempooral settings
!--      expected format yyyy-mm-dd
!*********************Climate Forcing datasets**********************
  TYPE, PUBLIC :: FORC
      REAL(r8), POINTER :: temp(:)
      REAL(r8), POINTER :: tempmx(:)
      REAL(r8), POINTER :: tempmn(:)
      REAL(r8), POINTER :: wind(:)
      REAL(r8), POINTER :: srad(:)
      REAL(r8), POINTER :: rh(:)
      REAL(r8), POINTER :: rain(:)
      REAL(r8), POINTER :: snow(:)
      REAL(r8), POINTER :: swdr(:)
      REAL(r8), POINTER :: swdf(:)
      CHARACTER(len=16) :: meteo_ref_yyyymmdd
  END TYPE FORC
  TYPE(FORC), SAVE, TARGET, PUBLIC :: clim
! PFT types
! soil texture
! PFT fraction
! snowdepth
!
! soil moisture
! for plant resp
! for soil resp
!!! soil carbon pools  units(g C/m2)
!     real(r8),pointer:: p_Vcmax(:)
!     real(r8),pointer:: p_q10(:)
!     real(r8),pointer:: p_drainage(:)
!     real(r8),pointer:: p_beta(:)
!     real(r8),pointer:: p_Ksat(:)
!     real(r8),pointer:: p_b(:)
!     real(r8),pointer:: u_Vcmax(:)
!     real(r8),pointer:: u_q10(:)
!     real(r8),pointer:: u_drainage(:)
!     real(r8),pointer:: u_beta(:)
!     real(r8),pointer:: u_Ksat(:)
!     real(r8),pointer:: u_b(:)
! for photosynthesis
! for data assimilation
!     character,pointer:: name(:)
!***********************for CPL datasets****************************
!******************for boundary/yrdata/lai/cpools/
  TYPE, PUBLIC :: SURF
      INTEGER, POINTER :: lcno(:, :)
      INTEGER, POINTER :: stext(:)
      REAL(r8), POINTER :: pct_pft(:, :)
      REAL(r8), POINTER :: clumping(:)
      REAL(r8), POINTER :: longitude(:)
      REAL(r8), POINTER :: latitude(:)
      REAL(r8), POINTER :: sdp(:)
      REAL(r8), POINTER :: st(:)
      REAL(r8), POINTER :: sw(:)
      REAL(r8), POINTER :: laiyr(:, :)
      REAL(r8), POINTER :: nppyr(:, :)
      REAL(r8), POINTER :: ccd(:, :)
      REAL(r8), POINTER :: cfmd(:, :)
      REAL(r8), POINTER :: cfsd(:, :)
      REAL(r8), POINTER :: cm(:, :)
      REAL(r8), POINTER :: cp(:, :)
      REAL(r8), POINTER :: cs(:, :)
      REAL(r8), POINTER :: csm(:, :)
      REAL(r8), POINTER :: csmd(:, :)
      REAL(r8), POINTER :: cssd(:, :)
      REAL(r8), POINTER :: lai(:, :)
      REAL(r8), POINTER :: vcmax(:, :)
  END TYPE SURF
! boundary conditions
  TYPE(SURF), SAVE, TARGET, PUBLIC :: bound
!    real(r8),pointer:: p_f_lr
!     real(r8),pointer:: u_f_lr
!******************for assimilation and parameter optimization/
  TYPE, PUBLIC :: PARA
      REAL(r8), POINTER :: p_vcmax(:)
      REAL(r8), POINTER :: p_vj_slope(:)
      REAL(r8), POINTER :: p_q10(:)
      REAL(r8), POINTER :: p_sif_alpha(:)
      REAL(r8), POINTER :: p_sif_beta(:)
      REAL(r8), POINTER :: p_taweff(:)
      REAL(r8), POINTER :: p_d0(:)
      REAL(r8), POINTER :: p_ksat_scalar(:)
      REAL(r8), POINTER :: p_b_scalar(:)
      REAL(r8), POINTER :: p_f_leaf
      REAL(r8), POINTER :: p_kc25
      REAL(r8), POINTER :: p_ko25
      REAL(r8), POINTER :: p_tau25
      REAL(r8), POINTER :: p_agb2vod
      REAL(r8), POINTER :: u_vcmax(:)
      REAL(r8), POINTER :: u_vj_slope(:)
      REAL(r8), POINTER :: u_q10(:)
      REAL(r8), POINTER :: u_sif_alpha(:)
      REAL(r8), POINTER :: u_sif_beta(:)
      REAL(r8), POINTER :: u_taweff(:)
      REAL(r8), POINTER :: u_d0(:)
      REAL(r8), POINTER :: u_ksat_scalar(:)
      REAL(r8), POINTER :: u_b_scalar(:)
      REAL(r8), POINTER :: u_f_leaf
      REAL(r8), POINTER :: u_kc25
      REAL(r8), POINTER :: u_ko25
      REAL(r8), POINTER :: u_tau25
      REAL(r8), POINTER :: u_agb2vod
  END TYPE PARA
  TYPE, PUBLIC :: PARA_DIFF
      REAL(r8), DIMENSION(:), POINTER :: p_vcmax
      REAL(r8), DIMENSION(:), POINTER :: p_vj_slope
      REAL(r8), DIMENSION(:), POINTER :: p_sif_alpha
      REAL(r8), DIMENSION(:), POINTER :: p_sif_beta
      REAL(r8), DIMENSION(:), POINTER :: p_ksat_scalar
      REAL(r8), DIMENSION(:), POINTER :: p_b_scalar
      REAL(r8), POINTER :: p_f_leaf
  END TYPE PARA_DIFF
! optimization of parameters
  TYPE(PARA), SAVE, TARGET, PUBLIC :: assim
  TYPE(PARA_DIFF), SAVE, TARGET, PUBLIC :: assim_bw
!!(npoints,0:Max_LayerS-1)
!*******************************************************************
!------------------Soil Status----------
!*******************************************************************
  TYPE, PUBLIC :: SOILS
      INTEGER, POINTER :: n_layer(:)
      REAL(r8), POINTER :: zp(:, :)
      REAL(r8), POINTER :: zsp(:, :)
      REAL(r8), POINTER :: r_rain_g(:, :)
      REAL(r8), POINTER :: r_drainage(:, :)
      REAL(r8), POINTER :: r_root_decay(:, :)
      REAL(r8), POINTER :: psi_min(:, :)
      REAL(r8), POINTER :: alpha(:, :)
      REAL(r8), POINTER :: f_soilwater(:, :)
      REAL(r8), POINTER :: d_soil(:, :)
      REAL(r8), POINTER :: f_root(:, :, :)
      REAL(r8), POINTER :: dt(:, :, :)
      REAL(r8), POINTER :: thermal_cond(:, :, :)
      REAL(r8), POINTER :: theta_vfc(:, :, :)
      REAL(r8), POINTER :: theta_vwp(:, :, :)
      REAL(r8), POINTER :: fei(:, :, :)
      REAL(r8), POINTER :: ksat(:, :, :)
      REAL(r8), POINTER :: psi_sat(:, :, :)
      REAL(r8), POINTER :: b(:, :, :)
      REAL(r8), POINTER :: density_soil(:, :)
      REAL(r8), POINTER :: f_org(:, :, :)
      REAL(r8), POINTER :: ice_ratio(:, :, :)
      REAL(r8), POINTER :: thetam(:, :, :)
      REAL(r8), POINTER :: thetam_prev(:, :, :)
      REAL(r8), POINTER :: temp_soil_p(:, :, :)
      REAL(r8), POINTER :: temp_soil_c(:, :, :)
      REAL(r8), POINTER :: f_ice(:, :, :)
      REAL(r8), POINTER :: psim(:, :, :)
      REAL(r8), POINTER :: thetab(:, :, :)
      REAL(r8), POINTER :: psib(:, :, :)
      REAL(r8), POINTER :: r_waterflow(:, :, :)
      REAL(r8), POINTER :: km(:, :, :)
      REAL(r8), POINTER :: kb(:, :, :)
      REAL(r8), POINTER :: kk(:, :, :)
      REAL(r8), POINTER :: cs(:, :, :)
      REAL(r8), POINTER :: lambda(:, :, :)
      REAL(r8), POINTER :: ett(:, :, :)
      REAL(r8), POINTER :: g(:, :, :)
  END TYPE SOILS
  TYPE(SOILS), TARGET, SAVE, PUBLIC :: soilstat
  TYPE(SOILS), TARGET, SAVE, PUBLIC :: soilstat_bw
!accord with the satellite data
!*********************************************************
!-----------Interest Variables For output-----------------
!*********************************************************
  TYPE, PUBLIC :: RES
      REAL(r8), POINTER :: gpppft(:, :)
      REAL(r8), POINTER :: sifpft(:, :)
      REAL(r8), POINTER :: sifpft_sat(:, :)
      REAL(r8), POINTER :: npppft(:, :)
      REAL(r8), POINTER :: neppft(:, :)
      REAL(r8), POINTER :: shpft(:, :)
      REAL(r8), POINTER :: lhpft(:, :)
      REAL(r8), POINTER :: transpft(:, :)
      REAL(r8), POINTER :: evappft(:, :)
      REAL(r8), POINTER :: net_radpft(:, :)
      REAL(r8), POINTER :: gpp(:)
      REAL(r8), POINTER :: sif(:)
      REAL(r8), POINTER :: sif_sat(:)
      REAL(r8), POINTER :: npp(:)
      REAL(r8), POINTER :: nep(:)
      REAL(r8), POINTER :: laipft(:, :)
      REAL(r8), POINTER :: lai(:)
      REAL(r8), POINTER :: sh(:)
      REAL(r8), POINTER :: lh(:)
      REAL(r8), POINTER :: trans(:)
      REAL(r8), POINTER :: evap(:)
      REAL(r8), POINTER :: net_rad(:)
      REAL(r8), POINTER :: thetampft(:, :)
      REAL(r8), POINTER :: thetam(:)
      REAL(r8), POINTER :: faparpft(:, :)
      REAL(r8), POINTER :: fapar(:)
      REAL(r8), POINTER :: vodpft(:, :)
      REAL(r8), POINTER :: vod(:)
      REAL(r8), POINTER :: cos_fluxpft(:, :)
      REAL(r8), POINTER :: cos_flux(:)
      REAL(r8), POINTER :: npp_yr_acc(:, :)
  END TYPE RES
  TYPE, PUBLIC :: RES_DIFF
      REAL(r8), DIMENSION(:, :), POINTER :: gpppft
      REAL(r8), DIMENSION(:, :), POINTER :: sifpft
      REAL(r8), DIMENSION(:, :), POINTER :: sifpft_sat
      REAL(r8), DIMENSION(:, :), POINTER :: npppft
      REAL(r8), DIMENSION(:, :), POINTER :: neppft
      REAL(r8), DIMENSION(:, :), POINTER :: shpft
      REAL(r8), DIMENSION(:, :), POINTER :: lhpft
      REAL(r8), DIMENSION(:, :), POINTER :: transpft
      REAL(r8), DIMENSION(:, :), POINTER :: evappft
      REAL(r8), DIMENSION(:, :), POINTER :: net_radpft
      REAL(r8), DIMENSION(:), POINTER :: sif
      REAL(r8), DIMENSION(:, :), POINTER :: laipft
      REAL(r8), DIMENSION(:, :), POINTER :: thetampft
      REAL(r8), DIMENSION(:), POINTER :: thetam
      REAL(r8), DIMENSION(:, :), POINTER :: faparpft
      REAL(r8), DIMENSION(:, :), POINTER :: vodpft
      REAL(r8), DIMENSION(:, :), POINTER :: cos_fluxpft
      REAL(r8), DIMENSION(:), POINTER :: cos_flux
  END TYPE RES_DIFF
  TYPE(RES), SAVE, TARGET, PUBLIC :: output
  TYPE(RES_DIFF), SAVE, TARGET, PUBLIC :: output_bw
END MODULE BEPSTYPE_DIFF
! This module is used to initialize bepstype variables
! Editted by J.Wang
! Date: 10May2017

MODULE BEPSTYPEINIT_DIFF
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
!--iLab::added further entities (as module bepstype does no longer use beps_par)
  USE BEPS_PAR, ONLY : npoints, pft, max_layers, texture
  USE BEPSTYPE_DIFF
  IMPLICIT NONE
!--iLab::can avoid 'save' here since no variables are declared,
!        use-associated entities should already have the attribute
! save
  PUBLIC :: initbepstype
  PUBLIC :: initbepstype_bw
  PRIVATE :: initatm2lnd
  PRIVATE :: initsurf
  PRIVATE :: initouput
  PRIVATE :: initouput_bw
  PRIVATE :: initassim
  PRIVATE :: initassim_bw

CONTAINS
!  Differentiation of initbepstype in forward (tangent) mode (with options noISIZE r8):
!   Plus diff mem management of: output.gpppft:out output.sifpft:out
!                output.sifpft_sat:out output.npppft:out output.neppft:out
!                output.shpft:out output.lhpft:out output.transpft:out
!                output.evappft:out output.net_radpft:out output.sif:out
!                output.laipft:out output.thetampft:out output.thetam:out
!                output.faparpft:out output.vodpft:out output.cos_fluxpft:out
!                output.cos_flux:out assim.p_vcmax:out assim.p_vj_slope:out
!                assim.p_sif_alpha:out assim.p_sif_beta:out assim.p_ksat_scalar:out
!                assim.p_b_scalar:out assim.p_f_leaf:out soilstat.zp:out
!                soilstat.zsp:out soilstat.r_rain_g:out soilstat.r_drainage:out
!                soilstat.r_root_decay:out soilstat.psi_min:out
!                soilstat.alpha:out soilstat.f_soilwater:out soilstat.d_soil:out
!                soilstat.f_root:out soilstat.dt:out soilstat.thermal_cond:out
!                soilstat.theta_vfc:out soilstat.theta_vwp:out
!                soilstat.fei:out soilstat.ksat:out soilstat.psi_sat:out
!                soilstat.b:out soilstat.density_soil:out soilstat.f_org:out
!                soilstat.ice_ratio:out soilstat.thetam:out soilstat.thetam_prev:out
!                soilstat.temp_soil_p:out soilstat.temp_soil_c:out
!                soilstat.f_ice:out soilstat.psim:out soilstat.thetab:out
!                soilstat.psib:out soilstat.r_waterflow:out soilstat.km:out
!                soilstat.kb:out soilstat.kk:out soilstat.cs:out
!                soilstat.lambda:out soilstat.ett:out soilstat.g:out
!                v2last:out
  SUBROUTINE INITBEPSTYPE_BW()
    IMPLICIT NONE
    ALLOCATE(v2last_bw(npoints, 0:40, pft))
    ALLOCATE(v2last(npoints, 0:40, pft))
    v2last = 0.
    CALL INITATM2LND()
    CALL INITSURF()
    CALL INITSOILSTAT_BW()
    CALL INITOUPUT_BW()
    CALL INITASSIM_BW()
    RETURN
  END SUBROUTINE INITBEPSTYPE_BW

  SUBROUTINE INITBEPSTYPE()
    IMPLICIT NONE
    ALLOCATE(v2last(npoints, 0:40, pft))
    v2last = 0.
    CALL INITATM2LND()
    CALL INITSURF()
    CALL INITSOILSTAT()
    CALL INITOUPUT()
    CALL INITASSIM()
    RETURN
  END SUBROUTINE INITBEPSTYPE

  SUBROUTINE INITATM2LND()
    IMPLICIT NONE
!--iLab::avoid pointer
! type(forc),pointer ::p
! p=>clim
    ALLOCATE(clim%temp(npoints))
    ALLOCATE(clim%tempmx(npoints))
    ALLOCATE(clim%tempmn(npoints))
    ALLOCATE(clim%wind(npoints))
    ALLOCATE(clim%srad(npoints))
    ALLOCATE(clim%rh(npoints))
    ALLOCATE(clim%rain(npoints))
    ALLOCATE(clim%snow(npoints))
    ALLOCATE(clim%swdr(npoints))
    ALLOCATE(clim%swdf(npoints))
    clim%temp(:) = 0.
    clim%tempmx(:) = 0.
    clim%tempmn(:) = 0.
    clim%wind(:) = 0.
    clim%srad(:) = 0.
    clim%rh(:) = 0.
    clim%rain(:) = 0.
    clim%snow(:) = 0.
    clim%swdr(:) = 0.
    clim%swdf(:) = 0.
    RETURN
  END SUBROUTINE INITATM2LND

  SUBROUTINE INITSURF()
    IMPLICIT NONE
!bound%p_Vcmax   = 0.
!bound%p_q10     = 0.
!bound%p_drainage   = 0.
!bound%p_beta   = 0.
!bound%p_Ksat   = 0.
!bound%p_b   = 0.
!bound%u_Vcmax   = 0.
!bound%u_q10   = 0.
!bound%u_drainage   = 0.
!bound%u_beta   = 0.
!bound%u_Ksat   = 0.
!bound%u_b   = 0.
!--iLab::avoid pointer
! type(surf),pointer::p
! p=>bound
    ALLOCATE(bound%lcno(npoints, pft))
    ALLOCATE(bound%stext(npoints))
    ALLOCATE(bound%pct_pft(npoints, pft))
    ALLOCATE(bound%clumping(npoints))
    ALLOCATE(bound%longitude(npoints))
    ALLOCATE(bound%latitude(npoints))
    ALLOCATE(bound%sdp(npoints))
    ALLOCATE(bound%st(npoints))
    ALLOCATE(bound%sw(npoints))
    ALLOCATE(bound%laiyr(npoints, pft))
    ALLOCATE(bound%nppyr(npoints, pft))
    ALLOCATE(bound%ccd(npoints, pft))
    ALLOCATE(bound%cfmd(npoints, pft))
    ALLOCATE(bound%cfsd(npoints, pft))
    ALLOCATE(bound%cm(npoints, pft))
    ALLOCATE(bound%cp(npoints, pft))
    ALLOCATE(bound%cs(npoints, pft))
    ALLOCATE(bound%csm(npoints, pft))
    ALLOCATE(bound%csmd(npoints, pft))
    ALLOCATE(bound%cssd(npoints, pft))
    ALLOCATE(bound%lai(npoints, pft))
    ALLOCATE(bound%vcmax(npoints, pft))
!allocate(bound%p_Vcmax(PFT))
!allocate(bound%p_q10(PFT))
!allocate(bound%p_drainage(PFT))
!allocate(bound%p_beta(PFT))
!allocate(bound%p_Ksat(texture))
!allocate(bound%p_b(texture))
!allocate(bound%u_Vcmax(PFT))
!allocate(bound%u_q10(PFT))
!allocate(bound%u_drainage(PFT))
!allocate(bound%u_beta(PFT))
!allocate(bound%u_Ksat(texture))
!allocate(bound%u_b(texture))
    bound%lcno = 0
    bound%stext = 0
    bound%pct_pft = 0
    bound%clumping = 0.
    bound%longitude = 0.
    bound%latitude = 0.
    bound%sdp = 0.
    bound%st = 0.
    bound%sw = 0.
    bound%laiyr = 0.
    bound%nppyr = 0.
    bound%ccd = 0.
    bound%cfmd = 0.
    bound%cfsd = 0.
    bound%cm = 0.
    bound%cp = 0.
    bound%cs = 0.
    bound%csm = 0.
    bound%csmd = 0.
    bound%cssd = 0.
    bound%lai = 0.
    bound%vcmax = 0.
  END SUBROUTINE INITSURF

!  Differentiation of initassim in forward (tangent) mode (with options noISIZE r8):
!   Plus diff mem management of: assim.p_vcmax:out assim.p_vj_slope:out
!                assim.p_sif_alpha:out assim.p_sif_beta:out assim.p_ksat_scalar:out
!                assim.p_b_scalar:out assim.p_f_leaf:out
  SUBROUTINE INITASSIM_BW()
    IMPLICIT NONE
!--iLab::avoid pointer
! type(para),pointer  ::p
! p => assim
    ALLOCATE(assim_bw%p_vcmax(pft))
    ALLOCATE(assim%p_vcmax(pft))
    ALLOCATE(assim%p_q10(pft))
    ALLOCATE(assim_bw%p_vj_slope(pft))
    ALLOCATE(assim%p_vj_slope(pft))
    ALLOCATE(assim_bw%p_sif_alpha(pft))
    ALLOCATE(assim%p_sif_alpha(pft))
    ALLOCATE(assim_bw%p_sif_beta(pft))
    ALLOCATE(assim%p_sif_beta(pft))
    ALLOCATE(assim%p_taweff(pft))
    ALLOCATE(assim%p_d0(pft))
    ALLOCATE(assim_bw%p_ksat_scalar(texture))
    ALLOCATE(assim%p_ksat_scalar(texture))
    ALLOCATE(assim_bw%p_b_scalar(texture))
    ALLOCATE(assim%p_b_scalar(texture))
    ALLOCATE(assim_bw%p_f_leaf)
    ALLOCATE(assim%p_f_leaf)
    ALLOCATE(assim%p_kc25)
    ALLOCATE(assim%p_ko25)
    ALLOCATE(assim%p_tau25)
!allocate(assim%p_f_lr)
    ALLOCATE(assim%p_agb2vod)
    ALLOCATE(assim%u_vcmax(pft))
    ALLOCATE(assim%u_q10(pft))
    ALLOCATE(assim%u_vj_slope(pft))
    ALLOCATE(assim%u_sif_alpha(pft))
    ALLOCATE(assim%u_sif_beta(pft))
    ALLOCATE(assim%u_taweff(pft))
    ALLOCATE(assim%u_d0(pft))
    ALLOCATE(assim%u_ksat_scalar(texture))
    ALLOCATE(assim%u_b_scalar(texture))
    ALLOCATE(assim%u_f_leaf)
    ALLOCATE(assim%u_kc25)
    ALLOCATE(assim%u_ko25)
    ALLOCATE(assim%u_tau25)
!allocate(assim%u_f_lr)
    ALLOCATE(assim%u_agb2vod)
    assim%p_vcmax = 0.
    assim%p_q10 = 0.
    assim%p_vj_slope = 0.
    assim%p_sif_alpha = 0.
    assim%p_sif_beta = 0.
    assim%p_taweff = 0.
    assim%p_d0 = 0.
    assim%p_ksat_scalar = 0.
    assim%p_b_scalar = 0.
    assim%p_f_leaf = 0.
    assim%p_kc25 = 0.
    assim%p_ko25 = 0.
    assim%p_tau25 = 0.
!assim%p_f_lr   = 0.
    assim%p_agb2vod = 0.
    assim%u_vcmax = 0.
    assim%u_q10 = 0.
    assim%u_vj_slope = 0.
    assim%u_sif_alpha = 0.
    assim%u_sif_beta = 0.
    assim%u_taweff = 0.
    assim%u_d0 = 0.
    assim%u_ksat_scalar = 0.
    assim%u_b_scalar = 0.
    assim%u_f_leaf = 0.
    assim%u_kc25 = 0.
    assim%u_ko25 = 0.
    assim%u_tau25 = 0.
!assim%u_f_lr   = 0.
    assim%u_agb2vod = 0.
  END SUBROUTINE INITASSIM_BW

  SUBROUTINE INITASSIM()
    IMPLICIT NONE
!--iLab::avoid pointer
! type(para),pointer  ::p
! p => assim
    ALLOCATE(assim%p_vcmax(pft))
    ALLOCATE(assim%p_q10(pft))
    ALLOCATE(assim%p_vj_slope(pft))
    ALLOCATE(assim%p_sif_alpha(pft))
    ALLOCATE(assim%p_sif_beta(pft))
    ALLOCATE(assim%p_taweff(pft))
    ALLOCATE(assim%p_d0(pft))
    ALLOCATE(assim%p_ksat_scalar(texture))
    ALLOCATE(assim%p_b_scalar(texture))
    ALLOCATE(assim%p_f_leaf)
    ALLOCATE(assim%p_kc25)
    ALLOCATE(assim%p_ko25)
    ALLOCATE(assim%p_tau25)
!allocate(assim%p_f_lr)
    ALLOCATE(assim%p_agb2vod)
    ALLOCATE(assim%u_vcmax(pft))
    ALLOCATE(assim%u_q10(pft))
    ALLOCATE(assim%u_vj_slope(pft))
    ALLOCATE(assim%u_sif_alpha(pft))
    ALLOCATE(assim%u_sif_beta(pft))
    ALLOCATE(assim%u_taweff(pft))
    ALLOCATE(assim%u_d0(pft))
    ALLOCATE(assim%u_ksat_scalar(texture))
    ALLOCATE(assim%u_b_scalar(texture))
    ALLOCATE(assim%u_f_leaf)
    ALLOCATE(assim%u_kc25)
    ALLOCATE(assim%u_ko25)
    ALLOCATE(assim%u_tau25)
!allocate(assim%u_f_lr)
    ALLOCATE(assim%u_agb2vod)
    assim%p_vcmax = 0.
    assim%p_q10 = 0.
    assim%p_vj_slope = 0.
    assim%p_sif_alpha = 0.
    assim%p_sif_beta = 0.
    assim%p_taweff = 0.
    assim%p_d0 = 0.
    assim%p_ksat_scalar = 0.
    assim%p_b_scalar = 0.
    assim%p_f_leaf = 0.
    assim%p_kc25 = 0.
    assim%p_ko25 = 0.
    assim%p_tau25 = 0.
!assim%p_f_lr   = 0.
    assim%p_agb2vod = 0.
    assim%u_vcmax = 0.
    assim%u_q10 = 0.
    assim%u_vj_slope = 0.
    assim%u_sif_alpha = 0.
    assim%u_sif_beta = 0.
    assim%u_taweff = 0.
    assim%u_d0 = 0.
    assim%u_ksat_scalar = 0.
    assim%u_b_scalar = 0.
    assim%u_f_leaf = 0.
    assim%u_kc25 = 0.
    assim%u_ko25 = 0.
    assim%u_tau25 = 0.
!assim%u_f_lr   = 0.
    assim%u_agb2vod = 0.
  END SUBROUTINE INITASSIM

!  Differentiation of initsoilstat in forward (tangent) mode (with options noISIZE r8):
!   Plus diff mem management of: soilstat.zp:out soilstat.zsp:out
!                soilstat.r_rain_g:out soilstat.r_drainage:out
!                soilstat.r_root_decay:out soilstat.psi_min:out
!                soilstat.alpha:out soilstat.f_soilwater:out soilstat.d_soil:out
!                soilstat.f_root:out soilstat.dt:out soilstat.thermal_cond:out
!                soilstat.theta_vfc:out soilstat.theta_vwp:out
!                soilstat.fei:out soilstat.ksat:out soilstat.psi_sat:out
!                soilstat.b:out soilstat.density_soil:out soilstat.f_org:out
!                soilstat.ice_ratio:out soilstat.thetam:out soilstat.thetam_prev:out
!                soilstat.temp_soil_p:out soilstat.temp_soil_c:out
!                soilstat.f_ice:out soilstat.psim:out soilstat.thetab:out
!                soilstat.psib:out soilstat.r_waterflow:out soilstat.km:out
!                soilstat.kb:out soilstat.kk:out soilstat.cs:out
!                soilstat.lambda:out soilstat.ett:out soilstat.g:out
  SUBROUTINE INITSOILSTAT_BW()
    IMPLICIT NONE
!--iLab::avoid pointer
! type(soils),pointer  :: p
! p => soilstat
    ALLOCATE(soilstat_bw%n_layer(npoints))
    ALLOCATE(soilstat%n_layer(npoints))
    ALLOCATE(soilstat_bw%zp(npoints, pft))
    ALLOCATE(soilstat%zp(npoints, pft))
    ALLOCATE(soilstat_bw%zsp(npoints, pft))
    ALLOCATE(soilstat%zsp(npoints, pft))
    ALLOCATE(soilstat_bw%r_rain_g(npoints, pft))
    ALLOCATE(soilstat%r_rain_g(npoints, pft))
    ALLOCATE(soilstat_bw%r_drainage(npoints, pft))
    ALLOCATE(soilstat%r_drainage(npoints, pft))
    ALLOCATE(soilstat_bw%r_root_decay(npoints, pft))
    ALLOCATE(soilstat%r_root_decay(npoints, pft))
    ALLOCATE(soilstat_bw%psi_min(npoints, pft))
    ALLOCATE(soilstat%psi_min(npoints, pft))
    ALLOCATE(soilstat_bw%alpha(npoints, pft))
    ALLOCATE(soilstat%alpha(npoints, pft))
    ALLOCATE(soilstat_bw%f_soilwater(npoints, pft))
    ALLOCATE(soilstat%f_soilwater(npoints, pft))
    ALLOCATE(soilstat_bw%d_soil(npoints, 0:max_layers-1))
    ALLOCATE(soilstat%d_soil(npoints, 0:max_layers-1))
    ALLOCATE(soilstat_bw%f_root(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%f_root(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_bw%dt(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%dt(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_bw%thermal_cond(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%thermal_cond(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_bw%theta_vfc(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%theta_vfc(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_bw%theta_vwp(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%theta_vwp(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_bw%fei(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%fei(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_bw%ksat(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%ksat(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_bw%psi_sat(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%psi_sat(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_bw%b(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%b(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_bw%density_soil(npoints, 0:max_layers-1))
    ALLOCATE(soilstat%density_soil(npoints, 0:max_layers-1))
    ALLOCATE(soilstat_bw%f_org(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%f_org(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_bw%ice_ratio(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%ice_ratio(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_bw%thetam(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%thetam(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_bw%thetam_prev(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%thetam_prev(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_bw%temp_soil_p(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%temp_soil_p(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_bw%temp_soil_c(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%temp_soil_c(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_bw%f_ice(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%f_ice(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_bw%psim(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%psim(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_bw%thetab(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%thetab(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_bw%psib(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%psib(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_bw%r_waterflow(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%r_waterflow(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_bw%km(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%km(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_bw%kb(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%kb(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_bw%kk(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%kk(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_bw%cs(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%cs(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_bw%lambda(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%lambda(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_bw%ett(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%ett(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat_bw%g(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%g(npoints, 0:max_layers-1, pft))
    soilstat%n_layer(:) = 0
    soilstat%zp(:, :) = 0.
    soilstat%zsp(:, :) = 0.
    soilstat%r_rain_g(:, :) = 0.
    soilstat%r_drainage(:, :) = 0.
    soilstat%r_root_decay(:, :) = 0.
    soilstat%psi_min(:, :) = 0.
    soilstat%alpha(:, :) = 0.
    soilstat%f_soilwater(:, :) = 0.
    soilstat%d_soil(:, :) = 0.
    soilstat%f_root(:, :, :) = 0.
    soilstat%dt(:, :, :) = 0.
    soilstat%thermal_cond(:, :, :) = 0.
    soilstat%theta_vfc(:, :, :) = 0.
    soilstat%theta_vwp(:, :, :) = 0.
    soilstat%fei(:, :, :) = 0.
    soilstat%ksat(:, :, :) = 0.
    soilstat%psi_sat(:, :, :) = 0.
    soilstat%b(:, :, :) = 0.
    soilstat%density_soil(:, :) = 0.
    soilstat%f_org(:, :, :) = 0.
    soilstat%ice_ratio(:, :, :) = 0.
    soilstat%thetam(:, :, :) = 0.
    soilstat%thetam_prev(:, :, :) = 0.
    soilstat%temp_soil_p(:, :, :) = 0.
    soilstat%temp_soil_c(:, :, :) = 0.
    soilstat%f_ice(:, :, :) = 0.
    soilstat%psim(:, :, :) = 0.
    soilstat%thetab(:, :, :) = 0.
    soilstat%psib(:, :, :) = 0.
    soilstat%r_waterflow(:, :, :) = 0.
    soilstat%km(:, :, :) = 0.
    soilstat%kb(:, :, :) = 0.
    soilstat%kk(:, :, :) = 0.
    soilstat%cs(:, :, :) = 0.
    soilstat%lambda(:, :, :) = 0.
    soilstat%ett(:, :, :) = 0.
    soilstat%g(:, :, :) = 0.
  END SUBROUTINE INITSOILSTAT_BW

  SUBROUTINE INITSOILSTAT()
    IMPLICIT NONE
!--iLab::avoid pointer
! type(soils),pointer  :: p
! p => soilstat
    ALLOCATE(soilstat%n_layer(npoints))
    ALLOCATE(soilstat%zp(npoints, pft))
    ALLOCATE(soilstat%zsp(npoints, pft))
    ALLOCATE(soilstat%r_rain_g(npoints, pft))
    ALLOCATE(soilstat%r_drainage(npoints, pft))
    ALLOCATE(soilstat%r_root_decay(npoints, pft))
    ALLOCATE(soilstat%psi_min(npoints, pft))
    ALLOCATE(soilstat%alpha(npoints, pft))
    ALLOCATE(soilstat%f_soilwater(npoints, pft))
    ALLOCATE(soilstat%d_soil(npoints, 0:max_layers-1))
    ALLOCATE(soilstat%f_root(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%dt(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%thermal_cond(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%theta_vfc(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%theta_vwp(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%fei(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%ksat(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%psi_sat(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%b(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%density_soil(npoints, 0:max_layers-1))
    ALLOCATE(soilstat%f_org(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%ice_ratio(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%thetam(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%thetam_prev(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%temp_soil_p(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%temp_soil_c(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%f_ice(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%psim(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%thetab(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%psib(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%r_waterflow(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%km(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%kb(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%kk(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%cs(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%lambda(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%ett(npoints, 0:max_layers-1, pft))
    ALLOCATE(soilstat%g(npoints, 0:max_layers-1, pft))
    soilstat%n_layer(:) = 0
    soilstat%zp(:, :) = 0.
    soilstat%zsp(:, :) = 0.
    soilstat%r_rain_g(:, :) = 0.
    soilstat%r_drainage(:, :) = 0.
    soilstat%r_root_decay(:, :) = 0.
    soilstat%psi_min(:, :) = 0.
    soilstat%alpha(:, :) = 0.
    soilstat%f_soilwater(:, :) = 0.
    soilstat%d_soil(:, :) = 0.
    soilstat%f_root(:, :, :) = 0.
    soilstat%dt(:, :, :) = 0.
    soilstat%thermal_cond(:, :, :) = 0.
    soilstat%theta_vfc(:, :, :) = 0.
    soilstat%theta_vwp(:, :, :) = 0.
    soilstat%fei(:, :, :) = 0.
    soilstat%ksat(:, :, :) = 0.
    soilstat%psi_sat(:, :, :) = 0.
    soilstat%b(:, :, :) = 0.
    soilstat%density_soil(:, :) = 0.
    soilstat%f_org(:, :, :) = 0.
    soilstat%ice_ratio(:, :, :) = 0.
    soilstat%thetam(:, :, :) = 0.
    soilstat%thetam_prev(:, :, :) = 0.
    soilstat%temp_soil_p(:, :, :) = 0.
    soilstat%temp_soil_c(:, :, :) = 0.
    soilstat%f_ice(:, :, :) = 0.
    soilstat%psim(:, :, :) = 0.
    soilstat%thetab(:, :, :) = 0.
    soilstat%psib(:, :, :) = 0.
    soilstat%r_waterflow(:, :, :) = 0.
    soilstat%km(:, :, :) = 0.
    soilstat%kb(:, :, :) = 0.
    soilstat%kk(:, :, :) = 0.
    soilstat%cs(:, :, :) = 0.
    soilstat%lambda(:, :, :) = 0.
    soilstat%ett(:, :, :) = 0.
    soilstat%g(:, :, :) = 0.
  END SUBROUTINE INITSOILSTAT

!  Differentiation of initouput in forward (tangent) mode (with options noISIZE r8):
!   Plus diff mem management of: output.gpppft:out output.sifpft:out
!                output.sifpft_sat:out output.npppft:out output.neppft:out
!                output.shpft:out output.lhpft:out output.transpft:out
!                output.evappft:out output.net_radpft:out output.sif:out
!                output.laipft:out output.thetampft:out output.thetam:out
!                output.faparpft:out output.vodpft:out output.cos_fluxpft:out
!                output.cos_flux:out
  SUBROUTINE INITOUPUT_BW()
    IMPLICIT NONE
!--iLab::avoid pointer
! type(res),pointer::p
! p=>output
    ALLOCATE(output_bw%gpppft(npoints, pft))
    ALLOCATE(output%gpppft(npoints, pft))
    ALLOCATE(output_bw%sifpft(npoints, pft))
    ALLOCATE(output%sifpft(npoints, pft))
    ALLOCATE(output_bw%sifpft_sat(npoints, pft))
    ALLOCATE(output%sifpft_sat(npoints, pft))
    ALLOCATE(output_bw%npppft(npoints, pft))
    ALLOCATE(output%npppft(npoints, pft))
    ALLOCATE(output_bw%neppft(npoints, pft))
    ALLOCATE(output%neppft(npoints, pft))
    ALLOCATE(output_bw%shpft(npoints, pft))
    ALLOCATE(output%shpft(npoints, pft))
    ALLOCATE(output_bw%lhpft(npoints, pft))
    ALLOCATE(output%lhpft(npoints, pft))
    ALLOCATE(output_bw%transpft(npoints, pft))
    ALLOCATE(output%transpft(npoints, pft))
    ALLOCATE(output_bw%evappft(npoints, pft))
    ALLOCATE(output%evappft(npoints, pft))
    ALLOCATE(output_bw%net_radpft(npoints, pft))
    ALLOCATE(output%net_radpft(npoints, pft))
    ALLOCATE(output%gpp(npoints))
    ALLOCATE(output_bw%sif(npoints))
    ALLOCATE(output%sif(npoints))
    ALLOCATE(output%sif_sat(npoints))
    ALLOCATE(output%npp(npoints))
    ALLOCATE(output%nep(npoints))
    ALLOCATE(output_bw%laipft(npoints, pft))
    ALLOCATE(output%laipft(npoints, pft))
    ALLOCATE(output%lai(npoints))
    ALLOCATE(output%sh(npoints))
    ALLOCATE(output%lh(npoints))
    ALLOCATE(output%trans(npoints))
    ALLOCATE(output%evap(npoints))
    ALLOCATE(output%net_rad(npoints))
    ALLOCATE(output_bw%thetampft(npoints, pft))
    ALLOCATE(output%thetampft(npoints, pft))
    ALLOCATE(output_bw%thetam(npoints))
    ALLOCATE(output%thetam(npoints))
    ALLOCATE(output_bw%faparpft(npoints, pft))
    ALLOCATE(output%faparpft(npoints, pft))
    ALLOCATE(output%fapar(npoints))
    ALLOCATE(output_bw%vodpft(npoints, pft))
    ALLOCATE(output%vodpft(npoints, pft))
    ALLOCATE(output%vod(npoints))
    ALLOCATE(output_bw%cos_fluxpft(npoints, pft))
    ALLOCATE(output%cos_fluxpft(npoints, pft))
    ALLOCATE(output_bw%cos_flux(npoints))
    ALLOCATE(output%cos_flux(npoints))
    ALLOCATE(output%npp_yr_acc(npoints, pft))
    output%gpppft(:, :) = 0.
    output%sifpft(:, :) = 0.
    output%sifpft_sat(:, :) = 0.
    output%npppft(:, :) = 0.
    output%neppft(:, :) = 0.
    output%shpft(:, :) = 0.
    output%lhpft(:, :) = 0.
    output%transpft(:, :) = 0.
    output%evappft(:, :) = 0.
    output%net_radpft(:, :) = 0.
    output%laipft(:, :) = 0.
    output%thetampft(:, :) = 0.
    output%faparpft(:, :) = 0.
    output%vodpft(:, :) = 0.
    output%cos_fluxpft(:, :) = 0.
    output%npp_yr_acc(:, :) = 0.
    output%gpp(:) = 0.
    output%sif(:) = 0.
    output%sif_sat(:) = 0.
    output%npp(:) = 0.
    output%nep(:) = 0.
    output%lai(:) = 0.
    output%sh(:) = 0.
    output%lh(:) = 0.
    output%trans(:) = 0.
    output%evap(:) = 0.
    output%net_rad(:) = 0.
    output%thetam(:) = 0.
    output%fapar(:) = 0.
    output%cos_flux(:) = 0.
    output%vod(:) = 0.
  END SUBROUTINE INITOUPUT_BW

  SUBROUTINE INITOUPUT()
    IMPLICIT NONE
!--iLab::avoid pointer
! type(res),pointer::p
! p=>output
    ALLOCATE(output%gpppft(npoints, pft))
    ALLOCATE(output%sifpft(npoints, pft))
    ALLOCATE(output%sifpft_sat(npoints, pft))
    ALLOCATE(output%npppft(npoints, pft))
    ALLOCATE(output%neppft(npoints, pft))
    ALLOCATE(output%shpft(npoints, pft))
    ALLOCATE(output%lhpft(npoints, pft))
    ALLOCATE(output%transpft(npoints, pft))
    ALLOCATE(output%evappft(npoints, pft))
    ALLOCATE(output%net_radpft(npoints, pft))
    ALLOCATE(output%gpp(npoints))
    ALLOCATE(output%sif(npoints))
    ALLOCATE(output%sif_sat(npoints))
    ALLOCATE(output%npp(npoints))
    ALLOCATE(output%nep(npoints))
    ALLOCATE(output%laipft(npoints, pft))
    ALLOCATE(output%lai(npoints))
    ALLOCATE(output%sh(npoints))
    ALLOCATE(output%lh(npoints))
    ALLOCATE(output%trans(npoints))
    ALLOCATE(output%evap(npoints))
    ALLOCATE(output%net_rad(npoints))
    ALLOCATE(output%thetampft(npoints, pft))
    ALLOCATE(output%thetam(npoints))
    ALLOCATE(output%faparpft(npoints, pft))
    ALLOCATE(output%fapar(npoints))
    ALLOCATE(output%vodpft(npoints, pft))
    ALLOCATE(output%vod(npoints))
    ALLOCATE(output%cos_fluxpft(npoints, pft))
    ALLOCATE(output%cos_flux(npoints))
    ALLOCATE(output%npp_yr_acc(npoints, pft))
    output%gpppft(:, :) = 0.
    output%sifpft(:, :) = 0.
    output%sifpft_sat(:, :) = 0.
    output%npppft(:, :) = 0.
    output%neppft(:, :) = 0.
    output%shpft(:, :) = 0.
    output%lhpft(:, :) = 0.
    output%transpft(:, :) = 0.
    output%evappft(:, :) = 0.
    output%net_radpft(:, :) = 0.
    output%laipft(:, :) = 0.
    output%thetampft(:, :) = 0.
    output%faparpft(:, :) = 0.
    output%vodpft(:, :) = 0.
    output%cos_fluxpft(:, :) = 0.
    output%npp_yr_acc(:, :) = 0.
    output%gpp(:) = 0.
    output%sif(:) = 0.
    output%sif_sat(:) = 0.
    output%npp(:) = 0.
    output%nep(:) = 0.
    output%lai(:) = 0.
    output%sh(:) = 0.
    output%lh(:) = 0.
    output%trans(:) = 0.
    output%evap(:) = 0.
    output%net_rad(:) = 0.
    output%thetam(:) = 0.
    output%fapar(:) = 0.
    output%cos_flux(:) = 0.
    output%vod(:) = 0.
  END SUBROUTINE INITOUPUT

END MODULE BEPSTYPEINIT_DIFF
!***************************************************************
!! This module will read control parameters,meteo input,boundary conditions,
!! yrdata,cpools etc. for beps
!! Editted by J. Wang
!! 22May 2017
!***************************************************************
MODULE CONTROLINPUT_MOD_DIFF
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE BEPS_PAR
  USE BEPSTYPE_DIFF
!--iLab::restricted use(s)
!-- update:with required arguments in routines below, can avoid completely
! use beps_time_manager,only: get_curr_date, get_curr_calday
! use beps_time_manager,only: set_timemgr_init,timemgr_init,get_curr_date,&
!      get_prev_date,get_curr_calday,timemgr_datediff
  USE NETCDF
  IMPLICIT NONE
!include 'mpif.h'
!--iLab::no need for include file, since we call 'use netcdf' above
! include 'netcdf.inc'
  SAVE 
  INTEGER :: nlat, nlon
  CHARACTER(len=80) :: calendar
  INTEGER :: sim_type
  INTEGER :: icdate
  INTEGER :: icsec
  INTEGER :: sim_duration
!!nstpd determines when to output
  INTEGER :: nhtfrq, nstpd
  INTEGER :: restart_frq
  INTEGER :: meteo_input
  INTEGER :: nscale, n_site
  INTEGER :: lai_input
  CHARACTER(len=255) :: meteo_path, meteo_flnm_prefix, &
& meteo_site_flnm_prefix
  CHARACTER(len=255) :: surface_data_path
  CHARACTER(len=255) :: beps_yrdata_path
  CHARACTER(len=255) :: beps_site_path, site_bound_prefix, &
& prior_para_prefix
  CHARACTER(len=255) :: beps_lai_path, beps_lai_prefix, &
& beps_lai_site_prefix
  CHARACTER(len=255) :: beps_vcmax_path, beps_vcmax_site_path
  CHARACTER(len=255) :: beps_domain
  CHARACTER(len=255) :: beps_cpools
  CHARACTER(len=255) :: beps_out_dir
  CHARACTER(len=255) :: beps_rst_dir
  PUBLIC :: rdnamelist
  PRIVATE :: read_beps_domain

CONTAINS
  SUBROUTINE RDNAMELIST()
    IMPLICIT NONE
    INTEGER :: ierr
    NAMELIST /nls/ nlat, nlon, nscale, calendar, icdate, icsec, sim_type&
&       , sim_duration, nhtfrq, restart_frq, meteo_input, meteo_path, &
&       meteo_flnm_prefix, meteo_site_flnm_prefix, surface_data_path, &
&       beps_yrdata_path, n_site, beps_site_path, site_bound_prefix, &
&       lai_input, beps_lai_path, beps_lai_prefix, beps_lai_site_prefix&
&       , beps_vcmax_path, beps_vcmax_site_path, beps_domain, &
&       prior_para_prefix, beps_cpools, beps_out_dir, beps_rst_dir
!if(myid ==0) then
    OPEN(5, file='beps.stdin', form='formatted') 
    REWIND(5) 
    READ(5, nml=nls, iostat=ierr) 
    IF (ierr .GT. 0) THEN
      WRITE(6, *) 'RDNAMELIST: Namelist read returns ', ierr
      CALL ENDRUN('Read Namelist Wrong!')
    END IF
    IF (nscale .EQ. 0) CALL READ_BEPS_DOMAIN(beps_domain)
!end if
!call mpi_barrier(mpi_comm_world,ierr)
!call mpi_bcast(nlat,1,mpi_integer,0,mpi_comm_world,ierr)
!call mpi_bcast(nlon,1,mpi_integer,0,mpi_comm_world,ierr)
!call mpi_bcast(nscale,1,mpi_integer,0,mpi_comm_world,ierr)
!call mpi_bcast(calendar,len(calendar),mpi_character,0,mpi_comm_world,ierr)
!call mpi_bcast(icdate,1,mpi_integer,0,mpi_comm_world,ierr)
!call mpi_bcast(icsec,1,mpi_integer,0,mpi_comm_world,ierr)
!call mpi_bcast(sim_type,1,mpi_integer,0,mpi_comm_world,ierr)
!call mpi_bcast(sim_duration,1,mpi_integer,0,mpi_comm_world,ierr)
!call mpi_bcast(nhtfrq,1,mpi_integer,0,mpi_comm_world,ierr)
!call mpi_bcast(restart_frq,1,mpi_integer,0,mpi_comm_world,ierr)
!call mpi_bcast(meteo_input,1,mpi_integer,0,mpi_comm_world,ierr)
!call mpi_bcast(meteo_path,len(meteo_path),mpi_character,0,mpi_comm_world,ierr)
!call mpi_bcast(meteo_flnm_prefix,len(meteo_flnm_prefix),mpi_character,0,mpi_comm_world,ierr)
!call mpi_bcast(meteo_site_flnm_prefix,len(meteo_site_flnm_prefix),mpi_character,0,mpi_comm_world,ierr)
!call mpi_bcast(surface_data_path,len(surface_data_path),mpi_character,0,mpi_comm_world,ierr)
!call mpi_bcast(beps_yrdata_path,len(beps_yrdata_path),mpi_character,0,mpi_comm_world,ierr)
!call mpi_bcast(n_site,1,mpi_integer,0,mpi_comm_world,ierr)
!call mpi_bcast(beps_site_path,len(beps_site_path),mpi_character,0,mpi_comm_world,ierr)
!call mpi_bcast(site_bound_prefix,len(site_bound_prefix),mpi_character,0,mpi_comm_world,ierr)
!call mpi_bcast(lai_input,1,mpi_integer,0,mpi_comm_world,ierr)
!call mpi_bcast(beps_lai_path,len(beps_lai_path),mpi_character,0,mpi_comm_world,ierr)
!call mpi_bcast(beps_lai_prefix,len(beps_lai_prefix),mpi_character,0,mpi_comm_world,ierr)
!call mpi_bcast(beps_lai_site_prefix,len(beps_lai_site_prefix),mpi_character,0,mpi_comm_world,ierr)
!call mpi_bcast(beps_Vcmax_path,len(beps_Vcmax_path),mpi_character,0,mpi_comm_world,ierr)
!call mpi_bcast(beps_Vcmax_site_path,len(beps_Vcmax_site_path),mpi_character,0,mpi_comm_world,ierr)
!call mpi_bcast(beps_domain,len(beps_domain),mpi_character,0,mpi_comm_world,ierr)
!call mpi_bcast(beps_cpools,len(beps_cpools),mpi_character,0,mpi_comm_world,ierr)
!call mpi_bcast(beps_out_dir,len(beps_out_dir),mpi_character,0,mpi_comm_world,ierr)
!call mpi_bcast(beps_rst_dir,len(beps_rst_dir),mpi_character,0,mpi_comm_world,ierr)
!call mpi_barrier(mpi_comm_world,ierr)
!!  store run type
    nsrest = sim_type
!! setting nstpd
    IF (nhtfrq .LT. 0) THEN
! means hours
      nstpd = -(nhtfrq*3600/step)
    END IF
  END SUBROUTINE RDNAMELIST

  SUBROUTINE READ_BEPS_DOMAIN(filname)
    IMPLICIT NONE
!deallocate(stype)
!deallocate(mapping)
    CHARACTER(len=*), INTENT(IN) :: filname
    INTEGER :: ncid, varid(2)
    INTEGER :: domain(nlon, nlat)
    INTEGER :: i, j
    INTRINSIC TRIM
    INTRINSIC RESHAPE
    INTEGER :: result1
    result1 = NF90_OPEN(TRIM(filname), nf90_nowrite, ncid)
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'domain', varid(1))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'nlp', varid(2))
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(1), domain)
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(2), nlp)
    CALL CHECK(result1)
    result1 = NF90_CLOSE(ncid)
    CALL CHECK(result1)
    ALLOCATE(stype(nlon*nlat))
    ALLOCATE(mapping(nlp))
    stype = RESHAPE(domain, (/nlon*nlat/))
    j = 1
    DO i=1,nlon*nlat
      IF (stype(i) .EQ. 1) THEN
        mapping(j) = i
        j = j + 1
      END IF
    END DO
  END SUBROUTINE READ_BEPS_DOMAIN

!***************Reading boundary data*************************
  SUBROUTINE READ_BOUNDARY()
    IMPLICIT NONE
    INTEGER :: i, ncid, varid(9), ierr
    INTEGER :: lcno(nlon, nlat, pft), stext(nlon, nlat)
    REAL(r8) :: pct_pft(nlon, nlat, pft), ci(nlon, nlat), longitude(nlon&
&   , nlat), latitude(nlon, nlat), sdp(nlon, nlat), st(nlon, nlat), sw(&
&   nlon, nlat)
    INTEGER :: lcno2(nlon*nlat, pft), stext2(nlon*nlat)
    REAL(r8) :: pct_pft2(nlon*nlat, pft), ci2(nlon*nlat), longitude2(&
&   nlon*nlat), latitude2(nlon*nlat), sdp2(nlon*nlat), st2(nlon*nlat), &
&   sw2(nlon*nlat)
    INTEGER :: lcno3(nlp, pft), stext3(nlp)
    REAL(r8) :: pct_pft3(nlp, pft), ci3(nlp), longitude3(nlp), latitude3&
&   (nlp), sdp3(nlp), st3(nlp), sw3(nlp)
    TYPE(SURF), POINTER :: p
    INTRINSIC TRIM
    INTRINSIC RESHAPE
    INTEGER :: result1
    p => bound
!if(myid == 0) then
    result1 = NF90_OPEN(TRIM(surface_data_path), nf90_nowrite, ncid)
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'PFT', varid(1))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'PCT_PFT', varid(2))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'ci', varid(3))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'stext', varid(4))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'longitude', varid(5))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'latitude', varid(6))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'sdp', varid(7))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'st', varid(8))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'sw', varid(9))
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(1), lcno)
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(2), pct_pft)
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(3), ci)
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(4), stext)
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(5), longitude)
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(6), latitude)
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(7), sdp)
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(8), st)
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(9), sw)
    CALL CHECK(result1)
    result1 = NF90_CLOSE(ncid)
    CALL CHECK(result1)
    lcno2 = RESHAPE(lcno, (/nlon*nlat, pft/))
    pct_pft2 = RESHAPE(pct_pft, (/nlon*nlat, pft/))
    ci2 = RESHAPE(ci, (/nlon*nlat/))
    stext2 = RESHAPE(stext, (/nlon*nlat/))
    longitude2 = RESHAPE(longitude, (/nlon*nlat/))
    latitude2 = RESHAPE(latitude, (/nlon*nlat/))
    sdp2 = RESHAPE(sdp, (/nlon*nlat/))
    st2 = RESHAPE(st, (/nlon*nlat/))
    sw2 = RESHAPE(sw, (/nlon*nlat/))
    lcno3 = lcno2(mapping, :)
    pct_pft3 = pct_pft2(mapping, :)
    ci3 = ci2(mapping)
    stext3 = stext2(mapping)
    longitude3 = longitude2(mapping)
    latitude3 = latitude2(mapping)
    sdp3 = sdp2(mapping)
    st3 = st2(mapping)
    sw3 = sw2(mapping)
!end if
!call mpi_barrier(mpi_comm_world,ierr)
!call mpi_scatterv(ci3(1),dp,sp,MPI_real8,p%clumping(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(stext3(1),dp,sp,mpi_integer,p%stext(1),npoints,mpi_integer,0,mpi_comm_world,ierr)
!call mpi_scatterv(longitude3(1),dp,sp,mpi_real8,p%longitude(1),npoints,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(latitude3(1),dp,sp,mpi_real8,p%latitude(1),npoints,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(sdp3(1),dp,sp,mpi_real8,p%sdp(1),npoints,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(st3(1),dp,sp,mpi_real8,p%st(1),npoints,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(sw3(1),dp,sp,mpi_real8,p%sw(1),npoints,mpi_real8,0,mpi_comm_world,ierr)
!do i=1,PFT
!   call mpi_scatterv(lcno3(1,i),dp,sp,mpi_integer,p%lcno(1,i),npoints,mpi_integer,0,mpi_comm_world,ierr)
!   call mpi_scatterv(PCT_PFT3(1,i),dp,sp,mpi_real8,p%PCT_PFT(1,i),npoints,mpi_real8,0,mpi_comm_world,ierr)
!end do
!call mpi_barrier(mpi_comm_world,ierr)
    p%clumping = ci3
    p%stext = stext3
    p%longitude = longitude3
    p%latitude = latitude3
    p%sdp = sdp3
    p%st = st3
    p%sw = sw3
    p%lcno = lcno3
    p%pct_pft = pct_pft3
  END SUBROUTINE READ_BOUNDARY

  SUBROUTINE READ_YRDATA()
    IMPLICIT NONE
    INTEGER :: i, ncid, varid(2), ierr
    REAL(r8) :: laiyr1(nlon, nlat, pft), nppyr1(nlon, nlat, pft)
    REAL(r8) :: laiyr2(nlon*nlat, pft), nppyr2(nlon*nlat, pft)
    REAL(r8) :: laiyr3(nlp, pft), nppyr3(nlp, pft)
    TYPE(SURF), POINTER :: p
    INTRINSIC TRIM
    INTRINSIC RESHAPE
    INTEGER :: result1
    p => bound
!if(myid ==0) then
    result1 = NF90_OPEN(TRIM(beps_yrdata_path), nf90_nowrite, ncid)
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'lai', varid(1))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'npp', varid(2))
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(1), laiyr1)
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(2), nppyr1)
    CALL CHECK(result1)
    result1 = NF90_CLOSE(ncid)
    CALL CHECK(result1)
    laiyr2 = RESHAPE(laiyr1, (/nlon*nlat, pft/))
    nppyr2 = RESHAPE(nppyr1, (/nlon*nlat, pft/))
    laiyr3 = laiyr2(mapping, :)
    nppyr3 = nppyr2(mapping, :)
!end if
!call mpi_barrier(mpi_comm_world,ierr)
!do i = 1,PFT
!   call mpi_scatterv(laiyr3(1,i),dp,sp,mpi_real8,p%laiyr(1,i),npoints,mpi_real8,0,mpi_comm_world,ierr)
!   call mpi_scatterv(nppyr3(1,i),dp,sp,mpi_real8,p%nppyr(1,i),npoints,mpi_real8,0,mpi_comm_world,ierr)
!end do
!call mpi_barrier(mpi_comm_world,ierr)
    p%laiyr = laiyr3
    p%nppyr = nppyr3
  END SUBROUTINE READ_YRDATA

  SUBROUTINE READ_BOUNDARY_SITE()
    IMPLICIT NONE
    INTEGER :: i, ncid, varid(20), ierr
    INTEGER :: lcno(nlp, pft), stext(nlp)
    REAL(r8) :: laiyr(nlp, pft), nppyr(nlp, pft)
    REAL(r8) :: pct_pft(nlp, pft)
    REAL(r8) :: longitude(nlp), latitude(nlp), sdp(nlp), st(nlp), sw(nlp&
&   ), ci(nlp)
    REAL(r8) :: ccd(nlp, pft), cfmd(nlp, pft), cfsd(nlp, pft), cm(nlp, &
&   pft), cp(nlp, pft), cs(nlp, pft), csm(nlp, pft), csmd(nlp, pft), &
&   cssd(nlp, pft)
!--iLab::avoid pointer
! type(surf),pointer :: p
! p => bound
    CHARACTER(len=255) :: fname
    CHARACTER(len=*), PARAMETER :: method='read_boundary_site'
    INTRINSIC TRIM
    INTRINSIC LEN
    INTEGER :: result1
    IF (LEN(TRIM(beps_site_path)) + LEN(TRIM(site_bound_prefix)) + LEN(&
&       '.nc') .GT. LEN(fname)) THEN
      WRITE(*, '(a)') 'FATAL::INTERNAL-ERROR::'//method//&
&     ':file name too long!'
      STOP
    ELSE
      fname = TRIM(beps_site_path)//TRIM(site_bound_prefix)//'.nc'
      PRINT*, 'START read_boundary_site with *****'//TRIM(fname)//&
&     '*****'
!if(myid == 0) then
      result1 = NF90_OPEN(fname, nf90_nowrite, ncid)
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'laiyr', varid(1))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'nppyr', varid(2))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'lcno', varid(3))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'PCT_PFT', varid(4))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'ci', varid(5))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'stext', varid(6))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'longitude', varid(7))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'latitude', varid(8))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'sdp', varid(9))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'st', varid(10))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'sw', varid(11))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'ccd', varid(12))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'cfmd', varid(13))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'cfsd', varid(14))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'cm', varid(15))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'cp', varid(16))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'cs', varid(17))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'csm', varid(18))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'csmd', varid(19))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'cssd', varid(20))
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(1), laiyr)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(2), nppyr)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(3), lcno)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(4), pct_pft)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(5), ci)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(6), stext)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(7), longitude)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(8), latitude)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(9), sdp)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(10), st)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(11), sw)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(12), ccd)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(13), cfmd)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(14), cfsd)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(15), cm)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(16), cp)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(17), cs)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(18), csm)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(19), csmd)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(20), cssd)
      CALL CHECK(result1)
      result1 = NF90_CLOSE(ncid)
      CALL CHECK(result1)
!end if
!! convert fraction to %
      pct_pft = pct_pft*1.0
!call mpi_barrier(mpi_comm_world,ierr)
!call mpi_scatterv(ci(1),dp,sp,MPI_real8,bound%clumping(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(stext(1),dp,sp,mpi_integer,bound%stext(1),npoints,mpi_integer,0,mpi_comm_world,ierr)
!call mpi_scatterv(longitude(1),dp,sp,mpi_real8,bound%longitude(1),npoints,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(latitude(1),dp,sp,mpi_real8,bound%latitude(1),npoints,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(sdp(1),dp,sp,mpi_real8,bound%sdp(1),npoints,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(st(1),dp,sp,mpi_real8,bound%st(1),npoints,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(sw(1),dp,sp,mpi_real8,bound%sw(1),npoints,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(name(1),dp,sp,mpi_character,bound%name(1),npoints,mpi_character,0,mpi_comm_world,ierr)
!call mpi_barrier(mpi_comm_world,ierr)
!do i = 1,PFT
!    call mpi_scatterv(lcno(1,i),dp,sp,mpi_integer,bound%lcno(1,i),npoints,mpi_integer,0,mpi_comm_world,ierr)
!    call mpi_scatterv(PCT_PFT(1,i),dp,sp,mpi_real8,bound%PCT_PFT(1,i),npoints,mpi_real8,0,mpi_comm_world,ierr)
!    call mpi_scatterv(laiyr(1,i),dp,sp,mpi_real8,bound%laiyr(1,i),npoints,mpi_real8,0,mpi_comm_world,ierr)
!    call mpi_scatterv(nppyr(1,i),dp,sp,mpi_real8,bound%nppyr(1,i),npoints,mpi_real8,0,mpi_comm_world,ierr)
!    call mpi_scatterv(ccd(1,i),dp,sp,MPI_real8,bound%ccd(1,i),npoints,MPI_real8,0,mpi_comm_world,ierr)
!    call mpi_scatterv(cfmd(1,i),dp,sp,MPI_real8,bound%cfmd(1,i),npoints,MPI_real8,0,mpi_comm_world,ierr)
!    call mpi_scatterv(cfsd(1,i),dp,sp,MPI_real8,bound%cfsd(1,i),npoints,MPI_real8,0,mpi_comm_world,ierr)
!    call mpi_scatterv(cm(1,i),dp,sp,MPI_real8,bound%cm(1,i),npoints,MPI_real8,0,mpi_comm_world,ierr)
!    call mpi_scatterv(cp(1,i),dp,sp,MPI_real8,bound%cp(1,i),npoints,MPI_real8,0,mpi_comm_world,ierr)
!    call mpi_scatterv(cs(1,i),dp,sp,MPI_real8,bound%cs(1,i),npoints,MPI_real8,0,mpi_comm_world,ierr)
!    call mpi_scatterv(csm(1,i),dp,sp,MPI_real8,bound%csm(1,i),npoints,MPI_real8,0,mpi_comm_world,ierr)
!    call mpi_scatterv(csmd(1,i),dp,sp,MPI_real8,bound%csmd(1,i),npoints,MPI_real8,0,mpi_comm_world,ierr)
!    call mpi_scatterv(cssd(1,i),dp,sp,MPI_real8,bound%cssd(1,i),npoints,MPI_real8,0,mpi_comm_world,ierr)
!end do
!call mpi_barrier(mpi_comm_world,ierr)
      bound%clumping = ci
      bound%stext = stext
      bound%longitude = longitude
      bound%latitude = latitude
      bound%sdp = sdp
      bound%st = st
      bound%sw = sw
      bound%lcno = lcno
      bound%pct_pft = pct_pft
      bound%laiyr = laiyr
      bound%nppyr = nppyr
      bound%ccd = ccd
      bound%cfmd = cfmd
      bound%cfsd = cfsd
      bound%cm = cm
      bound%cp = cp
      bound%cs = cs
      bound%csm = csm
      bound%csmd = csmd
      bound%cssd = cssd
    END IF
  END SUBROUTINE READ_BOUNDARY_SITE

  SUBROUTINE READ_METEO_DAILY(yr, mon, day, sec)
    IMPLICIT NONE
!--iLab::made yr/mon/day/sec arguments in order to avoid 'get_curr_date'
    INTEGER, INTENT(IN) :: yr, mon, day, sec
!character(len=*) :: file_path,file_flnm_prefix
    INTEGER :: ncid, ierr, varid(6)
    INTEGER :: nt
    INTEGER :: i
!--iLab::avoid pointer (see also below)
! type(forc),pointer :: p
    REAL(r8) :: t1(nlon, nlat), tmax1(nlon, nlat), tmin1(nlon, nlat), &
&   rh1(nlon, nlat), ws1(nlon, nlat), prcp1(nlon, nlat), ssrd1(nlon, &
&   nlat)
    REAL(r8) :: t2(nlon*nlat), tmax2(nlon*nlat), tmin2(nlon*nlat), rh2(&
&   nlon*nlat), ws2(nlon*nlat), prcp2(nlon*nlat), ssrd2(nlon*nlat)
    REAL(r8) :: t3(nlp), tmax3(nlp), tmin3(nlp), rh3(nlp), ws3(nlp), &
&   prcp3(nlp), ssrd3(nlp)
    REAL(r8) :: rainfall(nlp), snow(nlp)
    CHARACTER(len=6) :: monstr
    CHARACTER(len=8) :: datestr
    CHARACTER(len=4) :: yrstr
    REAL(r8), PARAMETER :: density_water=1025.
    REAL(r8) :: density_new_snow
    CHARACTER(len=255) :: fname
    CHARACTER(len=*), PARAMETER :: method='read_meteo_daily'
    INTRINSIC TRIM
    INTRINSIC LEN
    INTRINSIC RESHAPE
    INTRINSIC MAX
    INTRINSIC EXP
    INTEGER :: result1
    LOGICAL, DIMENSION(nlp) :: mask
!if(myid ==0) then
!   day  = get_curr_calday()
! call  get_curr_date(yr,mon,day,sec)
!   call get_prev_date(yr,mon,day,sec)   !!??
!  write(6,*) "Reading met data on ",sec,"of", yr*10000+mon*100+day
!  write(datestr,'(i8)')  yr*10000+mon*100+day
    WRITE(monstr, '(i6)') yr*100 + mon
    WRITE(yrstr, '(i4)') yr
!  call check(nf90_open(trim(meteo_path)//trim(yrstr)//'/'//trim(meteo_flnm_prefix)//trim(datestr)//".nc",nf90_nowrite,ncid))
    IF (LEN(TRIM(meteo_path)) + LEN(TRIM(meteo_flnm_prefix)) + LEN(TRIM(&
&       monstr)) + LEN('.nc') .GT. LEN(fname)) THEN
      WRITE(*, '(a)') 'FATAL::INTERNAL-ERROR::'//method//&
&     ':file name too long!'
      STOP
    ELSE
      fname = TRIM(meteo_path)//'/'//TRIM(meteo_flnm_prefix)//TRIM(&
&       monstr)//'.nc'
      result1 = NF90_OPEN(fname, nf90_nowrite, ncid)
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'TMAX', varid(1))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'TMIN', varid(2))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'RH', varid(3))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'WS', varid(4))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'PRCP', varid(5))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'SSRD', varid(6))
      CALL CHECK(result1)
!  nt    = (day-1)*24+sec/int(step)+1     !! data slide for months
!  nt    = sec/int(step)+1
      WRITE(*, *) 'Reading meteo data on ', day, 'of', monstr
      result1 = NF90_GET_VAR(ncid, varid(1), tmax1, start=(/1, 1, day/)&
&       , count=(/nlon, nlat, 1/))
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(2), tmin1, start=(/1, 1, day/)&
&       , count=(/nlon, nlat, 1/))
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(3), rh1, start=(/1, 1, day/), &
&       count=(/nlon, nlat, 1/))
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(4), ws1, start=(/1, 1, day/), &
&       count=(/nlon, nlat, 1/))
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(5), prcp1, start=(/1, 1, day/)&
&       , count=(/nlon, nlat, 1/))
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(6), ssrd1, start=(/1, 1, day/)&
&       , count=(/nlon, nlat, 1/))
      CALL CHECK(result1)
      result1 = NF90_CLOSE(ncid)
      CALL CHECK(result1)
      tmax2 = RESHAPE(tmax1, (/nlon*nlat/))
      tmin2 = RESHAPE(tmin1, (/nlon*nlat/))
      rh2 = RESHAPE(rh1, (/nlon*nlat/))
      ws2 = RESHAPE(ws1, (/nlon*nlat/))
      prcp2 = RESHAPE(prcp1, (/nlon*nlat/))
      ssrd2 = RESHAPE(ssrd1, (/nlon*nlat/))
!! K
      tmax3 = tmax2(mapping)
!! K
      tmin3 = tmin2(mapping)
!!
      rh3 = rh2(mapping)
!! m/s
      ws3 = ws2(mapping)
!! m/s(consult)
      prcp3 = prcp2(mapping)
!! w/m2
      ssrd3 = ssrd2(mapping)
!! translate into centigrade (oC)
      tmax3 = tmax3 - 273.16
!! translate into centigrade (oC)
      tmin3 = tmin3 - 273.16
!! %
      rh3 = rh3*100
      mask = 0. .LT. prcp3/3600.
      WHERE (mask) 
        prcp3 = prcp3/3600.
      ELSEWHERE
        prcp3 = 0.
      END WHERE
      t3 = (tmax3+tmin3)/2.
!! seperating total precip into liquid and solid according to temperature
      DO i=1,nlp
        IF (t3(i) .GT. 0.) THEN
          rainfall(i) = prcp3(i)
          snow(i) = 0.
        ELSE
          rainfall(i) = 0.
          density_new_snow = 67.9 + 51.3*EXP(t3(i)/2.6)
          snow(i) = prcp3(i)*density_water/density_new_snow
        END IF
      END DO
!end if
!--iLab::avoid pointer
! p =>clim
!call mpi_barrier(mpi_comm_world,ierr)
!call mpi_scatterv(TMAX3(1),dp,sp,MPI_real8,clim%Tempmx(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(TMIN3(1),dp,sp,MPI_real8,clim%Tempmn(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(RH3(1),dp,sp,MPI_real8,clim%Rh(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(WS3(1),dp,sp,MPI_real8,clim%Wind(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(SSRD3(1),dp,sp,MPI_real8,clim%Srad(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(rainfall(1),dp,sp,MPI_real8,clim%Rain(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(snow(1),dp,sp,MPI_real8,clim%Snow(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_barrier(mpi_comm_world,ierr)
      clim%tempmx = tmax3
      clim%tempmn = tmin3
      clim%rh = rh3
      clim%wind = ws3
      clim%srad = ssrd3
      clim%rain = rainfall
      clim%snow = snow
    END IF
  END SUBROUTINE READ_METEO_DAILY

  SUBROUTINE READ_METEO_HOURLY(yr, mon, day, sec)
    IMPLICIT NONE
!--iLab::made yr/mon/day/sec arguments in order to avoid 'get_curr_date'
    INTEGER, INTENT(IN) :: yr, mon, day, sec
!character(len=*) :: file_path,file_flnm_prefix
    INTEGER :: ncid, ierr, varid(5)
! integer          :: yr,mon,day,sec
    INTEGER :: nt
    INTEGER :: i
!--iLab::avoid pointer (see also below)
! type(forc),pointer :: p
    REAL(r8) :: t1(nlon, nlat), rh1(nlon, nlat), ws1(nlon, nlat), prcp1(&
&   nlon, nlat), ssrd1(nlon, nlat)
    REAL(r8) :: t2(nlon*nlat), rh2(nlon*nlat), ws2(nlon*nlat), prcp2(&
&   nlon*nlat), ssrd2(nlon*nlat)
    REAL(r8) :: t3(nlp), rh3(nlp), ws3(nlp), prcp3(nlp), ssrd3(nlp)
    REAL(r8) :: rainfall(nlp), snow(nlp)
!character(len=6)   :: monstr
    CHARACTER(len=8) :: datestr
    CHARACTER(len=4) :: yrstr
    REAL(r8), PARAMETER :: density_water=1025.
    REAL(r8) :: density_new_snow
    CHARACTER(len=255) :: fname
    CHARACTER(len=*), PARAMETER :: method='read_meteo_hourly'
    INTRINSIC TRIM
    INTRINSIC LEN
    INTRINSIC INT
    INTRINSIC RESHAPE
    INTRINSIC MAX
    INTRINSIC EXP
    INTEGER :: result1
    LOGICAL, DIMENSION(nlp) :: mask
!if(myid ==0) then
! call get_curr_date(yr,mon,day,sec)
    WRITE(datestr, '(i8)') yr*10000 + mon*100 + day
    WRITE(yrstr, '(i4)') yr
!  call check(nf90_open(trim(meteo_path)//trim(yrstr)//'/'//trim(meteo_flnm_prefix)//trim(datestr)//".nc",nf90_nowrite,ncid))
    IF (LEN(TRIM(meteo_path)) + LEN(TRIM(meteo_flnm_prefix)) + LEN(TRIM(&
&       datestr)) + LEN('.nc') .GT. LEN(fname)) THEN
      WRITE(*, '(a)') 'FATAL::INTERNAL-ERROR::'//method//&
&     ':file name too long!'
      STOP
    ELSE
      fname = TRIM(meteo_path)//'/'//TRIM(meteo_flnm_prefix)//TRIM(&
&       datestr)//'.nc'
      result1 = NF90_OPEN(fname, nf90_nowrite, ncid)
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'T', varid(1))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'RH', varid(2))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'WS', varid(3))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'PRCP', varid(4))
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'SSRD', varid(5))
      CALL CHECK(result1)
!  nt    = (day-1)*24+sec/int(step)+1     !! data slide for months
      nt = sec/INT(step) + 1
      WRITE(*, *) 'Reading meteo data on ', nt, 'of', datestr
      result1 = NF90_GET_VAR(ncid, varid(1), t1, start=(/1, 1, nt/), &
&       count=(/nlon, nlat, 1/))
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(2), rh1, start=(/1, 1, nt/), &
&       count=(/nlon, nlat, 1/))
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(3), ws1, start=(/1, 1, nt/), &
&       count=(/nlon, nlat, 1/))
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(4), prcp1, start=(/1, 1, nt/), &
&       count=(/nlon, nlat, 1/))
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid(5), ssrd1, start=(/1, 1, nt/), &
&       count=(/nlon, nlat, 1/))
      CALL CHECK(result1)
      result1 = NF90_CLOSE(ncid)
      CALL CHECK(result1)
      t2 = RESHAPE(t1, (/nlon*nlat/))
      rh2 = RESHAPE(rh1, (/nlon*nlat/))
      ws2 = RESHAPE(ws1, (/nlon*nlat/))
      prcp2 = RESHAPE(prcp1, (/nlon*nlat/))
      ssrd2 = RESHAPE(ssrd1, (/nlon*nlat/))
!! K
      t3 = t2(mapping)
!!
      rh3 = rh2(mapping)
!! m/s
      ws3 = ws2(mapping)
!! m/s(consult)
      prcp3 = prcp2(mapping)
!! w/m2
      ssrd3 = ssrd2(mapping)
!! translate into centigrade (oC)
      t3 = t3 - 273.16
!! %
      rh3 = rh3*100
      mask = 0. .LT. prcp3/3600.
      WHERE (mask) 
        prcp3 = prcp3/3600.
      ELSEWHERE
        prcp3 = 0.
      END WHERE
!! seperating total precip into liquid and solid according to temperature
      DO i=1,nlp
        IF (t3(i) .GT. 0.) THEN
          rainfall(i) = prcp3(i)
          snow(i) = 0.
        ELSE
          rainfall(i) = 0.
          density_new_snow = 67.9 + 51.3*EXP(t3(i)/2.6)
          snow(i) = prcp3(i)*density_water/density_new_snow
        END IF
      END DO
!end if
!--iLab::avoid pointer
! p =>clim
!call mpi_barrier(mpi_comm_world,ierr)
!call mpi_scatterv(T3(1),dp,sp,MPI_real8,clim%Temp(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(RH3(1),dp,sp,MPI_real8,clim%Rh(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(WS3(1),dp,sp,MPI_real8,clim%Wind(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(SSRD3(1),dp,sp,MPI_real8,clim%Srad(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(rainfall(1),dp,sp,MPI_real8,clim%Rain(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(snow(1),dp,sp,MPI_real8,clim%Snow(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_barrier(mpi_comm_world,ierr)
      clim%temp = t3
      clim%rh = rh3
      clim%wind = ws3
      clim%srad = ssrd3
      clim%rain = rainfall
      clim%snow = snow
    END IF
  END SUBROUTINE READ_METEO_HOURLY

  SUBROUTINE READ_METEO_SITE_REFTIME()
    IMPLICIT NONE
    INTEGER :: ncid, timevar_id
    LOGICAL :: ldebug
    CHARACTER(len=255) :: fname
    CHARACTER(len=*), PARAMETER :: method='read_meteo_site_reftime'
    CHARACTER(len=*), PARAMETER :: time_unit_expected=&
&     'hours since YYYY-MM-DD'
    CHARACTER(len=128) :: time_unit
    INTRINSIC TRIM
    INTRINSIC LEN
    INTEGER :: result1
    ldebug = .false.
    IF (LEN(TRIM(beps_site_path)) + LEN(TRIM(meteo_site_flnm_prefix)) + &
&       LEN('.nc') .GT. LEN(fname)) THEN
      WRITE(*, '(a)') 'FATAL::INTERNAL-ERROR::'//method//&
&     ':file name too long!'
      STOP
    ELSE
      fname = TRIM(beps_site_path)//'/'//TRIM(meteo_site_flnm_prefix)//&
&       '.nc'
      IF (ldebug) WRITE(*, '(a)') 'DEBUG::'//method//&
&                 ':reading meteo data ***'//TRIM(fname)//'***'
      result1 = NF90_OPEN(fname, nf90_nowrite, ncid)
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'time', timevar_id)
      CALL CHECK(result1)
      IF (ldebug) WRITE(*, '(a)') 'DEBUG::'//method//&
&                 ':data set identifier determined!'
!-- iLab::get reference time in meteorological forcing
      result1 = NF90_GET_ATT(ncid, timevar_id, 'units', time_unit)
      CALL CHECK(result1)
      IF (LEN(TRIM(time_unit)) .NE. LEN(time_unit_expected)) THEN
        WRITE(*, '(a)') ' FATAL::'//method//&
&       ': unexpected unit of time in met forcing '//'***'//TRIM(&
&       time_unit)//'***'
        STOP
      ELSE
!-- expected: "hours since yyyy-mm-dd"
        clim%meteo_ref_yyyymmdd = time_unit(13:22)
        result1 = NF90_CLOSE(ncid)
        CALL CHECK(result1)
        IF (ldebug) WRITE(*, '(a)') 'DEBUG::'//method//&
&                   ':NetCDF file closed again.'
      END IF
    END IF
  END SUBROUTINE READ_METEO_SITE_REFTIME

  SUBROUTINE READ_METEO_SITE(nd)
    IMPLICIT NONE
!character(len=*) :: file_path,file_flnm_prefix
    INTEGER, INTENT(IN) :: nd
    INTEGER :: ncid, ierr, varid(5)
    INTEGER :: yr, mon, day, sec
    INTEGER :: nt
    INTEGER :: i
!--iLab::avoid pointer (see also below)
! type(forc),pointer :: p
    REAL(r8) :: t(nlp), rh(nlp), ws(nlp), prcp(nlp), ssrd(nlp)
    REAL(r8) :: rainfall(nlp), snow(nlp)
!character(len=6)   :: monstr
    CHARACTER(len=8) :: datestr
    CHARACTER(len=4) :: yrstr
    REAL(r8), PARAMETER :: density_water=1025.
    REAL(r8) :: density_new_snow
    LOGICAL :: ldebug
    CHARACTER(len=255) :: fname
    CHARACTER(len=*), PARAMETER :: method='read_meteo_site'
    LOGICAL :: exist
    INTRINSIC TRIM
    INTRINSIC LEN
    INTRINSIC MAX
    INTRINSIC EXP
    INTEGER :: result1
    LOGICAL, DIMENSION(nlp) :: mask
    LOGICAL, DIMENSION(nlp) :: mask0
!--iLab::added missing initialisation
    ldebug = .false.
!if(myid ==0) then
!  call check(nf90_open(trim(meteo_path)//trim(yrstr)//'/'//trim(meteo_flnm_prefix)//trim(datestr)//".nc",nf90_nowrite,ncid))
    IF (LEN(TRIM(beps_site_path)) + LEN(TRIM(meteo_site_flnm_prefix)) + &
&       LEN('.nc') .GT. LEN(fname)) THEN
      WRITE(*, '(a)') 'FATAL::INTERNAL-ERROR::'//method//&
&     ':file name too long!'
      STOP
    ELSE
      fname = TRIM(beps_site_path)//'/'//TRIM(meteo_site_flnm_prefix)//&
&       '.nc'
!-- iLab::added: stop in case meteo file is not present
      INQUIRE(file=fname, exist=exist) 
      IF (.NOT.exist) THEN
        WRITE(*, '(a)') ' FATAL::'//method//': file ***'//TRIM(fname)//&
&       '*** does NOT exist'
        STOP
      ELSE
        IF (ldebug) WRITE(*, '(a)') 'DEBUG::'//method//&
&                   ':reading meteo data ***'//TRIM(fname)//'***'
        result1 = NF90_OPEN(fname, nf90_nowrite, ncid)
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'T', varid(1))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'RH', varid(2))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'WS', varid(3))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'PRCP', varid(4))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'SSRD', varid(5))
        CALL CHECK(result1)
        IF (ldebug) WRITE(*, '(a)') 'DEBUG::'//method//&
&                   ':data set identifier determined!'
!  nt    = (day-1)*24+sec/int(step)+1     !! data slide for months
        IF (ldebug) WRITE(*, '(a,2(a,i5,1x))') 'DEBUG::'//method//&
&                   ':reading meteo data on ', 'nd=', nd, 'nlp=', nlp
        result1 = NF90_GET_VAR(ncid, varid(1), t, start=(/1, nd/), count&
&         =(/nlp, 1/))
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(2), rh, start=(/1, nd/), &
&         count=(/nlp, 1/))
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(3), ws, start=(/1, nd/), &
&         count=(/nlp, 1/))
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(4), prcp, start=(/1, nd/), &
&         count=(/nlp, 1/))
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(5), ssrd, start=(/1, nd/), &
&         count=(/nlp, 1/))
        CALL CHECK(result1)
        result1 = NF90_CLOSE(ncid)
        CALL CHECK(result1)
        IF (ldebug) WRITE(*, '(a)') 'DEBUG::'//method//&
&                   ':NetCDF file closed again.'
!! translate into centigrade (oC), input is oC for site.@MOUSONG.WU
        t = t
!! %
        rh = rh*100
        mask = 0. .LT. prcp/3600.
        WHERE (mask) 
          prcp = prcp/3600.
        ELSEWHERE
          prcp = 0.
        END WHERE
        mask0 = 0. .LT. ssrd
        WHERE (mask0) 
          ssrd = ssrd
        ELSEWHERE
          ssrd = 0.
        END WHERE
!! seperating total precip into liquid and solid according to temperature
        DO i=1,nlp
          IF (t(i) .GT. 0.) THEN
            rainfall(i) = prcp(i)
            snow(i) = 0.
          ELSE
            rainfall(i) = 0.
            density_new_snow = 67.9 + 51.3*EXP(t(i)/2.6)
            snow(i) = prcp(i)*density_water/density_new_snow
          END IF
        END DO
!end if
!--iLab::avoid pointer
! p =>clim
!call mpi_barrier(mpi_comm_world,ierr)
!call mpi_scatterv(T(1),dp,sp,MPI_real8,clim%Temp(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(RH(1),dp,sp,MPI_real8,clim%Rh(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(WS(1),dp,sp,MPI_real8,clim%Wind(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(SSRD(1),dp,sp,MPI_real8,clim%Srad(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(rainfall(1),dp,sp,MPI_real8,clim%Rain(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_scatterv(snow(1),dp,sp,MPI_real8,clim%Snow(1),npoints,MPI_real8,0,mpi_comm_world,ierr)
!call mpi_barrier(mpi_comm_world,ierr)
        clim%temp = t
        clim%rh = rh
        clim%wind = ws
        clim%srad = ssrd
        clim%rain = rainfall
        clim%snow = snow
      END IF
    END IF
  END SUBROUTINE READ_METEO_SITE

  SUBROUTINE READ_LAI(yr, mn, dd, tod, day)
    IMPLICIT NONE
!--iLab::made yr/mon/day/sec arguments in order to avoid 'get_curr_date'/'get_cal_day'
    INTEGER, INTENT(IN) :: yr, mn, dd, tod, day
    REAL(r8) :: lai1(nlon, nlat, pft), lai2(nlon*nlat, pft), lai3(nlp, &
&   pft)
    CHARACTER(len=4) :: datestr
    INTEGER :: ncid, varid, ierr, i
!--iLab::avoid pointer (see also below)
! type(surf),pointer:: p
    CHARACTER(len=255) :: fname
    CHARACTER(len=*), PARAMETER :: method='read_lai'
    INTRINSIC TRIM
    INTRINSIC LEN
    INTRINSIC RESHAPE
    INTEGER :: result1
!if(myid ==0) then
! day  = get_curr_calday()
! call get_curr_date(yr,mn,dd,tod)
    WRITE(datestr, '(i4)') yr
    WRITE(*, *) 'Reading LAI On ', yr*10000 + mn*100 + dd
    IF (LEN(TRIM(beps_lai_path)) + LEN(TRIM(beps_lai_prefix)) + LEN(TRIM&
&       (datestr)) + LEN('.nc') .GT. LEN(fname)) THEN
      WRITE(*, '(a)') 'FATAL::INTERNAL-ERROR::'//method//&
&     ':file name too long!'
      STOP
    ELSE
      fname = TRIM(beps_lai_path)//TRIM(beps_lai_prefix)//TRIM(datestr)&
&       //'.nc'
      result1 = NF90_OPEN(fname, nf90_nowrite, ncid)
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'lai', varid)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid, lai1, start=(/1, 1, 1, day/), &
&       count=(/nlon, nlat, pft, 1/))
      CALL CHECK(result1)
      result1 = NF90_CLOSE(ncid)
      CALL CHECK(result1)
      lai2 = RESHAPE(lai1, (/nlon*nlat, pft/))
      lai3 = lai2(mapping, :)
!end if
!--iLab::avoid pointer
! p => bound
!call mpi_barrier(mpi_comm_world,ierr)
!do i = 1,PFT
!    call mpi_scatterv(lai3(1,i),dp,sp,mpi_real8,p%lai(1,i),npoints,mpi_real8,0,mpi_comm_world,ierr)
!end do
!call mpi_barrier(mpi_comm_world,ierr)
      bound%lai = lai3
    END IF
  END SUBROUTINE READ_LAI

  SUBROUTINE READ_LAI_SITE(day)
    IMPLICIT NONE
!--iLab::no need for actual day, calendar day as input
    INTEGER, INTENT(IN) :: day
! integer          :: yr,mn,dd,tod,day
    REAL(r8) :: lai1(nlp, pft)
    INTEGER :: ncid, varid, ierr, i
!--iLab::avoid pointer (see also below)
! type(surf),pointer:: p
!--iLab::added to limit terminal output
    LOGICAL :: ldebug
    CHARACTER(len=255) :: fname
    CHARACTER(len=*), PARAMETER :: method='read_lai_site'
    LOGICAL :: exist
    INTRINSIC TRIM
    INTRINSIC LEN
    INTEGER :: result1
!if(myid ==0) then
! day  = get_curr_calday()
! call get_curr_date(yr,mn,dd,tod)
    ldebug = .false.
    IF (ldebug) WRITE(*, *) 'INFO::'//method//':Reading LAI day=', day
    IF (LEN(TRIM(beps_site_path)) + LEN(TRIM(beps_lai_site_prefix)) + &
&       LEN('.nc') .GT. LEN(fname)) THEN
      WRITE(*, '(a)') 'FATAL::INTERNAL-ERROR::'//method//&
&     ':file name too long!'
      STOP
    ELSE
      fname = TRIM(beps_site_path)//TRIM(beps_lai_site_prefix)//'.nc'
      IF (ldebug) WRITE(*, *) 'INFO::'//method//':Reading from file ***'&
&                 //TRIM(fname)//'***'
!-- iLab::added: stop in case LAI file is not present
      INQUIRE(file=fname, exist=exist) 
      IF (.NOT.exist) THEN
        WRITE(*, '(a)') ' FATAL::'//method//': file ***'//TRIM(fname)//&
&       '*** does NOT exist'
        STOP
      ELSE
        result1 = NF90_OPEN(fname, nf90_nowrite, ncid)
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'lai', varid)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid, lai1, start=(/1, 1, day/), &
&         count=(/nlp, pft, 1/))
        CALL CHECK(result1)
        result1 = NF90_CLOSE(ncid)
        CALL CHECK(result1)
!end if
!--iLab::avoid pointer (see below)
! p => bound
!call mpi_barrier(mpi_comm_world,ierr)
!do i = 1,PFT
!    call mpi_scatterv(lai1(1,i),dp,sp,mpi_real8,p%lai(1,i),npoints,mpi_real8,0,mpi_comm_world,ierr)
!end do
!call mpi_barrier(mpi_comm_world,ierr)
        bound%lai = lai1
      END IF
    END IF
  END SUBROUTINE READ_LAI_SITE

!! Reading Vcmax for data assimilation use
  SUBROUTINE READ_VCMAX(yr, mn, dd, tod)
    IMPLICIT NONE
!--iLab::made yr/mon/day/sec arguments in order to avoid 'get_curr_date'
    INTEGER, INTENT(IN) :: yr, mn, dd, tod
! integer          :: yr,mn,dd,tod,day
    REAL(r8) :: vcmax1(nlon, nlat, pft), vcmax2(nlon*nlat, pft), vcmax3(&
&   nlp, pft)
    CHARACTER(len=6) :: datestr
    INTEGER :: ncid, varid, ierr, i
!--iLab::avoid pointer (see also below)
! type(surf),pointer:: p
    CHARACTER(len=255) :: fname
    CHARACTER(len=*), PARAMETER :: method='read_Vcmax'
    INTRINSIC TRIM
    INTRINSIC LEN
    INTRINSIC RESHAPE
    INTEGER :: result1
!if(myid ==0) then
!   day  = get_curr_calday()
! call get_curr_date(yr,mn,dd,tod)
    WRITE(datestr, '(i6)') yr*100 + mn
    WRITE(*, *) 'Reading Vcmax on '//datestr
    IF (LEN(TRIM(beps_vcmax_path)) + LEN('Vcmax_') + LEN(TRIM(datestr)) &
&       + LEN('.nc') .GT. LEN(fname)) THEN
      WRITE(*, '(a)') 'FATAL::INTERNAL-ERROR::'//method//&
&     ':file name too long!'
      STOP
    ELSE
      fname = TRIM(beps_vcmax_path)//'Vcmax_'//TRIM(datestr)//'.nc'
      result1 = NF90_OPEN(fname, nf90_nowrite, ncid)
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'Vcmax', varid)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid, vcmax1)
      CALL CHECK(result1)
      result1 = NF90_CLOSE(ncid)
      CALL CHECK(result1)
      vcmax2 = RESHAPE(vcmax1, (/nlon*nlat, pft/))
      vcmax3 = vcmax2(mapping, :)
!end if
!--iLab::avoid pointer (see also below)
! p => bound
!call mpi_barrier(mpi_comm_world,ierr)
!do i = 1,PFT
!    call mpi_scatterv(vcmax3(1,i),dp,sp,mpi_real8,bound%Vcmax(1,i),npoints,mpi_real8,0,mpi_comm_world,ierr)
!end do
!call mpi_barrier(mpi_comm_world,ierr)
      bound%vcmax = vcmax3
    END IF
  END SUBROUTINE READ_VCMAX

  SUBROUTINE READ_VCMAX_SITE(yr, mn, dd, tod)
    IMPLICIT NONE
!--iLab::made yr/mon/day/sec arguments in order to avoid 'get_curr_date'
    INTEGER, INTENT(IN) :: yr, mn, dd, tod
! integer          :: yr,mn,dd,tod,day
    REAL(r8) :: vcmax(nlp, pft)
    CHARACTER(len=6) :: datestr
    INTEGER :: ncid, varid, ierr, i
!--iLab::avoid pointer (see also below)
! type(surf),pointer:: p
    CHARACTER(len=255) :: fname
    CHARACTER(len=*), PARAMETER :: method='read_Vcmax_site'
    INTRINSIC TRIM
    INTRINSIC LEN
    INTEGER :: result1
!if(myid ==0) then
!   day  = get_curr_calday()
! call get_curr_date(yr,mn,dd,tod)
    WRITE(datestr, '(i6)') yr*100 + mn
    WRITE(*, *) 'Reading Vcmax on '//datestr
    IF (LEN(TRIM(beps_vcmax_site_path)) + LEN('Site_Vcmax_') + LEN(TRIM(&
&       datestr)) + LEN('.nc') .GT. LEN(fname)) THEN
      WRITE(*, '(a)') 'FATAL::INTERNAL-ERROR::'//method//&
&     ':file name too long!'
      STOP
    ELSE
      fname = TRIM(beps_vcmax_site_path)//'Site_Vcmax_'//TRIM(datestr)//&
&       '.nc'
      result1 = NF90_OPEN(fname, nf90_nowrite, ncid)
      CALL CHECK(result1)
      result1 = NF90_INQ_VARID(ncid, 'Vcmax', varid)
      CALL CHECK(result1)
      result1 = NF90_GET_VAR(ncid, varid, vcmax)
      CALL CHECK(result1)
      result1 = NF90_CLOSE(ncid)
      CALL CHECK(result1)
!end if
!--iLab::avoid pointer (see also below)
! p => bound
!call mpi_barrier(mpi_comm_world,ierr)
!do i = 1,PFT
!    call mpi_scatterv(vcmax(1,i),dp,sp,mpi_real8,bound%Vcmax(1,i),npoints,mpi_real8,0,mpi_comm_world,ierr)
!end do
!call mpi_barrier(mpi_comm_world,ierr)
      bound%vcmax = vcmax
    END IF
  END SUBROUTINE READ_VCMAX_SITE

  SUBROUTINE READ_CPOOLS()
    IMPLICIT NONE
    INTEGER :: ncid, varid(9), ierr, i
    REAL(r8) :: ccd(nlon, nlat, pft), cfmd(nlon, nlat, pft), cfsd(nlon, &
&   nlat, pft), cm(nlon, nlat, pft), cp(nlon, nlat, pft), cs(nlon, nlat&
&   , pft), csm(nlon, nlat, pft), csmd(nlon, nlat, pft), cssd(nlon, nlat&
&   , pft)
    REAL(r8) :: ccd2(nlon*nlat, pft), cfmd2(nlon*nlat, pft), cfsd2(nlon*&
&   nlat, pft), cm2(nlon*nlat, pft), cp2(nlon*nlat, pft), cs2(nlon*nlat&
&   , pft), csm2(nlon*nlat, pft), csmd2(nlon*nlat, pft), cssd2(nlon*nlat&
&   , pft)
    REAL(r8) :: ccd3(nlp, pft), cfmd3(nlp, pft), cfsd3(nlp, pft), cm3(&
&   nlp, pft), cp3(nlp, pft), cs3(nlp, pft), csm3(nlp, pft), csmd3(nlp, &
&   pft), cssd3(nlp, pft)
    INTRINSIC TRIM
    INTRINSIC RESHAPE
    INTEGER :: result1
!--iLab::avoid pointer (see also below)
! type(surf),pointer :: p
!--iLab::avoid pointer (see also below)
! p => bound
!if( myid ==0 ) then
    result1 = NF90_OPEN(TRIM(beps_cpools), nf90_nowrite, ncid)
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'ccd', varid(1))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'cfmd', varid(2))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'cfsd', varid(3))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'cm', varid(4))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'cp', varid(5))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'cs', varid(6))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'csm', varid(7))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'csmd', varid(8))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'cssd', varid(9))
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(1), ccd)
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(2), cfmd)
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(3), cfsd)
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(4), cm)
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(5), cp)
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(6), cs)
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(7), csm)
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(8), csmd)
    CALL CHECK(result1)
    result1 = NF90_GET_VAR(ncid, varid(9), cssd)
    CALL CHECK(result1)
    result1 = NF90_CLOSE(ncid)
    CALL CHECK(result1)
    ccd2 = RESHAPE(ccd, (/nlon*nlat, pft/))
    cfmd2 = RESHAPE(cfmd, (/nlon*nlat, pft/))
    cfsd2 = RESHAPE(cfsd, (/nlon*nlat, pft/))
    cm2 = RESHAPE(cm, (/nlon*nlat, pft/))
    cp2 = RESHAPE(cp, (/nlon*nlat, pft/))
    cs2 = RESHAPE(cs, (/nlon*nlat, pft/))
    csm2 = RESHAPE(csm, (/nlon*nlat, pft/))
    csmd2 = RESHAPE(csmd, (/nlon*nlat, pft/))
    cssd2 = RESHAPE(cssd, (/nlon*nlat, pft/))
!! kg->g
    ccd3 = ccd2(mapping, :)*1e3
    cfmd3 = cfmd2(mapping, :)*1e3
    cfsd3 = cfsd2(mapping, :)*1e3
    cm3 = cm2(mapping, :)*1e3
    cp3 = cp2(mapping, :)*1e3
    cs3 = cs2(mapping, :)*1e3
    csm3 = csm2(mapping, :)*1e3
    csmd3 = csmd2(mapping, :)*1e3
    cssd3 = cssd2(mapping, :)*1e3
!end if
!call mpi_barrier(mpi_comm_world,ierr)
!do i = 1,PFT
! call mpi_scatterv(ccd3(1,i),dp,sp,MPI_real8,bound%ccd(1,i),npoints,MPI_real8,0,mpi_comm_world,ierr)
! call mpi_scatterv(cfmd3(1,i),dp,sp,MPI_real8,bound%cfmd(1,i),npoints,MPI_real8,0,mpi_comm_world,ierr)
! call mpi_scatterv(cfsd3(1,i),dp,sp,MPI_real8,bound%cfsd(1,i),npoints,MPI_real8,0,mpi_comm_world,ierr)
! call mpi_scatterv(cm3(1,i),dp,sp,MPI_real8,bound%cm(1,i),npoints,MPI_real8,0,mpi_comm_world,ierr)
! call mpi_scatterv(cp3(1,i),dp,sp,MPI_real8,bound%cp(1,i),npoints,MPI_real8,0,mpi_comm_world,ierr)
! call mpi_scatterv(cs3(1,i),dp,sp,MPI_real8,bound%cs(1,i),npoints,MPI_real8,0,mpi_comm_world,ierr)
! call mpi_scatterv(csm3(1,i),dp,sp,MPI_real8,bound%csm(1,i),npoints,MPI_real8,0,mpi_comm_world,ierr)
! call mpi_scatterv(csmd3(1,i),dp,sp,MPI_real8,bound%csmd(1,i),npoints,MPI_real8,0,mpi_comm_world,ierr)
! call mpi_scatterv(cssd3(1,i),dp,sp,MPI_real8,bound%cssd(1,i),npoints,MPI_real8,0,mpi_comm_world,ierr)
!end do
!call mpi_barrier(mpi_comm_world,ierr)
    bound%ccd = ccd3
    bound%cfmd = cfmd3
    bound%cfsd = cfsd3
    bound%cm = cm3
    bound%cp = cp3
    bound%cs = cs3
    bound%csm = csm3
    bound%csmd = csmd3
    bound%cssd = cssd3
  END SUBROUTINE READ_CPOOLS

  SUBROUTINE READ_PRIOR_PARA()
    IMPLICIT NONE
    INTEGER :: i, ncid, varid(28), ierr
    REAL(r8) :: p_vcmax(pft), p_q10(pft), p_vj_slope(pft), p_sif_alpha(&
&   pft), p_sif_beta(pft), p_taweff(pft), p_d0(pft)
    REAL(r8) :: p_ksat_scalar(texture), p_b_scalar(texture)
    REAL(r8) :: p_f_leaf, p_kc25, p_ko25, p_tau25, p_agb2vod
    REAL(r8) :: u_vcmax(pft), u_q10(pft), u_vj_slope(pft), u_sif_alpha(&
&   pft), u_sif_beta(pft), u_taweff(pft), u_d0(pft)
    REAL(r8) :: u_ksat_scalar(texture), u_b_scalar(texture)
    REAL(r8) :: u_f_leaf, u_kc25, u_ko25, u_tau25, u_f_lr, u_agb2vod
!--iLab::avoid pointer (see also below)
! type(para),pointer :: p
    CHARACTER(len=255) :: fname
    CHARACTER(len=*), PARAMETER :: method='read_prior_para'
    LOGICAL :: exist
    INTRINSIC TRIM
    INTRINSIC LEN
    INTEGER :: result1
!--iLab::avoid pointer (see also below)
! p => assim
    IF (LEN(TRIM(beps_site_path)) + LEN(TRIM(prior_para_prefix)) + LEN(&
&       '.nc') .GT. LEN(fname)) THEN
      WRITE(*, '(a)') 'FATAL::INTERNAL-ERROR::'//method//&
&     ':file name too long!'
      STOP
    ELSE
      fname = TRIM(beps_site_path)//TRIM(prior_para_prefix)//'.nc'
!-- iLab::added: stop in case boundary file is not present
      INQUIRE(file=fname, exist=exist) 
      IF (.NOT.exist) THEN
        WRITE(*, '(a)') ' FATAL::'//method//': file ***'//TRIM(fname)//&
&       '*** does NOT exist'
        STOP
      ELSE
        result1 = NF90_OPEN(fname, nf90_nowrite, ncid)
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'p_Vcmax', varid(1))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'p_q10', varid(2))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'p_VJ_slope', varid(3))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'p_sif_alpha', varid(4))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'p_sif_beta', varid(5))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'p_taweff', varid(6))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'p_D0', varid(7))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'p_Ksat_scalar', varid(8))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'p_b_scalar', varid(9))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'p_f_leaf', varid(10))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'p_kc25', varid(11))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'p_ko25', varid(12))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'p_tau25', varid(13))
        CALL CHECK(result1)
!call check(nf90_inq_varid(ncid,"p_f_lr",varid(14)))
        result1 = NF90_INQ_VARID(ncid, 'p_agb2vod', varid(14))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'u_Vcmax', varid(15))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'u_q10', varid(16))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'u_VJ_slope', varid(17))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'u_sif_alpha', varid(18))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'u_sif_beta', varid(19))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'u_taweff', varid(20))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'u_D0', varid(21))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'u_Ksat_scalar', varid(22))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'u_b_scalar', varid(23))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'u_f_leaf', varid(24))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'u_kc25', varid(25))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'u_ko25', varid(26))
        CALL CHECK(result1)
        result1 = NF90_INQ_VARID(ncid, 'u_tau25', varid(27))
        CALL CHECK(result1)
!call check(nf90_inq_varid(ncid,"u_f_lr",varid(28)))
        result1 = NF90_INQ_VARID(ncid, 'u_agb2vod', varid(28))
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(1), p_vcmax)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(2), p_q10)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(3), p_vj_slope)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(4), p_sif_alpha)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(5), p_sif_beta)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(6), p_taweff)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(7), p_d0)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(8), p_ksat_scalar)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(9), p_b_scalar)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(10), p_f_leaf)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(11), p_kc25)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(12), p_ko25)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(13), p_tau25)
        CALL CHECK(result1)
! call check(nf90_get_var(ncid,varid(14),p_f_lr))
        result1 = NF90_GET_VAR(ncid, varid(14), p_agb2vod)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(15), u_vcmax)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(16), u_q10)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(17), u_vj_slope)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(18), u_sif_alpha)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(19), u_sif_beta)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(20), u_taweff)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(21), u_d0)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(22), u_ksat_scalar)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(23), u_b_scalar)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(24), u_f_leaf)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(25), u_kc25)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(26), u_ko25)
        CALL CHECK(result1)
        result1 = NF90_GET_VAR(ncid, varid(27), u_tau25)
        CALL CHECK(result1)
!call check(nf90_get_var(ncid,varid(29),u_f_lr))
        result1 = NF90_GET_VAR(ncid, varid(28), u_agb2vod)
        CALL CHECK(result1)
        result1 = NF90_CLOSE(ncid)
        CALL CHECK(result1)
        assim%p_vcmax = p_vcmax
        assim%p_q10 = p_q10
        assim%p_vj_slope = p_vj_slope
        assim%p_sif_alpha = p_sif_alpha
        assim%p_sif_beta = p_sif_beta
        assim%p_taweff = p_taweff
        assim%p_d0 = p_d0
        assim%p_ksat_scalar = p_ksat_scalar
        assim%p_b_scalar = p_b_scalar
        assim%p_f_leaf = p_f_leaf
        assim%p_kc25 = p_kc25
        assim%p_ko25 = p_ko25
        assim%p_tau25 = p_tau25
! assim%p_f_lr = p_f_lr
        assim%p_agb2vod = p_agb2vod
        assim%u_vcmax = u_vcmax
        assim%u_q10 = u_q10
        assim%u_vj_slope = u_vj_slope
        assim%u_sif_alpha = u_sif_alpha
        assim%u_sif_beta = u_sif_beta
        assim%u_taweff = u_taweff
        assim%u_d0 = u_d0
        assim%u_ksat_scalar = u_ksat_scalar
        assim%u_b_scalar = u_b_scalar
        assim%u_f_leaf = u_f_leaf
        assim%u_kc25 = u_kc25
        assim%u_ko25 = u_ko25
        assim%u_tau25 = u_tau25
!assim%u_f_lr = u_f_lr
        assim%u_agb2vod = u_agb2vod
      END IF
    END IF
  END SUBROUTINE READ_PRIOR_PARA

  SUBROUTINE CHECK(status)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: status
!write(*,*) 'get rid of check status'
    IF (status .NE. nf90_noerr) CALL ENDRUN('Reading nc file is wrong!!'&
&                                    )
  END SUBROUTINE CHECK

END MODULE CONTROLINPUT_MOD_DIFF

MODULE METEOMOD_DIFF
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE BEPS_CON, ONLY : rho_a
  IMPLICIT NONE
! kg/m3
  REAL(r8), PUBLIC :: density_air
! specific heat of air  J/kg/C
  REAL(r8), PUBLIC :: cp_air
  REAL(r8), PUBLIC :: cp_air_bw
! kPa
  REAL(r8), PUBLIC :: vpd
  REAL(r8), PUBLIC :: vpd_bw
! slope  of vapor presure to temperature kPa/C
  REAL(r8), PUBLIC :: slope_vapor
  REAL(r8), PUBLIC :: slope_vapor_bw
! psychrometer constant  kPa/C
  REAL(r8), PUBLIC :: psy
! saturate water vapor   kPa
  REAL(r8), PUBLIC :: e_saturate
  REAL(r8), PUBLIC :: e_saturate_bw
! actual water vapor     kPa
  REAL(r8), PUBLIC :: e_actual
  REAL(r8), PUBLIC :: e_actual_bw
! specific humidity g/g
  REAL(r8), PUBLIC :: sp_humidity
  REAL(r8), PUBLIC :: sp_humidity_bw
! condensation    J/kg
  REAL(r8), PUBLIC :: latent_water
! sublimation/deposition    J/kg
  REAL(r8), PUBLIC :: latent_snow

CONTAINS
!  Differentiation of meteo_pack in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: cp_air vpd slope_vapor temp
!   with respect to varying inputs: temp
  SUBROUTINE METEO_PACK_BW(temp, temp_bw1, rh)
    IMPLICIT NONE
    REAL(r8), INTENT(IN) :: temp
    REAL(r8) :: temp_bw1
    REAL(r8), INTENT(IN) :: rh
    INTRINSIC EXP
    REAL(r8) :: temp0
    REAL(r8) :: temp_bw
    REAL(r8) :: temp1
    REAL(r8) :: temp_bw0
! 0C 1.292
    e_saturate = 0.61078*EXP(17.3*temp/(237.3+temp))
    e_actual = e_saturate*rh/100.
    temp1 = temp/(temp+237.3)
    temp_bw = 2503.*slope_vapor_bw/(temp+237.3)**2
    temp_bw0 = 17.27*EXP(17.27*temp1)*temp_bw/(temp+237.3)
    temp_bw1 = temp_bw1 - 2*EXP(17.27*temp1)*temp_bw/(temp+237.3)
    sp_humidity_bw = 0.84*1004.65*cp_air_bw
    temp_bw = 0.622*sp_humidity_bw/(101.35-0.378*e_actual)
    e_actual_bw = (0.378*e_actual/(101.35-0.378*e_actual)+1.0)*temp_bw -&
&     vpd_bw
    e_saturate_bw = vpd_bw + rh*e_actual_bw/100.
    temp0 = temp/(temp+237.3)
    temp_bw = 17.3*EXP(17.3*temp0)*0.61078*e_saturate_bw/(temp+237.3)
    temp_bw1 = temp_bw1 + (1.0-temp1)*temp_bw0 + (1.0-temp0)*temp_bw
  END SUBROUTINE METEO_PACK_BW

  SUBROUTINE METEO_PACK(temp, rh)
    IMPLICIT NONE
    REAL(r8), INTENT(IN) :: temp
    REAL(r8), INTENT(IN) :: rh
    INTRINSIC EXP
! 0C 1.292
    density_air = rho_a
    e_saturate = 0.61078*EXP(17.3*temp/(237.3+temp))
    e_actual = e_saturate*rh/100.
    vpd = e_saturate - e_actual
    sp_humidity = 0.622*e_actual/(101.35-0.378*e_actual)
    cp_air = 1004.65*(1.+0.84*sp_humidity)
    slope_vapor = 2503./(temp+237.3)**2*EXP(17.27*temp/(temp+237.3))
    psy = 0.066
    latent_water = (2.501-0.00237*temp)*1e6
    latent_snow = 2.83*1e6
  END SUBROUTINE METEO_PACK

END MODULE METEOMOD_DIFF

MODULE MID_RESULTS_DIFF
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  IMPLICIT NONE
!   real(r8)  :: COS_grnd2
  TYPE RESULTS
      REAL(r8) :: gpp_o_sunlit
      REAL(r8) :: gpp_u_sunlit
      REAL(r8) :: gpp_o_shaded
      REAL(r8) :: gpp_u_shaded
      REAL(r8) :: plant_resp
      REAL(r8) :: npp_o
      REAL(r8) :: npp_u
      REAL(r8) :: gpp
      REAL(r8) :: sif
      REAL(r8) :: npp
      REAL(r8) :: nep
      REAL(r8) :: soil_resp
      REAL(r8) :: net_rad
      REAL(r8) :: sh
      REAL(r8) :: lh
      REAL(r8) :: trans
      REAL(r8) :: evap
      REAL(r8) :: thetam_surf
      REAL(r8) :: cos_flux
      REAL(r8) :: lai
      REAL(r8) :: lai_old
      REAL(r8) :: lai_new
      REAL(r8) :: cos_plant
      REAL(r8) :: cos_grnd
      REAL(r8) :: fapar
  END TYPE RESULTS
  TYPE RESULTS_DIFF
      REAL(r8) :: sif
      REAL(r8) :: trans
      REAL(r8) :: thetam_surf
      REAL(r8) :: lai_old
      REAL(r8) :: lai_new
      REAL(r8) :: cos_plant
      REAL(r8) :: cos_grnd
  END TYPE RESULTS_DIFF
! temperatre  (oC)
!solar radiation
!downward longwave radiation
!liquid water rainfall
!snow
!diffuse solar radiation
!direct solar radiation
  TYPE CLIMATEDATA
      REAL(r8) :: temp
      REAL(r8) :: srad
      REAL(r8) :: lr
      REAL(r8) :: rainfall
      REAL(r8) :: snow
      REAL(r8) :: s_dff
      REAL(r8) :: s_dir
      REAL(r8) :: rh
      REAL(r8) :: wind
      REAL(r8) :: tempmx
      REAL(r8) :: tempmn
  END TYPE CLIMATEDATA
!friction velocity, m s-1
!updated friction velocity with new H, m s-1
!absolute humidity, g m-3
!absolute humidity, kg m-3
!sensible heat flux, W M-2
!old sensible heat flux, W m-2
!air density, kg m-3
!absolute air temperature, K
!station pressure, kPa
!station pressure, bars
!pressure, Pa
!gas constant computations
!air density, mole m-3
!relative humidity, ea/es(T)
!vapor pressure deficit
!infrared flux density
!! These types are adapted from DB.h, but many variables are not used @J.Wang
!! Importantly, these three types are only used by photosynthesis module.
  TYPE METEOROLOGY
      REAL(r8) :: ustar
      REAL(r8) :: ustarnew
      REAL(r8) :: rhova_g
      REAL(r8) :: rhova_kg
      REAL(r8) :: sensible_heat_flux
      REAL(r8) :: h_old
      REAL(r8) :: air_density
      REAL(r8) :: t_kelvin
      REAL(r8) :: press_kpa
      REAL(r8) :: press_bars
      REAL(r8) :: press_pa
      REAL(r8) :: pstat273
      REAL(r8) :: air_density_mole
      REAL(r8) :: relative_humidity
      REAL(r8) :: vpd
      REAL(r8) :: ir_in
  END TYPE METEOROLOGY
!latent heat of vaporization, J kg-1
!latent heat of vaporization times molecular mass of vapor, 18 g mol-1
!factor for sensible heat flux density
!filter coefficients
!filter coefficients
!CO2 factor, ma/mc * rhoa (mole m-3)
  TYPE FACTORS
      REAL(r8) :: latent
      REAL(r8) :: latent18
      REAL(r8) :: heatcoef
      REAL(r8) :: a_filt
      REAL(r8) :: b_filt
      REAL(r8) :: co2
  END TYPE FACTORS
  TYPE FACTORS_DIFF
      REAL(r8) :: latent
  END TYPE FACTORS_DIFF
!resistance for water vapor, s/m
!resistance for heat, s/m
!resistance for CO2, s/m
  TYPE BOUNDARY_LAYER_RESISTANCES
      REAL(r8) :: vapor
      REAL(r8) :: heat
      REAL(r8) :: co2
  END TYPE BOUNDARY_LAYER_RESISTANCES
  TYPE BOUNDARY_LAYER_RESISTANCES_DIFF
      REAL(r8) :: vapor
  END TYPE BOUNDARY_LAYER_RESISTANCES_DIFF

CONTAINS
!-- iLab::added for debugging purpose
  SUBROUTINE MIDRES_DUMP(midres, fmt)
    IMPLICIT NONE
    TYPE(RESULTS), INTENT(IN) :: midres
    CHARACTER(len=*), INTENT(IN), OPTIONAL :: fmt
!-- local
    CHARACTER(len=16) :: r8_fmt
    INTRINSIC PRESENT
    INTRINSIC TRIM
    IF (PRESENT(fmt)) THEN
      r8_fmt = '(a15,'//TRIM(fmt)//')'
    ELSE
      r8_fmt = '(a15,e25.16)'
    END IF
    WRITE(*, r8_fmt) 'gpp_o_sunlit=', midres%gpp_o_sunlit
    WRITE(*, r8_fmt) 'gpp_u_sunlit=', midres%gpp_u_sunlit
    WRITE(*, r8_fmt) 'gpp_o_shaded=', midres%gpp_o_shaded
    WRITE(*, r8_fmt) 'gpp_u_shaded=', midres%gpp_u_shaded
    WRITE(*, r8_fmt) 'plant_resp=', midres%plant_resp
    WRITE(*, r8_fmt) 'npp_o=', midres%npp_o
    WRITE(*, r8_fmt) 'npp_u=', midres%npp_u
    WRITE(*, r8_fmt) 'GPP=', midres%gpp
    WRITE(*, r8_fmt) 'SIF=', midres%sif
    WRITE(*, r8_fmt) 'NPP=', midres%npp
    WRITE(*, r8_fmt) 'NEP=', midres%nep
    WRITE(*, r8_fmt) 'soil_resp=', midres%soil_resp
    WRITE(*, r8_fmt) 'Net_Rad=', midres%net_rad
    WRITE(*, r8_fmt) 'SH=', midres%sh
    WRITE(*, r8_fmt) 'LH=', midres%lh
    WRITE(*, r8_fmt) 'Trans=', midres%trans
    WRITE(*, r8_fmt) 'Evap=', midres%evap
    WRITE(*, r8_fmt) 'thetam_surf=', midres%thetam_surf
    WRITE(*, r8_fmt) 'COS_flux=', midres%cos_flux
    WRITE(*, r8_fmt) 'lai=', midres%lai
    WRITE(*, r8_fmt) 'lai_old=', midres%lai_old
    WRITE(*, r8_fmt) 'lai_new=', midres%lai_new
    WRITE(*, r8_fmt) 'COS_plant=', midres%cos_plant
    WRITE(*, r8_fmt) 'COS_grnd=', midres%cos_grnd
!write(*, r8_fmt) 'COS_grnd2=',midres%COS_grnd2
    WRITE(*, r8_fmt) 'fapar=', midres%fapar
  END SUBROUTINE MIDRES_DUMP

END MODULE MID_RESULTS_DIFF

!***************************************************
! Function : calculate the photosyntheis,leaf temp,
!            and the evapotraspiration
! created  : Jun Wang
! Date     : 2016/12/5
!***************************************************
MODULE ANGSMOD_DIFF
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE BEPS_CON
  USE BEPS_PAR
  USE MID_RESULTS_DIFF
  IMPLICIT NONE
  TYPE(METEOROLOGY) :: met
  TYPE(FACTORS) :: fact
  TYPE(FACTORS_DIFF) :: fact_bw
  TYPE(BOUNDARY_LAYER_RESISTANCES) :: bound_layer_res
  TYPE(BOUNDARY_LAYER_RESISTANCES_DIFF) :: bound_layer_res_bw
  PUBLIC :: lai_cal, vcmax_jmax, photosynthesis, transpiration, &
& evaporation_canopy
  PUBLIC :: lai_cal_bw, vcmax_jmax_bw, photosynthesis_bw, &
& transpiration_bw, evaporation_canopy_bw

CONTAINS
!  Differentiation of lai_cal in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: pai_o_shaded pai_u_sunlit lai_o_sunlit
!                pai_u_shaded lai_o_shaded lai_u_sunlit lai_o lai_u_shaded
!                lai_u pai_o_sunlit
!   with respect to varying inputs: lai_o lai_u
  SUBROUTINE LAI_CAL_BW(stem_o, stem_u, lc, coszs, lai_o, lai_o_bw, &
&   clumping, lai_u, lai_u_bw, lai_o_sunlit, lai_o_sunlit_bw, &
&   lai_o_shaded, lai_o_shaded_bw, lai_u_sunlit, lai_u_sunlit_bw, &
&   lai_u_shaded, lai_u_shaded_bw, pai_o_sunlit, pai_o_sunlit_bw, &
&   pai_o_shaded, pai_o_shaded_bw, pai_u_sunlit, pai_u_sunlit_bw, &
&   pai_u_shaded, pai_u_shaded_bw)
    IMPLICIT NONE
!overstory woody area
    REAL(r8) :: stem_o
!understory woody area
    REAL(r8) :: stem_u
!landcover type
    INTEGER :: lc
!cosine solar zenith angle
    REAL(r8) :: coszs
!overstory lai
    REAL(r8) :: lai_o
    REAL(r8) :: lai_o_bw
!clumping index
    REAL(r8) :: clumping
!understory lai
    REAL(r8) :: lai_u
    REAL(r8) :: lai_u_bw
!overstory sunlit lai
    REAL(r8) :: lai_o_sunlit
    REAL(r8) :: lai_o_sunlit_bw
!overstory shaded lai
    REAL(r8) :: lai_o_shaded
    REAL(r8) :: lai_o_shaded_bw
! understory sunlit lai
    REAL(r8) :: lai_u_sunlit
    REAL(r8) :: lai_u_sunlit_bw
!understory shaded lai
    REAL(r8) :: lai_u_shaded
    REAL(r8) :: lai_u_shaded_bw
!overstory sunlit lai
    REAL(r8) :: pai_o_sunlit
    REAL(r8) :: pai_o_sunlit_bw
!overstory shaded lai
    REAL(r8) :: pai_o_shaded
    REAL(r8) :: pai_o_shaded_bw
!understory sunlit lai
    REAL(r8) :: pai_u_sunlit
    REAL(r8) :: pai_u_sunlit_bw
!understory shaded lai
    REAL(r8) :: pai_u_shaded
    REAL(r8) :: pai_u_shaded_bw
    REAL(r8) :: temp
    INTRINSIC EXP
    INTRINSIC MAX
    REAL(r8) :: temp_bw
    INTEGER*4 :: branch
    IF (coszs .GT. 0) THEN
      temp = -(0.5*clumping*(lai_o+stem_o)/coszs)
      IF (temp .LT. -10) THEN
        CALL PUSHCONTROL2B(0)
        pai_o_sunlit = 2*coszs
      ELSE
        pai_o_sunlit = 2*coszs*(1-EXP(-(0.5*clumping*(lai_o+stem_o)/&
&         coszs)))
        CALL PUSHCONTROL2B(1)
      END IF
    ELSE
      CALL PUSHCONTROL2B(2)
      pai_o_sunlit = 0
    END IF
    IF (coszs .GT. 0) THEN
      temp = -(0.5*clumping*(lai_o+stem_o+lai_u+stem_u)/coszs)
      IF (temp .LT. -10) THEN
        pai_u_sunlit = 2*coszs - pai_o_sunlit
        CALL PUSHCONTROL2B(0)
      ELSE
        pai_u_sunlit = 2*coszs*(1-EXP(-(0.5*clumping*(lai_o+stem_o+lai_u&
&         +stem_u)/coszs))) - pai_o_sunlit
        CALL PUSHCONTROL2B(1)
      END IF
    ELSE
      CALL PUSHCONTROL2B(2)
      pai_u_sunlit = 0
    END IF
    IF (coszs .GT. 0) THEN
      temp = -(0.5*clumping*lai_o/coszs)
      IF (temp .LT. -10) THEN
        CALL PUSHCONTROL2B(2)
      ELSE
        CALL PUSHCONTROL2B(1)
      END IF
    ELSE
      CALL PUSHCONTROL2B(0)
    END IF
    IF (0. .LT. lai_o - pai_o_sunlit) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (coszs .GT. 0) THEN
      temp = -(0.5*clumping*(lai_o+lai_u)/coszs)
      IF (temp .LT. -10) THEN
        CALL PUSHCONTROL2B(2)
      ELSE
        CALL PUSHCONTROL2B(1)
      END IF
    ELSE
      CALL PUSHCONTROL2B(0)
    END IF
    IF (0. .LT. lai_u - pai_u_sunlit) THEN
      lai_u_bw = lai_u_bw + lai_u_shaded_bw
      pai_u_sunlit_bw = pai_u_sunlit_bw - lai_u_shaded_bw
    END IF
    CALL POPCONTROL2B(branch)
    IF (branch .NE. 0) THEN
      IF (branch .EQ. 1) THEN
        temp_bw = clumping*0.5*EXP(-(clumping*0.5*((lai_o+lai_u)/coszs))&
&         )*2*lai_u_sunlit_bw
        lai_o_sunlit_bw = lai_o_sunlit_bw - lai_u_sunlit_bw
        lai_o_bw = lai_o_bw + temp_bw
        lai_u_bw = lai_u_bw + temp_bw
      ELSE
        lai_o_sunlit_bw = lai_o_sunlit_bw - lai_u_sunlit_bw
      END IF
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      lai_o_bw = lai_o_bw + lai_o_shaded_bw
      pai_o_sunlit_bw = pai_o_sunlit_bw - lai_o_shaded_bw
    END IF
    CALL POPCONTROL2B(branch)
    IF (branch .NE. 0) THEN
      IF (branch .EQ. 1) lai_o_bw = lai_o_bw + clumping*0.5*EXP(-(&
&         clumping*0.5*(lai_o/coszs)))*2*lai_o_sunlit_bw
    END IF
    lai_u_bw = lai_u_bw + pai_u_shaded_bw
    pai_u_sunlit_bw = pai_u_sunlit_bw - pai_u_shaded_bw
    CALL POPCONTROL2B(branch)
    IF (branch .EQ. 0) THEN
      pai_o_sunlit_bw = pai_o_sunlit_bw - pai_u_sunlit_bw
    ELSE IF (branch .EQ. 1) THEN
      temp_bw = clumping*0.5*EXP(-(clumping*0.5*((stem_o+stem_u+lai_o+&
&       lai_u)/coszs)))*2*pai_u_sunlit_bw
      pai_o_sunlit_bw = pai_o_sunlit_bw - pai_u_sunlit_bw
      lai_o_bw = lai_o_bw + temp_bw
      lai_u_bw = lai_u_bw + temp_bw
    END IF
    lai_o_bw = lai_o_bw + pai_o_shaded_bw
    pai_o_sunlit_bw = pai_o_sunlit_bw - pai_o_shaded_bw
    CALL POPCONTROL2B(branch)
    IF (branch .NE. 0) THEN
      IF (branch .EQ. 1) lai_o_bw = lai_o_bw + clumping*0.5*EXP(-(&
&         clumping*0.5*((stem_o+lai_o)/coszs)))*2*pai_o_sunlit_bw
    END IF
  END SUBROUTINE LAI_CAL_BW

  SUBROUTINE LAI_CAL(stem_o, stem_u, lc, coszs, lai_o, clumping, lai_u, &
&   lai_o_sunlit, lai_o_shaded, lai_u_sunlit, lai_u_shaded, pai_o_sunlit&
&   , pai_o_shaded, pai_u_sunlit, pai_u_shaded)
    IMPLICIT NONE
!overstory woody area
    REAL(r8) :: stem_o
!understory woody area
    REAL(r8) :: stem_u
!landcover type
    INTEGER :: lc
!cosine solar zenith angle
    REAL(r8) :: coszs
!overstory lai
    REAL(r8) :: lai_o
!clumping index
    REAL(r8) :: clumping
!understory lai
    REAL(r8) :: lai_u
!overstory sunlit lai
    REAL(r8) :: lai_o_sunlit
!overstory shaded lai
    REAL(r8) :: lai_o_shaded
! understory sunlit lai
    REAL(r8) :: lai_u_sunlit
!understory shaded lai
    REAL(r8) :: lai_u_shaded
!overstory sunlit lai
    REAL(r8) :: pai_o_sunlit
!overstory shaded lai
    REAL(r8) :: pai_o_shaded
!understory sunlit lai
    REAL(r8) :: pai_u_sunlit
!understory shaded lai
    REAL(r8) :: pai_u_shaded
    REAL(r8) :: temp
    INTRINSIC EXP
    INTRINSIC MAX
    IF (coszs .GT. 0) THEN
      temp = -(0.5*clumping*(lai_o+stem_o)/coszs)
      IF (temp .LT. -10) THEN
        pai_o_sunlit = 2*coszs
      ELSE
        pai_o_sunlit = 2*coszs*(1-EXP(-(0.5*clumping*(lai_o+stem_o)/&
&         coszs)))
      END IF
    ELSE
      pai_o_sunlit = 0
    END IF
    pai_o_shaded = lai_o + stem_o - pai_o_sunlit
    IF (coszs .GT. 0) THEN
      temp = -(0.5*clumping*(lai_o+stem_o+lai_u+stem_u)/coszs)
      IF (temp .LT. -10) THEN
        pai_u_sunlit = 2*coszs - pai_o_sunlit
      ELSE
        pai_u_sunlit = 2*coszs*(1-EXP(-(0.5*clumping*(lai_o+stem_o+lai_u&
&         +stem_u)/coszs))) - pai_o_sunlit
      END IF
    ELSE
      pai_u_sunlit = 0
    END IF
    pai_u_shaded = lai_u + stem_u - pai_u_sunlit
    IF (coszs .GT. 0) THEN
      temp = -(0.5*clumping*lai_o/coszs)
      IF (temp .LT. -10) THEN
        lai_o_sunlit = 2*coszs
      ELSE
        lai_o_sunlit = 2*coszs*(1-EXP(-(0.5*clumping*lai_o/coszs)))
      END IF
    ELSE
      lai_o_sunlit = 0
    END IF
    IF (0. .LT. lai_o - pai_o_sunlit) THEN
      lai_o_shaded = lai_o - pai_o_sunlit
    ELSE
      lai_o_shaded = 0.
    END IF
    IF (coszs .GT. 0) THEN
      temp = -(0.5*clumping*(lai_o+lai_u)/coszs)
      IF (temp .LT. -10) THEN
        lai_u_sunlit = 2*coszs - lai_o_sunlit
      ELSE
        lai_u_sunlit = 2*coszs*(1-EXP(-(0.5*clumping*(lai_o+lai_u)/coszs&
&         ))) - lai_o_sunlit
      END IF
    ELSE
      lai_u_sunlit = 0
    END IF
    IF (0. .LT. lai_u - pai_u_sunlit) THEN
      lai_u_shaded = lai_u - pai_u_sunlit
    ELSE
      lai_u_shaded = 0.
    END IF
  END SUBROUTINE LAI_CAL

!  Differentiation of vcmax_jmax in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: vcmax0 lai_o vcmax_sunlit vcmax_shaded
!   with respect to varying inputs: vcmax0 lai_o
!*************************************************************************************************
! Subroutine to calculate the Vcmax and Jmax for sunlit and shaded big-leaf
! Reference:
!       (1) Chen, J. M., G. Mo, J. Pisek, F. Deng, M. Ishozawa, D. Chan, 2012.
!       Effects of foliage clumping on global terrestrial gross primary
!       productivity. Global Biogeochemical Cycles, VOL. 26, GB1019, 18,
!       doi:10.1029/2010GB003996
!       (2) Medlyn, B.E. et al., 1999. Effects of elevated [CO2] on photosynthesis
!   in European forest species: a meta-analysis of model parameters.
!   Plant, Cell & Environment, 22(12): 1475-1495.
!*************************************************************************************************
  SUBROUTINE VCMAX_JMAX_BW(lai_o, lai_o_bw, clumping, vcmax0, vcmax0_bw&
&   , vj_slope, slope_vcmax_n, leaf_n, coszs, vcmax_sunlit, &
&   vcmax_sunlit_bw, vcmax_shaded, vcmax_shaded_bw, jmax_sunlit, &
&   jmax_shaded)
    IMPLICIT NONE
    REAL(r8) :: lai_o, clumping, vcmax0, slope_vcmax_n
    REAL(r8) :: lai_o_bw, vcmax0_bw
    REAL(r8) :: leaf_n, coszs
    REAL(r8) :: vcmax_sunlit, vcmax_shaded
    REAL(r8) :: vcmax_sunlit_bw, vcmax_shaded_bw
    REAL(r8) :: jmax_sunlit, jmax_shaded
    REAL(r8) :: vj_slope
    REAL(r8) :: k, expr1, expr2, expr3
    REAL(r8) :: expr1_bw, expr2_bw, expr3_bw
    REAL(r8), PARAMETER :: kn=0.3
    REAL(r8), PARAMETER :: g_theta=0.5
    INTRINSIC EXP
    REAL(r8) :: temp_bw
    REAL(r8) :: temp
    REAL(r8) :: temp0
    REAL(r8) :: temp_bw0
    REAL(r8) :: temp_bw1
    INTEGER*4 :: branch
    IF (lai_o .LT. 0.001) THEN
      CALL PUSHREAL8ARRAY(lai_o, r8/8)
      lai_o = 0.001
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (coszs .GT. 0) THEN
      k = g_theta*clumping/coszs
      IF (k .GT. 10) THEN
        CALL PUSHCONTROL1B(0)
        expr1 = 1.
        expr2 = 1.
      ELSE
        expr1 = 1 - EXP(-(k*lai_o))
        expr2 = 1 - EXP(-((kn+k)*lai_o))
        CALL PUSHCONTROL1B(1)
      END IF
      expr3 = 1 - EXP(-(kn*lai_o))
      IF (expr1 .GT. 0) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (k .GT. 0 .AND. lai_o .GT. expr1/k) THEN
        temp = lai_o - expr1/k
        temp0 = vcmax0/temp
        temp_bw = slope_vcmax_n*leaf_n*vcmax_shaded_bw
        expr3_bw = temp0*temp_bw/kn
        expr2_bw = -(temp0*temp_bw/(kn+k))
        temp_bw0 = (expr3/kn-expr2/(kn+k))*temp_bw/temp
        vcmax0_bw = vcmax0_bw + temp_bw0
        temp_bw1 = -(temp0*temp_bw0)
        lai_o_bw = lai_o_bw + temp_bw1
        expr1_bw = -(temp_bw1/k)
      ELSE
        vcmax0_bw = vcmax0_bw + vcmax_shaded_bw
        expr1_bw = 0.0_8
        expr2_bw = 0.0_8
        expr3_bw = 0.0_8
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        temp_bw = slope_vcmax_n*leaf_n*k*vcmax_sunlit_bw/((kn+k)*expr1)
        vcmax0_bw = vcmax0_bw + expr2*temp_bw
        expr2_bw = expr2_bw + vcmax0*temp_bw
        expr1_bw = expr1_bw - vcmax0*expr2*temp_bw/expr1
      ELSE
        vcmax0_bw = vcmax0_bw + vcmax_sunlit_bw
      END IF
      lai_o_bw = lai_o_bw + kn*EXP(-(kn*lai_o))*expr3_bw
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) lai_o_bw = lai_o_bw + (kn+k)*EXP(-((kn+k)*lai_o&
&         ))*expr2_bw + k*EXP(-(k*lai_o))*expr1_bw
    ELSE
      vcmax0_bw = vcmax0_bw + vcmax_shaded_bw + vcmax_sunlit_bw
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8ARRAY(lai_o, r8/8)
      lai_o_bw = 0.0_8
    END IF
  END SUBROUTINE VCMAX_JMAX_BW

!*************************************************************************************************
! Subroutine to calculate the Vcmax and Jmax for sunlit and shaded big-leaf
! Reference:
!       (1) Chen, J. M., G. Mo, J. Pisek, F. Deng, M. Ishozawa, D. Chan, 2012.
!       Effects of foliage clumping on global terrestrial gross primary
!       productivity. Global Biogeochemical Cycles, VOL. 26, GB1019, 18,
!       doi:10.1029/2010GB003996
!       (2) Medlyn, B.E. et al., 1999. Effects of elevated [CO2] on photosynthesis
!   in European forest species: a meta-analysis of model parameters.
!   Plant, Cell & Environment, 22(12): 1475-1495.
!*************************************************************************************************
  SUBROUTINE VCMAX_JMAX(lai_o, clumping, vcmax0, vj_slope, slope_vcmax_n&
&   , leaf_n, coszs, vcmax_sunlit, vcmax_shaded, jmax_sunlit, &
&   jmax_shaded)
    IMPLICIT NONE
    REAL(r8) :: lai_o, clumping, vcmax0, slope_vcmax_n
    REAL(r8) :: leaf_n, coszs
    REAL(r8) :: vcmax_sunlit, vcmax_shaded
    REAL(r8) :: jmax_sunlit, jmax_shaded
    REAL(r8) :: vj_slope
    REAL(r8) :: k, expr1, expr2, expr3
    REAL(r8), PARAMETER :: kn=0.3
    REAL(r8), PARAMETER :: g_theta=0.5
    INTRINSIC EXP
    IF (lai_o .LT. 0.001) lai_o = 0.001
    IF (coszs .GT. 0) THEN
      k = g_theta*clumping/coszs
      IF (k .GT. 10) THEN
        expr1 = 1.
        expr2 = 1.
      ELSE
        expr1 = 1 - EXP(-(k*lai_o))
        expr2 = 1 - EXP(-((kn+k)*lai_o))
      END IF
      expr3 = 1 - EXP(-(kn*lai_o))
      IF (expr1 .GT. 0) THEN
        vcmax_sunlit = vcmax0*slope_vcmax_n*leaf_n*k*expr2/(kn+k)/expr1
      ELSE
        vcmax_sunlit = vcmax0
      END IF
      IF (k .GT. 0 .AND. lai_o .GT. expr1/k) THEN
        vcmax_shaded = vcmax0*slope_vcmax_n*leaf_n*(expr3/kn-expr2/(kn+k&
&         ))/(lai_o-expr1/k)
      ELSE
        vcmax_shaded = vcmax0
      END IF
    ELSE
      vcmax_sunlit = vcmax0
      vcmax_shaded = vcmax0
    END IF
    jmax_sunlit = vcmax_sunlit*2.39 - 14.2
    jmax_shaded = vcmax_shaded*2.39 - 14.2
  END SUBROUTINE VCMAX_JMAX

!  Differentiation of leaf_temperatures in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: xcs_o gh_o_sunlit xcs_u gh_o_shaded
!                gww_o_sunlit gw_o_sunlit tc_o_sunlit gww_o_shaded
!                gw_o_shaded gw_u_sunlit gww_u_sunlit tc_o_shaded
!                gw_u_shaded tc_u_sunlit gww_u_shaded tc_u_shaded
!                xcl_o xcl_u
!   with respect to varying inputs: xcs_o gh_o_sunlit xcs_u gh_o_shaded
!                gh_u_sunlit gww_o_sunlit radiation_o_shaded gw_o_sunlit
!                gh_u_shaded gww_o_shaded gw_o_shaded radiation_u_shaded
!                gw_u_sunlit gww_u_sunlit gw_u_shaded gww_u_shaded
!                radiation_o_sun xcl_o xcl_u radiation_u_sun
  SUBROUTINE LEAF_TEMPERATURES_BW(tair, slope, psychrometer, vpd_air, &
&   cp_ca, gw_o_sunlit, gw_o_sunlit_bw, gw_o_shaded, gw_o_shaded_bw, &
&   gw_u_sunlit, gw_u_sunlit_bw, gw_u_shaded, gw_u_shaded_bw, &
&   gww_o_sunlit, gww_o_sunlit_bw, gww_o_shaded, gww_o_shaded_bw, &
&   gww_u_sunlit, gww_u_sunlit_bw, gww_u_shaded, gww_u_shaded_bw, &
&   gh_o_sunlit, gh_o_sunlit_bw, gh_o_shaded, gh_o_shaded_bw, &
&   gh_u_sunlit, gh_u_sunlit_bw, gh_u_shaded, gh_u_shaded_bw, xcs_o, &
&   xcs_o_bw, xcl_o, xcl_o_bw, xcs_u, xcs_u_bw, xcl_u, xcl_u_bw, &
&   radiation_o_sun, radiation_o_sun_bw, radiation_o_shaded, &
&   radiation_o_shaded_bw, radiation_u_sun, radiation_u_sun_bw, &
&   radiation_u_shaded, radiation_u_shaded_bw, tc_o_sunlit, &
&   tc_o_sunlit_bw, tc_o_shaded, tc_o_shaded_bw, tc_u_sunlit, &
&   tc_u_sunlit_bw, tc_u_shaded, tc_u_shaded_bw)
    IMPLICIT NONE
!*************************************************************************
! Subroutine to calculate the sunlit and shaded leaf temperatures for
! overstory and understory leave.
!*************************************************************************
    REAL(r8) :: tair, slope, psychrometer, vpd_air, cp_ca
    REAL(r8) :: gw_o_sunlit, gw_o_shaded, gw_u_sunlit, gw_u_shaded
    REAL(r8) :: gw_o_sunlit_bw, gw_o_shaded_bw, gw_u_sunlit_bw, &
&   gw_u_shaded_bw
    REAL(r8) :: gww_o_sunlit, gww_o_shaded, gww_u_sunlit, gww_u_shaded
    REAL(r8) :: gww_o_sunlit_bw, gww_o_shaded_bw, gww_u_sunlit_bw, &
&   gww_u_shaded_bw
    REAL(r8) :: gh_o_sunlit, gh_o_shaded, gh_u_sunlit, gh_u_shaded
    REAL(r8) :: gh_o_sunlit_bw, gh_o_shaded_bw, gh_u_sunlit_bw, &
&   gh_u_shaded_bw
    REAL(r8) :: xcs_o, xcl_o, xcs_u, xcl_u
    REAL(r8) :: xcs_o_bw, xcl_o_bw, xcs_u_bw, xcl_u_bw
    REAL(r8) :: radiation_o_sun, radiation_o_shaded, radiation_u_sun, &
&   radiation_u_shaded
    REAL(r8) :: radiation_o_sun_bw, radiation_o_shaded_bw, &
&   radiation_u_sun_bw, radiation_u_shaded_bw
    REAL(r8) :: tc_o_sunlit, tc_o_shaded, tc_u_sunlit, tc_u_shaded
    REAL(r8) :: tc_o_sunlit_bw, tc_o_shaded_bw, tc_u_sunlit_bw, &
&   tc_u_shaded_bw
    gh_u_shaded_bw = 0.0_8
    CALL LEAF_TEMPERATURE_BW(tair, slope, psychrometer, vpd_air, cp_ca, &
&                      gw_u_shaded, gw_u_shaded_bw, gww_u_shaded, &
&                      gww_u_shaded_bw, gh_u_shaded, gh_u_shaded_bw, &
&                      xcs_u, xcs_u_bw, xcl_u, xcl_u_bw, &
&                      radiation_u_shaded, radiation_u_shaded_bw, &
&                      tc_u_shaded, tc_u_shaded_bw)
    gh_u_sunlit_bw = 0.0_8
    CALL LEAF_TEMPERATURE_BW(tair, slope, psychrometer, vpd_air, cp_ca, &
&                      gw_u_sunlit, gw_u_sunlit_bw, gww_u_sunlit, &
&                      gww_u_sunlit_bw, gh_u_sunlit, gh_u_sunlit_bw, &
&                      xcs_u, xcs_u_bw, xcl_u, xcl_u_bw, radiation_u_sun&
&                      , radiation_u_sun_bw, tc_u_sunlit, tc_u_sunlit_bw&
&                     )
    CALL LEAF_TEMPERATURE_BW(tair, slope, psychrometer, vpd_air, cp_ca, &
&                      gw_o_shaded, gw_o_shaded_bw, gww_o_shaded, &
&                      gww_o_shaded_bw, gh_o_shaded, gh_o_shaded_bw, &
&                      xcs_o, xcs_o_bw, xcl_o, xcl_o_bw, &
&                      radiation_o_shaded, radiation_o_shaded_bw, &
&                      tc_o_shaded, tc_o_shaded_bw)
    CALL LEAF_TEMPERATURE_BW(tair, slope, psychrometer, vpd_air, cp_ca, &
&                      gw_o_sunlit, gw_o_sunlit_bw, gww_o_sunlit, &
&                      gww_o_sunlit_bw, gh_o_sunlit, gh_o_sunlit_bw, &
&                      xcs_o, xcs_o_bw, xcl_o, xcl_o_bw, radiation_o_sun&
&                      , radiation_o_sun_bw, tc_o_sunlit, tc_o_sunlit_bw&
&                     )
  END SUBROUTINE LEAF_TEMPERATURES_BW

  SUBROUTINE LEAF_TEMPERATURES(tair, slope, psychrometer, vpd_air, cp_ca&
&   , gw_o_sunlit, gw_o_shaded, gw_u_sunlit, gw_u_shaded, gww_o_sunlit, &
&   gww_o_shaded, gww_u_sunlit, gww_u_shaded, gh_o_sunlit, gh_o_shaded, &
&   gh_u_sunlit, gh_u_shaded, xcs_o, xcl_o, xcs_u, xcl_u, &
&   radiation_o_sun, radiation_o_shaded, radiation_u_sun, &
&   radiation_u_shaded, tc_o_sunlit, tc_o_shaded, tc_u_sunlit, &
&   tc_u_shaded)
    IMPLICIT NONE
!*************************************************************************
! Subroutine to calculate the sunlit and shaded leaf temperatures for
! overstory and understory leave.
!*************************************************************************
    REAL(r8) :: tair, slope, psychrometer, vpd_air, cp_ca
    REAL(r8) :: gw_o_sunlit, gw_o_shaded, gw_u_sunlit, gw_u_shaded
    REAL(r8) :: gww_o_sunlit, gww_o_shaded, gww_u_sunlit, gww_u_shaded
    REAL(r8) :: gh_o_sunlit, gh_o_shaded, gh_u_sunlit, gh_u_shaded
    REAL(r8) :: xcs_o, xcl_o, xcs_u, xcl_u
    REAL(r8) :: radiation_o_sun, radiation_o_shaded, radiation_u_sun, &
&   radiation_u_shaded
    REAL(r8) :: tc_o_sunlit, tc_o_shaded, tc_u_sunlit, tc_u_shaded
    CALL LEAF_TEMPERATURE(tair, slope, psychrometer, vpd_air, cp_ca, &
&                   gw_o_sunlit, gww_o_sunlit, gh_o_sunlit, xcs_o, xcl_o&
&                   , radiation_o_sun, tc_o_sunlit)
    CALL LEAF_TEMPERATURE(tair, slope, psychrometer, vpd_air, cp_ca, &
&                   gw_o_shaded, gww_o_shaded, gh_o_shaded, xcs_o, xcl_o&
&                   , radiation_o_shaded, tc_o_shaded)
    CALL LEAF_TEMPERATURE(tair, slope, psychrometer, vpd_air, cp_ca, &
&                   gw_u_sunlit, gww_u_sunlit, gh_u_sunlit, xcs_u, xcl_u&
&                   , radiation_u_sun, tc_u_sunlit)
    CALL LEAF_TEMPERATURE(tair, slope, psychrometer, vpd_air, cp_ca, &
&                   gw_u_shaded, gww_u_shaded, gh_u_shaded, xcs_u, xcl_u&
&                   , radiation_u_shaded, tc_u_shaded)
  END SUBROUTINE LEAF_TEMPERATURES

!  Differentiation of leaf_temperature in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: xcs gw gww tc xcl gh
!   with respect to varying inputs: xcs gw radiation gww xcl gh
  SUBROUTINE LEAF_TEMPERATURE_BW(tair, slope, psychrometer, vpd_air, &
&   cp_ca, gw, gw_bw, gww, gww_bw, gh, gh_bw, xcs, xcs_bw, xcl, xcl_bw, &
&   radiation, radiation_bw, tc, tc_bw)
    IMPLICIT NONE
    REAL(r8) :: tair, slope, psychrometer, vpd_air, cp_ca
    REAL(r8) :: gw, gww, gh, xcs, xcl, radiation
    REAL(r8) :: gw_bw, gww_bw, gh_bw, xcs_bw, xcl_bw, radiation_bw
    REAL(r8) :: p_star, tc, r
    REAL(r8) :: p_star_bw, tc_bw
    INTRINSIC MAX
    INTRINSIC MIN
    REAL(r8) :: temp
    REAL(r8) :: temp_bw
    REAL(r8) :: temp_bw0
    REAL(r8) :: temp_bw1
    INTEGER*4 :: branch
!    R = 1. / Gw + 1. / (Gww* (Xcs + Xcl))
    p_star = (gw+gww*(xcs+xcl))/psychrometer
    CALL PUSHREAL8ARRAY(tc, r8/8)
    tc = tair + (radiation-vpd_air*rho_a*cp_ca*p_star)/(rho_a*cp_ca*(gh+&
&     slope*p_star))
    IF (tair - 3.0 .LT. tc) THEN
      CALL PUSHCONTROL1B(0)
      tc = tc
    ELSE
      tc = tair - 3.0
      CALL PUSHCONTROL1B(1)
    END IF
    IF (tair + 5.0 .LE. tc) tc_bw = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) tc_bw = 0.0_8
    CALL POPREAL8ARRAY(tc, r8/8)
    temp = rho_a*cp_ca*(gh+slope*p_star)
    temp_bw0 = tc_bw/temp
    radiation_bw = temp_bw0
    temp_bw1 = -(rho_a*cp_ca*(radiation-vpd_air*rho_a*(cp_ca*p_star))*&
&     temp_bw0/temp)
    p_star_bw = slope*temp_bw1 - cp_ca*vpd_air*rho_a*temp_bw0
    gh_bw = gh_bw + temp_bw1
    temp_bw = p_star_bw/psychrometer
    gw_bw = gw_bw + temp_bw
    gww_bw = gww_bw + (xcs+xcl)*temp_bw
    xcs_bw = xcs_bw + gww*temp_bw
    xcl_bw = xcl_bw + gww*temp_bw
  END SUBROUTINE LEAF_TEMPERATURE_BW

  SUBROUTINE LEAF_TEMPERATURE(tair, slope, psychrometer, vpd_air, cp_ca&
&   , gw, gww, gh, xcs, xcl, radiation, tc)
    IMPLICIT NONE
    REAL(r8) :: tair, slope, psychrometer, vpd_air, cp_ca
    REAL(r8) :: gw, gww, gh, xcs, xcl, radiation
    REAL(r8) :: p_star, tc, r
    INTRINSIC MAX
    INTRINSIC MIN
!    R = 1. / Gw + 1. / (Gww* (Xcs + Xcl))
    p_star = (gw+gww*(xcs+xcl))/psychrometer
    tc = tair + (radiation-vpd_air*rho_a*cp_ca*p_star)/(rho_a*cp_ca*(gh+&
&     slope*p_star))
    IF (tair - 3.0 .LT. tc) THEN
      tc = tc
    ELSE
      tc = tair - 3.0
    END IF
    IF (tair + 5.0 .GT. tc) THEN
      tc = tc
    ELSE
      tc = tair + 5.0
    END IF
  END SUBROUTINE LEAF_TEMPERATURE

!  Differentiation of transpiration in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: lai_o_sunlit templ_o_sunlit
!                trans_o trans_u lai_o_shaded templ_o_shaded lai_u_sunlit
!                templ_u_sunlit lai_u_shaded gtrans_o_sunlit templ_u_shaded
!                gtrans_o_shaded gtrans_u_sunlit gtrans_u_shaded
!   with respect to varying inputs: lai_o_sunlit templ_o_sunlit
!                lai_o_shaded templ_o_shaded lai_u_sunlit templ_u_sunlit
!                lai_u_shaded gtrans_o_sunlit templ_u_shaded gtrans_o_shaded
!                gtrans_u_sunlit gtrans_u_shaded
  SUBROUTINE TRANSPIRATION_BW(templ_o_sunlit, templ_o_sunlit_bw, &
&   templ_o_shaded, templ_o_shaded_bw, templ_u_sunlit, templ_u_sunlit_bw&
&   , templ_u_shaded, templ_u_shaded_bw, temp_air, rh_air, &
&   gtrans_o_sunlit, gtrans_o_sunlit_bw, gtrans_o_shaded, &
&   gtrans_o_shaded_bw, gtrans_u_sunlit, gtrans_u_sunlit_bw, &
&   gtrans_u_shaded, gtrans_u_shaded_bw, lai_o_sunlit, lai_o_sunlit_bw, &
&   lai_o_shaded, lai_o_shaded_bw, lai_u_sunlit, lai_u_sunlit_bw, &
&   lai_u_shaded, lai_u_shaded_bw, trans_o, trans_o_bw, trans_u, &
&   trans_u_bw)
    USE METEOMOD_DIFF
    IMPLICIT NONE
    REAL(r8) :: templ_o_sunlit, templ_o_shaded, templ_u_sunlit, &
&   templ_u_shaded
    REAL(r8) :: templ_o_sunlit_bw, templ_o_shaded_bw, templ_u_sunlit_bw&
&   , templ_u_shaded_bw
    REAL(r8) :: temp_air, rh_air
    REAL(r8) :: gtrans_o_sunlit, gtrans_o_shaded, gtrans_u_sunlit, &
&   gtrans_u_shaded
    REAL(r8) :: gtrans_o_sunlit_bw, gtrans_o_shaded_bw, &
&   gtrans_u_sunlit_bw, gtrans_u_shaded_bw
    REAL(r8) :: lai_o_sunlit, lai_o_shaded, lai_u_sunlit, lai_u_shaded
    REAL(r8) :: lai_o_sunlit_bw, lai_o_shaded_bw, lai_u_sunlit_bw, &
&   lai_u_shaded_bw
    REAL(r8) :: trans_o, trans_u
    REAL(r8) :: trans_o_bw, trans_u_bw
!latent heat from leaves W/m2
    REAL(r8) :: lht_o_sunlit, lht_o_shaded, lht_u_sunlit, lht_u_shaded
    REAL(r8) :: lht_o_sunlit_bw, lht_o_shaded_bw, lht_u_sunlit_bw, &
&   lht_u_shaded_bw
    REAL(r8) :: temp_bw
    CALL METEO_PACK(temp_air, rh_air)
    lht_o_sunlit = (vpd+slope_vapor*(templ_o_sunlit-temp_air))*&
&     density_air*cp_air*gtrans_o_sunlit/psy
    lht_o_shaded = (vpd+slope_vapor*(templ_o_shaded-temp_air))*&
&     density_air*cp_air*gtrans_o_shaded/psy
    lht_u_sunlit = (vpd+slope_vapor*(templ_u_sunlit-temp_air))*&
&     density_air*cp_air*gtrans_u_sunlit/psy
    lht_u_shaded = (vpd+slope_vapor*(templ_u_shaded-temp_air))*&
&     density_air*cp_air*gtrans_u_shaded/psy
    temp_bw = trans_u_bw/latent_water
    lht_u_sunlit_bw = lai_u_sunlit*temp_bw
    lai_u_sunlit_bw = lai_u_sunlit_bw + lht_u_sunlit*temp_bw
    lht_u_shaded_bw = lai_u_shaded*temp_bw
    lai_u_shaded_bw = lai_u_shaded_bw + lht_u_shaded*temp_bw
    temp_bw = trans_o_bw/latent_water
    lht_o_sunlit_bw = lai_o_sunlit*temp_bw
    lai_o_sunlit_bw = lai_o_sunlit_bw + lht_o_sunlit*temp_bw
    lht_o_shaded_bw = lai_o_shaded*temp_bw
    lai_o_shaded_bw = lai_o_shaded_bw + lht_o_shaded*temp_bw
    temp_bw = density_air*cp_air*lht_u_shaded_bw
    templ_u_shaded_bw = templ_u_shaded_bw + slope_vapor*gtrans_u_shaded*&
&     temp_bw/psy
    gtrans_u_shaded_bw = gtrans_u_shaded_bw + (vpd+slope_vapor*(&
&     templ_u_shaded-temp_air))*temp_bw/psy
    temp_bw = density_air*cp_air*lht_u_sunlit_bw
    templ_u_sunlit_bw = templ_u_sunlit_bw + slope_vapor*gtrans_u_sunlit*&
&     temp_bw/psy
    gtrans_u_sunlit_bw = gtrans_u_sunlit_bw + (vpd+slope_vapor*(&
&     templ_u_sunlit-temp_air))*temp_bw/psy
    temp_bw = density_air*cp_air*lht_o_shaded_bw
    templ_o_shaded_bw = templ_o_shaded_bw + slope_vapor*gtrans_o_shaded*&
&     temp_bw/psy
    gtrans_o_shaded_bw = gtrans_o_shaded_bw + (vpd+slope_vapor*(&
&     templ_o_shaded-temp_air))*temp_bw/psy
    temp_bw = density_air*cp_air*lht_o_sunlit_bw
    templ_o_sunlit_bw = templ_o_sunlit_bw + slope_vapor*gtrans_o_sunlit*&
&     temp_bw/psy
    gtrans_o_sunlit_bw = gtrans_o_sunlit_bw + (vpd+slope_vapor*(&
&     templ_o_sunlit-temp_air))*temp_bw/psy
  END SUBROUTINE TRANSPIRATION_BW

  SUBROUTINE TRANSPIRATION(templ_o_sunlit, templ_o_shaded, &
&   templ_u_sunlit, templ_u_shaded, temp_air, rh_air, gtrans_o_sunlit, &
&   gtrans_o_shaded, gtrans_u_sunlit, gtrans_u_shaded, lai_o_sunlit, &
&   lai_o_shaded, lai_u_sunlit, lai_u_shaded, trans_o, trans_u)
    USE METEOMOD_DIFF
    IMPLICIT NONE
    REAL(r8) :: templ_o_sunlit, templ_o_shaded, templ_u_sunlit, &
&   templ_u_shaded
    REAL(r8) :: temp_air, rh_air
    REAL(r8) :: gtrans_o_sunlit, gtrans_o_shaded, gtrans_u_sunlit, &
&   gtrans_u_shaded
    REAL(r8) :: lai_o_sunlit, lai_o_shaded, lai_u_sunlit, lai_u_shaded
    REAL(r8) :: trans_o, trans_u
!latent heat from leaves W/m2
    REAL(r8) :: lht_o_sunlit, lht_o_shaded, lht_u_sunlit, lht_u_shaded
    CALL METEO_PACK(temp_air, rh_air)
    lht_o_sunlit = (vpd+slope_vapor*(templ_o_sunlit-temp_air))*&
&     density_air*cp_air*gtrans_o_sunlit/psy
    lht_o_shaded = (vpd+slope_vapor*(templ_o_shaded-temp_air))*&
&     density_air*cp_air*gtrans_o_shaded/psy
    lht_u_sunlit = (vpd+slope_vapor*(templ_u_sunlit-temp_air))*&
&     density_air*cp_air*gtrans_u_sunlit/psy
    lht_u_shaded = (vpd+slope_vapor*(templ_u_shaded-temp_air))*&
&     density_air*cp_air*gtrans_u_shaded/psy
    trans_o = 1/latent_water*(lht_o_sunlit*lai_o_sunlit+lht_o_shaded*&
&     lai_o_shaded)
    trans_u = 1/latent_water*(lht_u_sunlit*lai_u_sunlit+lht_u_shaded*&
&     lai_u_shaded)
  END SUBROUTINE TRANSPIRATION

!  Differentiation of evaporation_canopy in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: lai_o_sunlit gwater_o_sunlit
!                templ_o_sunlit lai_o_shaded gwater_o_shaded gwater_u_sunlit
!                templ_o_shaded lai_u_sunlit templ_u_sunlit gwater_u_shaded
!                percent_water_o evapo_snow_o lai_u_shaded percent_water_u
!                templ_u_shaded evapo_snow_u percent_snow_o percent_snow_u
!                evapo_water_o evapo_water_u
!   with respect to varying inputs: lai_o_sunlit gwater_o_sunlit
!                templ_o_sunlit lai_o_shaded gwater_o_shaded gwater_u_sunlit
!                templ_o_shaded lai_u_sunlit templ_u_sunlit gwater_u_shaded
!                percent_water_o lai_u_shaded percent_water_u templ_u_shaded
!                percent_snow_o percent_snow_u
  SUBROUTINE EVAPORATION_CANOPY_BW(templ_o_sunlit, templ_o_sunlit_bw, &
&   templ_o_shaded, templ_o_shaded_bw, templ_u_sunlit, templ_u_sunlit_bw&
&   , templ_u_shaded, templ_u_shaded_bw, temp_air, rh_air, &
&   gwater_o_sunlit, gwater_o_sunlit_bw, gwater_o_shaded, &
&   gwater_o_shaded_bw, gwater_u_sunlit, gwater_u_sunlit_bw, &
&   gwater_u_shaded, gwater_u_shaded_bw, lai_o_sunlit, lai_o_sunlit_bw, &
&   lai_o_shaded, lai_o_shaded_bw, lai_u_sunlit, lai_u_sunlit_bw, &
&   lai_u_shaded, lai_u_shaded_bw, percent_water_o, percent_water_o_bw, &
&   percent_water_u, percent_water_u_bw, percent_snow_o, &
&   percent_snow_o_bw, percent_snow_u, percent_snow_u_bw, evapo_water_o&
&   , evapo_water_o_bw, evapo_water_u, evapo_water_u_bw, evapo_snow_o, &
&   evapo_snow_o_bw, evapo_snow_u, evapo_snow_u_bw)
    USE METEOMOD_DIFF
    IMPLICIT NONE
!*************************************************************************
! this module calculates evaporation and sublimation from canopy, from
!overstorey understorey sunlit and shaded
! input includes:
!temperature of sunlit and shaded leaves from other storey (leaf temperature module).
!temperature of air, relative humidity,
!aerodynamic conductance of water (snow) for sunlit shaded leaves from overstorey
!and understorey;
!percentage of overstorey or understorey covered by water or snow;
!leaf area index, sunlit and shaded, overstorey and understorey
!(from leaf area index module);
! output:
!evaporation of water and snow from overstorey and understorey
!*************************************************************************
    REAL(r8) :: templ_o_sunlit, templ_o_shaded, templ_u_sunlit, &
&   templ_u_shaded
    REAL(r8) :: templ_o_sunlit_bw, templ_o_shaded_bw, templ_u_sunlit_bw&
&   , templ_u_shaded_bw
    REAL(r8) :: temp_air, rh_air
    REAL(r8) :: gwater_o_sunlit, gwater_o_shaded, gwater_u_sunlit, &
&   gwater_u_shaded
    REAL(r8) :: gwater_o_sunlit_bw, gwater_o_shaded_bw, &
&   gwater_u_sunlit_bw, gwater_u_shaded_bw
    REAL(r8) :: lai_o_sunlit, lai_o_shaded, lai_u_sunlit, lai_u_shaded
    REAL(r8) :: lai_o_sunlit_bw, lai_o_shaded_bw, lai_u_sunlit_bw, &
&   lai_u_shaded_bw
    REAL(r8) :: percent_water_o, percent_water_u, percent_snow_o, &
&   percent_snow_u
    REAL(r8) :: percent_water_o_bw, percent_water_u_bw, &
&   percent_snow_o_bw, percent_snow_u_bw
    REAL(r8) :: evapo_water_o, evapo_water_u, evapo_snow_o, evapo_snow_u
    REAL(r8) :: evapo_water_o_bw, evapo_water_u_bw, evapo_snow_o_bw, &
&   evapo_snow_u_bw
    REAL(r8) :: lhw_o_sunlit, lhw_o_shaded, lhw_u_sunlit, lhw_u_shaded
    REAL(r8) :: lhw_o_sunlit_bw, lhw_o_shaded_bw, lhw_u_sunlit_bw, &
&   lhw_u_shaded_bw
    REAL(r8) :: lhs_o_sunlit, lhs_o_shaded, lhs_u_sunlit, lhs_u_shaded
    REAL(r8) :: lhs_o_sunlit_bw, lhs_o_shaded_bw, lhs_u_sunlit_bw, &
&   lhs_u_shaded_bw
    INTRINSIC MAX
    REAL(r8) :: max1
    REAL(r8) :: max1_bw
    REAL(r8) :: max2
    REAL(r8) :: max2_bw
    REAL(r8) :: max3
    REAL(r8) :: max3_bw
    REAL(r8) :: max4
    REAL(r8) :: max4_bw
    REAL(r8) :: max5
    REAL(r8) :: max5_bw
    REAL(r8) :: max6
    REAL(r8) :: max6_bw
    REAL(r8) :: max7
    REAL(r8) :: max7_bw
    REAL(r8) :: max8
    REAL(r8) :: max8_bw
    REAL(r8) :: temp_bw
    REAL(r8) :: temp_bw0
    INTEGER*4 :: branch
    CALL METEO_PACK(temp_air, rh_air)
    lhw_o_sunlit = percent_water_o*(vpd+slope_vapor*(templ_o_sunlit-&
&     temp_air))*density_air*cp_air*gwater_o_sunlit/psy
    lhw_o_shaded = percent_water_o*(vpd+slope_vapor*(templ_o_shaded-&
&     temp_air))*density_air*cp_air*gwater_o_shaded/psy
    lhw_u_sunlit = percent_water_u*(vpd+slope_vapor*(templ_u_sunlit-&
&     temp_air))*density_air*cp_air*gwater_u_sunlit/psy
    lhw_u_shaded = percent_water_u*(vpd+slope_vapor*(templ_u_shaded-&
&     temp_air))*density_air*cp_air*gwater_u_shaded/psy
    lhs_o_sunlit = percent_snow_o*(vpd+slope_vapor*(templ_o_sunlit-&
&     temp_air))*density_air*cp_air*gwater_o_sunlit/psy
    lhs_o_shaded = percent_snow_o*(vpd+slope_vapor*(templ_o_shaded-&
&     temp_air))*density_air*cp_air*gwater_o_shaded/psy
    lhs_u_sunlit = percent_snow_u*(vpd+slope_vapor*(templ_u_sunlit-&
&     temp_air))*density_air*cp_air*gwater_u_sunlit/psy
    lhs_u_shaded = percent_snow_u*(vpd+slope_vapor*(templ_u_shaded-&
&     temp_air))*density_air*cp_air*gwater_u_shaded/psy
    IF (lhw_o_sunlit .LT. 1.e-6) THEN
      max1 = 1.e-6
      CALL PUSHCONTROL1B(1)
    ELSE
      max1 = lhw_o_sunlit
      CALL PUSHCONTROL1B(0)
    END IF
    IF (lhw_o_shaded .LT. 1.e-6) THEN
      max5 = 1.e-6
      CALL PUSHCONTROL1B(0)
    ELSE
      max5 = lhw_o_shaded
      CALL PUSHCONTROL1B(1)
    END IF
    evapo_water_o = 1./latent_water*(max1*lai_o_sunlit+max5*lai_o_shaded&
&     )
    IF (lhw_u_sunlit .LT. 1.e-6) THEN
      max2 = 1.e-6
      CALL PUSHCONTROL1B(1)
    ELSE
      max2 = lhw_u_sunlit
      CALL PUSHCONTROL1B(0)
    END IF
    IF (lhw_u_shaded .LT. 1.e-6) THEN
      max6 = 1.e-6
      CALL PUSHCONTROL1B(0)
    ELSE
      max6 = lhw_u_shaded
      CALL PUSHCONTROL1B(1)
    END IF
!    write(*,*) LHw_u_sunlit,lai_u_sunlit,LHw_u_shaded,lai_u_shaded
    evapo_water_u = 1./latent_water*(max2*lai_u_sunlit+max6*lai_u_shaded&
&     )
    IF (lhs_o_sunlit .LT. 1.e-6) THEN
      max3 = 1.e-6
      CALL PUSHCONTROL1B(1)
    ELSE
      max3 = lhs_o_sunlit
      CALL PUSHCONTROL1B(0)
    END IF
    IF (lhs_o_shaded .LT. 1.e-6) THEN
      max7 = 1.e-6
      CALL PUSHCONTROL1B(0)
    ELSE
      max7 = lhs_o_shaded
      CALL PUSHCONTROL1B(1)
    END IF
    evapo_snow_o = 1/latent_snow*(max3*lai_o_sunlit+max7*lai_o_shaded)
    IF (lhs_u_sunlit .LT. 1.e-6) THEN
      max4 = 1.e-6
      CALL PUSHCONTROL1B(1)
    ELSE
      max4 = lhs_u_sunlit
      CALL PUSHCONTROL1B(0)
    END IF
    IF (lhs_u_shaded .LT. 1.e-6) THEN
      max8 = 1.e-6
      CALL PUSHCONTROL1B(0)
    ELSE
      max8 = lhs_u_shaded
      CALL PUSHCONTROL1B(1)
    END IF
    evapo_snow_u = 1/latent_snow*(max4*lai_u_sunlit+max8*lai_u_shaded)
    IF (0. .LT. evapo_water_o) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (0. .LT. evapo_water_u) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (0. .LT. evapo_snow_o) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (0. .GE. evapo_snow_u) evapo_snow_u_bw = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) evapo_snow_o_bw = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) evapo_water_u_bw = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) evapo_water_o_bw = 0.0_8
    temp_bw0 = evapo_snow_u_bw/latent_snow
    max4_bw = lai_u_sunlit*temp_bw0
    lai_u_sunlit_bw = lai_u_sunlit_bw + max4*temp_bw0
    max8_bw = lai_u_shaded*temp_bw0
    lai_u_shaded_bw = lai_u_shaded_bw + max8*temp_bw0
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      lhs_u_shaded_bw = 0.0_8
    ELSE
      lhs_u_shaded_bw = max8_bw
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      lhs_u_sunlit_bw = max4_bw
    ELSE
      lhs_u_sunlit_bw = 0.0_8
    END IF
    temp_bw0 = evapo_snow_o_bw/latent_snow
    max3_bw = lai_o_sunlit*temp_bw0
    lai_o_sunlit_bw = lai_o_sunlit_bw + max3*temp_bw0
    max7_bw = lai_o_shaded*temp_bw0
    lai_o_shaded_bw = lai_o_shaded_bw + max7*temp_bw0
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      lhs_o_shaded_bw = 0.0_8
    ELSE
      lhs_o_shaded_bw = max7_bw
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      lhs_o_sunlit_bw = max3_bw
    ELSE
      lhs_o_sunlit_bw = 0.0_8
    END IF
    temp_bw0 = evapo_water_u_bw/latent_water
    max2_bw = lai_u_sunlit*temp_bw0
    lai_u_sunlit_bw = lai_u_sunlit_bw + max2*temp_bw0
    max6_bw = lai_u_shaded*temp_bw0
    lai_u_shaded_bw = lai_u_shaded_bw + max6*temp_bw0
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      lhw_u_shaded_bw = 0.0_8
    ELSE
      lhw_u_shaded_bw = max6_bw
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      lhw_u_sunlit_bw = max2_bw
    ELSE
      lhw_u_sunlit_bw = 0.0_8
    END IF
    temp_bw0 = evapo_water_o_bw/latent_water
    max1_bw = lai_o_sunlit*temp_bw0
    lai_o_sunlit_bw = lai_o_sunlit_bw + max1*temp_bw0
    max5_bw = lai_o_shaded*temp_bw0
    lai_o_shaded_bw = lai_o_shaded_bw + max5*temp_bw0
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      lhw_o_shaded_bw = 0.0_8
    ELSE
      lhw_o_shaded_bw = max5_bw
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      lhw_o_sunlit_bw = max1_bw
    ELSE
      lhw_o_sunlit_bw = 0.0_8
    END IF
    temp_bw0 = density_air*cp_air*lhs_u_shaded_bw
    templ_u_shaded_bw = templ_u_shaded_bw + slope_vapor*percent_snow_u*&
&     gwater_u_shaded*temp_bw0/psy
    temp_bw = (vpd+slope_vapor*(templ_u_shaded-temp_air))*temp_bw0/psy
    percent_snow_u_bw = percent_snow_u_bw + gwater_u_shaded*temp_bw
    gwater_u_shaded_bw = gwater_u_shaded_bw + percent_snow_u*temp_bw
    temp_bw0 = density_air*cp_air*lhs_u_sunlit_bw
    templ_u_sunlit_bw = templ_u_sunlit_bw + slope_vapor*percent_snow_u*&
&     gwater_u_sunlit*temp_bw0/psy
    temp_bw = (vpd+slope_vapor*(templ_u_sunlit-temp_air))*temp_bw0/psy
    percent_snow_u_bw = percent_snow_u_bw + gwater_u_sunlit*temp_bw
    gwater_u_sunlit_bw = gwater_u_sunlit_bw + percent_snow_u*temp_bw
    temp_bw0 = density_air*cp_air*lhs_o_shaded_bw
    templ_o_shaded_bw = templ_o_shaded_bw + slope_vapor*percent_snow_o*&
&     gwater_o_shaded*temp_bw0/psy
    temp_bw = (vpd+slope_vapor*(templ_o_shaded-temp_air))*temp_bw0/psy
    percent_snow_o_bw = percent_snow_o_bw + gwater_o_shaded*temp_bw
    gwater_o_shaded_bw = gwater_o_shaded_bw + percent_snow_o*temp_bw
    temp_bw0 = density_air*cp_air*lhs_o_sunlit_bw
    templ_o_sunlit_bw = templ_o_sunlit_bw + slope_vapor*percent_snow_o*&
&     gwater_o_sunlit*temp_bw0/psy
    temp_bw = (vpd+slope_vapor*(templ_o_sunlit-temp_air))*temp_bw0/psy
    percent_snow_o_bw = percent_snow_o_bw + gwater_o_sunlit*temp_bw
    gwater_o_sunlit_bw = gwater_o_sunlit_bw + percent_snow_o*temp_bw
    temp_bw0 = density_air*cp_air*lhw_u_shaded_bw
    templ_u_shaded_bw = templ_u_shaded_bw + slope_vapor*percent_water_u*&
&     gwater_u_shaded*temp_bw0/psy
    temp_bw = (vpd+slope_vapor*(templ_u_shaded-temp_air))*temp_bw0/psy
    percent_water_u_bw = percent_water_u_bw + gwater_u_shaded*temp_bw
    gwater_u_shaded_bw = gwater_u_shaded_bw + percent_water_u*temp_bw
    temp_bw0 = density_air*cp_air*lhw_u_sunlit_bw
    templ_u_sunlit_bw = templ_u_sunlit_bw + slope_vapor*percent_water_u*&
&     gwater_u_sunlit*temp_bw0/psy
    temp_bw = (vpd+slope_vapor*(templ_u_sunlit-temp_air))*temp_bw0/psy
    percent_water_u_bw = percent_water_u_bw + gwater_u_sunlit*temp_bw
    gwater_u_sunlit_bw = gwater_u_sunlit_bw + percent_water_u*temp_bw
    temp_bw0 = density_air*cp_air*lhw_o_shaded_bw
    templ_o_shaded_bw = templ_o_shaded_bw + slope_vapor*percent_water_o*&
&     gwater_o_shaded*temp_bw0/psy
    temp_bw = (vpd+slope_vapor*(templ_o_shaded-temp_air))*temp_bw0/psy
    percent_water_o_bw = percent_water_o_bw + gwater_o_shaded*temp_bw
    gwater_o_shaded_bw = gwater_o_shaded_bw + percent_water_o*temp_bw
    temp_bw = density_air*cp_air*lhw_o_sunlit_bw
    templ_o_sunlit_bw = templ_o_sunlit_bw + slope_vapor*percent_water_o*&
&     gwater_o_sunlit*temp_bw/psy
    temp_bw0 = (vpd+slope_vapor*(templ_o_sunlit-temp_air))*temp_bw/psy
    percent_water_o_bw = percent_water_o_bw + gwater_o_sunlit*temp_bw0
    gwater_o_sunlit_bw = gwater_o_sunlit_bw + percent_water_o*temp_bw0
  END SUBROUTINE EVAPORATION_CANOPY_BW

  SUBROUTINE EVAPORATION_CANOPY(templ_o_sunlit, templ_o_shaded, &
&   templ_u_sunlit, templ_u_shaded, temp_air, rh_air, gwater_o_sunlit, &
&   gwater_o_shaded, gwater_u_sunlit, gwater_u_shaded, lai_o_sunlit, &
&   lai_o_shaded, lai_u_sunlit, lai_u_shaded, percent_water_o, &
&   percent_water_u, percent_snow_o, percent_snow_u, evapo_water_o, &
&   evapo_water_u, evapo_snow_o, evapo_snow_u)
    USE METEOMOD_DIFF
    IMPLICIT NONE
!*************************************************************************
! this module calculates evaporation and sublimation from canopy, from
!overstorey understorey sunlit and shaded
! input includes:
!temperature of sunlit and shaded leaves from other storey (leaf temperature module).
!temperature of air, relative humidity,
!aerodynamic conductance of water (snow) for sunlit shaded leaves from overstorey
!and understorey;
!percentage of overstorey or understorey covered by water or snow;
!leaf area index, sunlit and shaded, overstorey and understorey
!(from leaf area index module);
! output:
!evaporation of water and snow from overstorey and understorey
!*************************************************************************
    REAL(r8) :: templ_o_sunlit, templ_o_shaded, templ_u_sunlit, &
&   templ_u_shaded
    REAL(r8) :: temp_air, rh_air
    REAL(r8) :: gwater_o_sunlit, gwater_o_shaded, gwater_u_sunlit, &
&   gwater_u_shaded
    REAL(r8) :: lai_o_sunlit, lai_o_shaded, lai_u_sunlit, lai_u_shaded
    REAL(r8) :: percent_water_o, percent_water_u, percent_snow_o, &
&   percent_snow_u
    REAL(r8) :: evapo_water_o, evapo_water_u, evapo_snow_o, evapo_snow_u
    REAL(r8) :: lhw_o_sunlit, lhw_o_shaded, lhw_u_sunlit, lhw_u_shaded
    REAL(r8) :: lhs_o_sunlit, lhs_o_shaded, lhs_u_sunlit, lhs_u_shaded
    INTRINSIC MAX
    REAL(r8) :: max1
    REAL(r8) :: max2
    REAL(r8) :: max3
    REAL(r8) :: max4
    REAL(r8) :: max5
    REAL(r8) :: max6
    REAL(r8) :: max7
    REAL(r8) :: max8
    CALL METEO_PACK(temp_air, rh_air)
    lhw_o_sunlit = percent_water_o*(vpd+slope_vapor*(templ_o_sunlit-&
&     temp_air))*density_air*cp_air*gwater_o_sunlit/psy
    lhw_o_shaded = percent_water_o*(vpd+slope_vapor*(templ_o_shaded-&
&     temp_air))*density_air*cp_air*gwater_o_shaded/psy
    lhw_u_sunlit = percent_water_u*(vpd+slope_vapor*(templ_u_sunlit-&
&     temp_air))*density_air*cp_air*gwater_u_sunlit/psy
    lhw_u_shaded = percent_water_u*(vpd+slope_vapor*(templ_u_shaded-&
&     temp_air))*density_air*cp_air*gwater_u_shaded/psy
    lhs_o_sunlit = percent_snow_o*(vpd+slope_vapor*(templ_o_sunlit-&
&     temp_air))*density_air*cp_air*gwater_o_sunlit/psy
    lhs_o_shaded = percent_snow_o*(vpd+slope_vapor*(templ_o_shaded-&
&     temp_air))*density_air*cp_air*gwater_o_shaded/psy
    lhs_u_sunlit = percent_snow_u*(vpd+slope_vapor*(templ_u_sunlit-&
&     temp_air))*density_air*cp_air*gwater_u_sunlit/psy
    lhs_u_shaded = percent_snow_u*(vpd+slope_vapor*(templ_u_shaded-&
&     temp_air))*density_air*cp_air*gwater_u_shaded/psy
    IF (lhw_o_sunlit .LT. 1.e-6) THEN
      max1 = 1.e-6
    ELSE
      max1 = lhw_o_sunlit
    END IF
    IF (lhw_o_shaded .LT. 1.e-6) THEN
      max5 = 1.e-6
    ELSE
      max5 = lhw_o_shaded
    END IF
    evapo_water_o = 1./latent_water*(max1*lai_o_sunlit+max5*lai_o_shaded&
&     )
    IF (lhw_u_sunlit .LT. 1.e-6) THEN
      max2 = 1.e-6
    ELSE
      max2 = lhw_u_sunlit
    END IF
    IF (lhw_u_shaded .LT. 1.e-6) THEN
      max6 = 1.e-6
    ELSE
      max6 = lhw_u_shaded
    END IF
!    write(*,*) LHw_u_sunlit,lai_u_sunlit,LHw_u_shaded,lai_u_shaded
    evapo_water_u = 1./latent_water*(max2*lai_u_sunlit+max6*lai_u_shaded&
&     )
    IF (lhs_o_sunlit .LT. 1.e-6) THEN
      max3 = 1.e-6
    ELSE
      max3 = lhs_o_sunlit
    END IF
    IF (lhs_o_shaded .LT. 1.e-6) THEN
      max7 = 1.e-6
    ELSE
      max7 = lhs_o_shaded
    END IF
    evapo_snow_o = 1/latent_snow*(max3*lai_o_sunlit+max7*lai_o_shaded)
    IF (lhs_u_sunlit .LT. 1.e-6) THEN
      max4 = 1.e-6
    ELSE
      max4 = lhs_u_sunlit
    END IF
    IF (lhs_u_shaded .LT. 1.e-6) THEN
      max8 = 1.e-6
    ELSE
      max8 = lhs_u_shaded
    END IF
    evapo_snow_u = 1/latent_snow*(max4*lai_u_sunlit+max8*lai_u_shaded)
    IF (0. .LT. evapo_water_o) THEN
      evapo_water_o = evapo_water_o
    ELSE
      evapo_water_o = 0.
    END IF
    IF (0. .LT. evapo_water_u) THEN
      evapo_water_u = evapo_water_u
    ELSE
      evapo_water_u = 0.
    END IF
    IF (0. .LT. evapo_snow_o) THEN
      evapo_snow_o = evapo_snow_o
    ELSE
      evapo_snow_o = 0.
    END IF
    IF (0. .LT. evapo_snow_u) THEN
      evapo_snow_u = evapo_snow_u
    ELSE
      evapo_snow_u = 0.
    END IF
  END SUBROUTINE EVAPORATION_CANOPY

!  Differentiation of photosynthesis in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: cos_assim temp_leaf_p vc_opt
!                sif_alpha g_lb_w vj_slope aphoto cosi gs_w ffpa
!                sif_beta xsif f_soilwater f_leaf
!   with respect to varying inputs: temp_leaf_p vc_opt rad_leaf
!                sif_alpha g_lb_w vj_slope lh_leaf aphoto cosii
!                ffpa sif_beta f_soilwater f_leaf
  SUBROUTINE PHOTOSYNTHESIS_BW(lc, temp_leaf_p, temp_leaf_p_bw, f_leaf, &
&   f_leaf_bw, p_kc25, p_ko25, p_tau25, rad_leaf, rad_leaf_bw, e_air, &
&   g_lb_w, g_lb_w_bw, vc_opt, vc_opt_bw, vj_slope, vj_slope_bw, &
&   f_soilwater, f_soilwater_bw, b_h2o, m_h2o, cii, temp_leaf_c, lh_leaf&
&   , lh_leaf_bw, gs_w, gs_w_bw, gs_h2o_mole, aphoto, aphoto_bw, ci, &
&   ffpa, ffpa_bw, sif_alpha, sif_alpha_bw, sif_beta, sif_beta_bw, xsif&
&   , xsif_bw, cosii, cosii_bw, cosi, cosi_bw, cos_assim, cos_assim_bw)
    IMPLICIT NONE
!*************************************************************************
! This program solves a cubic equation to calculate
! leaf photosynthesis.  This cubic expression is derived from solving
! five simultaneous equations for A, PG, cs, CI and GS.
! Stomatal conductance is computed with the Ball-Berry model.
! The cubic derivation assumes that b', the intercept of the Ball-Berry
! stomatal conductance model, is non-zero.
! Gs = k A rh/cs + b'
! We also found that the solution for A can be obtained by a quadratic equation
! when Gs is constant or b' is zero.
! The derivation is published in:
! Baldocchi, D.D. 1994. An analytical solution for coupled leaf photosynthesis
! and stomatal conductance models. Tree Physiology 14: 1069-1079.
!-----------------------------------------------------------------------
! A Biochemical Model of C3 Photosynthesis
! After Farquhar, von Caemmerer and Berry (1980) Planta.
! 149: 78-90.
! The original program was modified to incorporate functions and parameters
! derived from gas exchange experiments of Harley, who paramertized Vc and J in
! terms of optimal temperature, rather than some reference temperature, eg 25C.
! Program calculates leaf photosynthesis from biochemical parameters
! rd25 - Dark respiration at 25 degrees C (umol m-2 s-1)
! tlk - leaf temperature, Kelvin
! jmax - optimal rate of electron transport
! vcopt - maximum rate of RuBP Carboxylase/oxygenase
! iphoton - incident photosynthetically active photon flux (umols m-2 s-1)
! note: Harley parameterized the model on the basis of incident PAR
! gs - stomatal conductance (mols m-2 s-1), typically 0.01-0.20
! pstat-station pressure, bars
! aphoto - net photosynthesis  (umol m-2 s-1)
! ps - gross photosynthesis (umol m-2 s-1)
! aps - net photosynthesis (mg m-2 s-1)
! aphoto (umol m-2 s-1)
!-----------------------------------------------------------------------
! iphoton is radiation incident on leaves
! The temperature dependency of the kinetic properties of
! RUBISCO are compensated for using the Arrhenius and
! Boltzmann equations.  From biochemistry, one observes that
! at moderate temperatures enzyme kinetic rates increase
! with temperature.  At extreme temperatures enzyme
! denaturization occurs and rates must decrease.
! Arrhenius Eq.
! f(T)=f(tk_25) exp(tk -298)eact/(298 R tk)), where eact is the
! activation energy.
! Boltzmann distribution
! F(T)=tboltz)
! Define terms for calculation of gross photosynthesis, PG
! PG is a function of the minimum of RuBP saturated rate of
! carboxylation, Wc, and the RuBP limited rate of carboxylation, Wj.
! Wj is limiting when light is low and electron transport, which
! re-generates RuBP, is limiting.  Wc is limiting when plenty of RuBP is
! available compared to the CO2 that is needed for carboxylation.
! Both equations take the form:
! PG-photorespiration= (a CI-a d)/(e CI + b)
! PG-photorespiration=min[Wj,Wc] (1-gamma_ps/Ci)
! Wc=Vcmax Ci/(Ci + Kc(1+O2/Ko))
! Wj=J Ci/(4 Ci + 8 gamma_ps)
! Ps kinetic coefficients from Harley at WBW.
! gamma_ps is the CO2 compensation point
! Jan 14, 1999 Updated the cubic solutions for photosynthesis.  There are
! times when the restriction that R^2 < Q^3 is violated.  I therefore need
! alternative algorithms to solve for the correct root.
!*************************************************************************
! It is temporay, will be removed later
    REAL(r8) :: temp_leaf_p
    REAL(r8) :: temp_leaf_p_bw
! Leaf respiration ratio, default value of 0.5
    REAL(r8) :: f_leaf
    REAL(r8) :: f_leaf_bw
! net shortwave radiation (W/m2)
    REAL(r8) :: rad_leaf
    REAL(r8) :: rad_leaf_bw
! water vapor pressure above canopy (kPa)
    REAL(r8) :: e_air
! leaf laminar boundary layer condunctance to H2O (m/s)
    REAL(r8) :: g_lb_w
    REAL(r8) :: g_lb_w_bw
! the maximum velocities of carboxylation of Rubisco at 25 deg C (umol m-2 s-1)
    REAL(r8) :: vc_opt
    REAL(r8) :: vc_opt_bw
! the ratio of Vmax/Jmax, default value of 2.39
    REAL(r8) :: vj_slope
    REAL(r8) :: vj_slope_bw
! an empirical scalar of soil water stress on stomatal conductance, dimensionless
    REAL(r8) :: f_soilwater
    REAL(r8) :: f_soilwater_bw
! the intercept term in BWB model (mol H2O m-2 s-1)
    REAL(r8) :: b_h2o
! the slope in BWB model
    REAL(r8) :: m_h2o
!landcover type
    INTEGER :: lc
! replace, kc25,ko25,tau25 with three pramters, default values are 274.6,419.8,2904.12, respectively
    REAL(r8) :: p_kc25, p_ko25, p_tau25
! initial intercellular co2 concentration (ppm)
    REAL(r8) :: cii
! leaf temperature (deg C)
    REAL(r8) :: temp_leaf_c
! leaf latent heat flux (W m-2)
    REAL(r8) :: lh_leaf
    REAL(r8) :: lh_leaf_bw
! stomatal conductance to water vapor (m s-1)
    REAL(r8) :: gs_w
    REAL(r8) :: gs_w_bw
! net photosynthesis rate (umol CO2 m-2 s-1)
    REAL(r8) :: aphoto
    REAL(r8) :: aphoto_bw
! intercellular co2 concentration (ppm)
    REAL(r8) :: ci
    REAL(r8) :: ci_bw
!    real(r8)  :: xSIF           ! SIF
! SIF
    REAL(r8) :: sif_alpha, sif_beta, xsif
    REAL(r8) :: sif_alpha_bw, sif_beta_bw, xsif_bw
!  air pressure (kPa)
    REAL(r8), PARAMETER :: air_pres=101.325
! atmospheric co2 concentration (ppm)
    REAL(r8) :: ca
! incident photosynthetic photon flux density (PPFD) umol m-2 s-1
    REAL(r8) :: iphoton
    REAL(r8) :: iphoton_bw
!    real(r8)  :: g_lb_c          ! leaf laminar boundary layer condunctance to CO2 (mol m-2 s-1)
! leaf laminar boundary layer condunctance to CO2,COS (mol m-2 s-1)
    REAL(r8) :: g_lb_c, g_lb_cos
    REAL(r8) :: g_lb_c_bw, g_lb_cos_bw
! relative humidity at leaf surface (0-1)
    REAL(r8) :: rh_leaf
    REAL(r8) :: rh_leaf_bw
! leaf temperature (K)
    REAL(r8) :: temp_leaf_k
! stomatal conductance to CO2 (mol m-2 s-1)
    REAL(r8) :: gs_co2_mole
    REAL(r8) :: gs_co2_mole_bw
! stomatal conductance to h2o (mol m-2 s-1)
    REAL(r8) :: gs_h2o_mole
    REAL(r8) :: gs_h2o_mole_bw
! temporary variable
    REAL(r8) :: bc
! CO2 concentration at leaf surface (ppm)
    REAL(r8) :: cs
    REAL(r8) :: cs_bw
! the intercept term in BWB model (mol CO2 m-2 s-1): b_h2o/1.6
    REAL(r8) :: b_co2
! the slope in BWB model: m_h2o/1.6
    REAL(r8) :: m_co2
! CO2 compensation point (ppm)
    REAL(r8) :: gammac
! the maximum potential electron transport rate at 25 deg C (umol m-2 s-1)
    REAL(r8) :: jmopt
    REAL(r8) :: jmopt_bw
! the maximum potential electron transport rate (umol m-2 s-1)
    REAL(r8) :: jmax
    REAL(r8) :: jmax_bw
! the maximum velocities of carboxylation of Rubisco (umol m-2 s-1)
    REAL(r8) :: vcmax
    REAL(r8) :: vcmax_bw
! Michaelis-Menten constant for CO2 (?ol mol-1)
    REAL(r8) :: km_co2
! Michaelis-Menten constant for O2 (mmol mol-1)
    REAL(r8) :: km_o2
! the specifity of Rubisco for CO2 compared with O2
    REAL(r8) :: tau
! leaf dark respiration (umol m-2 s-1)
    REAL(r8) :: resp_ld
    REAL(r8) :: resp_ld_bw
! leaf dark respiration at 25 deg C (umol m-2 s-1)
    REAL(r8) :: resp_ld25
    REAL(r8) :: resp_ld25_bw
! the flux of electrons through the thylakoid membrane (umol m-2 s-1)
    REAL(r8) :: j_photon
    REAL(r8) :: j_photon_bw
    REAL(r8) :: alpha_ps
    REAL(r8) :: alpha_ps_bw
    REAL(r8) :: beta_ps
    REAL(r8) :: beta_ps_bw
    REAL(r8) :: gamma_ps
    REAL(r8) :: gamma_ps_bw
    REAL(r8) :: theta_ps
    REAL(r8) :: theta_ps_bw
    REAL(r8) :: denom
    REAL(r8) :: denom_bw
    REAL(r8) :: p_cubic
    REAL(r8) :: p_cubic_bw
    REAL(r8) :: q_cubic
    REAL(r8) :: q_cubic_bw
    REAL(r8) :: r_cubic
    REAL(r8) :: r_cubic_bw
    REAL(r8) :: qroot
    REAL(r8) :: qroot_bw
    REAL(r8) :: rroot
    REAL(r8) :: rroot_bw
    REAL(r8) :: root1, root2, root3
    REAL(r8) :: root1_bw, root2_bw, root3_bw
    REAL(r8) :: ang_l
    REAL(r8) :: ang_l_bw
! net photosynthesis rate limited by sucrose synthesis (umol m-2 s-1)
    REAL(r8) :: j_sucrose
    REAL(r8) :: j_sucrose_bw
! gross photosynthesis rate limited by light (umol m-2 s-1)
    REAL(r8) :: wc, wj, psguess
    REAL(r8) :: wc_bw, wj_bw
!-- iLab::convf no longer required
! real(r8)  :: cosa,convf,cosi,cosii,coss  ! parameters used for COS calculations
! parameters used for COS calculations
    REAL(r8) :: cosa, cosi, cosii, coss
    REAL(r8) :: cosi_bw, cosii_bw, coss_bw
    REAL(r8) :: cos_assim
    REAL(r8) :: cos_assim_bw
    REAL(r8) :: kn, kf, kd, kp, ps_sif, fm
    REAL(r8) :: kn_bw, ps_sif_bw, fm_bw
    REAL(r8) :: je, xxn, fs, ffpa
    REAL(r8) :: je_bw, xxn_bw, fs_bw, ffpa_bw
    REAL(r8) :: aquad, bquad, cquad
    REAL(r8) :: aquad_bw, bquad_bw, cquad_bw
    REAL(r8) :: b_ps, a_ps, e_ps, d_ps
    REAL(r8) :: a_ps_bw
    REAL(r8) :: product1
    REAL(r8) :: product1_bw
    REAL(r8) :: ps_1
    REAL(r8) :: ps_1_bw
    REAL(r8) :: delta_1
    REAL(r8) :: delta_1_bw
    REAL(r8) :: r3q
    REAL(r8) :: r3q_bw
    REAL(r8) :: minroot, maxroot, midroot
    REAL(r8) :: minroot_bw, maxroot_bw, midroot_bw
    REAL(r8) :: tprime25
    REAL(r8) :: k_t_opt, k_t, theta, beta, m1, m2, m
    REAL(r8) :: k_t_opt_bw, k_t_bw, m1_bw, m2_bw, m_bw
    INTRINSIC SQRT
    INTRINSIC MAX
    INTRINSIC ACOS
    INTRINSIC COS
    REAL(r8) :: x1
    REAL(r8) :: x1_bw
    REAL(r8) :: temp_bw
    REAL(r8) :: temp_bw0
    REAL(r8) :: temp_bw1
    REAL(r8) :: temp_bw2
    REAL(r8) :: temp_bw3
    REAL(r8) :: temp_bw4
    REAL(r8) :: temp
    REAL(r8) :: temp_bw5
    REAL(r8) :: temp_bw6
    REAL(r8) :: temp_bw7
    REAL(r8) :: temp0
    REAL(r8) :: temp_bw8
    REAL(r8) :: temp_bw9
    REAL(r8) :: temp_bw10
    REAL(r8) :: temp_bw11
    REAL(r8) :: temp1
    REAL(r8) :: temp_bw12
    REAL(r8) :: temp2
    REAL(r8) :: temp_bw13
    INTEGER*4 :: branch
    minroot = 0.0
    maxroot = 0.0
    midroot = 0.0
    ca = co2_air
!    iphoton = 4.55*0.5*rad_leaf
! replace 0.5 to a coefficient, f_leaf, leaf respiration rate, for optimization purpose, @MOUSONG WU, 2020-09-14
    iphoton = 4.55*f_leaf*rad_leaf
    IF (2*iphoton .LT. 1) THEN
      iphoton = 0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    temp_leaf_k = temp_leaf_c + 273.13
    CALL LAMBDA(temp_leaf_p, fact%latent)
    bound_layer_res%vapor = 1.0/g_lb_w
    met%press_bars = 1.013
    met%pstat273 = 0.022624/(273.16*met%press_bars)
    met%t_kelvin = temp_leaf_c + 273.13
! absolute humidity, g m-3
    met%rhova_g = e_air*2165/met%t_kelvin
! absolute humidity, kg m-3
    met%rhova_kg = met%rhova_g/1000.0
    g_lb_c = 1./(1.0/g_lb_w*1.6*temp_leaf_k*met%pstat273)
    m_co2 = m_h2o/1.6
    b_co2 = b_h2o/1.6
    g_lb_cos = 1./(1.0/g_lb_w*1.56*temp_leaf_k*met%pstat273)
!-- iLab::convf no longer required
! convf = temp_leaf_K * (met%pstat273)
    CALL SFC_VPD(temp_leaf_k, lh_leaf, rh_leaf)
! temperature difference
    tprime25 = temp_leaf_k - tk_25
!   
    CALL TEMP_FUNC(kc25, ekc, tprime25, tk_25, temp_leaf_k, km_co2)
    CALL TEMP_FUNC(ko25, eko, tprime25, tk_25, temp_leaf_k, km_o2)
    CALL TEMP_FUNC(tau25, ektau, tprime25, tk_25, temp_leaf_k, tau)
    bc = km_co2*(1.0+o2/km_o2)
! umol mol-1
    gammac = 0.5*o2/tau*1000.0
    resp_ld25 = vc_opt*0.004657
    IF (2.0*iphoton .GT. 10) THEN
! Bin Chen: check this later.
! reduce respiration by 40% in light according to Amthor
      resp_ld25 = resp_ld25*0.4
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    CALL TEMP_FUNC(resp_ld25, erd, tprime25, tk_25, temp_leaf_k, resp_ld&
&           )
!    jmopt   = 2.39*vc_opt - 14.2
    jmopt = vj_slope*vc_opt - 14.2
! Apply temperature correction to JMAX
    CALL TBOLTZ(jmopt, ejm, toptjm, temp_leaf_k, jmax)
    IF (lc .EQ. 40 .OR. lc .EQ. 41) THEN
! Apply temperature correction to vcmax
      CALL TBOLTZC4(vc_opt, toptvc, temp_leaf_k, vcmax)
      CALL PUSHCONTROL1B(0)
    ELSE
! Apply temperature correction to vcmax
      CALL TBOLTZ(vc_opt, evc, toptvc, temp_leaf_k, vcmax)
      CALL PUSHCONTROL1B(1)
    END IF
!***************************************
!        APHOTO = PG - resp_ld, net photosynthesis is the difference
!        between gross photosynthesis and dark respiration. Note
!        photorespiration is already factored into PG.
!        Gs from Ball-Berry is for water vapor.  It must be divided
!        by the ratio of the molecular diffusivities to be valid
!        for A
!****************************************
    IF (lc .EQ. 40 .OR. lc .EQ. 41) THEN
! analytical solution for C4 photosynthesis, added by MOUSONG.WU@201907, refer to Chen et al.2019 AFM
      k_t_opt = 2.*1.e4*vc_opt
      k_t = k_t_opt*2.**((temp_leaf_k-298.15)/10.)
      j_photon = iphoton*0.05
      wj = j_photon
      wc = vcmax
      theta = 0.80
      beta = 0.95
      m1 = (wj+wc+SQRT((wj+wc)*(wj+wc)-4*theta*wj*wc))/(2*theta)
      m2 = (wj+wc+SQRT((wj+wc)*(wj+wc)+4*theta*wj*wc))/(2*theta)
      IF (m1 .LT. m2) THEN
        m = m1
        CALL PUSHCONTROL1B(0)
      ELSE
        m = m2
        CALL PUSHCONTROL1B(1)
      END IF
      alpha_ps = beta*m_co2*f_soilwater*rh_leaf - beta*b_co2/g_lb_c - &
&       1.6*k_t/g_lb_c + k_t*m_co2*f_soilwater*rh_leaf/g_lb_c - k_t*&
&       b_co2/g_lb_c/g_lb_c
      beta_ps = beta*b_co2*ca - beta*m_co2*f_soilwater*rh_leaf*resp_ld +&
&       1.6*k_t*ca - m*m_co2*f_soilwater*rh_leaf - k_t*m_co2*f_soilwater&
&       *rh_leaf*ca + m*b_co2/g_lb_c - resp_ld*k_t*m_co2*f_soilwater*&
&       rh_leaf/g_lb_c + 2*k_t*b_co2*ca/g_lb_c + (1.6*k_t*resp_ld+1.6*&
&       k_t*m-m*k_t*m_co2*f_soilwater*rh_leaf)/g_lb_c + m*k_t*b_co2/&
&       g_lb_c/g_lb_c
      gamma_ps = resp_ld*m*m_co2*f_soilwater*rh_leaf - m*b_co2*ca + &
&       resp_ld*k_t*m_co2*f_soilwater*rh_leaf*ca - k_t*b_co2*ca*ca + (m*&
&       k_t*m_co2*f_soilwater*rh_leaf-1.6*resp_ld*k_t-1.6*k_t*m)*ca - 2*&
&       m*k_t*b_co2*ca/g_lb_c - (1.6*m*resp_ld*k_t-m*k_t*m_co2*&
&       f_soilwater*rh_leaf*resp_ld)/g_lb_c
      theta_ps = m*k_t*b_co2*ca*ca + 1.6*m*resp_ld*k_t*ca - m*resp_ld*&
&       k_t*m_co2*f_soilwater*rh_leaf*ca
      IF (wj .LE. resp_ld .OR. wc .LE. resp_ld) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
!        //cubic solution:
!        // A^3 + p A^2 + q A + r = 0
        denom = alpha_ps
        p_cubic = beta_ps/denom
        q_cubic = gamma_ps/denom
        r_cubic = theta_ps/denom
!        // Use solution from Numerical Recipes from Press
        qroot = (p_cubic*p_cubic-3.0*q_cubic)/9.0
        rroot = (2.0*p_cubic*p_cubic*p_cubic-9.0*p_cubic*q_cubic+27.0*&
&         r_cubic)/54.0
        IF (qroot .LT. 1.e-6) THEN
          qroot = 1.e-6
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
          qroot = qroot
        END IF
        r3q = rroot/SQRT(qroot*qroot*qroot)
        IF (r3q .GT. 1) THEN
          r3q = 1
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (r3q .LT. -1) THEN
          r3q = -1
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        ang_l = ACOS(r3q)
        root1 = -(2.0*SQRT(qroot)*COS(ang_l/3.0)) - p_cubic/3.0
        root2 = -(2.0*SQRT(qroot)*COS((ang_l+pi2)/3.0)) - p_cubic/3.0
        root3 = -(2.0*SQRT(qroot)*COS((ang_l-pi2)/3.0)) - p_cubic/3.0
!   Here A = x - p / 3, allowing the cubic expression to be expressed
!   as: x^3 + ax + b = 0
!   rank roots #1,#2 and #3 according to the minimum, intermediate and maximum value
        IF (root1 .LE. root2 .AND. root1 .LE. root3) THEN
          minroot = root1
          IF (root2 .LE. root3) THEN
            midroot = root2
            maxroot = root3
            CALL PUSHCONTROL2B(0)
          ELSE
            midroot = root3
            maxroot = root2
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(2)
        END IF
        IF (root2 .LE. root1 .AND. root2 .LE. root3) THEN
          minroot = root2
          IF (root1 .LE. root3) THEN
            midroot = root1
            maxroot = root3
            CALL PUSHCONTROL2B(0)
          ELSE
            midroot = root3
            maxroot = root1
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(2)
        END IF
        IF (root3 .LE. root1 .AND. root3 .LE. root2) THEN
          minroot = root3
          IF (root1 .LT. root2) THEN
            midroot = root1
            maxroot = root2
            CALL PUSHCONTROL2B(0)
          ELSE
            midroot = root2
            maxroot = root1
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(2)
        END IF
        aphoto = 0
!     find out where roots plop down relative to the x-y axis
        IF (minroot .GT. 0 .AND. midroot .GT. 0 .AND. maxroot .GT. 0) &
&       THEN
          aphoto = minroot
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (minroot .LT. 0 .AND. midroot .LT. 0 .AND. maxroot .GT. 0) &
&       THEN
          aphoto = maxroot
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (minroot .LT. 0 .AND. midroot .GT. 0 .AND. maxroot .GT. 0) &
&       THEN
          aphoto = midroot
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!        //also test for sucrose limitation of photosynthesis, as suggested by
!        //Collatz.  Js=Vmax/2
        cs = ca - aphoto/g_lb_c
!mol m-2 s-1
        gs_h2o_mole = f_soilwater*m_h2o*rh_leaf*aphoto/cs + b_h2o
        gs_co2_mole = gs_h2o_mole/1.6
        ci = cs - aphoto/gs_co2_mole
        j_sucrose = k_t*ci - resp_ld
        IF (j_sucrose .LT. aphoto) THEN
          CALL PUSHREAL8ARRAY(aphoto, r8/8)
          aphoto = j_sucrose
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!         //Stomatal conductance for water vapor
!        //forest are hypostomatous.
!        //Hence we don't divide the total resistance
!        //by 2 since transfer is going on only one side of a leaf.
!        // if A < 0 then gs should go to cuticular value and recalculate A
!         //using quadratic solution
        IF (aphoto .LE. 0.0) THEN
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL2B(2)
          GOTO 400
        END IF
      END IF
!        // if aphoto < 0  set stomatal conductance to cuticle value
!        //a quadratic solution of A is derived if gs=b, but a cubic form occurs
!        //if gs =ax + b.  Use quadratic case when A <=0
!  // Bin Chen:
!         r_tot = 1.0/b_co2 + 1.0/g_lb_c; // total resistance to CO2 (m2 s mol-1)
!         denom = g_lb_c * b_co2;
!         Aquad = r_tot * e_ps;
!         Bquad = (e_ps*resp_ld + a_ps)*r_tot - b_ps - e_ps*ca;
!         Cquad = a_ps*(ca-d_ps) - resp_ld*(e_ps*ca+b_ps);
      aquad = beta + k_t/g_lb_c + 1.6*k_t/b_co2
      bquad = 2*beta*resp_ld - m - ca*k_t - (k_t/g_lb_c+1.6*k_t/b_co2)*(&
&       m-resp_ld)
      cquad = beta*resp_ld*resp_ld - m*resp_ld + ca*k_t*(m-resp_ld)
      product1 = bquad*bquad - 4.0*aquad*cquad
      IF (product1 .GE. 0) THEN
        CALL PUSHREAL8ARRAY(aphoto, r8/8)
        aphoto = (-bquad-SQRT(product1))/(2.0*aquad)
        CALL PUSHCONTROL2B(1)
      ELSE
        CALL PUSHCONTROL2B(0)
      END IF
 400  IF (0. .LT. aphoto) THEN
        CALL PUSHREAL8ARRAY(aphoto, r8/8)
        aphoto = aphoto
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHREAL8ARRAY(aphoto, r8/8)
        aphoto = 0.
        CALL PUSHCONTROL1B(1)
      END IF
      CALL PUSHREAL8ARRAY(cs, r8/8)
      cs = ca - aphoto/g_lb_c
!mol m-2 s-1
      gs_h2o_mole = f_soilwater*m_h2o*rh_leaf*aphoto/cs + b_h2o
      CALL PUSHREAL8ARRAY(gs_co2_mole, r8/8)
      gs_co2_mole = gs_h2o_mole/1.6
      CALL PUSHREAL8ARRAY(ci, r8/8)
      ci = cs - aphoto/gs_co2_mole
!m s-1
      CALL PUSHCONTROL1B(0)
    ELSE
      alpha_ps = 1.0 + b_co2/g_lb_c - m_co2*rh_leaf*f_soilwater
      beta_ps = ca*(g_lb_c*m_co2*rh_leaf*f_soilwater-2.0*b_co2-g_lb_c)
      gamma_ps = ca*ca*g_lb_c*b_co2
      theta_ps = g_lb_c*m_co2*rh_leaf*f_soilwater - b_co2
!***************************************
!        Test for the minimum of Wc and Wj.  Both have the form:
!        W = (a ci - ad)/(e ci + b)
!        after the minimum is chosen set a, b, e and d for the cubic solution.
!        estimate of J according to Farquhar and von Cammerer (1981)
!***************************************
      j_photon = jmax*iphoton/(iphoton+2.1*jmax)
!    if(LC == 40) then
!        j_photon = jmax
!    else
!      j_photon =jmax * iphoton/ (iphoton+ 2.1*jmax)
!    end if
!  initial guess of intercellular CO2 concentration to estimate Wc and Wj:
      wj = j_photon*(cii-gammac)/(4.*cii+8.0*gammac)
      wc = vcmax*(cii-gammac)/(cii+bc)
!    if(LC == 40) then
!        wc = vcmax
!    else
!      wc = vcmax * (cii - gammac) / (cii + bc)
!    end if
      IF (wj .LT. wc) THEN
!        // for Harley and Farquhar type model for Wj
        a_ps = j_photon
        b_ps = 8.0*gammac
        e_ps = 4.0
        d_ps = gammac
        CALL PUSHCONTROL1B(0)
      ELSE
        a_ps = vcmax
        b_ps = bc
        e_ps = 1.0
        d_ps = gammac
        CALL PUSHCONTROL1B(1)
      END IF
!***************************************
! if wj or wc are less than resp_ld then A would probably be less than
! zero.  This would yield a
! negative stomatal conductance.  In this case, assume gs equals the
! cuticular value. This
! assumptions yields a quadratic rather than cubic solution for A
!***************************************
      IF (wj .LE. resp_ld .OR. wc .LE. resp_ld) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
!        //cubic solution:
!        // A^3 + p A^2 + q A + r = 0
        denom = e_ps*alpha_ps
        p_cubic = e_ps*beta_ps + b_ps*theta_ps - a_ps*alpha_ps + e_ps*&
&         resp_ld*alpha_ps
        CALL PUSHREAL8ARRAY(p_cubic, r8/8)
        p_cubic = p_cubic/denom
        q_cubic = e_ps*gamma_ps + b_ps*gamma_ps/ca - a_ps*beta_ps + a_ps&
&         *d_ps*theta_ps + e_ps*resp_ld*beta_ps + resp_ld*b_ps*theta_ps
        CALL PUSHREAL8ARRAY(q_cubic, r8/8)
        q_cubic = q_cubic/denom
        r_cubic = -(a_ps*gamma_ps) + a_ps*d_ps*gamma_ps/ca + e_ps*&
&         resp_ld*gamma_ps + resp_ld*b_ps*gamma_ps/ca
        CALL PUSHREAL8ARRAY(r_cubic, r8/8)
        r_cubic = r_cubic/denom
!        // Use solution from Numerical Recipes from Press
        qroot = (p_cubic*p_cubic-3.0*q_cubic)/9.0
        rroot = (2.0*p_cubic*p_cubic*p_cubic-9.0*p_cubic*q_cubic+27.0*&
&         r_cubic)/54.0
        IF (qroot .LT. 1.e-6) THEN
          qroot = 1.e-6
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
          qroot = qroot
        END IF
        r3q = rroot/SQRT(qroot*qroot*qroot)
        IF (r3q .GT. 1) THEN
          r3q = 1
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (r3q .LT. -1) THEN
          r3q = -1
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        ang_l = ACOS(r3q)
        root1 = -(2.0*SQRT(qroot)*COS(ang_l/3.0)) - p_cubic/3.0
        root2 = -(2.0*SQRT(qroot)*COS((ang_l+pi2)/3.0)) - p_cubic/3.0
        root3 = -(2.0*SQRT(qroot)*COS((ang_l-pi2)/3.0)) - p_cubic/3.0
!   Here A = x - p / 3, allowing the cubic expression to be expressed
!   as: x^3 + ax + b = 0
!   rank roots #1,#2 and #3 according to the minimum, intermediate and maximum value
        IF (root1 .LE. root2 .AND. root1 .LE. root3) THEN
          minroot = root1
          IF (root2 .LE. root3) THEN
            midroot = root2
            maxroot = root3
            CALL PUSHCONTROL2B(0)
          ELSE
            midroot = root3
            maxroot = root2
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(2)
        END IF
        IF (root2 .LE. root1 .AND. root2 .LE. root3) THEN
          minroot = root2
          IF (root1 .LE. root3) THEN
            midroot = root1
            maxroot = root3
            CALL PUSHCONTROL2B(0)
          ELSE
            midroot = root3
            maxroot = root1
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(2)
        END IF
        IF (root3 .LE. root1 .AND. root3 .LE. root2) THEN
          minroot = root3
          IF (root1 .LT. root2) THEN
            midroot = root1
            maxroot = root2
            CALL PUSHCONTROL2B(0)
          ELSE
            midroot = root2
            maxroot = root1
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(2)
        END IF
        aphoto = 0
!     find out where roots plop down relative to the x-y axis
        IF (minroot .GT. 0 .AND. midroot .GT. 0 .AND. maxroot .GT. 0) &
&       THEN
          aphoto = minroot
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (minroot .LT. 0 .AND. midroot .LT. 0 .AND. maxroot .GT. 0) &
&       THEN
          aphoto = maxroot
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (minroot .LT. 0 .AND. midroot .GT. 0 .AND. maxroot .GT. 0) &
&       THEN
          aphoto = midroot
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!        //also test for sucrose limitation of photosynthesis, as suggested by
!        //Collatz.  Js=Vmax/2
        j_sucrose = vcmax/2. - resp_ld
!    if(LC == 40) then
!      j_sucrose = 2.*1.e4*vcmax*cii/air_pres/1000. - resp_ld
!    else
!      j_sucrose = vcmax / 2. - resp_ld
!    end if
        IF (j_sucrose .LT. aphoto) THEN
          aphoto = j_sucrose
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!         //Stomatal conductance for water vapor
!        //forest are hypostomatous.
!        //Hence we don't divide the total resistance
!        //by 2 since transfer is going on only one side of a leaf.
!        // if A < 0 then gs should go to cuticular value and recalculate A
!         //using quadratic solution
        IF (aphoto .LE. 0.0) THEN
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL2B(2)
          GOTO 200
        END IF
      END IF
!        // if aphoto < 0  set stomatal conductance to cuticle value
!        //a quadratic solution of A is derived if gs=b, but a cubic form occurs
!        //if gs =ax + b.  Use quadratic case when A <=0
!  // Bin Chen:
!         r_tot = 1.0/b_co2 + 1.0/g_lb_c; // total resistance to CO2 (m2 s mol-1)
!         denom = g_lb_c * b_co2;
!         Aquad = r_tot * e_ps;
!         Bquad = (e_ps*resp_ld + a_ps)*r_tot - b_ps - e_ps*ca;
!         Cquad = a_ps*(ca-d_ps) - resp_ld*(e_ps*ca+b_ps);
      ps_1 = ca*g_lb_c*b_co2
      delta_1 = b_co2 + g_lb_c
      denom = g_lb_c*b_co2
      aquad = delta_1*e_ps
      bquad = -(ps_1*e_ps) - a_ps*delta_1 + e_ps*resp_ld*delta_1 - b_ps*&
&       denom
      cquad = a_ps*ps_1 - a_ps*d_ps*denom - e_ps*resp_ld*ps_1 - resp_ld*&
&       b_ps*denom
      product1 = bquad*bquad - 4.0*aquad*cquad
      IF (product1 .GE. 0) THEN
        aphoto = (-bquad-SQRT(product1))/(2.0*aquad)
        CALL PUSHCONTROL2B(1)
      ELSE
        CALL PUSHCONTROL2B(0)
      END IF
 200  IF (0. .LT. aphoto) THEN
        CALL PUSHCONTROL1B(0)
        aphoto = aphoto
      ELSE
        aphoto = 0.
        CALL PUSHCONTROL1B(1)
      END IF
      cs = ca - aphoto/g_lb_c
!mol m-2 s-1
      gs_h2o_mole = f_soilwater*m_h2o*rh_leaf*aphoto/cs + b_h2o
      gs_co2_mole = gs_h2o_mole/1.6
      ci = cs - aphoto/gs_co2_mole
!m s-1
      CALL PUSHCONTROL1B(1)
    END IF
!! QBO
!   ffpa = 0.8;   ! 0.6~0.9
    IF (iphoton .LE. 0.) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
! C4 je is added, @MOUSONG WU, 2020-09-10
      IF (lc .EQ. 40 .OR. lc .EQ. 41) THEN
        je = aphoto
        CALL PUSHCONTROL2B(0)
      ELSE
        x1 = aphoto*(ci+2.0*gammac)/(ci-gammac)
        IF (x1 .LT. 0.0) THEN
          je = 0.0
          CALL PUSHCONTROL2B(2)
        ELSE
          je = x1
          CALL PUSHCONTROL2B(1)
        END IF
      END IF
      xxn = 1.0 - je/(iphoton*ffpa*0.05)
      IF (xxn .LT. 0) THEN
        xxn = 0.
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      kf = 0.05
      kd = 0.95
      kp = 4.0
      ps_sif = kp/(kf+kp+kd)*(1.-xxn)
      kn = (sif_alpha*xxn+sif_beta)*xxn
! kn     = (6.2473*xxn - 0.5994)*xxn
      fm = kf/(kf+kd+kn)
      fs = fm*(1.0-ps_sif)
      IF (xxn .LT. 0.26) THEN
        fs = -(0.0075*xxn) + 0.0181
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      CALL PUSHCONTROL1B(1)
    END IF
! add the module for calculating COS uptake by plants, @MOUSONG.WU 2020-09-17
!-- iLab::convf no longer required
! call cos_plant(LC,cosii,convf,gs_h2o_mole,g_lb_cos,vcmax,ffpa,f_soilwater,cos_assim)
    CALL PUSHREAL8ARRAY(cos_assim, r8/8)
    CALL PUSHREAL8ARRAY(g_lb_cos, r8/8)
    CALL PUSHREAL8ARRAY(gs_h2o_mole, r8/8)
    CALL COS_PLANT(lc, cosii, gs_h2o_mole, g_lb_cos, vcmax, ffpa, &
&            f_soilwater, cos_assim)
! ppb
! ppb
    coss_bw = cosi_bw
    temp_bw13 = -(1.56*cosi_bw/gs_h2o_mole)
    cos_assim_bw = cos_assim_bw + temp_bw13 - coss_bw/g_lb_cos
    gs_h2o_mole_bw = -(cos_assim*temp_bw13/gs_h2o_mole)
    g_lb_cos_bw = cos_assim*coss_bw/g_lb_cos**2
    CALL POPREAL8ARRAY(gs_h2o_mole, r8/8)
    CALL POPREAL8ARRAY(g_lb_cos, r8/8)
    CALL POPREAL8ARRAY(cos_assim, r8/8)
    CALL COS_PLANT_BW(lc, cosii, cosii_bw, gs_h2o_mole, gs_h2o_mole_bw, &
&               g_lb_cos, g_lb_cos_bw, vcmax, vcmax_bw, ffpa, ffpa_bw, &
&               f_soilwater, f_soilwater_bw, cos_assim, cos_assim_bw)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      ci_bw = 0.0_8
      iphoton_bw = 0.0_8
    ELSE
      fs_bw = iphoton*ffpa*xsif_bw
      iphoton_bw = fs*ffpa*xsif_bw
      ffpa_bw = ffpa_bw + fs*iphoton*xsif_bw
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        xxn_bw = -(0.0075*fs_bw)
        fs_bw = 0.0_8
      ELSE
        xxn_bw = 0.0_8
      END IF
      fm_bw = (1.0-ps_sif)*fs_bw
      ps_sif_bw = -(fm*fs_bw)
      kn_bw = -(kf*fm_bw/(kf+kd+kn)**2)
      temp_bw13 = xxn*kn_bw
      xxn_bw = xxn_bw + (sif_alpha*xxn+sif_beta)*kn_bw + sif_alpha*&
&       temp_bw13 - kp*ps_sif_bw/(kf+kp+kd)
      sif_alpha_bw = sif_alpha_bw + xxn*temp_bw13
      sif_beta_bw = sif_beta_bw + temp_bw13
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) xxn_bw = 0.0_8
      temp2 = 0.05*iphoton*ffpa
      je_bw = -(xxn_bw/temp2)
      temp_bw13 = je*xxn_bw/temp2**2
      iphoton_bw = iphoton_bw + 0.05*ffpa*temp_bw13
      ffpa_bw = ffpa_bw + 0.05*iphoton*temp_bw13
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        aphoto_bw = aphoto_bw + je_bw
        ci_bw = 0.0_8
      ELSE
        IF (branch .EQ. 1) THEN
          x1_bw = je_bw
        ELSE
          x1_bw = 0.0_8
        END IF
        temp_bw13 = (gammac*2.0+ci)*x1_bw/(ci-gammac)
        temp2 = aphoto/(ci-gammac)
        ci_bw = temp2*x1_bw - temp2*temp_bw13
        aphoto_bw = aphoto_bw + temp_bw13
      END IF
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      gs_co2_mole_bw = aphoto*ci_bw/gs_co2_mole**2
      gs_h2o_mole_bw = gs_h2o_mole_bw + temp_leaf_k*met%pstat273*gs_w_bw&
&       + gs_co2_mole_bw/1.6
      CALL POPREAL8ARRAY(ci, r8/8)
      temp_bw13 = aphoto*m_h2o*gs_h2o_mole_bw/cs
      temp_bw12 = f_soilwater*rh_leaf*m_h2o*gs_h2o_mole_bw/cs
      cs_bw = ci_bw - aphoto*temp_bw12/cs
      aphoto_bw = aphoto_bw + temp_bw12 - ci_bw/gs_co2_mole - cs_bw/&
&       g_lb_c
      CALL POPREAL8ARRAY(gs_co2_mole, r8/8)
      f_soilwater_bw = f_soilwater_bw + rh_leaf*temp_bw13
      rh_leaf_bw = f_soilwater*temp_bw13
      CALL POPREAL8ARRAY(cs, r8/8)
      g_lb_c_bw = aphoto*cs_bw/g_lb_c**2
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8ARRAY(aphoto, r8/8)
      ELSE
        CALL POPREAL8ARRAY(aphoto, r8/8)
        aphoto_bw = 0.0_8
      END IF
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        product1_bw = 0.0_8
        aquad_bw = 0.0_8
        bquad_bw = 0.0_8
      ELSE IF (branch .EQ. 1) THEN
        CALL POPREAL8ARRAY(aphoto, r8/8)
        temp1 = SQRT(product1)
        temp_bw13 = aphoto_bw/(2.0*aquad)
        bquad_bw = -temp_bw13
        IF (product1 .EQ. 0.0_8) THEN
          product1_bw = 0.0_8
        ELSE
          product1_bw = -(temp_bw13/(2.0*temp1))
        END IF
        aquad_bw = -((-bquad-temp1)*temp_bw13/aquad)
        aphoto_bw = 0.0_8
      ELSE
        m_bw = 0.0_8
        resp_ld_bw = 0.0_8
        k_t_bw = 0.0_8
        GOTO 110
      END IF
      bquad_bw = bquad_bw + 2*bquad*product1_bw
      aquad_bw = aquad_bw - cquad*4.0*product1_bw
      cquad_bw = -(aquad*4.0*product1_bw)
      temp_bw13 = ca*cquad_bw
      k_t_bw = (m-resp_ld)*temp_bw13
      temp_bw12 = -((k_t/g_lb_c+1.6*(k_t/b_co2))*bquad_bw)
      resp_ld_bw = (2*resp_ld*beta-m)*cquad_bw + beta*2*bquad_bw - k_t*&
&       temp_bw13 - temp_bw12
      m_bw = k_t*temp_bw13 - resp_ld*cquad_bw + temp_bw12 - bquad_bw
      temp_bw13 = -((m-resp_ld)*bquad_bw)
      k_t_bw = k_t_bw + (1.0/g_lb_c+1.6/b_co2)*temp_bw13 - ca*bquad_bw +&
&       (1.0/g_lb_c+1.6/b_co2)*aquad_bw
      g_lb_c_bw = g_lb_c_bw - k_t*temp_bw13/g_lb_c**2 - k_t*aquad_bw/&
&       g_lb_c**2
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        beta_ps_bw = 0.0_8
        theta_ps_bw = 0.0_8
        gamma_ps_bw = 0.0_8
        alpha_ps_bw = 0.0_8
        GOTO 150
      END IF
 110  CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8ARRAY(aphoto, r8/8)
        j_sucrose_bw = aphoto_bw
        aphoto_bw = 0.0_8
      ELSE
        j_sucrose_bw = 0.0_8
      END IF
      k_t_bw = k_t_bw + ci*j_sucrose_bw
      ci_bw = k_t*j_sucrose_bw
      resp_ld_bw = resp_ld_bw - j_sucrose_bw
      gs_co2_mole_bw = aphoto*ci_bw/gs_co2_mole**2
      gs_h2o_mole_bw = gs_co2_mole_bw/1.6
      temp_bw13 = aphoto*m_h2o*gs_h2o_mole_bw/cs
      temp_bw12 = f_soilwater*rh_leaf*m_h2o*gs_h2o_mole_bw/cs
      cs_bw = ci_bw - aphoto*temp_bw12/cs
      aphoto_bw = aphoto_bw + temp_bw12 - ci_bw/gs_co2_mole - cs_bw/&
&       g_lb_c
      f_soilwater_bw = f_soilwater_bw + rh_leaf*temp_bw13
      rh_leaf_bw = rh_leaf_bw + f_soilwater*temp_bw13
      g_lb_c_bw = g_lb_c_bw + aphoto*cs_bw/g_lb_c**2
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        midroot_bw = aphoto_bw
        aphoto_bw = 0.0_8
      ELSE
        midroot_bw = 0.0_8
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        maxroot_bw = aphoto_bw
        aphoto_bw = 0.0_8
      ELSE
        maxroot_bw = 0.0_8
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        minroot_bw = aphoto_bw
      ELSE
        minroot_bw = 0.0_8
      END IF
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        root2_bw = maxroot_bw
        root1_bw = midroot_bw
      ELSE IF (branch .EQ. 1) THEN
        root1_bw = maxroot_bw
        root2_bw = midroot_bw
      ELSE
        root1_bw = 0.0_8
        root2_bw = 0.0_8
        root3_bw = 0.0_8
        GOTO 120
      END IF
      root3_bw = minroot_bw
      midroot_bw = 0.0_8
      minroot_bw = 0.0_8
      maxroot_bw = 0.0_8
 120  CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        root3_bw = root3_bw + maxroot_bw
        root1_bw = root1_bw + midroot_bw
      ELSE IF (branch .EQ. 1) THEN
        root1_bw = root1_bw + maxroot_bw
        root3_bw = root3_bw + midroot_bw
      ELSE
        GOTO 130
      END IF
      root2_bw = root2_bw + minroot_bw
      midroot_bw = 0.0_8
      minroot_bw = 0.0_8
      maxroot_bw = 0.0_8
 130  CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        root3_bw = root3_bw + maxroot_bw
        root2_bw = root2_bw + midroot_bw
      ELSE IF (branch .EQ. 1) THEN
        root2_bw = root2_bw + maxroot_bw
        root3_bw = root3_bw + midroot_bw
      ELSE
        GOTO 140
      END IF
      root1_bw = root1_bw + minroot_bw
 140  temp2 = (ang_l-pi2)/3.0
      temp1 = SQRT(qroot)
      IF (qroot .EQ. 0.0_8) THEN
        qroot_bw = 0.0_8
      ELSE
        qroot_bw = -(COS(temp2)*root3_bw/temp1)
      END IF
      ang_l_bw = SIN(temp2)*temp1*2.0*root3_bw/3.0
      p_cubic_bw = -(root3_bw/3.0) - root2_bw/3.0 - root1_bw/3.0
      temp2 = (pi2+ang_l)/3.0
      temp1 = SQRT(qroot)
      IF (.NOT.qroot .EQ. 0.0_8) qroot_bw = qroot_bw - COS(temp2)*&
&         root2_bw/temp1
      ang_l_bw = ang_l_bw + SIN(temp2)*temp1*2.0*root2_bw/3.0
      temp2 = SQRT(qroot)
      IF (.NOT.qroot .EQ. 0.0_8) qroot_bw = qroot_bw - COS(ang_l/3.0)*&
&         root1_bw/temp2
      ang_l_bw = ang_l_bw + SIN(ang_l/3.0)*temp2*2.0*root1_bw/3.0
      IF (r3q .EQ. 1.0 .OR. r3q .EQ. (-1.0)) THEN
        r3q_bw = 0.0_8
      ELSE
        r3q_bw = -(ang_l_bw/SQRT(1.0-r3q**2))
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) r3q_bw = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) r3q_bw = 0.0_8
      temp2 = qroot*qroot*qroot
      temp1 = SQRT(temp2)
      rroot_bw = r3q_bw/temp1
      IF (.NOT.temp2 .EQ. 0.0_8) qroot_bw = qroot_bw - 3*qroot**2*rroot*&
&         r3q_bw/(2.0*temp1**3)
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) qroot_bw = 0.0_8
      temp_bw13 = rroot_bw/54.0
      p_cubic_bw = p_cubic_bw + (3*p_cubic**2*2.0-q_cubic*9.0)*temp_bw13&
&       + 2*p_cubic*qroot_bw/9.0
      q_cubic_bw = -(p_cubic*9.0*temp_bw13) - 3.0*qroot_bw/9.0
      r_cubic_bw = 27.0*temp_bw13
      theta_ps_bw = r_cubic_bw/denom
      denom_bw = -(theta_ps*r_cubic_bw/denom**2) - gamma_ps*q_cubic_bw/&
&       denom**2 - beta_ps*p_cubic_bw/denom**2
      gamma_ps_bw = q_cubic_bw/denom
      beta_ps_bw = p_cubic_bw/denom
      alpha_ps_bw = denom_bw
      aphoto_bw = 0.0_8
 150  temp_bw13 = b_co2*ca**2*theta_ps_bw
      temp_bw12 = ca*1.6*theta_ps_bw
      temp_bw11 = -(m_co2*ca*theta_ps_bw)
      temp_bw10 = k_t*f_soilwater*temp_bw11
      temp_bw9 = m*resp_ld*rh_leaf*temp_bw11
      k_t_bw = k_t_bw + f_soilwater*temp_bw9 + m*resp_ld*temp_bw12
      f_soilwater_bw = f_soilwater_bw + k_t*temp_bw9
      m_bw = m_bw + resp_ld*rh_leaf*temp_bw10 + resp_ld*k_t*temp_bw12
      resp_ld_bw = resp_ld_bw + m*rh_leaf*temp_bw10 + m*k_t*temp_bw12
      rh_leaf_bw = rh_leaf_bw + m*resp_ld*temp_bw10
      temp1 = m*k_t*resp_ld
      temp_bw9 = m_co2*gamma_ps_bw
      temp_bw6 = m_co2*ca*gamma_ps_bw
      temp_bw3 = ca*gamma_ps_bw
      temp_bw = -(b_co2*2*ca*gamma_ps_bw/g_lb_c)
      temp_bw10 = -(gamma_ps_bw/g_lb_c)
      temp_bw11 = k_t*1.6*temp_bw10
      temp_bw12 = -(f_soilwater*rh_leaf*m_co2*temp_bw10)
      g_lb_c_bw = g_lb_c_bw - (1.6*(m*resp_ld*k_t)-m_co2*(temp1*(&
&       f_soilwater*rh_leaf)))*temp_bw10/g_lb_c - m*k_t*temp_bw/g_lb_c
      temp_bw2 = m_co2*temp_bw3
      temp_bw1 = f_soilwater*rh_leaf*temp_bw2
      m_bw = m_bw + k_t*temp_bw13 + k_t*resp_ld*temp_bw12 - b_co2*ca*&
&       gamma_ps_bw + resp_ld*temp_bw11 + k_t*temp_bw + k_t*temp_bw1 - &
&       k_t*1.6*temp_bw3
      temp_bw0 = m*k_t*temp_bw2
      temp_bw5 = f_soilwater*rh_leaf*temp_bw6
      k_t_bw = k_t_bw + m*temp_bw13 + m*resp_ld*1.6*temp_bw10 - b_co2*ca&
&       **2*gamma_ps_bw + m*resp_ld*temp_bw12 + m*temp_bw + m*temp_bw1 -&
&       (resp_ld*1.6+m*1.6)*temp_bw3 + resp_ld*temp_bw5
      temp_bw13 = -(temp1*m_co2*temp_bw10)
      resp_ld_bw = resp_ld_bw + m*k_t*temp_bw12 + m*temp_bw11 + k_t*&
&       temp_bw5 - k_t*1.6*temp_bw3
      temp_bw4 = resp_ld*k_t*temp_bw6
      temp_bw8 = f_soilwater*rh_leaf*temp_bw9
      temp_bw7 = resp_ld*m*temp_bw9
      f_soilwater_bw = f_soilwater_bw + rh_leaf*temp_bw13 + rh_leaf*&
&       temp_bw0 + rh_leaf*temp_bw4 + rh_leaf*temp_bw7
      rh_leaf_bw = rh_leaf_bw + f_soilwater*temp_bw13 + f_soilwater*&
&       temp_bw0 + f_soilwater*temp_bw4 + f_soilwater*temp_bw7
      temp = resp_ld*k_t/g_lb_c
      temp0 = f_soilwater*rh_leaf
      temp_bw3 = -(beta*m_co2*beta_ps_bw)
      temp_bw2 = -(m_co2*beta_ps_bw)
      temp_bw1 = b_co2*beta_ps_bw/g_lb_c
      temp_bw0 = -(m_co2*ca*beta_ps_bw)
      temp_bw = b_co2*2*ca*beta_ps_bw/g_lb_c
      temp_bw4 = -(m_co2*beta_ps_bw)
      temp_bw6 = beta_ps_bw/g_lb_c
      temp_bw9 = b_co2*beta_ps_bw/g_lb_c**2
      temp_bw7 = -(m_co2*temp_bw6)
      m_bw = m_bw + resp_ld*temp_bw8 + k_t*temp_bw9 + k_t*1.6*temp_bw6 +&
&       k_t*temp0*temp_bw7 + temp_bw1 + f_soilwater*rh_leaf*temp_bw2
      temp_bw5 = f_soilwater*rh_leaf*temp_bw4/g_lb_c
      resp_ld_bw = resp_ld_bw + m*temp_bw8 + k_t*1.6*temp_bw6 + k_t*&
&       temp_bw5 + f_soilwater*rh_leaf*temp_bw3
      k_t_bw = k_t_bw + ca*1.6*beta_ps_bw + m*temp_bw9 + (resp_ld*1.6+m*&
&       1.6)*temp_bw6 + m*temp0*temp_bw7 + resp_ld*temp_bw5 + temp_bw + &
&       f_soilwater*rh_leaf*temp_bw0
      g_lb_c_bw = g_lb_c_bw - 2*m*k_t*temp_bw9/g_lb_c - (1.6*(k_t*&
&       resp_ld)+1.6*(k_t*m)-m_co2*(m*k_t*temp0))*temp_bw6/g_lb_c - temp&
&       *temp_bw5 - k_t*temp_bw/g_lb_c - m*temp_bw1/g_lb_c
      temp_bw8 = m*k_t*temp_bw7
      f_soilwater_bw = f_soilwater_bw + rh_leaf*temp_bw8 + rh_leaf*temp*&
&       temp_bw4 + k_t*rh_leaf*temp_bw0 + m*rh_leaf*temp_bw2
      rh_leaf_bw = rh_leaf_bw + f_soilwater*temp_bw8 + f_soilwater*temp*&
&       temp_bw4 + k_t*f_soilwater*temp_bw0 + m*f_soilwater*temp_bw2
      temp_bw2 = beta*m_co2*alpha_ps_bw
      temp_bw1 = -(1.6*alpha_ps_bw/g_lb_c)
      temp_bw0 = rh_leaf*m_co2*alpha_ps_bw/g_lb_c
      f_soilwater_bw = f_soilwater_bw + rh_leaf*resp_ld*temp_bw3 + k_t*&
&       temp_bw0 + rh_leaf*temp_bw2
      temp_bw = k_t*f_soilwater*m_co2*alpha_ps_bw/g_lb_c
      rh_leaf_bw = rh_leaf_bw + f_soilwater*resp_ld*temp_bw3 + temp_bw +&
&       f_soilwater*temp_bw2
      temp_bw3 = -(b_co2*alpha_ps_bw/g_lb_c**2)
      g_lb_c_bw = g_lb_c_bw + beta*b_co2*alpha_ps_bw/g_lb_c**2 - 2*k_t*&
&       temp_bw3/g_lb_c - rh_leaf*temp_bw/g_lb_c - k_t*temp_bw1/g_lb_c
      k_t_bw = k_t_bw + temp_bw3 + f_soilwater*temp_bw0 + temp_bw1
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        m1_bw = m_bw
        m2_bw = 0.0_8
      ELSE
        m2_bw = m_bw
        m1_bw = 0.0_8
      END IF
      temp_bw2 = m2_bw/(2*theta)
      IF ((wj+wc)**2 + theta*4*(wj*wc) .EQ. 0.0_8) THEN
        temp_bw1 = 0.0_8
      ELSE
        temp_bw1 = temp_bw2/(2.0*SQRT((wj+wc)**2+theta*4*(wj*wc)))
      END IF
      temp_bw0 = 2*(wj+wc)*temp_bw1
      temp_bw = theta*4*temp_bw1
      wj_bw = temp_bw2 + wc*temp_bw + temp_bw0
      wc_bw = temp_bw2 + wj*temp_bw + temp_bw0
      temp_bw = m1_bw/(2*theta)
      IF ((wj+wc)**2 - theta*4*(wj*wc) .EQ. 0.0_8) THEN
        temp_bw0 = 0.0_8
      ELSE
        temp_bw0 = temp_bw/(2.0*SQRT((wj+wc)**2-theta*4*(wj*wc)))
      END IF
      temp_bw1 = 2*(wj+wc)*temp_bw0
      temp_bw2 = -(theta*4*temp_bw0)
      wj_bw = wj_bw + temp_bw + wc*temp_bw2 + temp_bw1
      wc_bw = wc_bw + temp_bw + wj*temp_bw2 + temp_bw1
      vcmax_bw = vcmax_bw + wc_bw
      j_photon_bw = wj_bw
      iphoton_bw = iphoton_bw + 0.05*j_photon_bw
      k_t_opt_bw = 2.**((temp_leaf_k-298.15)/10.)*k_t_bw
      vc_opt_bw = vc_opt_bw + 1.e4*2.*k_t_opt_bw
      jmax_bw = 0.0_8
    ELSE
      gs_co2_mole_bw = aphoto*ci_bw/gs_co2_mole**2
      gs_h2o_mole_bw = gs_h2o_mole_bw + temp_leaf_k*met%pstat273*gs_w_bw&
&       + gs_co2_mole_bw/1.6
      temp_bw13 = aphoto*m_h2o*gs_h2o_mole_bw/cs
      temp_bw12 = f_soilwater*rh_leaf*m_h2o*gs_h2o_mole_bw/cs
      cs_bw = ci_bw - aphoto*temp_bw12/cs
      aphoto_bw = aphoto_bw + temp_bw12 - ci_bw/gs_co2_mole - cs_bw/&
&       g_lb_c
      f_soilwater_bw = f_soilwater_bw + rh_leaf*temp_bw13
      rh_leaf_bw = f_soilwater*temp_bw13
      g_lb_c_bw = aphoto*cs_bw/g_lb_c**2
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) aphoto_bw = 0.0_8
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        product1_bw = 0.0_8
        aquad_bw = 0.0_8
        bquad_bw = 0.0_8
      ELSE IF (branch .EQ. 1) THEN
        temp1 = SQRT(product1)
        temp_bw13 = aphoto_bw/(2.0*aquad)
        bquad_bw = -temp_bw13
        IF (product1 .EQ. 0.0_8) THEN
          product1_bw = 0.0_8
        ELSE
          product1_bw = -(temp_bw13/(2.0*temp1))
        END IF
        aquad_bw = -((-bquad-temp1)*temp_bw13/aquad)
        aphoto_bw = 0.0_8
      ELSE
        a_ps_bw = 0.0_8
        resp_ld_bw = 0.0_8
        GOTO 160
      END IF
      bquad_bw = bquad_bw + 2*bquad*product1_bw
      aquad_bw = aquad_bw - cquad*4.0*product1_bw
      cquad_bw = -(aquad*4.0*product1_bw)
      a_ps_bw = (ps_1-denom*d_ps)*cquad_bw - delta_1*bquad_bw
      ps_1_bw = (a_ps-resp_ld*e_ps)*cquad_bw - e_ps*bquad_bw
      denom_bw = -((a_ps*d_ps+resp_ld*b_ps)*cquad_bw) - b_ps*bquad_bw
      resp_ld_bw = delta_1*e_ps*bquad_bw - (ps_1*e_ps+denom*b_ps)*&
&       cquad_bw
      delta_1_bw = (resp_ld*e_ps-a_ps)*bquad_bw + e_ps*aquad_bw
      g_lb_c_bw = g_lb_c_bw + b_co2*denom_bw + delta_1_bw + ca*b_co2*&
&       ps_1_bw
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        beta_ps_bw = 0.0_8
        theta_ps_bw = 0.0_8
        gamma_ps_bw = 0.0_8
        alpha_ps_bw = 0.0_8
        GOTO 210
      END IF
 160  CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        j_sucrose_bw = aphoto_bw
        aphoto_bw = 0.0_8
      ELSE
        j_sucrose_bw = 0.0_8
      END IF
      vcmax_bw = vcmax_bw + j_sucrose_bw/2.
      resp_ld_bw = resp_ld_bw - j_sucrose_bw
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        midroot_bw = aphoto_bw
        aphoto_bw = 0.0_8
      ELSE
        midroot_bw = 0.0_8
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        maxroot_bw = aphoto_bw
        aphoto_bw = 0.0_8
      ELSE
        maxroot_bw = 0.0_8
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        minroot_bw = aphoto_bw
      ELSE
        minroot_bw = 0.0_8
      END IF
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        root2_bw = maxroot_bw
        root1_bw = midroot_bw
      ELSE IF (branch .EQ. 1) THEN
        root1_bw = maxroot_bw
        root2_bw = midroot_bw
      ELSE
        root1_bw = 0.0_8
        root2_bw = 0.0_8
        root3_bw = 0.0_8
        GOTO 170
      END IF
      root3_bw = minroot_bw
      midroot_bw = 0.0_8
      minroot_bw = 0.0_8
      maxroot_bw = 0.0_8
 170  CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        root3_bw = root3_bw + maxroot_bw
        root1_bw = root1_bw + midroot_bw
      ELSE IF (branch .EQ. 1) THEN
        root1_bw = root1_bw + maxroot_bw
        root3_bw = root3_bw + midroot_bw
      ELSE
        GOTO 180
      END IF
      root2_bw = root2_bw + minroot_bw
      midroot_bw = 0.0_8
      minroot_bw = 0.0_8
      maxroot_bw = 0.0_8
 180  CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        root3_bw = root3_bw + maxroot_bw
        root2_bw = root2_bw + midroot_bw
      ELSE IF (branch .EQ. 1) THEN
        root2_bw = root2_bw + maxroot_bw
        root3_bw = root3_bw + midroot_bw
      ELSE
        GOTO 190
      END IF
      root1_bw = root1_bw + minroot_bw
 190  temp2 = (ang_l-pi2)/3.0
      temp1 = SQRT(qroot)
      IF (qroot .EQ. 0.0_8) THEN
        qroot_bw = 0.0_8
      ELSE
        qroot_bw = -(COS(temp2)*root3_bw/temp1)
      END IF
      ang_l_bw = SIN(temp2)*temp1*2.0*root3_bw/3.0
      p_cubic_bw = -(root3_bw/3.0) - root2_bw/3.0 - root1_bw/3.0
      temp2 = (pi2+ang_l)/3.0
      temp1 = SQRT(qroot)
      IF (.NOT.qroot .EQ. 0.0_8) qroot_bw = qroot_bw - COS(temp2)*&
&         root2_bw/temp1
      ang_l_bw = ang_l_bw + SIN(temp2)*temp1*2.0*root2_bw/3.0
      temp2 = SQRT(qroot)
      IF (.NOT.qroot .EQ. 0.0_8) qroot_bw = qroot_bw - COS(ang_l/3.0)*&
&         root1_bw/temp2
      ang_l_bw = ang_l_bw + SIN(ang_l/3.0)*temp2*2.0*root1_bw/3.0
      IF (r3q .EQ. 1.0 .OR. r3q .EQ. (-1.0)) THEN
        r3q_bw = 0.0_8
      ELSE
        r3q_bw = -(ang_l_bw/SQRT(1.0-r3q**2))
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) r3q_bw = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) r3q_bw = 0.0_8
      temp2 = qroot*qroot*qroot
      temp1 = SQRT(temp2)
      rroot_bw = r3q_bw/temp1
      IF (.NOT.temp2 .EQ. 0.0_8) qroot_bw = qroot_bw - 3*qroot**2*rroot*&
&         r3q_bw/(2.0*temp1**3)
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) qroot_bw = 0.0_8
      temp_bw13 = rroot_bw/54.0
      p_cubic_bw = p_cubic_bw + (3*p_cubic**2*2.0-q_cubic*9.0)*temp_bw13&
&       + 2*p_cubic*qroot_bw/9.0
      q_cubic_bw = -(p_cubic*9.0*temp_bw13) - 3.0*qroot_bw/9.0
      r_cubic_bw = 27.0*temp_bw13
      denom = e_ps*alpha_ps
      CALL POPREAL8ARRAY(r_cubic, r8/8)
      CALL POPREAL8ARRAY(q_cubic, r8/8)
      CALL POPREAL8ARRAY(p_cubic, r8/8)
      denom_bw = -(r_cubic*r_cubic_bw/denom**2) - q_cubic*q_cubic_bw/&
&       denom**2 - p_cubic*p_cubic_bw/denom**2
      r_cubic_bw = r_cubic_bw/denom
      temp_bw13 = d_ps*r_cubic_bw/ca
      temp_bw12 = b_ps*r_cubic_bw/ca
      q_cubic_bw = q_cubic_bw/denom
      gamma_ps_bw = (resp_ld*e_ps-a_ps)*r_cubic_bw + resp_ld*temp_bw12 +&
&       a_ps*temp_bw13 + (e_ps+b_ps/ca)*q_cubic_bw
      p_cubic_bw = p_cubic_bw/denom
      a_ps_bw = a_ps_bw + gamma_ps*temp_bw13 - gamma_ps*r_cubic_bw + (&
&       theta_ps*d_ps-beta_ps)*q_cubic_bw - alpha_ps*p_cubic_bw
      resp_ld_bw = resp_ld_bw + gamma_ps*e_ps*r_cubic_bw + gamma_ps*&
&       temp_bw12 + (beta_ps*e_ps+theta_ps*b_ps)*q_cubic_bw + alpha_ps*&
&       e_ps*p_cubic_bw
      beta_ps_bw = (resp_ld*e_ps-a_ps)*q_cubic_bw + e_ps*p_cubic_bw
      theta_ps_bw = (a_ps*d_ps+resp_ld*b_ps)*q_cubic_bw + b_ps*&
&       p_cubic_bw
      alpha_ps_bw = (resp_ld*e_ps-a_ps)*p_cubic_bw + e_ps*denom_bw
      aphoto_bw = 0.0_8
 210  CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        j_photon_bw = a_ps_bw
      ELSE
        vcmax_bw = vcmax_bw + a_ps_bw
        j_photon_bw = 0.0_8
      END IF
      temp_bw13 = j_photon_bw/(iphoton+2.1*jmax)
      temp_bw12 = -(jmax*iphoton*temp_bw13/(iphoton+2.1*jmax))
      jmax_bw = iphoton*temp_bw13 + 2.1*temp_bw12
      iphoton_bw = iphoton_bw + jmax*temp_bw13 + temp_bw12
      temp_bw13 = m_co2*theta_ps_bw
      g_lb_c_bw = g_lb_c_bw + rh_leaf*f_soilwater*temp_bw13
      rh_leaf_bw = rh_leaf_bw + g_lb_c*f_soilwater*temp_bw13
      f_soilwater_bw = f_soilwater_bw + g_lb_c*rh_leaf*temp_bw13
      temp_bw13 = m_co2*ca*beta_ps_bw
      g_lb_c_bw = g_lb_c_bw + b_co2*ca**2*gamma_ps_bw + rh_leaf*&
&       f_soilwater*temp_bw13 - ca*beta_ps_bw - b_co2*alpha_ps_bw/g_lb_c&
&       **2
      rh_leaf_bw = rh_leaf_bw + g_lb_c*f_soilwater*temp_bw13 - &
&       f_soilwater*m_co2*alpha_ps_bw
      f_soilwater_bw = f_soilwater_bw + g_lb_c*rh_leaf*temp_bw13 - &
&       rh_leaf*m_co2*alpha_ps_bw
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL TBOLTZC4_BW(vc_opt, vc_opt_bw, toptvc, temp_leaf_k, vcmax, &
&                vcmax_bw)
    ELSE
      CALL TBOLTZ_BW(vc_opt, vc_opt_bw, evc, toptvc, temp_leaf_k, vcmax&
&              , vcmax_bw)
    END IF
    jmopt_bw = 0.0_8
    CALL TBOLTZ_BW(jmopt, jmopt_bw, ejm, toptjm, temp_leaf_k, jmax, &
&            jmax_bw)
    vj_slope_bw = vj_slope_bw + vc_opt*jmopt_bw
    vc_opt_bw = vc_opt_bw + vj_slope*jmopt_bw
    CALL TEMP_FUNC_BW(resp_ld25, resp_ld25_bw, erd, tprime25, tk_25, &
&               temp_leaf_k, resp_ld, resp_ld_bw)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) resp_ld25_bw = 0.4*resp_ld25_bw
    vc_opt_bw = vc_opt_bw + 0.004657*resp_ld25_bw
    CALL SFC_VPD_BW(temp_leaf_k, lh_leaf, lh_leaf_bw, rh_leaf, &
&             rh_leaf_bw)
    g_lb_w_bw = g_lb_w_bw + g_lb_cos_bw/(1.56*temp_leaf_k*met%pstat273) &
&     + g_lb_c_bw/(1.6*temp_leaf_k*met%pstat273) - bound_layer_res_bw%&
&     vapor/g_lb_w**2
    CALL LAMBDA_BW(temp_leaf_p, temp_leaf_p_bw, fact%latent, fact_bw%&
&            latent)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) iphoton_bw = 0.0_8
    f_leaf_bw = f_leaf_bw + rad_leaf*4.55*iphoton_bw
    rad_leaf_bw = f_leaf*4.55*iphoton_bw
  END SUBROUTINE PHOTOSYNTHESIS_BW

  SUBROUTINE PHOTOSYNTHESIS(lc, temp_leaf_p, f_leaf, p_kc25, p_ko25, &
&   p_tau25, rad_leaf, e_air, g_lb_w, vc_opt, vj_slope, f_soilwater, &
&   b_h2o, m_h2o, cii, temp_leaf_c, lh_leaf, gs_w, gs_h2o_mole, aphoto, &
&   ci, ffpa, sif_alpha, sif_beta, xsif, cosii, cosi, cos_assim)
    IMPLICIT NONE
!*************************************************************************
! This program solves a cubic equation to calculate
! leaf photosynthesis.  This cubic expression is derived from solving
! five simultaneous equations for A, PG, cs, CI and GS.
! Stomatal conductance is computed with the Ball-Berry model.
! The cubic derivation assumes that b', the intercept of the Ball-Berry
! stomatal conductance model, is non-zero.
! Gs = k A rh/cs + b'
! We also found that the solution for A can be obtained by a quadratic equation
! when Gs is constant or b' is zero.
! The derivation is published in:
! Baldocchi, D.D. 1994. An analytical solution for coupled leaf photosynthesis
! and stomatal conductance models. Tree Physiology 14: 1069-1079.
!-----------------------------------------------------------------------
! A Biochemical Model of C3 Photosynthesis
! After Farquhar, von Caemmerer and Berry (1980) Planta.
! 149: 78-90.
! The original program was modified to incorporate functions and parameters
! derived from gas exchange experiments of Harley, who paramertized Vc and J in
! terms of optimal temperature, rather than some reference temperature, eg 25C.
! Program calculates leaf photosynthesis from biochemical parameters
! rd25 - Dark respiration at 25 degrees C (umol m-2 s-1)
! tlk - leaf temperature, Kelvin
! jmax - optimal rate of electron transport
! vcopt - maximum rate of RuBP Carboxylase/oxygenase
! iphoton - incident photosynthetically active photon flux (umols m-2 s-1)
! note: Harley parameterized the model on the basis of incident PAR
! gs - stomatal conductance (mols m-2 s-1), typically 0.01-0.20
! pstat-station pressure, bars
! aphoto - net photosynthesis  (umol m-2 s-1)
! ps - gross photosynthesis (umol m-2 s-1)
! aps - net photosynthesis (mg m-2 s-1)
! aphoto (umol m-2 s-1)
!-----------------------------------------------------------------------
! iphoton is radiation incident on leaves
! The temperature dependency of the kinetic properties of
! RUBISCO are compensated for using the Arrhenius and
! Boltzmann equations.  From biochemistry, one observes that
! at moderate temperatures enzyme kinetic rates increase
! with temperature.  At extreme temperatures enzyme
! denaturization occurs and rates must decrease.
! Arrhenius Eq.
! f(T)=f(tk_25) exp(tk -298)eact/(298 R tk)), where eact is the
! activation energy.
! Boltzmann distribution
! F(T)=tboltz)
! Define terms for calculation of gross photosynthesis, PG
! PG is a function of the minimum of RuBP saturated rate of
! carboxylation, Wc, and the RuBP limited rate of carboxylation, Wj.
! Wj is limiting when light is low and electron transport, which
! re-generates RuBP, is limiting.  Wc is limiting when plenty of RuBP is
! available compared to the CO2 that is needed for carboxylation.
! Both equations take the form:
! PG-photorespiration= (a CI-a d)/(e CI + b)
! PG-photorespiration=min[Wj,Wc] (1-gamma_ps/Ci)
! Wc=Vcmax Ci/(Ci + Kc(1+O2/Ko))
! Wj=J Ci/(4 Ci + 8 gamma_ps)
! Ps kinetic coefficients from Harley at WBW.
! gamma_ps is the CO2 compensation point
! Jan 14, 1999 Updated the cubic solutions for photosynthesis.  There are
! times when the restriction that R^2 < Q^3 is violated.  I therefore need
! alternative algorithms to solve for the correct root.
!*************************************************************************
! It is temporay, will be removed later
    REAL(r8) :: temp_leaf_p
! Leaf respiration ratio, default value of 0.5
    REAL(r8) :: f_leaf
! net shortwave radiation (W/m2)
    REAL(r8) :: rad_leaf
! water vapor pressure above canopy (kPa)
    REAL(r8) :: e_air
! leaf laminar boundary layer condunctance to H2O (m/s)
    REAL(r8) :: g_lb_w
! the maximum velocities of carboxylation of Rubisco at 25 deg C (umol m-2 s-1)
    REAL(r8) :: vc_opt
! the ratio of Vmax/Jmax, default value of 2.39
    REAL(r8) :: vj_slope
! an empirical scalar of soil water stress on stomatal conductance, dimensionless
    REAL(r8) :: f_soilwater
! the intercept term in BWB model (mol H2O m-2 s-1)
    REAL(r8) :: b_h2o
! the slope in BWB model
    REAL(r8) :: m_h2o
!landcover type
    INTEGER :: lc
! replace, kc25,ko25,tau25 with three pramters, default values are 274.6,419.8,2904.12, respectively
    REAL(r8) :: p_kc25, p_ko25, p_tau25
! initial intercellular co2 concentration (ppm)
    REAL(r8) :: cii
! leaf temperature (deg C)
    REAL(r8) :: temp_leaf_c
! leaf latent heat flux (W m-2)
    REAL(r8) :: lh_leaf
! stomatal conductance to water vapor (m s-1)
    REAL(r8) :: gs_w
! net photosynthesis rate (umol CO2 m-2 s-1)
    REAL(r8) :: aphoto
! intercellular co2 concentration (ppm)
    REAL(r8) :: ci
!    real(r8)  :: xSIF           ! SIF
! SIF
    REAL(r8) :: sif_alpha, sif_beta, xsif
!  air pressure (kPa)
    REAL(r8), PARAMETER :: air_pres=101.325
! atmospheric co2 concentration (ppm)
    REAL(r8) :: ca
! incident photosynthetic photon flux density (PPFD) umol m-2 s-1
    REAL(r8) :: iphoton
!    real(r8)  :: g_lb_c          ! leaf laminar boundary layer condunctance to CO2 (mol m-2 s-1)
! leaf laminar boundary layer condunctance to CO2,COS (mol m-2 s-1)
    REAL(r8) :: g_lb_c, g_lb_cos
! relative humidity at leaf surface (0-1)
    REAL(r8) :: rh_leaf
! leaf temperature (K)
    REAL(r8) :: temp_leaf_k
! stomatal conductance to CO2 (mol m-2 s-1)
    REAL(r8) :: gs_co2_mole
! stomatal conductance to h2o (mol m-2 s-1)
    REAL(r8) :: gs_h2o_mole
! temporary variable
    REAL(r8) :: bc
! CO2 concentration at leaf surface (ppm)
    REAL(r8) :: cs
! the intercept term in BWB model (mol CO2 m-2 s-1): b_h2o/1.6
    REAL(r8) :: b_co2
! the slope in BWB model: m_h2o/1.6
    REAL(r8) :: m_co2
! CO2 compensation point (ppm)
    REAL(r8) :: gammac
! the maximum potential electron transport rate at 25 deg C (umol m-2 s-1)
    REAL(r8) :: jmopt
! the maximum potential electron transport rate (umol m-2 s-1)
    REAL(r8) :: jmax
! the maximum velocities of carboxylation of Rubisco (umol m-2 s-1)
    REAL(r8) :: vcmax
! Michaelis-Menten constant for CO2 (?ol mol-1)
    REAL(r8) :: km_co2
! Michaelis-Menten constant for O2 (mmol mol-1)
    REAL(r8) :: km_o2
! the specifity of Rubisco for CO2 compared with O2
    REAL(r8) :: tau
! leaf dark respiration (umol m-2 s-1)
    REAL(r8) :: resp_ld
! leaf dark respiration at 25 deg C (umol m-2 s-1)
    REAL(r8) :: resp_ld25
! the flux of electrons through the thylakoid membrane (umol m-2 s-1)
    REAL(r8) :: j_photon
    REAL(r8) :: alpha_ps
    REAL(r8) :: beta_ps
    REAL(r8) :: gamma_ps
    REAL(r8) :: theta_ps
    REAL(r8) :: denom
    REAL(r8) :: p_cubic
    REAL(r8) :: q_cubic
    REAL(r8) :: r_cubic
    REAL(r8) :: qroot
    REAL(r8) :: rroot
    REAL(r8) :: root1, root2, root3
    REAL(r8) :: ang_l
! net photosynthesis rate limited by sucrose synthesis (umol m-2 s-1)
    REAL(r8) :: j_sucrose
! gross photosynthesis rate limited by light (umol m-2 s-1)
    REAL(r8) :: wc, wj, psguess
!-- iLab::convf no longer required
! real(r8)  :: cosa,convf,cosi,cosii,coss  ! parameters used for COS calculations
! parameters used for COS calculations
    REAL(r8) :: cosa, cosi, cosii, coss
    REAL(r8) :: cos_assim
    REAL(r8) :: kn, kf, kd, kp, ps_sif, fm
    REAL(r8) :: je, xxn, fs, ffpa
    REAL(r8) :: aquad, bquad, cquad
    REAL(r8) :: b_ps, a_ps, e_ps, d_ps
    REAL(r8) :: product1
    REAL(r8) :: ps_1
    REAL(r8) :: delta_1
    REAL(r8) :: r3q
    REAL(r8) :: minroot, maxroot, midroot
    REAL(r8) :: tprime25
    REAL(r8) :: k_t_opt, k_t, theta, beta, m1, m2, m
    INTRINSIC SQRT
    INTRINSIC MAX
    INTRINSIC ACOS
    INTRINSIC COS
    REAL(r8) :: x1
    minroot = 0.0
    maxroot = 0.0
    midroot = 0.0
    ca = co2_air
    cosa = cos_air
!    iphoton = 4.55*0.5*rad_leaf
! replace 0.5 to a coefficient, f_leaf, leaf respiration rate, for optimization purpose, @MOUSONG WU, 2020-09-14
    iphoton = 4.55*f_leaf*rad_leaf
    IF (2*iphoton .LT. 1) iphoton = 0
    temp_leaf_k = temp_leaf_c + 273.13
    CALL LAMBDA(temp_leaf_p, fact%latent)
    bound_layer_res%vapor = 1.0/g_lb_w
    met%press_bars = 1.013
    met%pstat273 = 0.022624/(273.16*met%press_bars)
    met%t_kelvin = temp_leaf_c + 273.13
! absolute humidity, g m-3
    met%rhova_g = e_air*2165/met%t_kelvin
! absolute humidity, kg m-3
    met%rhova_kg = met%rhova_g/1000.0
    g_lb_c = 1./(1.0/g_lb_w*1.6*temp_leaf_k*met%pstat273)
    m_co2 = m_h2o/1.6
    b_co2 = b_h2o/1.6
    g_lb_cos = 1./(1.0/g_lb_w*1.56*temp_leaf_k*met%pstat273)
!-- iLab::convf no longer required
! convf = temp_leaf_K * (met%pstat273)
    CALL SFC_VPD(temp_leaf_k, lh_leaf, rh_leaf)
! temperature difference
    tprime25 = temp_leaf_k - tk_25
!   
    CALL TEMP_FUNC(kc25, ekc, tprime25, tk_25, temp_leaf_k, km_co2)
    CALL TEMP_FUNC(ko25, eko, tprime25, tk_25, temp_leaf_k, km_o2)
    CALL TEMP_FUNC(tau25, ektau, tprime25, tk_25, temp_leaf_k, tau)
    bc = km_co2*(1.0+o2/km_o2)
! umol mol-1
    gammac = 0.5*o2/tau*1000.0
    resp_ld25 = vc_opt*0.004657
    IF (2.0*iphoton .GT. 10) THEN
! Bin Chen: check this later.
! reduce respiration by 40% in light according to Amthor
      resp_ld25 = resp_ld25*0.4
    END IF
    CALL TEMP_FUNC(resp_ld25, erd, tprime25, tk_25, temp_leaf_k, resp_ld&
&           )
!    jmopt   = 2.39*vc_opt - 14.2
    jmopt = vj_slope*vc_opt - 14.2
! Apply temperature correction to JMAX
    CALL TBOLTZ(jmopt, ejm, toptjm, temp_leaf_k, jmax)
    IF (lc .EQ. 40 .OR. lc .EQ. 41) THEN
! Apply temperature correction to vcmax
      CALL TBOLTZC4(vc_opt, toptvc, temp_leaf_k, vcmax)
    ELSE
! Apply temperature correction to vcmax
      CALL TBOLTZ(vc_opt, evc, toptvc, temp_leaf_k, vcmax)
    END IF
!***************************************
!        APHOTO = PG - resp_ld, net photosynthesis is the difference
!        between gross photosynthesis and dark respiration. Note
!        photorespiration is already factored into PG.
!        Gs from Ball-Berry is for water vapor.  It must be divided
!        by the ratio of the molecular diffusivities to be valid
!        for A
!****************************************
    IF (lc .EQ. 40 .OR. lc .EQ. 41) THEN
! analytical solution for C4 photosynthesis, added by MOUSONG.WU@201907, refer to Chen et al.2019 AFM
      k_t_opt = 2.*1.e4*vc_opt
      k_t = k_t_opt*2.**((temp_leaf_k-298.15)/10.)
      j_photon = iphoton*0.05
      wj = j_photon
      wc = vcmax
      theta = 0.80
      beta = 0.95
      m1 = (wj+wc+SQRT((wj+wc)*(wj+wc)-4*theta*wj*wc))/(2*theta)
      m2 = (wj+wc+SQRT((wj+wc)*(wj+wc)+4*theta*wj*wc))/(2*theta)
      IF (m1 .LT. m2) THEN
        m = m1
      ELSE
        m = m2
      END IF
      alpha_ps = beta*m_co2*f_soilwater*rh_leaf - beta*b_co2/g_lb_c - &
&       1.6*k_t/g_lb_c + k_t*m_co2*f_soilwater*rh_leaf/g_lb_c - k_t*&
&       b_co2/g_lb_c/g_lb_c
      beta_ps = beta*b_co2*ca - beta*m_co2*f_soilwater*rh_leaf*resp_ld +&
&       1.6*k_t*ca - m*m_co2*f_soilwater*rh_leaf - k_t*m_co2*f_soilwater&
&       *rh_leaf*ca + m*b_co2/g_lb_c - resp_ld*k_t*m_co2*f_soilwater*&
&       rh_leaf/g_lb_c + 2*k_t*b_co2*ca/g_lb_c + (1.6*k_t*resp_ld+1.6*&
&       k_t*m-m*k_t*m_co2*f_soilwater*rh_leaf)/g_lb_c + m*k_t*b_co2/&
&       g_lb_c/g_lb_c
      gamma_ps = resp_ld*m*m_co2*f_soilwater*rh_leaf - m*b_co2*ca + &
&       resp_ld*k_t*m_co2*f_soilwater*rh_leaf*ca - k_t*b_co2*ca*ca + (m*&
&       k_t*m_co2*f_soilwater*rh_leaf-1.6*resp_ld*k_t-1.6*k_t*m)*ca - 2*&
&       m*k_t*b_co2*ca/g_lb_c - (1.6*m*resp_ld*k_t-m*k_t*m_co2*&
&       f_soilwater*rh_leaf*resp_ld)/g_lb_c
      theta_ps = m*k_t*b_co2*ca*ca + 1.6*m*resp_ld*k_t*ca - m*resp_ld*&
&       k_t*m_co2*f_soilwater*rh_leaf*ca
      IF (.NOT.(wj .LE. resp_ld .OR. wc .LE. resp_ld)) THEN
!        //cubic solution:
!        // A^3 + p A^2 + q A + r = 0
        denom = alpha_ps
        p_cubic = beta_ps/denom
        q_cubic = gamma_ps/denom
        r_cubic = theta_ps/denom
!        // Use solution from Numerical Recipes from Press
        qroot = (p_cubic*p_cubic-3.0*q_cubic)/9.0
        rroot = (2.0*p_cubic*p_cubic*p_cubic-9.0*p_cubic*q_cubic+27.0*&
&         r_cubic)/54.0
        IF (qroot .LT. 1.e-6) THEN
          qroot = 1.e-6
        ELSE
          qroot = qroot
        END IF
        r3q = rroot/SQRT(qroot*qroot*qroot)
        IF (r3q .GT. 1) r3q = 1
        IF (r3q .LT. -1) r3q = -1
        ang_l = ACOS(r3q)
        root1 = -(2.0*SQRT(qroot)*COS(ang_l/3.0)) - p_cubic/3.0
        root2 = -(2.0*SQRT(qroot)*COS((ang_l+pi2)/3.0)) - p_cubic/3.0
        root3 = -(2.0*SQRT(qroot)*COS((ang_l-pi2)/3.0)) - p_cubic/3.0
!   Here A = x - p / 3, allowing the cubic expression to be expressed
!   as: x^3 + ax + b = 0
!   rank roots #1,#2 and #3 according to the minimum, intermediate and maximum value
        IF (root1 .LE. root2 .AND. root1 .LE. root3) THEN
          minroot = root1
          IF (root2 .LE. root3) THEN
            midroot = root2
            maxroot = root3
          ELSE
            midroot = root3
            maxroot = root2
          END IF
        END IF
        IF (root2 .LE. root1 .AND. root2 .LE. root3) THEN
          minroot = root2
          IF (root1 .LE. root3) THEN
            midroot = root1
            maxroot = root3
          ELSE
            midroot = root3
            maxroot = root1
          END IF
        END IF
        IF (root3 .LE. root1 .AND. root3 .LE. root2) THEN
          minroot = root3
          IF (root1 .LT. root2) THEN
            midroot = root1
            maxroot = root2
          ELSE
            midroot = root2
            maxroot = root1
          END IF
        END IF
        aphoto = 0
!     find out where roots plop down relative to the x-y axis
        IF (minroot .GT. 0 .AND. midroot .GT. 0 .AND. maxroot .GT. 0) &
&         aphoto = minroot
        IF (minroot .LT. 0 .AND. midroot .LT. 0 .AND. maxroot .GT. 0) &
&         aphoto = maxroot
        IF (minroot .LT. 0 .AND. midroot .GT. 0 .AND. maxroot .GT. 0) &
&         aphoto = midroot
!        //also test for sucrose limitation of photosynthesis, as suggested by
!        //Collatz.  Js=Vmax/2
        cs = ca - aphoto/g_lb_c
!mol m-2 s-1
        gs_h2o_mole = f_soilwater*m_h2o*rh_leaf*aphoto/cs + b_h2o
        gs_co2_mole = gs_h2o_mole/1.6
        ci = cs - aphoto/gs_co2_mole
        j_sucrose = k_t*ci - resp_ld
        IF (j_sucrose .LT. aphoto) aphoto = j_sucrose
!         //Stomatal conductance for water vapor
!        //forest are hypostomatous.
!        //Hence we don't divide the total resistance
!        //by 2 since transfer is going on only one side of a leaf.
!        // if A < 0 then gs should go to cuticular value and recalculate A
!         //using quadratic solution
        IF (aphoto .GT. 0.0) GOTO 400
      END IF
!        // if aphoto < 0  set stomatal conductance to cuticle value
!        //a quadratic solution of A is derived if gs=b, but a cubic form occurs
!        //if gs =ax + b.  Use quadratic case when A <=0
!  // Bin Chen:
!         r_tot = 1.0/b_co2 + 1.0/g_lb_c; // total resistance to CO2 (m2 s mol-1)
!         denom = g_lb_c * b_co2;
!         Aquad = r_tot * e_ps;
!         Bquad = (e_ps*resp_ld + a_ps)*r_tot - b_ps - e_ps*ca;
!         Cquad = a_ps*(ca-d_ps) - resp_ld*(e_ps*ca+b_ps);
      aquad = beta + k_t/g_lb_c + 1.6*k_t/b_co2
      bquad = 2*beta*resp_ld - m - ca*k_t - (k_t/g_lb_c+1.6*k_t/b_co2)*(&
&       m-resp_ld)
      cquad = beta*resp_ld*resp_ld - m*resp_ld + ca*k_t*(m-resp_ld)
      product1 = bquad*bquad - 4.0*aquad*cquad
      IF (product1 .GE. 0) aphoto = (-bquad-SQRT(product1))/(2.0*aquad)
 400  IF (0. .LT. aphoto) THEN
        aphoto = aphoto
      ELSE
        aphoto = 0.
      END IF
      cs = ca - aphoto/g_lb_c
!mol m-2 s-1
      gs_h2o_mole = f_soilwater*m_h2o*rh_leaf*aphoto/cs + b_h2o
      gs_co2_mole = gs_h2o_mole/1.6
      ci = cs - aphoto/gs_co2_mole
!m s-1
      gs_w = gs_h2o_mole*temp_leaf_k*met%pstat273
    ELSE
      alpha_ps = 1.0 + b_co2/g_lb_c - m_co2*rh_leaf*f_soilwater
      beta_ps = ca*(g_lb_c*m_co2*rh_leaf*f_soilwater-2.0*b_co2-g_lb_c)
      gamma_ps = ca*ca*g_lb_c*b_co2
      theta_ps = g_lb_c*m_co2*rh_leaf*f_soilwater - b_co2
!***************************************
!        Test for the minimum of Wc and Wj.  Both have the form:
!        W = (a ci - ad)/(e ci + b)
!        after the minimum is chosen set a, b, e and d for the cubic solution.
!        estimate of J according to Farquhar and von Cammerer (1981)
!***************************************
      j_photon = jmax*iphoton/(iphoton+2.1*jmax)
!    if(LC == 40) then
!        j_photon = jmax
!    else
!      j_photon =jmax * iphoton/ (iphoton+ 2.1*jmax)
!    end if
!  initial guess of intercellular CO2 concentration to estimate Wc and Wj:
      wj = j_photon*(cii-gammac)/(4.*cii+8.0*gammac)
      wc = vcmax*(cii-gammac)/(cii+bc)
!    if(LC == 40) then
!        wc = vcmax
!    else
!      wc = vcmax * (cii - gammac) / (cii + bc)
!    end if
      IF (wj .LT. wc) THEN
!        // for Harley and Farquhar type model for Wj
        psguess = wj
        a_ps = j_photon
        b_ps = 8.0*gammac
        e_ps = 4.0
        d_ps = gammac
      ELSE
        psguess = wc
        a_ps = vcmax
        b_ps = bc
        e_ps = 1.0
        d_ps = gammac
      END IF
!***************************************
! if wj or wc are less than resp_ld then A would probably be less than
! zero.  This would yield a
! negative stomatal conductance.  In this case, assume gs equals the
! cuticular value. This
! assumptions yields a quadratic rather than cubic solution for A
!***************************************
      IF (.NOT.(wj .LE. resp_ld .OR. wc .LE. resp_ld)) THEN
!        //cubic solution:
!        // A^3 + p A^2 + q A + r = 0
        denom = e_ps*alpha_ps
        p_cubic = e_ps*beta_ps + b_ps*theta_ps - a_ps*alpha_ps + e_ps*&
&         resp_ld*alpha_ps
        p_cubic = p_cubic/denom
        q_cubic = e_ps*gamma_ps + b_ps*gamma_ps/ca - a_ps*beta_ps + a_ps&
&         *d_ps*theta_ps + e_ps*resp_ld*beta_ps + resp_ld*b_ps*theta_ps
        q_cubic = q_cubic/denom
        r_cubic = -(a_ps*gamma_ps) + a_ps*d_ps*gamma_ps/ca + e_ps*&
&         resp_ld*gamma_ps + resp_ld*b_ps*gamma_ps/ca
        r_cubic = r_cubic/denom
!        // Use solution from Numerical Recipes from Press
        qroot = (p_cubic*p_cubic-3.0*q_cubic)/9.0
        rroot = (2.0*p_cubic*p_cubic*p_cubic-9.0*p_cubic*q_cubic+27.0*&
&         r_cubic)/54.0
        IF (qroot .LT. 1.e-6) THEN
          qroot = 1.e-6
        ELSE
          qroot = qroot
        END IF
        r3q = rroot/SQRT(qroot*qroot*qroot)
        IF (r3q .GT. 1) r3q = 1
        IF (r3q .LT. -1) r3q = -1
        ang_l = ACOS(r3q)
        root1 = -(2.0*SQRT(qroot)*COS(ang_l/3.0)) - p_cubic/3.0
        root2 = -(2.0*SQRT(qroot)*COS((ang_l+pi2)/3.0)) - p_cubic/3.0
        root3 = -(2.0*SQRT(qroot)*COS((ang_l-pi2)/3.0)) - p_cubic/3.0
!   Here A = x - p / 3, allowing the cubic expression to be expressed
!   as: x^3 + ax + b = 0
!   rank roots #1,#2 and #3 according to the minimum, intermediate and maximum value
        IF (root1 .LE. root2 .AND. root1 .LE. root3) THEN
          minroot = root1
          IF (root2 .LE. root3) THEN
            midroot = root2
            maxroot = root3
          ELSE
            midroot = root3
            maxroot = root2
          END IF
        END IF
        IF (root2 .LE. root1 .AND. root2 .LE. root3) THEN
          minroot = root2
          IF (root1 .LE. root3) THEN
            midroot = root1
            maxroot = root3
          ELSE
            midroot = root3
            maxroot = root1
          END IF
        END IF
        IF (root3 .LE. root1 .AND. root3 .LE. root2) THEN
          minroot = root3
          IF (root1 .LT. root2) THEN
            midroot = root1
            maxroot = root2
          ELSE
            midroot = root2
            maxroot = root1
          END IF
        END IF
        aphoto = 0
!     find out where roots plop down relative to the x-y axis
        IF (minroot .GT. 0 .AND. midroot .GT. 0 .AND. maxroot .GT. 0) &
&         aphoto = minroot
        IF (minroot .LT. 0 .AND. midroot .LT. 0 .AND. maxroot .GT. 0) &
&         aphoto = maxroot
        IF (minroot .LT. 0 .AND. midroot .GT. 0 .AND. maxroot .GT. 0) &
&         aphoto = midroot
!        //also test for sucrose limitation of photosynthesis, as suggested by
!        //Collatz.  Js=Vmax/2
        j_sucrose = vcmax/2. - resp_ld
!    if(LC == 40) then
!      j_sucrose = 2.*1.e4*vcmax*cii/air_pres/1000. - resp_ld
!    else
!      j_sucrose = vcmax / 2. - resp_ld
!    end if
        IF (j_sucrose .LT. aphoto) aphoto = j_sucrose
!         //Stomatal conductance for water vapor
!        //forest are hypostomatous.
!        //Hence we don't divide the total resistance
!        //by 2 since transfer is going on only one side of a leaf.
!        // if A < 0 then gs should go to cuticular value and recalculate A
!         //using quadratic solution
        IF (aphoto .GT. 0.0) GOTO 200
      END IF
!        // if aphoto < 0  set stomatal conductance to cuticle value
!        //a quadratic solution of A is derived if gs=b, but a cubic form occurs
!        //if gs =ax + b.  Use quadratic case when A <=0
!  // Bin Chen:
!         r_tot = 1.0/b_co2 + 1.0/g_lb_c; // total resistance to CO2 (m2 s mol-1)
!         denom = g_lb_c * b_co2;
!         Aquad = r_tot * e_ps;
!         Bquad = (e_ps*resp_ld + a_ps)*r_tot - b_ps - e_ps*ca;
!         Cquad = a_ps*(ca-d_ps) - resp_ld*(e_ps*ca+b_ps);
      ps_1 = ca*g_lb_c*b_co2
      delta_1 = b_co2 + g_lb_c
      denom = g_lb_c*b_co2
      aquad = delta_1*e_ps
      bquad = -(ps_1*e_ps) - a_ps*delta_1 + e_ps*resp_ld*delta_1 - b_ps*&
&       denom
      cquad = a_ps*ps_1 - a_ps*d_ps*denom - e_ps*resp_ld*ps_1 - resp_ld*&
&       b_ps*denom
      product1 = bquad*bquad - 4.0*aquad*cquad
      IF (product1 .GE. 0) aphoto = (-bquad-SQRT(product1))/(2.0*aquad)
 200  IF (0. .LT. aphoto) THEN
        aphoto = aphoto
      ELSE
        aphoto = 0.
      END IF
      cs = ca - aphoto/g_lb_c
!mol m-2 s-1
      gs_h2o_mole = f_soilwater*m_h2o*rh_leaf*aphoto/cs + b_h2o
      gs_co2_mole = gs_h2o_mole/1.6
      ci = cs - aphoto/gs_co2_mole
!m s-1
      gs_w = gs_h2o_mole*temp_leaf_k*met%pstat273
    END IF
!! QBO
!   ffpa = 0.8;   ! 0.6~0.9
    IF (iphoton .LE. 0.) THEN
      xsif = 0.
    ELSE
! C4 je is added, @MOUSONG WU, 2020-09-10
      IF (lc .EQ. 40 .OR. lc .EQ. 41) THEN
        je = aphoto
      ELSE
        x1 = aphoto*(ci+2.0*gammac)/(ci-gammac)
        IF (x1 .LT. 0.0) THEN
          je = 0.0
        ELSE
          je = x1
        END IF
      END IF
      xxn = 1.0 - je/(iphoton*ffpa*0.05)
      IF (xxn .LT. 0) xxn = 0.
      kf = 0.05
      kd = 0.95
      kp = 4.0
      ps_sif = kp/(kf+kp+kd)*(1.-xxn)
      kn = (sif_alpha*xxn+sif_beta)*xxn
! kn     = (6.2473*xxn - 0.5994)*xxn
      fm = kf/(kf+kd+kn)
      fs = fm*(1.0-ps_sif)
      IF (xxn .LT. 0.26) fs = -(0.0075*xxn) + 0.0181
      xsif = fs*iphoton*ffpa
!    xSIF = iphoton
    END IF
! add the module for calculating COS uptake by plants, @MOUSONG.WU 2020-09-17
!-- iLab::convf no longer required
! call cos_plant(LC,cosii,convf,gs_h2o_mole,g_lb_cos,vcmax,ffpa,f_soilwater,cos_assim)
    CALL COS_PLANT(lc, cosii, gs_h2o_mole, g_lb_cos, vcmax, ffpa, &
&            f_soilwater, cos_assim)
! ppb
    coss = cosa - cos_assim/g_lb_cos
! ppb
    cosi = coss - cos_assim/(gs_h2o_mole/1.56)
  END SUBROUTINE PHOTOSYNTHESIS

!  Differentiation of sfc_vpd in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: y
!   with respect to varying inputs: bound_layer_res.vapor fact.latent
!                leleafpt
  SUBROUTINE SFC_VPD_BW(temp_leaf_k, leleafpt, leleafpt_bw, y, y_bw)
    IMPLICIT NONE
!****************************************************
! this function computes the relative humidity at the leaf surface for
! application in the Ball Berry Equation
! latent heat flux, LE, is passed through the function, mol m-2 s-1
! and it solves for the humidity at leaf surface
! es_leaf : saturation vapor pressure at leaf temperature.
!****************************************************
    REAL(r8) :: temp_leaf_k, leleafpt
    REAL(r8) :: leleafpt_bw
    REAL(r8) :: y, rhov_sfc, e_sfc, vpd_sfc, rhum_leaf
    REAL(r8) :: y_bw, rhov_sfc_bw, e_sfc_bw, vpd_sfc_bw, rhum_leaf_bw
    REAL(r8) :: es_leaf
    REAL(r8) :: temp_bw
    CALL ES(temp_leaf_k, es_leaf)
!  kg m-3
! mb
! mb
! 0 to 1.0
    rhum_leaf_bw = y_bw
    vpd_sfc_bw = -(rhum_leaf_bw/es_leaf)
    e_sfc_bw = -vpd_sfc_bw
    rhov_sfc_bw = temp_leaf_k*e_sfc_bw/0.2165
    temp_bw = rhov_sfc_bw/fact%latent
    leleafpt_bw = bound_layer_res%vapor*temp_bw
    bound_layer_res_bw%vapor = leleafpt*temp_bw
    fact_bw%latent = -(leleafpt*bound_layer_res%vapor*temp_bw/fact%&
&     latent)
  END SUBROUTINE SFC_VPD_BW

  SUBROUTINE SFC_VPD(temp_leaf_k, leleafpt, y)
    IMPLICIT NONE
!****************************************************
! this function computes the relative humidity at the leaf surface for
! application in the Ball Berry Equation
! latent heat flux, LE, is passed through the function, mol m-2 s-1
! and it solves for the humidity at leaf surface
! es_leaf : saturation vapor pressure at leaf temperature.
!****************************************************
    REAL(r8) :: temp_leaf_k, leleafpt
    REAL(r8) :: y, rhov_sfc, e_sfc, vpd_sfc, rhum_leaf
    REAL(r8) :: es_leaf
    CALL ES(temp_leaf_k, es_leaf)
!  kg m-3
    rhov_sfc = leleafpt/fact%latent*bound_layer_res%vapor + met%rhova_kg
! mb
    e_sfc = rhov_sfc*temp_leaf_k/0.2165
! mb
    vpd_sfc = es_leaf - e_sfc
! 0 to 1.0
    rhum_leaf = 1.0 - vpd_sfc/es_leaf
    y = rhum_leaf
  END SUBROUTINE SFC_VPD

!  Differentiation of temp_func in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: y
!   with respect to varying inputs: rate
  SUBROUTINE TEMP_FUNC_BW(rate, rate_bw, eact, tprime, tref, t_lk, y, &
&   y_bw)
    IMPLICIT NONE
    REAL(r8) :: rate, eact, tprime, tref, t_lk, y
    REAL(r8) :: rate_bw, y_bw
    INTRINSIC EXP
!   Arhennius temperature function
    rate_bw = EXP(tprime*eact/(tref*rugc*t_lk))*y_bw
  END SUBROUTINE TEMP_FUNC_BW

  SUBROUTINE TEMP_FUNC(rate, eact, tprime, tref, t_lk, y)
    IMPLICIT NONE
    REAL(r8) :: rate, eact, tprime, tref, t_lk, y
    INTRINSIC EXP
!   Arhennius temperature function
    y = rate*EXP(tprime*eact/(tref*rugc*t_lk))
  END SUBROUTINE TEMP_FUNC

!  Differentiation of lambda in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: y tak
!   with respect to varying inputs: tak
  SUBROUTINE LAMBDA_BW(tak, tak_bw, y, y_bw)
    IMPLICIT NONE
!   Latent heat of Vaporiation, J kg-1
    REAL(r8) :: tak, y
    REAL(r8) :: tak_bw, y_bw
!   add heat of fusion for melting ice
    tak_bw = tak_bw - 2370.0*y_bw
  END SUBROUTINE LAMBDA_BW

  SUBROUTINE LAMBDA(tak, y)
    IMPLICIT NONE
!   Latent heat of Vaporiation, J kg-1
    REAL(r8) :: tak, y
    y = 3149000.0 - 2370.0*tak
!   add heat of fusion for melting ice
    IF (tak .LT. 273.0) y = y + 333
  END SUBROUTINE LAMBDA

  SUBROUTINE ES(t, y)
    IMPLICIT NONE
! saturation vapor pressure function (mb)
! T is temperature in Kelvin
    REAL(r8) :: t, y, y1
    INTRINSIC LOG
    INTRINSIC EXP
    IF (t .GT. 0) THEN
      y1 = 54.8781919 - 6790.4985/t - 5.02808*LOG(t)
      y = EXP(y1)
    ELSE
      WRITE(*, *) 'bad es calc'
    END IF
  END SUBROUTINE ES

!  Differentiation of tboltz in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: y rate
!   with respect to varying inputs: rate
  SUBROUTINE TBOLTZ_BW(rate, rate_bw, eakin, topt, tl, y, y_bw)
    IMPLICIT NONE
!   Boltzmann temperature distribution for photosynthesis
    REAL(r8) :: rate, eakin, topt, tl
    REAL(r8) :: rate_bw
    REAL(r8) :: y, dtlopt, prodt, numm, denom
    REAL(r8) :: y_bw
    INTRINSIC EXP
    dtlopt = tl - topt
    prodt = rugc*topt*tl
    numm = hkin*EXP(eakin*dtlopt/prodt)
    denom = hkin - eakin*(1.0-EXP(hkin*dtlopt/prodt))
    rate_bw = rate_bw + numm*y_bw/denom
  END SUBROUTINE TBOLTZ_BW

  SUBROUTINE TBOLTZ(rate, eakin, topt, tl, y)
    IMPLICIT NONE
!   Boltzmann temperature distribution for photosynthesis
    REAL(r8) :: rate, eakin, topt, tl
    REAL(r8) :: y, dtlopt, prodt, numm, denom
    INTRINSIC EXP
    dtlopt = tl - topt
    prodt = rugc*topt*tl
    numm = hkin*EXP(eakin*dtlopt/prodt)
    denom = hkin - eakin*(1.0-EXP(hkin*dtlopt/prodt))
    y = rate*numm/denom
  END SUBROUTINE TBOLTZ

!  Differentiation of tboltzc4 in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: y rate
!   with respect to varying inputs: rate
  SUBROUTINE TBOLTZC4_BW(rate, rate_bw, topt, tl, y, y_bw)
    IMPLICIT NONE
! temperature correction for C4 plants
    REAL(r8) :: rate, topt, tl
    REAL(r8) :: rate_bw
    REAL(r8) :: y, dtlopt, q
    REAL(r8) :: y_bw
    REAL(r8) :: s1, s2, s3, s4, fh, fl
    INTRINSIC EXP
    dtlopt = tl - topt
    q = 2.
    s1 = 0.3
    s2 = 313.15
    s3 = 0.2
    s4 = 288.15
    fh = 1 + EXP(s1*(tl-s2))
    fl = 1 + EXP(s3*(s4-tl))
    rate_bw = rate_bw + q**dtlopt*y_bw/(fh*fl)
  END SUBROUTINE TBOLTZC4_BW

  SUBROUTINE TBOLTZC4(rate, topt, tl, y)
    IMPLICIT NONE
! temperature correction for C4 plants
    REAL(r8) :: rate, topt, tl
    REAL(r8) :: y, dtlopt, q
    REAL(r8) :: s1, s2, s3, s4, fh, fl
    INTRINSIC EXP
    dtlopt = tl - topt
    q = 2.
    s1 = 0.3
    s2 = 313.15
    s3 = 0.2
    s4 = 288.15
    fh = 1 + EXP(s1*(tl-s2))
    fl = 1 + EXP(s3*(s4-tl))
    y = rate*q**dtlopt/fh/fl
  END SUBROUTINE TBOLTZC4

  SUBROUTINE FLUORESCENCE(x, fs)
    IMPLICIT NONE
    REAL, INTENT(IN) :: x
    REAL, INTENT(OUT) :: fs
    REAL :: kn
    REAL :: kf
    REAL :: kd
    REAL :: kp
    REAL :: po0
    REAL :: ps
    REAL :: fo0
    REAL :: fo
    REAL :: fm
    REAL :: fm0
    REAL :: eta
    REAL :: qq
    REAL :: qe
    kf = 0.05
    kd = 0.95
    kp = 4.0
    po0 = kp/(kf+kd+kp)
    ps = po0*(1.0-x)
    kn = (6.2473*x-0.5944)*x
    fo0 = kf/(kf+kp+kd)
    fo = kf/(kf+kp+kd+kn)
    fm = kf/(kf+kd+kn)
    fm0 = kf/(kf+kd)
    fs = fm*(1.0-ps)
    eta = fs/fo0
    qq = 1.0 - (fs-fo)/(fm-fo)
    qe = 1.0 - (fm-fo)/(fm0-fo0)
  END SUBROUTINE FLUORESCENCE

END MODULE ANGSMOD_DIFF

!*******************************************************
! Function: Soil module( Initialize/Update soil status,soil
!           water, soil thermal etc.)
! Created : Jun Wang
! Date    : 2016/12/5
!*******************************************************
MODULE BEPS_SOILMOD_DIFF
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE BEPS_PAR
  USE METEOMOD_DIFF
  USE BEPS_CON
  USE MID_RESULTS_DIFF
  IMPLICIT NONE
! generic index
  INTEGER, PRIVATE :: i
!the number layers used in model
! depth of ponded water on the ground surface
! snow depth
! the rainfall rate on ground m/s
!    real(r8)  :: soil_r     ! not used
! units:??
! decay_rate_of_root_distribution
! for fw
! for fw
!!! Properties belong to each soil horizon
!root weight
! the weight calculated from soil_water_factor
! read from patameters
! thermal conductivity
!  field capacity
!  wiltng point
! porosity
! saturated hydraulic conductivity
! water potential in sat
! Cambell parameter b
! soil bulk density of layer
! volume fraction of organic matter in layer (%)
! needed to save
! The ratio of ice of soil layer
! soil water content in the layer
! soil temperature in this layer
!?
!!   ! derived variables
! soil water suction in this layer
! soil water content at the bottom of each layer
! soil water suction at the bottom this layer
! the liquid water flow rates at the soil layer interfaces
! the hydraulic conducitivity
! the averaged conductivity of two soil layer
!
! thermal conductivity of each soil layer
! ET in each layer
! energy fluxes
  TYPE, PUBLIC :: SOIL
      INTEGER :: n_layer
      REAL(r8) :: zp
      REAL(r8) :: zsp
      REAL(r8) :: r_rain_g
      REAL(r8) :: r_drainage
      REAL(r8) :: r_root_decay
      REAL(r8) :: psi_min
      REAL(r8) :: alpha
      REAL(r8) :: f_soilwater
      REAL(r8) :: d_soil(0:max_layers-1)
      REAL(r8) :: f_root(0:max_layers-1)
      REAL(r8) :: dt(0:max_layers-1)
      REAL(r8) :: thermal_cond(0:max_layers-1)
      REAL(r8) :: theta_vfc(0:max_layers-1)
      REAL(r8) :: theta_vwp(0:max_layers-1)
      REAL(r8) :: fei(0:max_layers-1)
      REAL(r8) :: ksat(0:max_layers-1)
      REAL(r8) :: psi_sat(0:max_layers-1)
      REAL(r8) :: b(0:max_layers-1)
      REAL(r8) :: density_soil(0:max_layers-1)
      REAL(r8) :: f_org(0:max_layers-1)
      REAL(r8) :: ice_ratio(0:max_layers-1)
      REAL(r8) :: thetam(0:max_layers-1)
      REAL(r8) :: thetam_prev(0:max_layers-1)
      REAL(r8) :: temp_soil_p(0:max_layers-1)
      REAL(r8) :: temp_soil_c(0:max_layers-1)
      REAL(r8) :: f_ice(0:max_layers-1)
      REAL(r8) :: psim(0:max_layers-1)
      REAL(r8) :: thetab(0:max_layers-1)
      REAL(r8) :: psib(0:max_layers-1)
      REAL(r8) :: r_waterflow(0:max_layers-1)
      REAL(r8) :: km(0:max_layers-1)
      REAL(r8) :: kb(0:max_layers-1)
      REAL(r8) :: kk(0:max_layers-1)
      REAL(r8) :: cs(0:max_layers-1)
      REAL(r8) :: lambda(0:max_layers-1)
      REAL(r8) :: ett(0:max_layers-1)
      REAL(r8) :: g(0:max_layers-1)
  END TYPE SOIL
  TYPE, PUBLIC :: SOIL_DIFF
      REAL(r8) :: zp
      REAL(r8) :: zsp
      REAL(r8) :: r_rain_g
      REAL(r8) :: r_drainage
      REAL(r8) :: r_root_decay
      REAL(r8) :: psi_min
      REAL(r8) :: alpha
      REAL(r8) :: f_soilwater
      REAL(r8), DIMENSION(0:max_layers-1) :: d_soil
      REAL(r8), DIMENSION(0:max_layers-1) :: f_root
      REAL(r8), DIMENSION(0:max_layers-1) :: dt
      REAL(r8), DIMENSION(0:max_layers-1) :: thermal_cond
      REAL(r8), DIMENSION(0:max_layers-1) :: theta_vfc
      REAL(r8), DIMENSION(0:max_layers-1) :: theta_vwp
      REAL(r8), DIMENSION(0:max_layers-1) :: fei
      REAL(r8), DIMENSION(0:max_layers-1) :: ksat
      REAL(r8), DIMENSION(0:max_layers-1) :: psi_sat
      REAL(r8), DIMENSION(0:max_layers-1) :: b
      REAL(r8), DIMENSION(0:max_layers-1) :: density_soil
      REAL(r8), DIMENSION(0:max_layers-1) :: f_org
      REAL(r8), DIMENSION(0:max_layers-1) :: ice_ratio
      REAL(r8), DIMENSION(0:max_layers-1) :: thetam
      REAL(r8), DIMENSION(0:max_layers-1) :: thetam_prev
      REAL(r8), DIMENSION(0:max_layers-1) :: temp_soil_p
      REAL(r8), DIMENSION(0:max_layers-1) :: temp_soil_c
      REAL(r8), DIMENSION(0:max_layers-1) :: f_ice
      REAL(r8), DIMENSION(0:max_layers-1) :: psim
      REAL(r8), DIMENSION(0:max_layers-1) :: thetab
      REAL(r8), DIMENSION(0:max_layers-1) :: psib
      REAL(r8), DIMENSION(0:max_layers-1) :: r_waterflow
      REAL(r8), DIMENSION(0:max_layers-1) :: km
      REAL(r8), DIMENSION(0:max_layers-1) :: kb
      REAL(r8), DIMENSION(0:max_layers-1) :: kk
      REAL(r8), DIMENSION(0:max_layers-1) :: cs
      REAL(r8), DIMENSION(0:max_layers-1) :: lambda
      REAL(r8), DIMENSION(0:max_layers-1) :: ett
      REAL(r8), DIMENSION(0:max_layers-1) :: g
  END TYPE SOIL_DIFF
! initial
!Soil thermal
! soil water
  PUBLIC :: init_soil_parameters, init_soil_status, updateheatflux, &
& update_cs, updatesoilthermalconductivity, surfacetemperature, &
& updatesoilmoisture, soil_water_uptake, soil_water_factor_v2, &
& soil_evaporation
  PUBLIC :: init_soil_parameters_bw, init_soil_status_bw, &
& updateheatflux_bw, update_cs_bw, updatesoilthermalconductivity_bw, &
& surfacetemperature_bw, updatesoilmoisture_bw, soil_water_uptake_bw, &
& soil_water_factor_v2_bw, soil_evaporation_bw
  PRIVATE :: init_soil_rootfraction, update_ice_ratio
  PRIVATE :: update_ice_ratio_bw

CONTAINS
!  Differentiation of init_soil_parameters in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: p.ksat p.b
!   with respect to varying inputs: p.ksat p.b
! Initialization process
  SUBROUTINE INIT_SOIL_PARAMETERS_BW(lc, stxt, r_root_decay, p, p_bw)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: lc
    INTEGER, INTENT(IN) :: stxt
    REAL(r8), INTENT(IN) :: r_root_decay
    TYPE(SOIL) :: p
    TYPE(SOIL_DIFF) :: p_bw
! depth_layer
    SELECT CASE  (stxt) 
    CASE (1) 
      p_bw%ksat(0:4) = 0.0_8
      p_bw%b(0:4) = 0.0_8
    CASE (2) 
      p_bw%ksat(0:4) = 0.0_8
      p_bw%b(0:4) = 0.0_8
    CASE (3) 
      p_bw%ksat(0:4) = 0.0_8
      p_bw%b(0:4) = 0.0_8
    CASE (4) 
      p_bw%ksat(0:4) = 0.0_8
      p_bw%b(0:4) = 0.0_8
    CASE (5) 
      p_bw%ksat(0:4) = 0.0_8
      p_bw%b(0:4) = 0.0_8
    CASE (6) 
      p_bw%ksat(0:4) = 0.0_8
      p_bw%b(0:4) = 0.0_8
    CASE (7) 
      p_bw%ksat(0:4) = 0.0_8
      p_bw%b(0:4) = 0.0_8
    CASE (8) 
      p_bw%ksat(0:4) = 0.0_8
      p_bw%b(0:4) = 0.0_8
    CASE (9) 
      p_bw%ksat(0:4) = 0.0_8
      p_bw%b(0:4) = 0.0_8
    CASE (10) 
      p_bw%ksat(0:4) = 0.0_8
      p_bw%b(0:4) = 0.0_8
    CASE (11) 
      p_bw%ksat(0:4) = 0.0_8
      p_bw%b(0:4) = 0.0_8
    CASE DEFAULT
      p_bw%ksat(0:4) = 0.0_8
      p_bw%b(0:4) = 0.0_8
    END SELECT
  END SUBROUTINE INIT_SOIL_PARAMETERS_BW

! Initialization process
  SUBROUTINE INIT_SOIL_PARAMETERS(lc, stxt, r_root_decay, p)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: lc
    INTEGER, INTENT(IN) :: stxt
    REAL(r8), INTENT(IN) :: r_root_decay
    TYPE(SOIL) :: p
    p%n_layer = 5
    IF (lc .EQ. 3 .OR. lc .EQ. 4) THEN
! for fw
      p%psi_min = 10.0
      p%alpha = 1.5
    ELSE
      p%psi_min = 33.0
      p%alpha = 0.4
    END IF
! depth_layer
    p%d_soil(0:4) = (/0.05, 0.10, 0.20, 0.40, 1.25/)
    p%r_root_decay = r_root_decay
    CALL INIT_SOIL_ROOTFRACTION(p)
    p%density_soil(0:4) = (/1300.0, 1500.0, 1517.0, 1517.0, 1517.0/)
    p%f_org(0:4) = (/5., 2., 1., 1., 0.3/)
    SELECT CASE  (stxt) 
    CASE (1) 
! sand
      p%b(0:4) = (/1.7, 1.9, 2.1, 2.3, 2.5/)
! saturated hydraulic conductivity
      p%ksat(0:4) = (/58., 52., 46., 35., 10./)*1e-6
      p%fei(0:4) = 0.437
!field capacity
      p%theta_vfc(0:4) = 0.09
!wilting point
      p%theta_vwp(0:4) = 0.03
! thermal conductivity
      p%thermal_cond(0:4) = 8.6
      p%psi_sat(0:4) = (/0.07, 0.08, 0.09, 0.10, 0.12/)
    CASE (2) 
!loamy sand
      p%b(0:4) = (/2.1, 2.3, 2.5, 2.7, 2.9/)
      p%ksat(0:4) = (/17., 15., 14., 10., 3./)*1e-6
      p%fei(0:4) = 0.437
      p%theta_vfc(0:4) = 0.21
      p%theta_vwp(0:4) = 0.06
      p%thermal_cond(0:4) = 8.3
      p%psi_sat(0:4) = (/0.09, 0.10, 0.11, 0.12, 0.14/)
    CASE (3) 
! sandy loam
      p%b(0:4) = (/3.1, 3.3, 3.5, 3.7, 3.9/)
      p%ksat(0:4) = (/720., 648., 576., 432., 144./)*1e-8
      p%fei(0:4) = 0.453
      p%theta_vfc(0:4) = 0.21
      p%theta_vwp(0:4) = 0.10
      p%thermal_cond(0:4) = 8.0
      p%psi_sat(0:4) = (/0.15, 0.16, 0.17, 0.18, 0.20/)
    CASE (4) 
!loam
      p%b(0:4) = (/4.5, 4.7, 4.9, 5.1, 5.3/)
      p%ksat(0:4) = (/370., 330., 296., 222., 74./)*1e-8
      p%fei(0:4) = 0.463
      p%theta_vfc(0:4) = 0.27
      p%theta_vwp(0:4) = 0.12
      p%thermal_cond(0:4) = 7.0
      p%psi_sat(0:4) = (/0.11, 0.12, 0.13, 0.14, 0.16/)
    CASE (5) 
!silty loam
      p%b(0:4) = (/4.7, 4.9, 5.1, 5.3, 5.5/)
      p%ksat(0:4) = (/190., 170., 152., 114., 38./)*1e-8
      p%fei(0:4) = 0.501
      p%theta_vfc(0:4) = 0.33
      p%theta_vwp(0:4) = 0.13
      p%thermal_cond(0:4) = 6.3
      p%psi_sat(0:4) = (/0.21, 0.22, 0.23, 0.24, 0.26/)
    CASE (6) 
! sandy caly loam
      p%b(0:4) = (/4.0, 4.2, 4.4, 4.6, 4.8/)
      p%ksat(0:4) = (/12., 10.8, 96., 72., 24./)*1e-7
      p%fei(0:4) = 0.398
      p%theta_vfc(0:4) = 0.26
      p%theta_vwp(0:4) = 0.15
      p%thermal_cond(0:4) = 7.0
      p%psi_sat(0:4) = (/0.28, 0.29, 0.30, 0.31, 0.33/)
    CASE (7) 
!clay loam
      p%b(0:4) = (/5.2, 5.4, 5.6, 5.8, 6.0/)
      p%ksat(0:4) = (/64., 58., 51., 38., 13./)*1e-8
      p%fei(0:4) = 0.464
      p%theta_vfc(0:4) = 0.32
      p%theta_vwp(0:4) = 0.20
      p%thermal_cond(0:4) = (/5.8, 5.8, 5.7, 5.8, 5.8/)
      p%psi_sat(0:4) = (/0.26, 0.27, 0.28, 0.29, 0.31/)
    CASE (8) 
!silty clay loam
      p%b(0:4) = (/6.6, 6.8, 7.0, 7.2, 7.4/)
      p%ksat(0:4) = (/42., 38., 34., 25.2, 8.4/)*1e-8
      p%fei(0:4) = 0.471
      p%theta_vfc(0:4) = 0.37
      p%theta_vwp(0:4) = 0.32
      p%thermal_cond(0:4) = 4.2
      p%psi_sat(0:4) = (/0.33, 0.34, 0.35, 0.36, 0.38/)
    CASE (9) 
! sandy clay
      p%b(0:4) = (/6., 6.2, 6.4, 6.6, 6.8/)
      p%ksat(0:4) = (/33., 30., 26.4, 19.8, 6.6/)*1e-8
      p%fei(0:4) = 0.43
      p%theta_vfc(0:4) = 0.34
      p%theta_vwp(0:4) = 0.24
      p%thermal_cond(0:4) = 6.3
      p%psi_sat(0:4) = (/0.29, 0.30, 0.31, 0.32, 0.34/)
    CASE (10) 
!silty clay
      p%b(0:4) = (/7.9, 8.1, 8.3, 8.5, 8.7/)
      p%ksat(0:4) = (/25., 22.5, 20., 15., 5./)*1e-8
      p%fei(0:4) = 0.479
      p%theta_vfc(0:4) = 0.39
      p%theta_vwp(0:4) = 0.25
      p%thermal_cond(0:4) = 4.0
      p%psi_sat(0:4) = (/0.34, 0.35, 0.36, 0.37, 0.39/)
    CASE (11) 
! clay
      p%b(0:4) = (/7.6, 7.8, 8.0, 8.2, 8.4/)
      p%ksat(0:4) = (/17., 15.3, 13.6, 10.2, 3.4/)*1e-8
      p%fei(0:4) = 0.475
      p%theta_vfc(0:4) = 0.40
      p%theta_vwp(0:4) = 0.27
      p%thermal_cond(0:4) = 4.4
      p%psi_sat(0:4) = (/0.37, 0.38, 0.39, 0.40, 0.42/)
    CASE DEFAULT
      p%b(0:4) = (/7.6, 7.8, 8.0, 8.2, 8.4/)
      p%ksat(0:4) = (/17., 15.3, 13.6, 10.2, 3.4/)*1e-8
      p%fei(0:4) = 0.475
      p%theta_vfc(0:4) = 0.40
      p%theta_vwp(0:4) = 0.27
      p%psi_sat(0:4) = (/0.37, 0.38, 0.39, 0.40, 0.42/)
    END SELECT
    RETURN
  END SUBROUTINE INIT_SOIL_PARAMETERS

!  Differentiation of init_soil_status in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: p.ice_ratio p.thetam p.thetam_prev
!                p.temp_soil_p p.temp_soil_c
!   with respect to varying inputs: p.ice_ratio p.thetam p.thetam_prev
!                p.temp_soil_p p.temp_soil_c
  SUBROUTINE INIT_SOIL_STATUS_BW(p, p_bw, tsoil, tair, ms, snowdepth)
    IMPLICIT NONE
! soil temperatures and moisutre for each layer
! ponded water,snow depth
    TYPE(SOIL) :: p
    TYPE(SOIL_DIFF) :: p_bw
    REAL(r8), INTENT(IN) :: tsoil
    REAL(r8), INTENT(IN) :: tair
! soil moisture
    REAL(r8), INTENT(IN) :: ms
    REAL(r8), INTENT(IN) :: snowdepth
    REAL(r8) :: d_t
    INTEGER*4 :: branch
    d_t = tsoil - tair
! depth of ponded water on the surface
    IF (d_t .GT. 5.0) d_t = 5.0
    IF (d_t .LT. -5.0) d_t = -5.0
    p%temp_soil_c(0) = tair + 0.4*d_t
    p%temp_soil_c(1) = tair + 0.5*d_t
    p%temp_soil_c(2) = tair + d_t
    p%temp_soil_c(3) = tair + 1.2*d_t
    p%temp_soil_c(4) = tair + 1.4*d_t
    p%temp_soil_c(5) = tair + 1.4*d_t
!-1
    DO i=0,p%n_layer
      IF (p%temp_soil_c(i) .LT. -1.0) THEN
        CALL PUSHCONTROL2B(2)
      ELSE IF (p%temp_soil_c(i) .GT. 0) THEN
        CALL PUSHCONTROL2B(1)
      ELSE
        CALL PUSHCONTROL2B(0)
      END IF
    END DO
    DO i=p%n_layer,0,-1
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        p_bw%temp_soil_c(i) = p_bw%temp_soil_c(i) - p_bw%ice_ratio(i)
        p_bw%ice_ratio(i) = 0.0_8
      ELSE IF (branch .EQ. 1) THEN
        p_bw%ice_ratio(i) = 0.0_8
      ELSE
        p_bw%ice_ratio(i) = 0.0_8
      END IF
    END DO
    p_bw%thetam(0:5) = p_bw%thetam(0:5) + p_bw%thetam_prev(0:5)
    p_bw%thetam_prev(0:5) = 0.0_8
    p_bw%thetam(5) = 0.0_8
    p_bw%thetam(4) = 0.0_8
    p_bw%thetam(3) = 0.0_8
    p_bw%thetam(2) = 0.0_8
    p_bw%thetam(1) = 0.0_8
    p_bw%thetam(0) = 0.0_8
    p_bw%temp_soil_c(0:5) = p_bw%temp_soil_c(0:5) + p_bw%temp_soil_p(0:5&
&     )
    p_bw%temp_soil_p(0:5) = 0.0_8
    p_bw%temp_soil_c(5) = 0.0_8
    p_bw%temp_soil_c(4) = 0.0_8
    p_bw%temp_soil_c(3) = 0.0_8
    p_bw%temp_soil_c(2) = 0.0_8
    p_bw%temp_soil_c(1) = 0.0_8
    p_bw%temp_soil_c(0) = 0.0_8
  END SUBROUTINE INIT_SOIL_STATUS_BW

  SUBROUTINE INIT_SOIL_STATUS(p, tsoil, tair, ms, snowdepth)
    IMPLICIT NONE
! soil temperatures and moisutre for each layer
! ponded water,snow depth
    TYPE(SOIL) :: p
    REAL(r8), INTENT(IN) :: tsoil
    REAL(r8), INTENT(IN) :: tair
! soil moisture
    REAL(r8), INTENT(IN) :: ms
    REAL(r8), INTENT(IN) :: snowdepth
    REAL(r8) :: d_t
    d_t = tsoil - tair
! depth of ponded water on the surface
    p%zp = 0.0
    p%zsp = snowdepth
    p%r_rain_g = 0.0
    IF (d_t .GT. 5.0) d_t = 5.0
    IF (d_t .LT. -5.0) d_t = -5.0
    p%temp_soil_c(0) = tair + 0.4*d_t
    p%temp_soil_c(1) = tair + 0.5*d_t
    p%temp_soil_c(2) = tair + d_t
    p%temp_soil_c(3) = tair + 1.2*d_t
    p%temp_soil_c(4) = tair + 1.4*d_t
    p%temp_soil_c(5) = tair + 1.4*d_t
    p%temp_soil_p(0:5) = p%temp_soil_c(0:5)
    p%thetam(0) = 0.8*ms
    p%thetam(1) = ms
    p%thetam(2) = 1.05*ms
    p%thetam(3) = 1.10*ms
    p%thetam(4) = 1.15*ms
    p%thetam(5) = 1.25*ms
    p%thetam_prev(0:5) = p%thetam(0:5)
!-1
    DO i=0,p%n_layer
      IF (p%temp_soil_c(i) .LT. -1.0) THEN
        p%ice_ratio(i) = 1.0
      ELSE IF (p%temp_soil_c(i) .GT. 0) THEN
        p%ice_ratio(i) = 0.
      ELSE
        p%ice_ratio(i) = (0-p%temp_soil_c(i))/1.0
      END IF
    END DO
    RETURN
  END SUBROUTINE INIT_SOIL_STATUS

  SUBROUTINE INIT_SOIL_ROOTFRACTION(p)
    IMPLICIT NONE
    TYPE(SOIL) :: p
    REAL(r8) :: cum_depth(0:max_layers-1)
    cum_depth(0) = p%d_soil(0)
    p%f_root(0) = 1 - p%r_root_decay**(cum_depth(0)*100)
    DO i=1,p%n_layer-2
      cum_depth(i) = cum_depth(i-1) + p%d_soil(i)
      p%f_root(i) = p%r_root_decay**(cum_depth(i-1)*100) - p%&
&       r_root_decay**(cum_depth(i)*100)
    END DO
    p%f_root(p%n_layer-1) = p%r_root_decay**(cum_depth(p%n_layer-2)*100)
    RETURN
  END SUBROUTINE INIT_SOIL_ROOTFRACTION

!  Differentiation of surfacetemperature in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: temp_snow1 temp_snow2 heat_flux_soil1
!                density_snow evapo_soil temp_snow1_last temp_any0_last
!                heat_flux lambda_soil1 temp_soil1_last evapo_snow_g
!                capacity_heat_soil0 capacity_heat_soil1 percent_snow_g
!                temp_snow temp_any0 temp_ground evapo_water_g
!                temp_snow_last templ_u temp_ground_last depth_snow
!                netrad_g temp_snow2_last temp_soil0 temp_soil0_last
!   with respect to varying inputs: temp_snow1 temp_snow2 gheat_g
!                heat_flux_soil1 density_snow evapo_soil temp_snow1_last
!                temp_any0_last heat_flux lambda_soil1 temp_soil1_last
!                evapo_snow_g capacity_heat_soil0 capacity_heat_soil1
!                percent_snow_g temp_snow temp_any0 temp_ground
!                evapo_water_g temp_snow_last templ_u temp_ground_last
!                depth_snow netrad_g temp_snow2_last temp_soil0
!                temp_soil0_last
!****************************************************
!  soil thermal regime
! update the soil temperatures for each soil layer
!****************************************************
  SUBROUTINE SURFACETEMPERATURE_BW(temp_air, rh_air, depth_snow, &
&   depth_snow_bw, depth_water, capacity_heat_soil1, &
&   capacity_heat_soil1_bw, capacity_heat_soil0, capacity_heat_soil0_bw&
&   , gheat_g, gheat_g_bw, depth_soil1, density_snow, density_snow_bw, &
&   templ_u, templ_u_bw, netrad_g, netrad_g_bw, evapo_soil, &
&   evapo_soil_bw, evapo_water_g, evapo_water_g_bw, evapo_snow_g, &
&   evapo_snow_g_bw, lambda_soil1, lambda_soil1_bw, percent_snow_g, &
&   percent_snow_g_bw, heat_flux_soil1, heat_flux_soil1_bw, &
&   temp_ground_last, temp_ground_last_bw, temp_soil1_last, &
&   temp_soil1_last_bw, temp_any0_last, temp_any0_last_bw, &
&   temp_snow_last, temp_snow_last_bw, temp_soil0_last, &
&   temp_soil0_last_bw, temp_snow1_last, temp_snow1_last_bw, &
&   temp_snow2_last, temp_snow2_last_bw, temp_ground, temp_ground_bw, &
&   temp_any0, temp_any0_bw, temp_snow, temp_snow_bw, temp_soil0, &
&   temp_soil0_bw, temp_snow1, temp_snow1_bw, temp_snow2, temp_snow2_bw&
&   , heat_flux, heat_flux_bw)
    IMPLICIT NONE
    REAL(r8), INTENT(IN) :: temp_air, rh_air, depth_snow, depth_water, &
&   capacity_heat_soil1, capacity_heat_soil0
    REAL(r8) :: depth_snow_bw, capacity_heat_soil1_bw, &
&   capacity_heat_soil0_bw
! aerodynamic conductance of heat at ground Gheat = 1/ra_g
    REAL(r8), INTENT(IN) :: gheat_g
    REAL(r8) :: gheat_g_bw
    REAL(r8), INTENT(IN) :: depth_soil1, density_snow, templ_u, netrad_g
    REAL(r8) :: density_snow_bw, templ_u_bw, netrad_g_bw
    REAL(r8), INTENT(IN) :: evapo_soil, evapo_water_g, evapo_snow_g
    REAL(r8) :: evapo_soil_bw, evapo_water_g_bw, evapo_snow_g_bw
! thermal conductivity of first layer soil
    REAL(r8), INTENT(IN) :: lambda_soil1
    REAL(r8) :: lambda_soil1_bw
    REAL(r8), INTENT(IN) :: percent_snow_g, heat_flux_soil1
    REAL(r8) :: percent_snow_g_bw, heat_flux_soil1_bw
    REAL(r8), INTENT(IN) :: temp_ground_last, temp_soil1_last, &
&   temp_any0_last, temp_snow_last, temp_soil0_last, temp_snow1_last, &
&   temp_snow2_last
    REAL(r8) :: temp_ground_last_bw, temp_soil1_last_bw, &
&   temp_any0_last_bw, temp_snow_last_bw, temp_soil0_last_bw, &
&   temp_snow1_last_bw, temp_snow2_last_bw
! ground => ground surface; soil0=>temperature of soil surface right above the soil in last step,the part is not covered by snow;
! soil1=>temperature of first layer soil in last step
! ground surface tem in current
    REAL(r8) :: temp_ground
    REAL(r8) :: temp_ground_bw
! temperature of any layer right abover the soil,could be a mixture of snow temperature and soil surface temperature
    REAL(r8) :: temp_any0
    REAL(r8) :: temp_any0_bw
    REAL(r8) :: temp_snow
    REAL(r8) :: temp_snow_bw
! temperature of soil surface right above the soil, the part not covered by snow
    REAL(r8) :: temp_soil0
    REAL(r8) :: temp_soil0_bw
! temperature of snow layer 2 and 3, used when depth_snow > 0.05m
    REAL(r8) :: temp_snow1, temp_snow2
    REAL(r8) :: temp_snow1_bw, temp_snow2_bw
! heat_flux from ground to soil
    REAL(r8) :: heat_flux
    REAL(r8) :: heat_flux_bw
! radiation available for heating the ground
    REAL(r8) :: gg
    REAL(r8) :: gg_bw
! thermal conductivity
    REAL(r8) :: lambda_snow
    REAL(r8) :: lambda_snow_bw
! heat flux through the soil and snow fraction on ground, separatively
    REAL(r8) :: heat_flux_soil, heat_flux_snow
    REAL(r8) :: heat_flux_soil_bw, heat_flux_snow_bw
    REAL(r8) :: heat_flux_snow1, heat_flux_snow2
    REAL(r8) :: heat_flux_snow1_bw, heat_flux_snow2_bw
! aerodynamic resistence of heat
    REAL(r8) :: ra_g
    REAL(r8) :: ra_g_bw
! temporary vars
    REAL(r8) :: ttt
    REAL(r8) :: ttt_bw
    INTRINSIC MAX
    INTRINSIC MIN
    REAL(r8) :: temp
    REAL(r8) :: temp_bw
    REAL(r8) :: temp0
    REAL(r8) :: temp_bw0
    REAL(r8) :: temp1
    REAL(r8) :: temp_bw1
    REAL(r8) :: temp2
    REAL(r8) :: temp_bw2
    INTEGER*4 :: branch
    CALL METEO_PACK(temp_air, rh_air)
    ra_g = 1./gheat_g
    lambda_snow = 0.021 + 4.2*density_snow/10000. + 2.2*density_snow**3*&
&     1e-9
! available energy on ground
    gg = netrad_g - evapo_snow_g*latent_snow - (evapo_water_g+evapo_soil&
&     )*latent_water
!!case 1 snow depth < 2cm, snow temperature ,ground temperature, soil surface temperature are the same
    IF (depth_snow .LE. 0.02) THEN
      ttt = capacity_heat_soil1*0.02/kstep
      CALL PUSHREAL8ARRAY(temp_ground, r8/8)
      temp_ground = temp_ground_last*ttt*ra_g*depth_soil1 + gg*ra_g*&
&       depth_soil1 + density_air*cp_air*temp_air*depth_soil1 + ra_g*&
&       lambda_soil1*temp_soil1_last
      CALL PUSHREAL8ARRAY(temp_ground, r8/8)
      temp_ground = temp_ground/(density_air*cp_air*depth_soil1+ra_g*&
&       lambda_soil1+ttt*ra_g*depth_soil1)
      IF (temp_ground_last - 25 .LT. temp_ground) THEN
        CALL PUSHCONTROL1B(0)
        temp_ground = temp_ground
      ELSE
        temp_ground = temp_ground_last - 25
        CALL PUSHCONTROL1B(1)
      END IF
      IF (temp_ground_last + 25 .GT. temp_ground) THEN
        CALL PUSHCONTROL1B(0)
        temp_ground = temp_ground
      ELSE
        temp_ground = temp_ground_last + 25
        CALL PUSHCONTROL1B(1)
      END IF
      CALL PUSHREAL8ARRAY(temp_any0, r8/8)
      temp_any0 = temp_ground
      heat_flux = 2*lambda_soil1*(temp_any0-temp_soil1_last)/depth_soil1
      IF (100. .GT. heat_flux) THEN
        CALL PUSHCONTROL1B(0)
        heat_flux = heat_flux
      ELSE
        heat_flux = 100.
        CALL PUSHCONTROL1B(1)
      END IF
      IF (-100. .GE. heat_flux) heat_flux_bw = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) heat_flux_bw = 0.0_8
      temp_bw = lambda_soil1*2*heat_flux_bw/depth_soil1
      lambda_soil1_bw = lambda_soil1_bw + (temp_any0-temp_soil1_last)*2*&
&       heat_flux_bw/depth_soil1
      temp_any0_bw = temp_any0_bw + temp_bw + temp_snow2_bw + &
&       temp_snow1_bw + temp_soil0_bw + temp_snow_bw
      temp_soil1_last_bw = temp_soil1_last_bw - temp_bw
      CALL POPREAL8ARRAY(temp_any0, r8/8)
      temp_ground_bw = temp_ground_bw + temp_any0_bw
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        temp_ground_last_bw = temp_ground_last_bw + temp_ground_bw
        temp_ground_bw = 0.0_8
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        temp_ground_last_bw = temp_ground_last_bw + temp_ground_bw
        temp_ground_bw = 0.0_8
      END IF
      CALL POPREAL8ARRAY(temp_ground, r8/8)
      temp = density_air*cp_air*depth_soil1 + ra_g*lambda_soil1 + &
&       depth_soil1*ttt*ra_g
      temp_bw = -(temp_ground*temp_ground_bw/temp**2)
      temp_ground_bw = temp_ground_bw/temp
      ra_g_bw = (lambda_soil1+ttt*depth_soil1)*temp_bw
      lambda_soil1_bw = lambda_soil1_bw + ra_g*temp_bw + ra_g*&
&       temp_soil1_last*temp_ground_bw
      ttt_bw = ra_g*depth_soil1*temp_bw
      CALL POPREAL8ARRAY(temp_ground, r8/8)
      temp_bw = depth_soil1*temp_ground_bw
      gg_bw = ra_g*depth_soil1*temp_ground_bw
      ra_g_bw = ra_g_bw + (gg*depth_soil1+lambda_soil1*temp_soil1_last)*&
&       temp_ground_bw + temp_ground_last*ttt*temp_bw
      temp_soil1_last_bw = temp_soil1_last_bw + ra_g*lambda_soil1*&
&       temp_ground_bw
      temp_ground_last_bw = temp_ground_last_bw + ttt*ra_g*temp_bw
      ttt_bw = ttt_bw + temp_ground_last*ra_g*temp_bw
      capacity_heat_soil1_bw = capacity_heat_soil1_bw + 0.02*ttt_bw/&
&       kstep
      temp_snow1_bw = 0.0_8
      temp_snow2_bw = 0.0_8
      heat_flux_bw = 0.0_8
      temp_snow_bw = 0.0_8
      temp_any0_bw = 0.0_8
      temp_ground_bw = 0.0_8
      temp_soil0_bw = 0.0_8
      lambda_snow_bw = 0.0_8
    ELSE IF (depth_snow .GT. 0.02 .AND. depth_snow .LE. 0.05) THEN
!! snow fraction on ground decide the snow temperature based on energy balance
!! soil fraction on ground decide the soil surface temperature based on energy balance
!! snow and soil fraction works in parallel to determine the ground surface temperature
! for soil
      ttt = capacity_heat_soil1*0.02/kstep
      CALL PUSHREAL8ARRAY(temp_soil0, r8/8)
      temp_soil0 = (temp_soil0_last*ttt*ra_g*depth_soil1+gg*ra_g*&
&       depth_soil1+density_air*cp_air*temp_air*depth_soil1+2*ra_g*&
&       lambda_soil1*temp_soil1_last)/(density_air*cp_air*depth_soil1+2*&
&       ra_g*lambda_soil1+ttt*ra_g*depth_soil1)
      IF (temp_air - 25 .LT. temp_soil0) THEN
        CALL PUSHCONTROL1B(0)
        temp_soil0 = temp_soil0
      ELSE
        temp_soil0 = temp_air - 25
        CALL PUSHCONTROL1B(1)
      END IF
      IF (temp_air + 25 .GT. temp_soil0) THEN
        CALL PUSHCONTROL1B(0)
        temp_soil0 = temp_soil0
      ELSE
        temp_soil0 = temp_air + 25
        CALL PUSHCONTROL1B(1)
      END IF
      ttt = cp_ice*density_snow*depth_snow/kstep
      CALL PUSHREAL8ARRAY(temp_snow, r8/8)
      temp_snow = (temp_snow_last*ttt*ra_g*depth_snow+gg*ra_g*depth_snow&
&       +density_air*cp_air*templ_u*depth_snow+ra_g*lambda_snow*&
&       temp_any0_last)/(density_air*cp_air*depth_snow+ra_g*lambda_snow+&
&       ttt*ra_g*depth_snow)
      IF (temp_air - 25 .LT. temp_snow) THEN
        CALL PUSHCONTROL1B(0)
        temp_snow = temp_snow
      ELSE
        temp_snow = temp_air - 25
        CALL PUSHCONTROL1B(1)
      END IF
      IF (temp_air + 25 .GT. temp_snow) THEN
        CALL PUSHCONTROL1B(0)
        temp_snow = temp_snow
      ELSE
        temp_snow = temp_air + 25
        CALL PUSHCONTROL1B(1)
      END IF
      ttt = (lambda_soil1*temp_soil1_last/depth_soil1+temp_snow*&
&       lambda_snow+0.02*capacity_heat_soil1/kstep*temp_any0_last)/(&
&       lambda_soil1/depth_soil1+lambda_snow/depth_snow+0.02*&
&       capacity_heat_soil1/kstep)
      CALL PUSHREAL8ARRAY(temp_any0, r8/8)
      temp_any0 = temp_soil0*(1-percent_snow_g) + ttt*percent_snow_g
      heat_flux_snow = lambda_snow/(depth_snow+0.5*depth_soil1)*(&
&       temp_snow-temp_soil1_last)
      heat_flux_soil = heat_flux_snow*(temp_any0-temp_soil1_last)/&
&       depth_soil1
!!!!Wrong???
      heat_flux = heat_flux_snow*percent_snow_g + heat_flux_soil*(1-&
&       percent_snow_g)
      IF (100. .GT. heat_flux) THEN
        CALL PUSHCONTROL1B(0)
        heat_flux = heat_flux
      ELSE
        heat_flux = 100.
        CALL PUSHCONTROL1B(1)
      END IF
      IF (-100. .LT. heat_flux) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
! starting to melt
      IF (temp_snow .GT. zero .AND. temp_snow_last .LE. zero .AND. &
&         depth_snow .GT. zero) THEN
        CALL PUSHREAL8ARRAY(temp_snow, r8/8)
        temp_snow = 0
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
! frozen
      IF (temp_snow .LT. zero .AND. temp_snow_last .GE. zero .AND. &
&         depth_water .GT. zero) THEN
        CALL PUSHREAL8ARRAY(temp_snow, r8/8)
        temp_snow = 0
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      CALL PUSHREAL8ARRAY(temp_ground, r8/8)
      temp_ground = temp_snow*percent_snow_g + temp_soil0*(1-&
&       percent_snow_g)
      IF (temp_air - 25 .LT. temp_ground) THEN
        CALL PUSHCONTROL1B(0)
        temp_ground = temp_ground
      ELSE
        temp_ground = temp_air - 25
        CALL PUSHCONTROL1B(1)
      END IF
      IF (temp_air + 25 .GT. temp_ground) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      temp_snow_bw = temp_snow_bw + temp_snow2_bw + temp_snow1_bw
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) temp_ground_bw = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) temp_ground_bw = 0.0_8
      CALL POPREAL8ARRAY(temp_ground, r8/8)
      temp_snow_bw = temp_snow_bw + percent_snow_g*temp_ground_bw
      percent_snow_g_bw = percent_snow_g_bw + (temp_snow-temp_soil0)*&
&       temp_ground_bw
      temp_soil0_bw = temp_soil0_bw + (1-percent_snow_g)*temp_ground_bw
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        CALL POPREAL8ARRAY(temp_snow, r8/8)
        temp_snow_bw = 0.0_8
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8ARRAY(temp_snow, r8/8)
        temp_snow_bw = 0.0_8
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) heat_flux_bw = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) heat_flux_bw = 0.0_8
      heat_flux_soil_bw = (1-percent_snow_g)*heat_flux_bw
      temp_bw2 = heat_flux_snow*heat_flux_soil_bw/depth_soil1
      temp_any0_bw = temp_any0_bw + temp_bw2
      ttt_bw = percent_snow_g*temp_any0_bw
      temp2 = lambda_soil1/depth_soil1 + lambda_snow/depth_snow + 0.02*&
&       capacity_heat_soil1/kstep
      temp_bw1 = ttt_bw/temp2
      heat_flux_snow_bw = percent_snow_g*heat_flux_bw + (temp_any0-&
&       temp_soil1_last)*heat_flux_soil_bw/depth_soil1
      percent_snow_g_bw = percent_snow_g_bw + (heat_flux_snow-&
&       heat_flux_soil)*heat_flux_bw + (ttt-temp_soil0)*temp_any0_bw
      temp_soil1_last_bw = temp_soil1_last_bw - temp_bw2
      temp_bw2 = heat_flux_snow_bw/(depth_soil1*0.5+depth_snow)
      lambda_snow_bw = (temp_snow-temp_soil1_last)*temp_bw2
      temp_snow_bw = temp_snow_bw + lambda_snow*temp_bw2 + lambda_snow*&
&       temp_bw1
      temp_soil1_last_bw = temp_soil1_last_bw + lambda_soil1*temp_bw1/&
&       depth_soil1 - lambda_snow*temp_bw2
      depth_snow_bw = depth_snow_bw - lambda_snow*(temp_snow-&
&       temp_soil1_last)*temp_bw2/(depth_soil1*0.5+depth_snow)
      CALL POPREAL8ARRAY(temp_any0, r8/8)
      temp_soil0_bw = temp_soil0_bw + (1-percent_snow_g)*temp_any0_bw
      temp_bw0 = 0.02*temp_bw1/kstep
      temp_bw2 = -((lambda_soil1*temp_soil1_last/depth_soil1+temp_snow*&
&       lambda_snow+0.02*(capacity_heat_soil1*temp_any0_last/kstep))*&
&       temp_bw1/temp2)
      lambda_soil1_bw = lambda_soil1_bw + temp_soil1_last*temp_bw1/&
&       depth_soil1 + temp_bw2/depth_soil1
      lambda_snow_bw = lambda_snow_bw + temp_snow*temp_bw1 + temp_bw2/&
&       depth_snow
      depth_snow_bw = depth_snow_bw - lambda_snow*temp_bw2/depth_snow**2
      capacity_heat_soil1_bw = capacity_heat_soil1_bw + 0.02*temp_bw2/&
&       kstep + temp_any0_last*temp_bw0
      temp_any0_last_bw = temp_any0_last_bw + capacity_heat_soil1*&
&       temp_bw0
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) temp_snow_bw = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) temp_snow_bw = 0.0_8
      ttt = cp_ice*density_snow*depth_snow/kstep
      CALL POPREAL8ARRAY(temp_snow, r8/8)
      temp2 = density_air*cp_air*depth_snow + ra_g*lambda_snow + ttt*&
&       ra_g*depth_snow
      temp0 = ra_g*depth_snow
      temp_bw1 = temp_snow_bw/temp2
      temp_snow_last_bw = temp_snow_last_bw + ttt*temp0*temp_bw1
      temp_bw0 = temp_snow_last*ttt*temp_bw1
      gg_bw = ra_g*depth_snow*temp_bw1
      temp_bw = density_air*cp_air*temp_bw1
      temp_any0_last_bw = temp_any0_last_bw + ra_g*lambda_snow*temp_bw1
      temp_bw2 = -((temp_snow_last*ttt*temp0+gg*ra_g*depth_snow+&
&       density_air*cp_air*(templ_u*depth_snow)+ra_g*lambda_snow*&
&       temp_any0_last)*temp_bw1/temp2)
      ttt_bw = temp_snow_last*temp0*temp_bw1 + ra_g*depth_snow*temp_bw2
      ra_g_bw = (gg*depth_snow+lambda_snow*temp_any0_last)*temp_bw1 + (&
&       lambda_snow+ttt*depth_snow)*temp_bw2 + depth_snow*temp_bw0
      depth_snow_bw = depth_snow_bw + gg*ra_g*temp_bw1 + (density_air*&
&       cp_air+ttt*ra_g)*temp_bw2
      lambda_snow_bw = lambda_snow_bw + ra_g*temp_any0_last*temp_bw1 + &
&       ra_g*temp_bw2
      templ_u_bw = templ_u_bw + depth_snow*temp_bw
      temp_bw2 = cp_ice*ttt_bw/kstep
      depth_snow_bw = depth_snow_bw + templ_u*temp_bw + ra_g*temp_bw0 + &
&       density_snow*temp_bw2
      density_snow_bw = density_snow_bw + depth_snow*temp_bw2
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) temp_soil0_bw = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) temp_soil0_bw = 0.0_8
      ttt = capacity_heat_soil1*0.02/kstep
      CALL POPREAL8ARRAY(temp_soil0, r8/8)
      temp = density_air*cp_air*depth_soil1 + 2*ra_g*lambda_soil1 + &
&       depth_soil1*ttt*ra_g
      temp2 = 2*ra_g*lambda_soil1
      temp_bw0 = temp_soil0_bw/temp
      temp_bw1 = depth_soil1*temp_bw0
      gg_bw = gg_bw + ra_g*depth_soil1*temp_bw0
      temp_soil1_last_bw = temp_soil1_last_bw + temp2*temp_bw0
      temp_bw = -((density_air*cp_air*(temp_air*depth_soil1)+depth_soil1&
&       *(temp_soil0_last*ttt*ra_g)+depth_soil1*(gg*ra_g)+temp2*&
&       temp_soil1_last)*temp_bw0/temp)
      ra_g_bw = ra_g_bw + (gg*depth_soil1+2*lambda_soil1*temp_soil1_last&
&       )*temp_bw0 + (2*lambda_soil1+ttt*depth_soil1)*temp_bw + &
&       temp_soil0_last*ttt*temp_bw1
      lambda_soil1_bw = lambda_soil1_bw + 2*ra_g*temp_soil1_last*&
&       temp_bw0 + 2*ra_g*temp_bw
      ttt_bw = ra_g*depth_soil1*temp_bw + temp_soil0_last*ra_g*temp_bw1
      temp_soil0_last_bw = temp_soil0_last_bw + ttt*ra_g*temp_bw1
      capacity_heat_soil1_bw = capacity_heat_soil1_bw + 0.02*ttt_bw/&
&       kstep
      temp_snow1_bw = 0.0_8
      temp_snow2_bw = 0.0_8
      heat_flux_bw = 0.0_8
      temp_snow_bw = 0.0_8
      temp_any0_bw = 0.0_8
      temp_ground_bw = 0.0_8
      temp_soil0_bw = 0.0_8
    ELSE IF (depth_snow .GT. 0.05) THEN
!! case 3
!! snow_cover on ground is 100%
!! teh first layer of snow is set as 2cm
!! second layer as 2cm, too
!! the depth of third snow layer is depth_snow-0.04
      ttt = cp_ice*density_snow*0.02/kstep
      CALL PUSHREAL8ARRAY(temp_snow, r8/8)
      temp_snow = (temp_snow_last*ttt*ra_g*0.04+gg*ra_g*0.02+density_air&
&       *cp_air*temp_air*0.04+ra_g*lambda_snow*temp_snow1_last)/(&
&       density_air*cp_air*0.04+ra_g*lambda_snow+ttt*ra_g*0.04)
      IF (temp_air - 25 .LT. temp_snow) THEN
        CALL PUSHCONTROL1B(0)
        temp_snow = temp_snow
      ELSE
        temp_snow = temp_air - 25
        CALL PUSHCONTROL1B(1)
      END IF
      IF (temp_air + 25 .GT. temp_snow) THEN
        CALL PUSHCONTROL1B(0)
        temp_snow = temp_snow
      ELSE
        temp_snow = temp_air + 25
        CALL PUSHCONTROL1B(1)
      END IF
!why 0.04 here?
      heat_flux_snow = lambda_snow*(temp_snow-temp_snow1_last)/0.04
      heat_flux = heat_flux_snow
      IF (100. .GT. heat_flux) THEN
        CALL PUSHCONTROL1B(0)
        heat_flux = heat_flux
      ELSE
        heat_flux = 100.
        CALL PUSHCONTROL1B(1)
      END IF
      IF (-100. .LT. heat_flux) THEN
        CALL PUSHCONTROL1B(0)
        heat_flux = heat_flux
      ELSE
        heat_flux = -100.
        CALL PUSHCONTROL1B(1)
      END IF
      heat_flux_snow1 = lambda_snow*(temp_snow1_last-temp_snow2_last)/(&
&       depth_snow-0.02)
      heat_flux_snow2 = (temp_snow2_last-temp_any0_last)/(0.5*(&
&       depth_snow-0.04)/lambda_snow+0.02/lambda_soil1)
      IF (temp_snow .GT. zero .AND. temp_snow_last .LE. zero .AND. &
&         depth_snow .GT. zero) THEN
        CALL PUSHREAL8ARRAY(temp_snow, r8/8)
        temp_snow = 0
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (temp_snow .LT. zero .AND. temp_snow_last .GE. zero .AND. &
&         depth_water .GT. zero) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      temp_snow_bw = temp_snow_bw + temp_ground_bw
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) temp_snow_bw = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8ARRAY(temp_snow, r8/8)
        temp_snow_bw = 0.0_8
      END IF
      temp2 = cp_ice*density_snow*(depth_snow-0.04)
      temp_bw1 = kstep*temp_snow2_bw/temp2
      temp_any0_bw = temp_any0_bw + temp_soil0_bw
      temp_bw2 = kstep*temp_any0_bw/(0.02*capacity_heat_soil0)
      heat_flux_snow2_bw = temp_bw2 - temp_bw1
      heat_flux_soil1_bw = heat_flux_soil1_bw - temp_bw2
      capacity_heat_soil0_bw = capacity_heat_soil0_bw - (heat_flux_snow2&
&       -heat_flux_soil1)*temp_bw2/capacity_heat_soil0
      heat_flux_snow1_bw = temp_bw1
      temp_bw2 = -((heat_flux_snow1-heat_flux_snow2)*temp_bw1/temp2)
      density_snow_bw = density_snow_bw + cp_ice*(depth_snow-0.04)*&
&       temp_bw2
      depth_snow_bw = depth_snow_bw + cp_ice*density_snow*temp_bw2
      temp2 = (depth_snow-0.04)/lambda_snow
      temp1 = 0.5*temp2 + 0.02/lambda_soil1
      temp_bw0 = heat_flux_snow2_bw/temp1
      temp_any0_last_bw = temp_any0_last_bw + temp_any0_bw - temp_bw0
      temp_bw1 = -((temp_snow2_last-temp_any0_last)*temp_bw0/temp1)
      temp_bw2 = 0.5*temp_bw1/lambda_snow
      lambda_soil1_bw = lambda_soil1_bw - 0.02*temp_bw1/lambda_soil1**2
      depth_snow_bw = depth_snow_bw + temp_bw2
      lambda_snow_bw = -(temp2*temp_bw2)
      temp2 = 0.02*cp_ice*density_snow
      temp_bw1 = kstep*temp_snow1_bw/temp2
      heat_flux_bw = heat_flux_bw + temp_bw1
      heat_flux_snow1_bw = heat_flux_snow1_bw - temp_bw1
      density_snow_bw = density_snow_bw - cp_ice*0.02*(heat_flux-&
&       heat_flux_snow1)*temp_bw1/temp2
      temp2 = lambda_snow/(depth_snow-0.02)
      temp_snow2_last_bw = temp_snow2_last_bw + temp_snow2_bw + temp_bw0&
&       - temp2*heat_flux_snow1_bw
      temp_snow1_last_bw = temp_snow1_last_bw + temp_snow1_bw + temp2*&
&       heat_flux_snow1_bw
      temp_bw2 = (temp_snow1_last-temp_snow2_last)*heat_flux_snow1_bw/(&
&       depth_snow-0.02)
      lambda_snow_bw = lambda_snow_bw + temp_bw2
      depth_snow_bw = depth_snow_bw - temp2*temp_bw2
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) heat_flux_bw = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) heat_flux_bw = 0.0_8
      heat_flux_snow_bw = heat_flux_bw
      lambda_snow_bw = lambda_snow_bw + (temp_snow-temp_snow1_last)*&
&       heat_flux_snow_bw/0.04
      temp_bw2 = lambda_snow*heat_flux_snow_bw/0.04
      temp_snow_bw = temp_snow_bw + temp_bw2
      temp_snow1_last_bw = temp_snow1_last_bw - temp_bw2
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) temp_snow_bw = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) temp_snow_bw = 0.0_8
      CALL POPREAL8ARRAY(temp_snow, r8/8)
      temp2 = 0.04*density_air*cp_air + ra_g*lambda_snow + 0.04*ttt*ra_g
      temp_bw1 = temp_snow_bw/temp2
      temp_bw0 = ra_g*0.04*temp_bw1
      gg_bw = ra_g*0.02*temp_bw1
      temp_snow1_last_bw = temp_snow1_last_bw + ra_g*lambda_snow*&
&       temp_bw1
      temp_bw2 = -((density_air*0.04*(cp_air*temp_air)+0.04*(&
&       temp_snow_last*ttt*ra_g)+0.02*(gg*ra_g)+ra_g*lambda_snow*&
&       temp_snow1_last)*temp_bw1/temp2)
      ra_g_bw = (temp_snow_last*ttt*0.04+gg*0.02+lambda_snow*&
&       temp_snow1_last)*temp_bw1 + (lambda_snow+ttt*0.04)*temp_bw2
      lambda_snow_bw = lambda_snow_bw + ra_g*temp_snow1_last*temp_bw1 + &
&       ra_g*temp_bw2
      ttt_bw = ra_g*0.04*temp_bw2 + temp_snow_last*temp_bw0
      temp_snow_last_bw = temp_snow_last_bw + ttt*temp_bw0
      density_snow_bw = density_snow_bw + cp_ice*0.02*ttt_bw/kstep
      temp_snow1_bw = 0.0_8
      temp_snow2_bw = 0.0_8
      heat_flux_bw = 0.0_8
      temp_snow_bw = 0.0_8
      temp_any0_bw = 0.0_8
      temp_ground_bw = 0.0_8
      temp_soil0_bw = 0.0_8
    ELSE
      ra_g_bw = 0.0_8
      lambda_snow_bw = 0.0_8
      gg_bw = 0.0_8
    END IF
    netrad_g_bw = netrad_g_bw + gg_bw
    evapo_snow_g_bw = evapo_snow_g_bw - latent_snow*gg_bw
    evapo_water_g_bw = evapo_water_g_bw - latent_water*gg_bw
    evapo_soil_bw = evapo_soil_bw - latent_water*gg_bw
    density_snow_bw = density_snow_bw + (4.2/10000.+3*density_snow**2*&
&     1e-9*2.2)*lambda_snow_bw
    gheat_g_bw = -(ra_g_bw/gheat_g**2)
  END SUBROUTINE SURFACETEMPERATURE_BW

!****************************************************
!  soil thermal regime
! update the soil temperatures for each soil layer
!****************************************************
  SUBROUTINE SURFACETEMPERATURE(temp_air, rh_air, depth_snow, &
&   depth_water, capacity_heat_soil1, capacity_heat_soil0, gheat_g, &
&   depth_soil1, density_snow, templ_u, netrad_g, evapo_soil, &
&   evapo_water_g, evapo_snow_g, lambda_soil1, percent_snow_g, &
&   heat_flux_soil1, temp_ground_last, temp_soil1_last, temp_any0_last, &
&   temp_snow_last, temp_soil0_last, temp_snow1_last, temp_snow2_last, &
&   temp_ground, temp_any0, temp_snow, temp_soil0, temp_snow1, &
&   temp_snow2, heat_flux)
    IMPLICIT NONE
    REAL(r8), INTENT(IN) :: temp_air, rh_air, depth_snow, depth_water, &
&   capacity_heat_soil1, capacity_heat_soil0
! aerodynamic conductance of heat at ground Gheat = 1/ra_g
    REAL(r8), INTENT(IN) :: gheat_g
    REAL(r8), INTENT(IN) :: depth_soil1, density_snow, templ_u, netrad_g
    REAL(r8), INTENT(IN) :: evapo_soil, evapo_water_g, evapo_snow_g
! thermal conductivity of first layer soil
    REAL(r8), INTENT(IN) :: lambda_soil1
    REAL(r8), INTENT(IN) :: percent_snow_g, heat_flux_soil1
    REAL(r8), INTENT(IN) :: temp_ground_last, temp_soil1_last, &
&   temp_any0_last, temp_snow_last, temp_soil0_last, temp_snow1_last, &
&   temp_snow2_last
! ground => ground surface; soil0=>temperature of soil surface right above the soil in last step,the part is not covered by snow;
! soil1=>temperature of first layer soil in last step
! ground surface tem in current
    REAL(r8), INTENT(OUT) :: temp_ground
! temperature of any layer right abover the soil,could be a mixture of snow temperature and soil surface temperature
    REAL(r8), INTENT(OUT) :: temp_any0
    REAL(r8), INTENT(OUT) :: temp_snow
! temperature of soil surface right above the soil, the part not covered by snow
    REAL(r8), INTENT(OUT) :: temp_soil0
! temperature of snow layer 2 and 3, used when depth_snow > 0.05m
    REAL(r8), INTENT(OUT) :: temp_snow1, temp_snow2
! heat_flux from ground to soil
    REAL(r8), INTENT(OUT) :: heat_flux
! radiation available for heating the ground
    REAL(r8) :: gg
! thermal conductivity
    REAL(r8) :: lambda_snow
! heat flux through the soil and snow fraction on ground, separatively
    REAL(r8) :: heat_flux_soil, heat_flux_snow
    REAL(r8) :: heat_flux_snow1, heat_flux_snow2
! aerodynamic resistence of heat
    REAL(r8) :: ra_g
! temporary vars
    REAL(r8) :: ttt
    INTRINSIC MAX
    INTRINSIC MIN
    CALL METEO_PACK(temp_air, rh_air)
    ra_g = 1./gheat_g
    lambda_snow = 0.021 + 4.2*density_snow/10000. + 2.2*density_snow**3*&
&     1e-9
! available energy on ground
    gg = netrad_g - evapo_snow_g*latent_snow - (evapo_water_g+evapo_soil&
&     )*latent_water
!!case 1 snow depth < 2cm, snow temperature ,ground temperature, soil surface temperature are the same
    IF (depth_snow .LE. 0.02) THEN
      ttt = capacity_heat_soil1*0.02/kstep
      temp_ground = temp_ground_last*ttt*ra_g*depth_soil1 + gg*ra_g*&
&       depth_soil1 + density_air*cp_air*temp_air*depth_soil1 + ra_g*&
&       lambda_soil1*temp_soil1_last
      temp_ground = temp_ground/(density_air*cp_air*depth_soil1+ra_g*&
&       lambda_soil1+ttt*ra_g*depth_soil1)
      IF (temp_ground_last - 25 .LT. temp_ground) THEN
        temp_ground = temp_ground
      ELSE
        temp_ground = temp_ground_last - 25
      END IF
      IF (temp_ground_last + 25 .GT. temp_ground) THEN
        temp_ground = temp_ground
      ELSE
        temp_ground = temp_ground_last + 25
      END IF
      temp_any0 = temp_ground
      temp_snow = temp_any0
      temp_soil0 = temp_any0
      temp_snow1 = temp_any0
      temp_snow2 = temp_any0
      heat_flux = 2*lambda_soil1*(temp_any0-temp_soil1_last)/depth_soil1
      IF (100. .GT. heat_flux) THEN
        heat_flux = heat_flux
      ELSE
        heat_flux = 100.
      END IF
      IF (-100. .LT. heat_flux) THEN
        heat_flux = heat_flux
      ELSE
        heat_flux = -100.
      END IF
    ELSE IF (depth_snow .GT. 0.02 .AND. depth_snow .LE. 0.05) THEN
!! snow fraction on ground decide the snow temperature based on energy balance
!! soil fraction on ground decide the soil surface temperature based on energy balance
!! snow and soil fraction works in parallel to determine the ground surface temperature
! for soil
      ttt = capacity_heat_soil1*0.02/kstep
      temp_soil0 = (temp_soil0_last*ttt*ra_g*depth_soil1+gg*ra_g*&
&       depth_soil1+density_air*cp_air*temp_air*depth_soil1+2*ra_g*&
&       lambda_soil1*temp_soil1_last)/(density_air*cp_air*depth_soil1+2*&
&       ra_g*lambda_soil1+ttt*ra_g*depth_soil1)
      IF (temp_air - 25 .LT. temp_soil0) THEN
        temp_soil0 = temp_soil0
      ELSE
        temp_soil0 = temp_air - 25
      END IF
      IF (temp_air + 25 .GT. temp_soil0) THEN
        temp_soil0 = temp_soil0
      ELSE
        temp_soil0 = temp_air + 25
      END IF
      ttt = cp_ice*density_snow*depth_snow/kstep
      temp_snow = (temp_snow_last*ttt*ra_g*depth_snow+gg*ra_g*depth_snow&
&       +density_air*cp_air*templ_u*depth_snow+ra_g*lambda_snow*&
&       temp_any0_last)/(density_air*cp_air*depth_snow+ra_g*lambda_snow+&
&       ttt*ra_g*depth_snow)
      IF (temp_air - 25 .LT. temp_snow) THEN
        temp_snow = temp_snow
      ELSE
        temp_snow = temp_air - 25
      END IF
      IF (temp_air + 25 .GT. temp_snow) THEN
        temp_snow = temp_snow
      ELSE
        temp_snow = temp_air + 25
      END IF
      ttt = (lambda_soil1*temp_soil1_last/depth_soil1+temp_snow*&
&       lambda_snow+0.02*capacity_heat_soil1/kstep*temp_any0_last)/(&
&       lambda_soil1/depth_soil1+lambda_snow/depth_snow+0.02*&
&       capacity_heat_soil1/kstep)
      temp_any0 = temp_soil0*(1-percent_snow_g) + ttt*percent_snow_g
      heat_flux_snow = lambda_snow/(depth_snow+0.5*depth_soil1)*(&
&       temp_snow-temp_soil1_last)
      heat_flux_soil = heat_flux_snow*(temp_any0-temp_soil1_last)/&
&       depth_soil1
!!!!Wrong???
      heat_flux = heat_flux_snow*percent_snow_g + heat_flux_soil*(1-&
&       percent_snow_g)
      IF (100. .GT. heat_flux) THEN
        heat_flux = heat_flux
      ELSE
        heat_flux = 100.
      END IF
      IF (-100. .LT. heat_flux) THEN
        heat_flux = heat_flux
      ELSE
        heat_flux = -100.
      END IF
! starting to melt
      IF (temp_snow .GT. zero .AND. temp_snow_last .LE. zero .AND. &
&         depth_snow .GT. zero) temp_snow = 0
! frozen
      IF (temp_snow .LT. zero .AND. temp_snow_last .GE. zero .AND. &
&         depth_water .GT. zero) temp_snow = 0
      temp_ground = temp_snow*percent_snow_g + temp_soil0*(1-&
&       percent_snow_g)
      IF (temp_air - 25 .LT. temp_ground) THEN
        temp_ground = temp_ground
      ELSE
        temp_ground = temp_air - 25
      END IF
      IF (temp_air + 25 .GT. temp_ground) THEN
        temp_ground = temp_ground
      ELSE
        temp_ground = temp_air + 25
      END IF
      temp_snow1 = temp_snow
      temp_snow2 = temp_snow
    ELSE IF (depth_snow .GT. 0.05) THEN
!! case 3
!! snow_cover on ground is 100%
!! teh first layer of snow is set as 2cm
!! second layer as 2cm, too
!! the depth of third snow layer is depth_snow-0.04
      ttt = cp_ice*density_snow*0.02/kstep
      temp_snow = (temp_snow_last*ttt*ra_g*0.04+gg*ra_g*0.02+density_air&
&       *cp_air*temp_air*0.04+ra_g*lambda_snow*temp_snow1_last)/(&
&       density_air*cp_air*0.04+ra_g*lambda_snow+ttt*ra_g*0.04)
      IF (temp_air - 25 .LT. temp_snow) THEN
        temp_snow = temp_snow
      ELSE
        temp_snow = temp_air - 25
      END IF
      IF (temp_air + 25 .GT. temp_snow) THEN
        temp_snow = temp_snow
      ELSE
        temp_snow = temp_air + 25
      END IF
!why 0.04 here?
      heat_flux_snow = lambda_snow*(temp_snow-temp_snow1_last)/0.04
      heat_flux = heat_flux_snow
      IF (100. .GT. heat_flux) THEN
        heat_flux = heat_flux
      ELSE
        heat_flux = 100.
      END IF
      IF (-100. .LT. heat_flux) THEN
        heat_flux = heat_flux
      ELSE
        heat_flux = -100.
      END IF
      heat_flux_snow1 = lambda_snow*(temp_snow1_last-temp_snow2_last)/(&
&       depth_snow-0.02)
      temp_snow1 = temp_snow1_last + (heat_flux-heat_flux_snow1)/(cp_ice&
&       *density_snow*0.02)*kstep
      heat_flux_snow2 = (temp_snow2_last-temp_any0_last)/(0.5*(&
&       depth_snow-0.04)/lambda_snow+0.02/lambda_soil1)
      temp_snow2 = temp_snow2_last + (heat_flux_snow1-heat_flux_snow2)/(&
&       cp_ice*density_snow*(depth_snow-0.04))*kstep
      temp_any0 = temp_any0_last + (heat_flux_snow2-heat_flux_soil1)/(&
&       capacity_heat_soil0*0.02)*kstep
      temp_soil0 = temp_any0
      IF (temp_snow .GT. zero .AND. temp_snow_last .LE. zero .AND. &
&         depth_snow .GT. zero) temp_snow = 0
      IF (temp_snow .LT. zero .AND. temp_snow_last .GE. zero .AND. &
&         depth_water .GT. zero) temp_snow = 0
      temp_ground = temp_snow
    END IF
    RETURN
  END SUBROUTINE SURFACETEMPERATURE

!  Differentiation of updateheatflux in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: p.ice_ratio p.thetam p.thetam_prev
!                p.temp_soil_p p.temp_soil_c p.cs p.lambda p.g
!   with respect to varying inputs: p.ice_ratio p.thetam p.thetam_prev
!                p.temp_soil_p p.temp_soil_c p.cs p.lambda p.g
  SUBROUTINE UPDATEHEATFLUX_BW(p, p_bw, xg_snow, lambda_snow, tsn0, &
&   tair_annual_mean, period_in_seconds)
    IMPLICIT NONE
    TYPE(SOIL) :: p
    TYPE(SOIL_DIFF) :: p_bw
    REAL(r8), INTENT(IN) :: xg_snow
    REAL(r8), INTENT(IN) :: lambda_snow
    REAL(r8), INTENT(IN) :: tsn0, tair_annual_mean
    INTEGER, INTENT(IN) :: period_in_seconds
!-- iLab::no need to have variable 's' 'implicitl save',
!         or may also switch to parameter?
! real(r8)              :: S = 0.    !what? Wangjun
    REAL(r8) :: s
    INTRINSIC REAL
    REAL(r8) :: temp
    REAL(r8) :: temp0
    REAL(r8) :: temp1
    REAL(r8) :: temp2
    REAL(r8) :: temp_bw
    REAL(r8) :: temp_bw0
    INTEGER*4 :: branch
    s = 0._r8
    DO i=1,p%n_layer
      IF (i .LT. p%n_layer) THEN
        p%g(i) = (p%temp_soil_p(i-1)-p%temp_soil_p(i))/(0.5*p%d_soil(i-1&
&         )/p%lambda(i-1)+0.5*p%d_soil(i)/p%lambda(i))
        CALL PUSHCONTROL1B(0)
      ELSE
        p%g(i) = p%lambda(i-1)*(p%temp_soil_p(i-1)-tair_annual_mean)/(&
&         depth_f+p%d_soil(i-1)*0.5)
        CALL PUSHCONTROL1B(1)
      END IF
      IF (p%g(i) .GT. 200) THEN
        p%g(i) = 200
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (p%g(i) .LT. -200) THEN
        p%g(i) = -200
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    DO i=0,p%n_layer-1
      CALL PUSHREAL8ARRAY(p%temp_soil_c(i), r8/8)
      p%temp_soil_c(i) = p%temp_soil_p(i) + (p%g(i)-p%g(i+1)+s)/(p%cs(i)&
&       *p%d_soil(i))*REAL(period_in_seconds)
      IF (p%temp_soil_c(i) .GT. 50.0) THEN
        p%temp_soil_c(i) = 50.
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (p%temp_soil_c(i) .LT. -50.0) THEN
        p%temp_soil_c(i) = -50.
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    i = p%n_layer
    DO i=p%n_layer-1,0,-1
      p_bw%temp_soil_c(i) = p_bw%temp_soil_c(i) + p_bw%temp_soil_p(i)
      p_bw%temp_soil_p(i) = 0.0_8
    END DO
    CALL UPDATE_ICE_RATIO_BW(p, p_bw)
    DO i=p%n_layer-1,0,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) p_bw%temp_soil_c(i) = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) p_bw%temp_soil_c(i) = 0.0_8
      CALL POPREAL8ARRAY(p%temp_soil_c(i), r8/8)
      temp2 = p%d_soil(i)*p%cs(i)
      p_bw%temp_soil_p(i) = p_bw%temp_soil_p(i) + p_bw%temp_soil_c(i)
      temp_bw0 = REAL(period_in_seconds)*p_bw%temp_soil_c(i)/temp2
      p_bw%temp_soil_c(i) = 0.0_8
      p_bw%g(i) = p_bw%g(i) + temp_bw0
      p_bw%g(i+1) = p_bw%g(i+1) - temp_bw0
      p_bw%cs(i) = p_bw%cs(i) - p%d_soil(i)*(s+p%g(i)-p%g(i+1))*temp_bw0&
&       /temp2
    END DO
    DO i=p%n_layer,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) p_bw%g(i) = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) p_bw%g(i) = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        temp = 0.5*p%d_soil(i)/p%lambda(i)
        temp0 = 0.5*p%d_soil(i-1)/p%lambda(i-1)
        temp1 = temp0 + temp
        temp_bw = p_bw%g(i)/temp1
        p_bw%g(i) = 0.0_8
        p_bw%temp_soil_p(i-1) = p_bw%temp_soil_p(i-1) + temp_bw
        p_bw%temp_soil_p(i) = p_bw%temp_soil_p(i) - temp_bw
        temp_bw0 = -((p%temp_soil_p(i-1)-p%temp_soil_p(i))*temp_bw/temp1&
&         )
        p_bw%lambda(i-1) = p_bw%lambda(i-1) - temp0*temp_bw0/p%lambda(i-&
&         1)
        p_bw%lambda(i) = p_bw%lambda(i) - temp*temp_bw0/p%lambda(i)
      ELSE
        temp_bw = p_bw%g(i)/(depth_f+p%d_soil(i-1)*0.5)
        p_bw%g(i) = 0.0_8
        p_bw%lambda(i-1) = p_bw%lambda(i-1) + (p%temp_soil_p(i-1)-&
&         tair_annual_mean)*temp_bw
        p_bw%temp_soil_p(i-1) = p_bw%temp_soil_p(i-1) + p%lambda(i-1)*&
&         temp_bw
      END IF
    END DO
  END SUBROUTINE UPDATEHEATFLUX_BW

  SUBROUTINE UPDATEHEATFLUX(p, xg_snow, lambda_snow, tsn0, &
&   tair_annual_mean, period_in_seconds)
    IMPLICIT NONE
    TYPE(SOIL) :: p
    REAL(r8), INTENT(IN) :: xg_snow
    REAL(r8), INTENT(IN) :: lambda_snow
    REAL(r8), INTENT(IN) :: tsn0, tair_annual_mean
    INTEGER, INTENT(IN) :: period_in_seconds
!-- iLab::no need to have variable 's' 'implicitl save',
!         or may also switch to parameter?
! real(r8)              :: S = 0.    !what? Wangjun
    REAL(r8) :: s
    INTRINSIC REAL
    s = 0._r8
    DO i=1,p%n_layer
      IF (i .LT. p%n_layer) THEN
        p%g(i) = (p%temp_soil_p(i-1)-p%temp_soil_p(i))/(0.5*p%d_soil(i-1&
&         )/p%lambda(i-1)+0.5*p%d_soil(i)/p%lambda(i))
      ELSE
        p%g(i) = p%lambda(i-1)*(p%temp_soil_p(i-1)-tair_annual_mean)/(&
&         depth_f+p%d_soil(i-1)*0.5)
      END IF
      IF (p%g(i) .GT. 200) p%g(i) = 200
      IF (p%g(i) .LT. -200) p%g(i) = -200
    END DO
    DO i=0,p%n_layer-1
      p%temp_soil_c(i) = p%temp_soil_p(i) + (p%g(i)-p%g(i+1)+s)/(p%cs(i)&
&       *p%d_soil(i))*REAL(period_in_seconds)
      IF (p%temp_soil_c(i) .GT. 50.0) p%temp_soil_c(i) = 50.
      IF (p%temp_soil_c(i) .LT. -50.0) p%temp_soil_c(i) = -50.
    END DO
! do i = 0,p%n_layer-1
!  write(*,*) 'DG0031: soil temperature diagnosis', p%temp_soil_c(i)
! end do
    CALL UPDATE_ICE_RATIO(p)
    DO i=0,p%n_layer-1
      p%temp_soil_p(i) = p%temp_soil_c(i)
    END DO
    RETURN
  END SUBROUTINE UPDATEHEATFLUX

!  Differentiation of update_cs in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: p.ice_ratio p.thetam p.cs
!   with respect to varying inputs: p.ice_ratio p.thetam p.cs
  SUBROUTINE UPDATE_CS_BW(p, p_bw)
    IMPLICIT NONE
    TYPE(SOIL) :: p
    TYPE(SOIL_DIFF) :: p_bw
    REAL(r8) :: term1, term2, term3
    REAL(r8) :: term2_bw
    REAL(r8) :: temp_bw
!Chen B. (2007) Ecological Modelling 209, 277-300  (equation 18)
    i = p%n_layer
    DO i=p%n_layer-1,0,-1
      term2_bw = p_bw%cs(i)
      p_bw%cs(i) = 0.0_8
      p_bw%thetam(i) = p_bw%thetam(i) + (4.2*(1.-p%ice_ratio(i))+2.09*p%&
&       ice_ratio(i))*1.e6*term2_bw
      temp_bw = p%thetam(i)*1.e6*term2_bw
      p_bw%ice_ratio(i) = p_bw%ice_ratio(i) + (-2.11)*temp_bw
    END DO
  END SUBROUTINE UPDATE_CS_BW

  SUBROUTINE UPDATE_CS(p)
    IMPLICIT NONE
    TYPE(SOIL) :: p
    REAL(r8) :: term1, term2, term3
!Chen B. (2007) Ecological Modelling 209, 277-300  (equation 18)
    DO i=0,p%n_layer-1
      term1 = 2.*1.e3*p%density_soil(i)/2.65
      term2 = 1.e6*p%thetam(i)*(4.2*(1.-p%ice_ratio(i))+2.09*p%ice_ratio&
&       (i))
      term3 = 2.5*1.e6*p%f_org(i)
      p%cs(i) = term1 + term2 + term3
    END DO
    RETURN
  END SUBROUTINE UPDATE_CS

!  Differentiation of update_ice_ratio in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: p.ice_ratio p.thetam p.thetam_prev
!                p.temp_soil_c p.cs
!   with respect to varying inputs: p.ice_ratio p.thetam p.thetam_prev
!                p.temp_soil_c p.cs
  SUBROUTINE UPDATE_ICE_RATIO_BW(p, p_bw)
    IMPLICIT NONE
    TYPE(SOIL) :: p
    TYPE(SOIL_DIFF) :: p_bw
! latent heat of fusion at 0C
    REAL(r8), SAVE :: lf0=3.34*1.e5
    REAL(r8) :: tmp
    REAL(r8) :: tmp_bw
    INTRINSIC MIN
    INTRINSIC MAX
    REAL(r8) :: temp
    REAL(r8) :: temp0
    REAL(r8) :: temp_bw
    INTEGER*4 :: branch
    DO i=0,p%n_layer-1
! starting to frozen
      IF (p%temp_soil_p(i) .GE. 0. .AND. p%temp_soil_c(i) .LT. 0. .AND. &
&         p%ice_ratio(i) .LT. 1.0 .AND. p%thetam(i) .GT. 0.) THEN
!! Add p%thetam(i) >0. by @J.Wang
        tmp = (0.-p%temp_soil_c(i))*p%cs(i)*p%d_soil(i)
        CALL PUSHREAL8ARRAY(p%ice_ratio(i), r8/8)
        p%ice_ratio(i) = p%ice_ratio(i) + tmp/lf0/1000./(p%thetam(i)*p%&
&         d_soil(i))
        IF (1.0 .GT. p%ice_ratio(i)) THEN
          CALL PUSHCONTROL1B(0)
          p%ice_ratio(i) = p%ice_ratio(i)
        ELSE
          p%ice_ratio(i) = 1.0
          CALL PUSHCONTROL1B(1)
        END IF
        CALL PUSHCONTROL2B(2)
      ELSE IF (p%temp_soil_p(i) .LE. 0 .AND. p%temp_soil_c(i) .GT. 0. &
&         .AND. p%ice_ratio(i) .GT. 0.) THEN
        tmp = (p%temp_soil_c(i)-0.0)*p%cs(i)*p%d_soil(i)
        CALL PUSHREAL8ARRAY(p%ice_ratio(i), r8/8)
        p%ice_ratio(i) = p%ice_ratio(i) - tmp/lf0/1000./(p%thetam(i)*p%&
&         d_soil(i))
        IF (0. .LT. p%ice_ratio(i)) THEN
          CALL PUSHCONTROL1B(0)
          p%ice_ratio(i) = p%ice_ratio(i)
        ELSE
          p%ice_ratio(i) = 0.
          CALL PUSHCONTROL1B(1)
        END IF
        CALL PUSHCONTROL2B(1)
      ELSE
        CALL PUSHCONTROL2B(0)
      END IF
      CALL PUSHREAL8ARRAY(p%ice_ratio(i), r8/8)
      p%ice_ratio(i) = p%ice_ratio(i)*p%thetam_prev(i)/p%thetam(i)
      IF (1. .GT. p%ice_ratio(i)) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
    END DO
    DO i=p%n_layer-1,0,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) p_bw%ice_ratio(i) = 0.0_8
      CALL POPREAL8ARRAY(p%ice_ratio(i), r8/8)
      temp_bw = p_bw%ice_ratio(i)/p%thetam(i)
      p_bw%ice_ratio(i) = p%thetam_prev(i)*temp_bw
      p_bw%thetam_prev(i) = p_bw%thetam_prev(i) + p%ice_ratio(i)*temp_bw
      p_bw%thetam(i) = p_bw%thetam(i) - p%ice_ratio(i)*p%thetam_prev(i)*&
&       temp_bw/p%thetam(i)
      CALL POPCONTROL2B(branch)
      IF (branch .NE. 0) THEN
        IF (branch .EQ. 1) THEN
          p_bw%temp_soil_c(i) = 0.0_8
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) p_bw%ice_ratio(i) = 0.0_8
          tmp = (p%temp_soil_c(i)-0.0)*p%cs(i)*p%d_soil(i)
          CALL POPREAL8ARRAY(p%ice_ratio(i), r8/8)
          temp0 = 1000.*lf0*p%d_soil(i)
          temp = temp0*p%thetam(i)
          tmp_bw = -(p_bw%ice_ratio(i)/temp)
          p_bw%thetam(i) = p_bw%thetam(i) + temp0*tmp*p_bw%ice_ratio(i)/&
&           temp**2
          p_bw%temp_soil_c(i) = p_bw%temp_soil_c(i) + p%cs(i)*p%d_soil(i&
&           )*tmp_bw
          p_bw%cs(i) = p_bw%cs(i) + p%temp_soil_c(i)*p%d_soil(i)*tmp_bw
        ELSE
          p_bw%temp_soil_c(i) = 0.0_8
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) p_bw%ice_ratio(i) = 0.0_8
          tmp = (0.-p%temp_soil_c(i))*p%cs(i)*p%d_soil(i)
          CALL POPREAL8ARRAY(p%ice_ratio(i), r8/8)
          temp = 1000.*lf0*p%d_soil(i)
          temp0 = temp*p%thetam(i)
          tmp_bw = p_bw%ice_ratio(i)/temp0
          p_bw%thetam(i) = p_bw%thetam(i) - temp*tmp*p_bw%ice_ratio(i)/&
&           temp0**2
          p_bw%temp_soil_c(i) = p_bw%temp_soil_c(i) - p%cs(i)*p%d_soil(i&
&           )*tmp_bw
          p_bw%cs(i) = p_bw%cs(i) - p%temp_soil_c(i)*p%d_soil(i)*tmp_bw
        END IF
      END IF
    END DO
  END SUBROUTINE UPDATE_ICE_RATIO_BW

  SUBROUTINE UPDATE_ICE_RATIO(p)
    IMPLICIT NONE
    TYPE(SOIL) :: p
! latent heat of fusion at 0C
    REAL(r8), SAVE :: lf0=3.34*1.e5
    REAL(r8) :: tmp
    INTRINSIC MIN
    INTRINSIC MAX
    DO i=0,p%n_layer-1
! starting to frozen
      IF (p%temp_soil_p(i) .GE. 0. .AND. p%temp_soil_c(i) .LT. 0. .AND. &
&         p%ice_ratio(i) .LT. 1.0 .AND. p%thetam(i) .GT. 0.) THEN
!! Add p%thetam(i) >0. by @J.Wang
        tmp = (0.-p%temp_soil_c(i))*p%cs(i)*p%d_soil(i)
        p%ice_ratio(i) = p%ice_ratio(i) + tmp/lf0/1000./(p%thetam(i)*p%&
&         d_soil(i))
        IF (1.0 .GT. p%ice_ratio(i)) THEN
          p%ice_ratio(i) = p%ice_ratio(i)
        ELSE
          p%ice_ratio(i) = 1.0
        END IF
        p%temp_soil_c(i) = 0
! Be melting
      ELSE IF (p%temp_soil_p(i) .LE. 0 .AND. p%temp_soil_c(i) .GT. 0. &
&         .AND. p%ice_ratio(i) .GT. 0.) THEN
        tmp = (p%temp_soil_c(i)-0.0)*p%cs(i)*p%d_soil(i)
        p%ice_ratio(i) = p%ice_ratio(i) - tmp/lf0/1000./(p%thetam(i)*p%&
&         d_soil(i))
        IF (0. .LT. p%ice_ratio(i)) THEN
          p%ice_ratio(i) = p%ice_ratio(i)
        ELSE
          p%ice_ratio(i) = 0.
        END IF
        p%temp_soil_c(i) = 0
      END IF
      p%ice_ratio(i) = p%ice_ratio(i)*p%thetam_prev(i)/p%thetam(i)
      IF (1. .GT. p%ice_ratio(i)) THEN
        p%ice_ratio(i) = p%ice_ratio(i)
      ELSE
        p%ice_ratio(i) = 1.
      END IF
    END DO
    RETURN
  END SUBROUTINE UPDATE_ICE_RATIO

!  Differentiation of updatesoilthermalconductivity in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: p.ice_ratio p.thetam p.lambda
!   with respect to varying inputs: p.ice_ratio p.thetam p.lambda
  SUBROUTINE UPDATESOILTHERMALCONDUCTIVITY_BW(p, p_bw)
    IMPLICIT NONE
    TYPE(SOIL) :: p
    TYPE(SOIL_DIFF) :: p_bw
! the thermal conductivity of ice
    REAL(r8), SAVE :: ki=2.1
! the thermal conductivity of water
    REAL(r8), SAVE :: kw=0.61
    REAL(r8) :: tmp1, tmp2, tmp3, tmp4
    REAL(r8) :: tmp2_bw, tmp3_bw, tmp4_bw
    INTRINSIC MAX
    REAL(r8) :: temp_bw
    INTEGER*4 :: branch
    DO i=0,p%n_layer-1
! dry
      tmp1 = p%thermal_cond(i)**(1-p%fei(i))
!ice
      tmp2 = ki**(1.2*p%thetam(i)*p%ice_ratio(i))
!water
      tmp3 = kw**(p%thetam(i)*(1-p%ice_ratio(i)))
!!Sr ??
      tmp4 = p%thetam(i)/p%fei(i)
!eq. 8. LHE
      CALL PUSHREAL8ARRAY(p%lambda(i), r8/8)
      p%lambda(i) = (tmp1*tmp2*tmp3-0.15)*tmp4 + 0.15
      IF (p%lambda(i) .LT. 0.15) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
    END DO
    DO i=p%n_layer-1,0,-1
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) p_bw%lambda(i) = 0.0_8
      tmp1 = p%thermal_cond(i)**(1-p%fei(i))
      tmp2 = ki**(1.2*p%thetam(i)*p%ice_ratio(i))
      tmp3 = kw**(p%thetam(i)*(1-p%ice_ratio(i)))
      tmp4 = p%thetam(i)/p%fei(i)
      CALL POPREAL8ARRAY(p%lambda(i), r8/8)
      temp_bw = tmp1*tmp4*p_bw%lambda(i)
      tmp4_bw = (tmp1*(tmp2*tmp3)-0.15)*p_bw%lambda(i)
      p_bw%lambda(i) = 0.0_8
      tmp2_bw = tmp3*temp_bw
      tmp3_bw = tmp2*temp_bw
      IF (kw .LE. 0.0_8) THEN
        temp_bw = 0.0_8
      ELSE
        temp_bw = kw**(p%thetam(i)*(1-p%ice_ratio(i)))*LOG(kw)*tmp3_bw
      END IF
      p_bw%thetam(i) = p_bw%thetam(i) + tmp4_bw/p%fei(i) + (1-p%&
&       ice_ratio(i))*temp_bw
      p_bw%ice_ratio(i) = p_bw%ice_ratio(i) - p%thetam(i)*temp_bw
      IF (ki .LE. 0.0_8) THEN
        temp_bw = 0.0_8
      ELSE
        temp_bw = 1.2*ki**(1.2*(p%thetam(i)*p%ice_ratio(i)))*LOG(ki)*&
&         tmp2_bw
      END IF
      p_bw%thetam(i) = p_bw%thetam(i) + p%ice_ratio(i)*temp_bw
      p_bw%ice_ratio(i) = p_bw%ice_ratio(i) + p%thetam(i)*temp_bw
    END DO
  END SUBROUTINE UPDATESOILTHERMALCONDUCTIVITY_BW

  SUBROUTINE UPDATESOILTHERMALCONDUCTIVITY(p)
    IMPLICIT NONE
    TYPE(SOIL) :: p
! the thermal conductivity of ice
    REAL(r8), SAVE :: ki=2.1
! the thermal conductivity of water
    REAL(r8), SAVE :: kw=0.61
    REAL(r8) :: tmp1, tmp2, tmp3, tmp4
    INTRINSIC MAX
    DO i=0,p%n_layer-1
! dry
      tmp1 = p%thermal_cond(i)**(1-p%fei(i))
!ice
      tmp2 = ki**(1.2*p%thetam(i)*p%ice_ratio(i))
!water
      tmp3 = kw**(p%thetam(i)*(1-p%ice_ratio(i)))
!!Sr ??
      tmp4 = p%thetam(i)/p%fei(i)
!eq. 8. LHE
      p%lambda(i) = (tmp1*tmp2*tmp3-0.15)*tmp4 + 0.15
      IF (p%lambda(i) .LT. 0.15) THEN
        p%lambda(i) = 0.15
      ELSE
        p%lambda(i) = p%lambda(i)
      END IF
    END DO
    RETURN
  END SUBROUTINE UPDATESOILTHERMALCONDUCTIVITY

!  Differentiation of updatesoilmoisture in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: p.zp p.r_rain_g p.ksat p.b
!                p.ice_ratio p.thetam p.thetam_prev p.temp_soil_c
!                p.f_ice p.psim p.thetab p.psib p.r_waterflow p.km
!                p.kb p.kk p.ett
!   with respect to varying inputs: p.zp p.r_rain_g p.ksat p.b
!                p.ice_ratio p.thetam p.thetam_prev p.temp_soil_c
!                p.f_ice p.psim p.thetab p.psib p.r_waterflow p.km
!                p.kb p.kk p.ett
!******************************************************
! Soil hydraulic state
!******************************************************
!remove the parameter 'kstep'@J.Wang
  SUBROUTINE UPDATESOILMOISTURE_BW(p, p_bw)
    IMPLICIT NONE
    TYPE(SOIL) :: p
    TYPE(SOIL_DIFF) :: p_bw
! infiltration, and Maximum infiltration
    REAL(r8) :: infil, infil_max
    REAL(r8) :: infil_bw, infil_max_bw
    REAL(r8) :: this_step, total_t, max_fb, kkstep
    REAL(r8) :: d1
    REAL(r8) :: d1_bw
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC ABS
    REAL(r8) :: x1
    REAL(r8) :: x1_bw
    REAL(r8) :: abs0
    REAL(r8) :: temp
    REAL(r8) :: temp_bw
    REAL(r8) :: temp0
    REAL(r8) :: temp_bw0
    REAL(r8) :: temp1
    REAL(r8) :: temp_bw1
    REAL(r8) :: temp2
    REAL(r8) :: temp_bw2
    REAL(r8) :: temp3
    REAL(r8) :: temp4
    REAL(r8) :: temp_bw3
    REAL(r8) :: temp_bw4
    INTEGER*4 :: branch
    INTEGER :: ad_count
    INTEGER :: i0
    kkstep = 1.*kstep
    DO i=0,p%n_layer
!save previous thetam
      CALL PUSHREAL8ARRAY(p%thetam_prev(i), r8/8)
      p%thetam_prev(i) = p%thetam(i)
    END DO
    DO i=0,p%n_layer
      IF (p%temp_soil_c(i) .GT. 0.0) THEN
!! f_ice should be named as f_water
        p%f_ice(i) = 1.0
        CALL PUSHCONTROL2B(2)
      ELSE IF (p%temp_soil_c(i) .LT. -1.) THEN
        p%f_ice(i) = 0.1
        CALL PUSHCONTROL2B(1)
      ELSE
        p%f_ice(i) = 0.1 + 0.9*(p%temp_soil_c(i)+1.0)
        CALL PUSHCONTROL2B(0)
      END IF
    END DO
!write(*,*) p%f_ice(0),p%Zp,p%r_rain_g
!! juweimin
!! this part solve the upper boundary condition (Infiltration). LHE
!! the maximum Infiltration. The Inf should be changing very fast during precipitation because thetam
!! is changing. LHE
    infil_max = p%f_ice(0)*p%ksat(0)*(1.+(p%fei(0)-p%thetam_prev(0))/p%&
&     d_soil(0)*p%psi_sat(0)*p%b(0)/p%fei(0))
    IF (p%f_ice(0)*(p%zp/kkstep+p%r_rain_g) .LT. 0.) THEN
      CALL PUSHCONTROL1B(0)
      infil = 0.
    ELSE
      infil = p%f_ice(0)*(p%zp/kkstep+p%r_rain_g)
      CALL PUSHCONTROL1B(1)
    END IF
    IF (infil_max .GT. infil) THEN
      infil = infil
      CALL PUSHCONTROL1B(0)
    ELSE
      infil = infil_max
      CALL PUSHCONTROL1B(1)
    END IF
    IF (0. .LT. infil) THEN
      CALL PUSHCONTROL1B(0)
      infil = infil
    ELSE
      infil = 0.
      CALL PUSHCONTROL1B(1)
    END IF
! Ponded water after runoff. This one is related to runoff
    total_t = 0.
    max_fb = 0.
    ad_count = 0
    DO WHILE (total_t .LT. kkstep)
      DO i=0,p%n_layer-1
        CALL PUSHREAL8ARRAY(p%km(i), r8/8)
        p%km(i) = p%f_ice(i)*p%ksat(i)*(p%thetam(i)/p%fei(i))**(2.*p%b(i&
&         )+3.)
      END DO
      DO i=0,p%n_layer-1
        IF (i .LT. p%n_layer - 1) THEN
          CALL PUSHREAL8ARRAY(p%thetab(i), r8/8)
          p%thetab(i) = (p%thetam(i+1)/p%d_soil(i+1)+p%thetam(i)/p%&
&           d_soil(i))/(1./p%d_soil(i)+1./p%d_soil(i+1))
          CALL PUSHCONTROL2B(2)
        ELSE
          d1 = (p%thetam(i)-p%thetab(i-1))*2./p%d_soil(i)
          IF (d1 .LT. 0.) THEN
            d1 = 0.
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
            d1 = d1
          END IF
          CALL PUSHREAL8ARRAY(p%thetab(i), r8/8)
          p%thetab(i) = p%thetam(i) + d1*p%d_soil(i)/2.
          IF (p%thetab(i) .GT. p%fei(i)) THEN
            CALL PUSHREAL8ARRAY(p%thetab(i), r8/8)
            p%thetab(i) = p%fei(i)
            CALL PUSHCONTROL2B(0)
          ELSE
            CALL PUSHREAL8ARRAY(p%thetab(i), r8/8)
            p%thetab(i) = p%thetab(i)
            CALL PUSHCONTROL2B(1)
          END IF
        END IF
      END DO
      DO i=0,p%n_layer-1
        IF (i .LT. p%n_layer - 1) THEN
! the unsaturated hydraulic conductivity at soil lower boundary
!! Note: Kb(0) to Kb(n_layer-1) are not used in the model
          CALL PUSHREAL8ARRAY(p%kb(i), r8/8)
          p%kb(i) = p%f_ice(i)*(p%ksat(i)*p%d_soil(i)+p%ksat(i+1)*p%&
&           d_soil(i+1))/(p%d_soil(i)+p%d_soil(i+1))*(p%thetab(i)/p%fei(&
&           i))**(2.*p%b(i)+3.)
          CALL PUSHCONTROL1B(1)
        ELSE
! i= n_layer-1
          CALL PUSHREAL8ARRAY(p%kb(i), r8/8)
          p%kb(i) = 0.5*p%f_ice(i)*p%ksat(i)*(p%thetab(i)/p%fei(i))**(2.&
&           *p%b(i)+3.)
          CALL PUSHCONTROL1B(0)
        END IF
      END DO
! the unsaturated soil water retention
      DO i=0,p%n_layer-1
        CALL PUSHREAL8ARRAY(p%psim(i), r8/8)
        p%psim(i) = p%psi_sat(i)*(p%thetam(i)/p%fei(i))**(-p%b(i))
        IF (p%psi_sat(i) .LT. p%psim(i)) THEN
          CALL PUSHCONTROL1B(0)
          p%psim(i) = p%psim(i)
        ELSE
          p%psim(i) = p%psi_sat(i)
          CALL PUSHCONTROL1B(1)
        END IF
      END DO
! the unsaturated soil water retention @boundary LHE
      DO i=0,p%n_layer-1
        CALL PUSHREAL8ARRAY(p%psib(i), r8/8)
        p%psib(i) = p%psi_sat(i)*(p%thetab(i)/p%fei(i))**(-(1.*p%b(i)))
        IF (p%psi_sat(i) .LT. p%psib(i)) THEN
          CALL PUSHCONTROL1B(0)
          p%psib(i) = p%psib(i)
        ELSE
          p%psib(i) = p%psi_sat(i)
          CALL PUSHCONTROL1B(1)
        END IF
      END DO
! the unsaturated hydraulic conductivity of soil p%n_layer
      DO i=0,p%n_layer-1
        IF (i .LT. p%n_layer - 1) THEN
! see seller's
          CALL PUSHREAL8ARRAY(p%kk(i), r8/8)
          p%kk(i) = (p%km(i)*p%psim(i)+p%km(i+1)*p%psim(i+1))/(p%psim(i)&
&           +p%psim(i+1))*(p%b(i)+p%b(i+1))/(p%b(i)+p%b(i+1)+6)
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHREAL8ARRAY(p%kk(i), r8/8)
          p%kk(i) = (p%km(i)*p%psim(i)+p%kb(i)*p%psib(i))/(p%psim(i)+p%&
&           psib(i))*p%b(i)/(p%b(i)+3)
          CALL PUSHCONTROL1B(0)
        END IF
      END DO
! Fb flow speed, Dancy's law LHE
      DO i=0,p%n_layer-1
        IF (i .LT. p%n_layer - 1) THEN
! downwards positive , +1 accounts for gravitational drainage LHE
          p%r_waterflow(i) = p%kk(i)*(2*(p%psim(i+1)-p%psim(i))/(p%&
&           d_soil(i)+p%d_soil(i+1))+1)
          CALL PUSHCONTROL1B(1)
        ELSE
! from Ju
          p%r_waterflow(i) = 0.
          CALL PUSHCONTROL1B(0)
        END IF
      END DO
! check the r_waterflow further
      DO i=0,p%n_layer-2
        x1 = (p%fei(i+1)-p%thetam(i+1))*p%d_soil(i+1)/kkstep + p%ett(i+1&
&         )
        IF (x1 .GT. p%r_waterflow(i)) THEN
          p%r_waterflow(i) = p%r_waterflow(i)
          CALL PUSHCONTROL1B(0)
        ELSE
          p%r_waterflow(i) = x1
          CALL PUSHCONTROL1B(1)
        END IF
        IF (p%r_waterflow(i) .GE. 0.) THEN
          abs0 = p%r_waterflow(i)
        ELSE
          abs0 = -p%r_waterflow(i)
        END IF
! find max_Fb for all p%LAYERS
        IF (abs0 .GT. max_fb) THEN
          IF (p%r_waterflow(i) .GE. 0.) THEN
            CALL PUSHCONTROL2B(1)
            max_fb = p%r_waterflow(i)
          ELSE
            CALL PUSHCONTROL2B(2)
            max_fb = -p%r_waterflow(i)
          END IF
        ELSE
          CALL PUSHCONTROL2B(0)
        END IF
      END DO
      IF (max_fb .GT. 1.e-5) THEN
! determine the sub_step according to order of Fb emirically
        CALL PUSHREAL8ARRAY(this_step, r8/8)
        this_step = 1.
        CALL PUSHCONTROL2B(0)
      ELSE IF (max_fb .GT. 1.e-6) THEN
        CALL PUSHREAL8ARRAY(this_step, r8/8)
        this_step = 30.
        CALL PUSHCONTROL2B(1)
      ELSE
!       this_step  = 360.
!!@J.Wang replace 360 by kstep
        CALL PUSHREAL8ARRAY(this_step, r8/8)
        this_step = kkstep
        CALL PUSHCONTROL2B(2)
      END IF
      total_t = total_t + this_step
      IF (total_t .GT. kstep) this_step = this_step - (total_t-kkstep)
      DO i=0,p%n_layer-1
        IF (i .EQ. 0) THEN
          CALL PUSHREAL8ARRAY(p%thetam(i), r8/8)
          p%thetam(i) = p%thetam(i) + (infil*this_step-p%r_waterflow(i)*&
&           this_step-p%ett(i)*this_step)/p%d_soil(i)
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHREAL8ARRAY(p%thetam(i), r8/8)
          p%thetam(i) = p%thetam(i) + (p%r_waterflow(i-1)-p%r_waterflow(&
&           i)-p%ett(i))*this_step/p%d_soil(i)
          CALL PUSHCONTROL1B(0)
        END IF
        IF (p%theta_vwp(i) .LT. p%thetam(i)) THEN
          CALL PUSHCONTROL1B(0)
          p%thetam(i) = p%thetam(i)
        ELSE
          p%thetam(i) = p%theta_vwp(i)
          CALL PUSHCONTROL1B(1)
        END IF
        IF (p%fei(i) .GT. p%thetam(i)) THEN
          CALL PUSHCONTROL1B(0)
          p%thetam(i) = p%thetam(i)
        ELSE
          p%thetam(i) = p%fei(i)
          CALL PUSHCONTROL1B(1)
        END IF
      END DO
      ad_count = ad_count + 1
    END DO
    CALL PUSHINTEGER4(ad_count)
! end do while
    DO i=0,p%n_layer-1
      CALL PUSHREAL8ARRAY(p%ice_ratio(i), r8/8)
      p%ice_ratio(i) = p%ice_ratio(i)*p%thetam_prev(i)/p%thetam(i)
      IF (1.0 .GT. p%ice_ratio(i)) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
    END DO
    DO i=p%n_layer-1,0,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) p_bw%ice_ratio(i) = 0.0_8
      CALL POPREAL8ARRAY(p%ice_ratio(i), r8/8)
      temp_bw4 = p_bw%ice_ratio(i)/p%thetam(i)
      p_bw%ice_ratio(i) = p%thetam_prev(i)*temp_bw4
      p_bw%thetam_prev(i) = p_bw%thetam_prev(i) + p%ice_ratio(i)*&
&       temp_bw4
      p_bw%thetam(i) = p_bw%thetam(i) - p%ice_ratio(i)*p%thetam_prev(i)*&
&       temp_bw4/p%thetam(i)
    END DO
    infil_bw = 0.0_8
    CALL POPINTEGER4(ad_count)
    DO i0=1,ad_count
      DO i=p%n_layer-1,0,-1
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) p_bw%thetam(i) = 0.0_8
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) p_bw%thetam(i) = 0.0_8
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8ARRAY(p%thetam(i), r8/8)
          temp_bw4 = this_step*p_bw%thetam(i)/p%d_soil(i)
          p_bw%r_waterflow(i-1) = p_bw%r_waterflow(i-1) + temp_bw4
          p_bw%r_waterflow(i) = p_bw%r_waterflow(i) - temp_bw4
          p_bw%ett(i) = p_bw%ett(i) - temp_bw4
        ELSE
          CALL POPREAL8ARRAY(p%thetam(i), r8/8)
          temp_bw4 = p_bw%thetam(i)/p%d_soil(i)
          infil_bw = infil_bw + this_step*temp_bw4
          p_bw%r_waterflow(i) = p_bw%r_waterflow(i) - this_step*temp_bw4
          p_bw%ett(i) = p_bw%ett(i) - this_step*temp_bw4
        END IF
      END DO
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8ARRAY(this_step, r8/8)
      ELSE IF (branch .EQ. 1) THEN
        CALL POPREAL8ARRAY(this_step, r8/8)
      ELSE
        CALL POPREAL8ARRAY(this_step, r8/8)
      END IF
      DO i=p%n_layer-2,0,-1
        CALL POPCONTROL2B(branch)
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          x1_bw = 0.0_8
        ELSE
          x1_bw = p_bw%r_waterflow(i)
          p_bw%r_waterflow(i) = 0.0_8
        END IF
        p_bw%thetam(i+1) = p_bw%thetam(i+1) - p%d_soil(i+1)*x1_bw/kkstep
        p_bw%ett(i+1) = p_bw%ett(i+1) + x1_bw
      END DO
      DO i=p%n_layer-1,0,-1
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          p_bw%r_waterflow(i) = 0.0_8
        ELSE
          p_bw%kk(i) = p_bw%kk(i) + (2*(p%psim(i+1)-p%psim(i))/(p%d_soil&
&           (i)+p%d_soil(i+1))+1)*p_bw%r_waterflow(i)
          temp_bw4 = 2*p%kk(i)*p_bw%r_waterflow(i)/(p%d_soil(i)+p%d_soil&
&           (i+1))
          p_bw%r_waterflow(i) = 0.0_8
          p_bw%psim(i+1) = p_bw%psim(i+1) + temp_bw4
          p_bw%psim(i) = p_bw%psim(i) - temp_bw4
        END IF
      END DO
      DO i=p%n_layer-1,0,-1
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8ARRAY(p%kk(i), r8/8)
          temp4 = (p%psim(i)+p%psib(i))*(p%b(i)+3)
          temp3 = p%b(i)/temp4
          temp_bw2 = temp3*p_bw%kk(i)
          temp_bw3 = (p%km(i)*p%psim(i)+p%kb(i)*p%psib(i))*p_bw%kk(i)/&
&           temp4
          p_bw%kk(i) = 0.0_8
          temp_bw4 = -(temp3*temp_bw3)
          p_bw%b(i) = p_bw%b(i) + temp_bw3 + (p%psim(i)+p%psib(i))*&
&           temp_bw4
          temp_bw1 = (p%b(i)+3)*temp_bw4
          p_bw%psim(i) = p_bw%psim(i) + temp_bw1 + p%km(i)*temp_bw2
          p_bw%psib(i) = p_bw%psib(i) + temp_bw1 + p%kb(i)*temp_bw2
          p_bw%km(i) = p_bw%km(i) + p%psim(i)*temp_bw2
          p_bw%kb(i) = p_bw%kb(i) + p%psib(i)*temp_bw2
        ELSE
          CALL POPREAL8ARRAY(p%kk(i), r8/8)
          temp4 = p%b(i) + p%b(i+1) + 6
          temp3 = p%psim(i) + p%psim(i+1)
          temp2 = temp3*temp4
          temp1 = (p%b(i)+p%b(i+1))/temp2
          temp_bw0 = temp1*p_bw%kk(i)
          temp_bw1 = (p%km(i)*p%psim(i)+p%km(i+1)*p%psim(i+1))*p_bw%kk(i&
&           )/temp2
          p_bw%kk(i) = 0.0_8
          temp_bw2 = -(temp1*temp_bw1)
          p_bw%b(i) = p_bw%b(i) + temp_bw1 + temp3*temp_bw2
          p_bw%b(i+1) = p_bw%b(i+1) + temp_bw1 + temp3*temp_bw2
          p_bw%psim(i) = p_bw%psim(i) + temp4*temp_bw2 + p%km(i)*&
&           temp_bw0
          p_bw%psim(i+1) = p_bw%psim(i+1) + temp4*temp_bw2 + p%km(i+1)*&
&           temp_bw0
          p_bw%km(i) = p_bw%km(i) + p%psim(i)*temp_bw0
          p_bw%km(i+1) = p_bw%km(i+1) + p%psim(i+1)*temp_bw0
        END IF
      END DO
      DO i=p%n_layer-1,0,-1
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) p_bw%psib(i) = 0.0_8
        CALL POPREAL8ARRAY(p%psib(i), r8/8)
        temp4 = p%thetab(i)/p%fei(i)
        temp3 = -p%b(i)
        IF (.NOT.(temp4 .LE. 0.0_8 .AND. (temp3 .EQ. 0.0_8 .OR. temp3 &
&           .NE. INT(temp3)))) p_bw%thetab(i) = p_bw%thetab(i) + temp3*&
&           temp4**(temp3-1)*p%psi_sat(i)*p_bw%psib(i)/p%fei(i)
        IF (.NOT.temp4 .LE. 0.0_8) p_bw%b(i) = p_bw%b(i) - temp4**temp3*&
&           LOG(temp4)*p%psi_sat(i)*p_bw%psib(i)
        p_bw%psib(i) = 0.0_8
      END DO
      DO i=p%n_layer-1,0,-1
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) p_bw%psim(i) = 0.0_8
        CALL POPREAL8ARRAY(p%psim(i), r8/8)
        temp4 = p%thetam(i)/p%fei(i)
        temp3 = -p%b(i)
        IF (.NOT.(temp4 .LE. 0.0_8 .AND. (temp3 .EQ. 0.0_8 .OR. temp3 &
&           .NE. INT(temp3)))) p_bw%thetam(i) = p_bw%thetam(i) + temp3*&
&           temp4**(temp3-1)*p%psi_sat(i)*p_bw%psim(i)/p%fei(i)
        IF (.NOT.temp4 .LE. 0.0_8) p_bw%b(i) = p_bw%b(i) - temp4**temp3*&
&           LOG(temp4)*p%psi_sat(i)*p_bw%psim(i)
        p_bw%psim(i) = 0.0_8
      END DO
      DO i=p%n_layer-1,0,-1
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8ARRAY(p%kb(i), r8/8)
          temp4 = 2.*p%b(i) + 3.
          temp3 = p%thetab(i)/p%fei(i)
          temp2 = temp3**temp4
          temp_bw1 = temp2*0.5*p_bw%kb(i)
          temp_bw2 = p%f_ice(i)*p%ksat(i)*0.5*p_bw%kb(i)
          p_bw%kb(i) = 0.0_8
          IF (.NOT.(temp3 .LE. 0.0_8 .AND. (temp4 .EQ. 0.0_8 .OR. temp4 &
&             .NE. INT(temp4)))) p_bw%thetab(i) = p_bw%thetab(i) + temp4&
&             *temp3**(temp4-1)*temp_bw2/p%fei(i)
          IF (.NOT.temp3 .LE. 0.0_8) p_bw%b(i) = p_bw%b(i) + 2.*temp2*&
&             LOG(temp3)*temp_bw2
          p_bw%f_ice(i) = p_bw%f_ice(i) + p%ksat(i)*temp_bw1
          p_bw%ksat(i) = p_bw%ksat(i) + p%f_ice(i)*temp_bw1
        ELSE
          CALL POPREAL8ARRAY(p%kb(i), r8/8)
          temp1 = 2.*p%b(i) + 3.
          temp0 = p%thetab(i)/p%fei(i)
          temp = temp0**temp1
          temp3 = p%f_ice(i)/(p%d_soil(i)+p%d_soil(i+1))
          temp4 = p%d_soil(i)*p%ksat(i) + p%d_soil(i+1)*p%ksat(i+1)
          temp_bw2 = temp*p_bw%kb(i)
          temp_bw = temp4*temp3*p_bw%kb(i)
          p_bw%kb(i) = 0.0_8
          IF (.NOT.(temp0 .LE. 0.0_8 .AND. (temp1 .EQ. 0.0_8 .OR. temp1 &
&             .NE. INT(temp1)))) p_bw%thetab(i) = p_bw%thetab(i) + temp1&
&             *temp0**(temp1-1)*temp_bw/p%fei(i)
          IF (.NOT.temp0 .LE. 0.0_8) p_bw%b(i) = p_bw%b(i) + 2.*temp*LOG&
&             (temp0)*temp_bw
          p_bw%ksat(i) = p_bw%ksat(i) + p%d_soil(i)*temp3*temp_bw2
          p_bw%ksat(i+1) = p_bw%ksat(i+1) + p%d_soil(i+1)*temp3*temp_bw2
          p_bw%f_ice(i) = p_bw%f_ice(i) + temp4*temp_bw2/(p%d_soil(i)+p%&
&           d_soil(i+1))
        END IF
      END DO
      DO 100 i=p%n_layer-1,0,-1
        CALL POPCONTROL2B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8ARRAY(p%thetab(i), r8/8)
          p_bw%thetab(i) = 0.0_8
        ELSE IF (branch .EQ. 1) THEN
          CALL POPREAL8ARRAY(p%thetab(i), r8/8)
        ELSE
          CALL POPREAL8ARRAY(p%thetab(i), r8/8)
          temp_bw1 = p_bw%thetab(i)/(1.0/p%d_soil(i)+1.0/p%d_soil(i+1))
          p_bw%thetab(i) = 0.0_8
          p_bw%thetam(i+1) = p_bw%thetam(i+1) + temp_bw1/p%d_soil(i+1)
          p_bw%thetam(i) = p_bw%thetam(i) + temp_bw1/p%d_soil(i)
          GOTO 100
        END IF
        CALL POPREAL8ARRAY(p%thetab(i), r8/8)
        p_bw%thetam(i) = p_bw%thetam(i) + p_bw%thetab(i)
        d1_bw = p%d_soil(i)*p_bw%thetab(i)/2.
        p_bw%thetab(i) = 0.0_8
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) d1_bw = 0.0_8
        temp_bw1 = 2.*d1_bw/p%d_soil(i)
        p_bw%thetam(i) = p_bw%thetam(i) + temp_bw1
        p_bw%thetab(i-1) = p_bw%thetab(i-1) - temp_bw1
 100  CONTINUE
      DO i=p%n_layer-1,0,-1
        CALL POPREAL8ARRAY(p%km(i), r8/8)
        temp0 = 2.*p%b(i) + 3.
        temp = p%thetam(i)/p%fei(i)
        temp1 = temp**temp0
        p_bw%f_ice(i) = p_bw%f_ice(i) + p%ksat(i)*temp1*p_bw%km(i)
        p_bw%ksat(i) = p_bw%ksat(i) + p%f_ice(i)*temp1*p_bw%km(i)
        temp_bw1 = p%f_ice(i)*p%ksat(i)*p_bw%km(i)
        p_bw%km(i) = 0.0_8
        IF (.NOT.(temp .LE. 0.0_8 .AND. (temp0 .EQ. 0.0_8 .OR. temp0 &
&           .NE. INT(temp0)))) p_bw%thetam(i) = p_bw%thetam(i) + temp0*&
&           temp**(temp0-1)*temp_bw1/p%fei(i)
        IF (.NOT.temp .LE. 0.0_8) p_bw%b(i) = p_bw%b(i) + 2.*temp1*LOG(&
&           temp)*temp_bw1
      END DO
    END DO
    temp_bw0 = kkstep*p%r_drainage*p_bw%zp
    p_bw%zp = temp_bw0/kkstep
    p_bw%r_rain_g = p_bw%r_rain_g + temp_bw0
    infil_bw = infil_bw - temp_bw0
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) infil_bw = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      infil_max_bw = 0.0_8
    ELSE
      infil_max_bw = infil_bw
      infil_bw = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) THEN
      p_bw%f_ice(0) = p_bw%f_ice(0) + (p%zp/kkstep+p%r_rain_g)*infil_bw
      p_bw%zp = p_bw%zp + p%f_ice(0)*infil_bw/kkstep
      p_bw%r_rain_g = p_bw%r_rain_g + p%f_ice(0)*infil_bw
    END IF
    temp_bw = (p%psi_sat(0)*((p%fei(0)-p%thetam_prev(0))*p%b(0)/(p%&
&     d_soil(0)*p%fei(0)))+1.)*infil_max_bw
    temp_bw0 = p%psi_sat(0)*p%f_ice(0)*p%ksat(0)*infil_max_bw/(p%d_soil(&
&     0)*p%fei(0))
    p_bw%thetam_prev(0) = p_bw%thetam_prev(0) - p%b(0)*temp_bw0
    p_bw%b(0) = p_bw%b(0) + (p%fei(0)-p%thetam_prev(0))*temp_bw0
    p_bw%f_ice(0) = p_bw%f_ice(0) + p%ksat(0)*temp_bw
    p_bw%ksat(0) = p_bw%ksat(0) + p%f_ice(0)*temp_bw
    DO i=p%n_layer,0,-1
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        p_bw%temp_soil_c(i) = p_bw%temp_soil_c(i) + 0.9*p_bw%f_ice(i)
        p_bw%f_ice(i) = 0.0_8
      ELSE IF (branch .EQ. 1) THEN
        p_bw%f_ice(i) = 0.0_8
      ELSE
        p_bw%f_ice(i) = 0.0_8
      END IF
    END DO
    DO i=p%n_layer,0,-1
      CALL POPREAL8ARRAY(p%thetam_prev(i), r8/8)
      p_bw%thetam(i) = p_bw%thetam(i) + p_bw%thetam_prev(i)
      p_bw%thetam_prev(i) = 0.0_8
    END DO
  END SUBROUTINE UPDATESOILMOISTURE_BW

!******************************************************
! Soil hydraulic state
!******************************************************
!remove the parameter 'kstep'@J.Wang
  SUBROUTINE UPDATESOILMOISTURE(p)
    IMPLICIT NONE
    TYPE(SOIL) :: p
! infiltration, and Maximum infiltration
    REAL(r8) :: infil, infil_max
    REAL(r8) :: this_step, total_t, max_fb, kkstep
    REAL(r8) :: d1
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC ABS
    REAL(r8) :: x1
    REAL(r8) :: abs0
    kkstep = 1.*kstep
    DO i=0,p%n_layer
!save previous thetam
      p%thetam_prev(i) = p%thetam(i)
    END DO
    DO i=0,p%n_layer
      IF (p%temp_soil_c(i) .GT. 0.0) THEN
!! f_ice should be named as f_water
        p%f_ice(i) = 1.0
      ELSE IF (p%temp_soil_c(i) .LT. -1.) THEN
        p%f_ice(i) = 0.1
      ELSE
        p%f_ice(i) = 0.1 + 0.9*(p%temp_soil_c(i)+1.0)
      END IF
    END DO
!write(*,*) p%f_ice(0),p%Zp,p%r_rain_g
!! juweimin
!! this part solve the upper boundary condition (Infiltration). LHE
!! the maximum Infiltration. The Inf should be changing very fast during precipitation because thetam
!! is changing. LHE
    infil_max = p%f_ice(0)*p%ksat(0)*(1.+(p%fei(0)-p%thetam_prev(0))/p%&
&     d_soil(0)*p%psi_sat(0)*p%b(0)/p%fei(0))
    IF (p%f_ice(0)*(p%zp/kkstep+p%r_rain_g) .LT. 0.) THEN
      infil = 0.
    ELSE
      infil = p%f_ice(0)*(p%zp/kkstep+p%r_rain_g)
    END IF
    IF (infil_max .GT. infil) THEN
      infil = infil
    ELSE
      infil = infil_max
    END IF
    IF (0. .LT. infil) THEN
      infil = infil
    ELSE
      infil = 0.
    END IF
! Ponded water after runoff. This one is related to runoff
    p%zp = (p%zp/kkstep+p%r_rain_g-infil)*kkstep*p%r_drainage
    this_step = 0.
    total_t = 0.
    max_fb = 0.
    DO WHILE (total_t .LT. kkstep)
      DO i=0,p%n_layer-1
        p%km(i) = p%f_ice(i)*p%ksat(i)*(p%thetam(i)/p%fei(i))**(2.*p%b(i&
&         )+3.)
      END DO
      DO i=0,p%n_layer-1
        IF (i .LT. p%n_layer - 1) THEN
          p%thetab(i) = (p%thetam(i+1)/p%d_soil(i+1)+p%thetam(i)/p%&
&           d_soil(i))/(1./p%d_soil(i)+1./p%d_soil(i+1))
        ELSE
          d1 = (p%thetam(i)-p%thetab(i-1))*2./p%d_soil(i)
          IF (d1 .LT. 0.) THEN
            d1 = 0.
          ELSE
            d1 = d1
          END IF
          p%thetab(i) = p%thetam(i) + d1*p%d_soil(i)/2.
          IF (p%thetab(i) .GT. p%fei(i)) THEN
            p%thetab(i) = p%fei(i)
          ELSE
            p%thetab(i) = p%thetab(i)
          END IF
        END IF
      END DO
      DO i=0,p%n_layer-1
        IF (i .LT. p%n_layer - 1) THEN
! the unsaturated hydraulic conductivity at soil lower boundary
!! Note: Kb(0) to Kb(n_layer-1) are not used in the model
          p%kb(i) = p%f_ice(i)*(p%ksat(i)*p%d_soil(i)+p%ksat(i+1)*p%&
&           d_soil(i+1))/(p%d_soil(i)+p%d_soil(i+1))*(p%thetab(i)/p%fei(&
&           i))**(2.*p%b(i)+3.)
        ELSE
! i= n_layer-1
          p%kb(i) = 0.5*p%f_ice(i)*p%ksat(i)*(p%thetab(i)/p%fei(i))**(2.&
&           *p%b(i)+3.)
        END IF
      END DO
! the unsaturated soil water retention
      DO i=0,p%n_layer-1
        p%psim(i) = p%psi_sat(i)*(p%thetam(i)/p%fei(i))**(-p%b(i))
        IF (p%psi_sat(i) .LT. p%psim(i)) THEN
          p%psim(i) = p%psim(i)
        ELSE
          p%psim(i) = p%psi_sat(i)
        END IF
      END DO
! the unsaturated soil water retention @boundary LHE
      DO i=0,p%n_layer-1
        p%psib(i) = p%psi_sat(i)*(p%thetab(i)/p%fei(i))**(-(1.*p%b(i)))
        IF (p%psi_sat(i) .LT. p%psib(i)) THEN
          p%psib(i) = p%psib(i)
        ELSE
          p%psib(i) = p%psi_sat(i)
        END IF
      END DO
! the unsaturated hydraulic conductivity of soil p%n_layer
      DO i=0,p%n_layer-1
        IF (i .LT. p%n_layer - 1) THEN
! see seller's
          p%kk(i) = (p%km(i)*p%psim(i)+p%km(i+1)*p%psim(i+1))/(p%psim(i)&
&           +p%psim(i+1))*(p%b(i)+p%b(i+1))/(p%b(i)+p%b(i+1)+6)
        ELSE
          p%kk(i) = (p%km(i)*p%psim(i)+p%kb(i)*p%psib(i))/(p%psim(i)+p%&
&           psib(i))*p%b(i)/(p%b(i)+3)
        END IF
      END DO
! Fb flow speed, Dancy's law LHE
      DO i=0,p%n_layer-1
        IF (i .LT. p%n_layer - 1) THEN
! downwards positive , +1 accounts for gravitational drainage LHE
          p%r_waterflow(i) = p%kk(i)*(2*(p%psim(i+1)-p%psim(i))/(p%&
&           d_soil(i)+p%d_soil(i+1))+1)
        ELSE
! from Ju
          p%r_waterflow(i) = 0.
        END IF
      END DO
! check the r_waterflow further
      DO i=0,p%n_layer-2
        x1 = (p%fei(i+1)-p%thetam(i+1))*p%d_soil(i+1)/kkstep + p%ett(i+1&
&         )
        IF (x1 .GT. p%r_waterflow(i)) THEN
          p%r_waterflow(i) = p%r_waterflow(i)
        ELSE
          p%r_waterflow(i) = x1
        END IF
        IF (p%r_waterflow(i) .GE. 0.) THEN
          abs0 = p%r_waterflow(i)
        ELSE
          abs0 = -p%r_waterflow(i)
        END IF
! find max_Fb for all p%LAYERS
        IF (abs0 .GT. max_fb) THEN
          IF (p%r_waterflow(i) .GE. 0.) THEN
            max_fb = p%r_waterflow(i)
          ELSE
            max_fb = -p%r_waterflow(i)
          END IF
        END IF
      END DO
      IF (max_fb .GT. 1.e-5) THEN
! determine the sub_step according to order of Fb emirically
        this_step = 1.
      ELSE IF (max_fb .GT. 1.e-6) THEN
        this_step = 30.
      ELSE
!       this_step  = 360.
!!@J.Wang replace 360 by kstep
        this_step = kkstep
      END IF
      total_t = total_t + this_step
      IF (total_t .GT. kstep) this_step = this_step - (total_t-kkstep)
      DO i=0,p%n_layer-1
        IF (i .EQ. 0) THEN
          p%thetam(i) = p%thetam(i) + (infil*this_step-p%r_waterflow(i)*&
&           this_step-p%ett(i)*this_step)/p%d_soil(i)
        ELSE
          p%thetam(i) = p%thetam(i) + (p%r_waterflow(i-1)-p%r_waterflow(&
&           i)-p%ett(i))*this_step/p%d_soil(i)
        END IF
        IF (p%theta_vwp(i) .LT. p%thetam(i)) THEN
          p%thetam(i) = p%thetam(i)
        ELSE
          p%thetam(i) = p%theta_vwp(i)
        END IF
        IF (p%fei(i) .GT. p%thetam(i)) THEN
          p%thetam(i) = p%thetam(i)
        ELSE
          p%thetam(i) = p%fei(i)
        END IF
      END DO
    END DO
! end do while
    DO i=0,p%n_layer-1
      p%ice_ratio(i) = p%ice_ratio(i)*p%thetam_prev(i)/p%thetam(i)
      IF (1.0 .GT. p%ice_ratio(i)) THEN
        p%ice_ratio(i) = p%ice_ratio(i)
      ELSE
        p%ice_ratio(i) = 1.0
      END IF
    END DO
    RETURN
  END SUBROUTINE UPDATESOILMOISTURE

!  Differentiation of soil_water_uptake in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: p.dt p.ett trans_o evap_soil
!                trans_u
!   with respect to varying inputs: p.dt p.ett trans_o evap_soil
!                trans_u
  SUBROUTINE SOIL_WATER_UPTAKE_BW(p, p_bw, trans_o, trans_o_bw, trans_u&
&   , trans_u_bw, evap_soil, evap_soil_bw)
    IMPLICIT NONE
    TYPE(SOIL) :: p
    TYPE(SOIL_DIFF) :: p_bw
    REAL(r8) :: trans_o, trans_u, evap_soil
    REAL(r8) :: trans_o_bw, trans_u_bw, evap_soil_bw
    REAL(r8) :: source
    REAL(r8) :: source_bw
    source = trans_o + trans_u
! for the top layer
!  p%Ett(0) = 0.
! for each layer
    i = p%n_layer
    source_bw = 0.0_8
    DO i=p%n_layer-1,1,-1
      p_bw%dt(i) = p_bw%dt(i) + source*p_bw%ett(i)/rho_w
      source_bw = source_bw + p%dt(i)*p_bw%ett(i)/rho_w
      p_bw%ett(i) = 0.0_8
    END DO
    p_bw%dt(0) = p_bw%dt(0) + source*p_bw%ett(0)/rho_w
    source_bw = source_bw + p%dt(0)*p_bw%ett(0)/rho_w
    evap_soil_bw = evap_soil_bw + p_bw%ett(0)/rho_w
    p_bw%ett(0) = 0.0_8
    trans_o_bw = trans_o_bw + source_bw
    trans_u_bw = trans_u_bw + source_bw
  END SUBROUTINE SOIL_WATER_UPTAKE_BW

  SUBROUTINE SOIL_WATER_UPTAKE(p, trans_o, trans_u, evap_soil)
    IMPLICIT NONE
    TYPE(SOIL) :: p
    REAL(r8) :: trans_o, trans_u, evap_soil
    REAL(r8) :: source
    source = trans_o + trans_u
! for the top layer
    p%ett(0) = source/rho_w*p%dt(0) + evap_soil/rho_w
!  p%Ett(0) = 0.
! for each layer
    DO i=1,p%n_layer-1
      p%ett(i) = source/rho_w*p%dt(i)
    END DO
    RETURN
  END SUBROUTINE SOIL_WATER_UPTAKE

!  Differentiation of soil_water_factor_v2 in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: p.f_soilwater p.dt p.b p.thetam
!                p.temp_soil_p p.psim
!   with respect to varying inputs: p.dt p.b p.thetam p.temp_soil_p
!                p.psim
  SUBROUTINE SOIL_WATER_FACTOR_V2_BW(p, p_bw)
    IMPLICIT NONE
    TYPE(SOIL) :: p
    TYPE(SOIL_DIFF) :: p_bw
    REAL(r8) :: ft(0:max_layers-1), fpsisr(0:max_layers-1)
    REAL(r8) :: ft_bw(0:max_layers-1), fpsisr_bw(0:max_layers-1)
    REAL(r8) :: dtt(0:max_layers-1)
    REAL(r8) :: dtt_bw(0:max_layers-1)
    REAL(r8), SAVE :: t1=-0.02
    REAL(r8), SAVE :: t2=2.0
!--iLab::changed in order to avoid "implicit save" for these variables
! real(r8):: dtt_sum = 0.,fpsisr_sum = 0.
    REAL(r8) :: dtt_sum, fpsisr_sum
    REAL(r8) :: dtt_sum_bw, fpsisr_sum_bw
    INTRINSIC MAX
    INTRINSIC EXP
    REAL(r8) :: temp
    REAL(r8) :: temp0
    INTEGER*4 :: branch
    dtt_sum = 0._8
    fpsisr_sum = 0._8
!! change the rule for updating p%psim @MOUSONG.WU,2018.11
    DO i=0,p%n_layer-1
      IF (p%psi_sat(i) .LT. 1.e-6) THEN
        p%psim(i) = 1.e-6
        CALL PUSHCONTROL1B(0)
      ELSE
        p%psim(i) = p%psi_sat(i)
        CALL PUSHCONTROL1B(1)
      END IF
    END DO
    DO i=0,p%n_layer-1
      IF (p%psim(i) .GT. p%psi_min) THEN
        fpsisr(i) = 1./(1.+((p%psim(i)-p%psi_min)/p%psi_min)**p%alpha)
        CALL PUSHCONTROL1B(0)
      ELSE
        fpsisr(i) = 1.
        CALL PUSHCONTROL1B(1)
      END IF
      IF (p%temp_soil_p(i) .GT. 0.) THEN
        ft(i) = 1. - EXP(t1*p%temp_soil_p(i)**t2)
        CALL PUSHCONTROL1B(0)
      ELSE
        ft(i) = 0.
        CALL PUSHCONTROL1B(1)
      END IF
      CALL PUSHREAL8ARRAY(fpsisr(i), r8/8)
      fpsisr(i) = fpsisr(i)*ft(i)
    END DO
    IF (fw_version .EQ. 1) THEN
      DO i=0,p%n_layer-1
!eq. 14 in Ju 2006
        dtt(i) = p%f_root(i)*fpsisr(i)
      END DO
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
      DO i=0,p%n_layer-1
        dtt(i) = p%f_root(i)
      END DO
    END IF
    DO i=0,p%n_layer-1
      dtt_sum = dtt_sum + dtt(i)
    END DO
    IF (dtt_sum .LT. 1.e-6) THEN
      i = p%n_layer
      DO i=p%n_layer-1,0,-1
        p_bw%dt(i) = 0.0_8
      END DO
      fpsisr_bw = 0.0_8
      dtt_bw = 0.0_8
      dtt_sum_bw = 0.0_8
    ELSE
      DO i=0,p%n_layer-1
        CALL PUSHREAL8ARRAY(p%dt(i), r8/8)
        p%dt(i) = dtt(i)/dtt_sum
        IF (p%dt(i) .LT. 1.e-6) THEN
          p%dt(i) = 1.e-6
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
          p%dt(i) = p%dt(i)
        END IF
      END DO
!if(isnan(p%dt(i))) then
!p%dt(i) = 0.
!write(*,*) p%dt(i)
!end if
      DO i=0,p%n_layer-1
! eq. 12, in Chen 2012 GBC; eq 15 in JU
        fpsisr_sum = fpsisr_sum + fpsisr(i)*p%dt(i)
      END DO
      IF (0.1 .LT. fpsisr_sum) THEN
        fpsisr_sum_bw = p_bw%f_soilwater
      ELSE
        fpsisr_sum_bw = 0.0_8
      END IF
      fpsisr_bw = 0.0_8
      DO i=p%n_layer-1,0,-1
        fpsisr_bw(i) = fpsisr_bw(i) + p%dt(i)*fpsisr_sum_bw
        p_bw%dt(i) = p_bw%dt(i) + fpsisr(i)*fpsisr_sum_bw
      END DO
      dtt_bw = 0.0_8
      dtt_sum_bw = 0.0_8
      DO i=p%n_layer-1,0,-1
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) p_bw%dt(i) = 0.0_8
        CALL POPREAL8ARRAY(p%dt(i), r8/8)
        dtt_bw(i) = dtt_bw(i) + p_bw%dt(i)/dtt_sum
        dtt_sum_bw = dtt_sum_bw - dtt(i)*p_bw%dt(i)/dtt_sum**2
        p_bw%dt(i) = 0.0_8
      END DO
    END IF
    DO i=p%n_layer-1,0,-1
      dtt_bw(i) = dtt_bw(i) + dtt_sum_bw
    END DO
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) THEN
      DO i=p%n_layer-1,0,-1
        fpsisr_bw(i) = fpsisr_bw(i) + p%f_root(i)*dtt_bw(i)
        dtt_bw(i) = 0.0_8
      END DO
    END IF
    ft_bw = 0.0_8
    DO i=p%n_layer-1,0,-1
      CALL POPREAL8ARRAY(fpsisr(i), r8/8)
      ft_bw(i) = ft_bw(i) + fpsisr(i)*fpsisr_bw(i)
      fpsisr_bw(i) = ft(i)*fpsisr_bw(i)
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        IF (.NOT.(p%temp_soil_p(i) .LE. 0.0_8 .AND. (t2 .EQ. 0.0_8 .OR. &
&           t2 .NE. INT(t2)))) p_bw%temp_soil_p(i) = p_bw%temp_soil_p(i)&
&           - t2*p%temp_soil_p(i)**(t2-1)*t1*EXP(t1*p%temp_soil_p(i)**t2&
&           )*ft_bw(i)
        ft_bw(i) = 0.0_8
      ELSE
        ft_bw(i) = 0.0_8
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        temp0 = (p%psim(i)-p%psi_min)/p%psi_min
        temp = temp0**p%alpha + 1.
        IF (.NOT.(temp0 .LE. 0.0_8 .AND. (p%alpha .EQ. 0.0_8 .OR. p%&
&           alpha .NE. INT(p%alpha)))) p_bw%psim(i) = p_bw%psim(i) - p%&
&           alpha*temp0**(p%alpha-1)*fpsisr_bw(i)/(p%psi_min*temp**2)
        fpsisr_bw(i) = 0.0_8
      ELSE
        fpsisr_bw(i) = 0.0_8
      END IF
    END DO
    DO i=p%n_layer-1,0,-1
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        p_bw%psim(i) = 0.0_8
      ELSE
        p_bw%psim(i) = 0.0_8
      END IF
      temp = p%thetam(i)/p%fei(i)
      temp0 = -p%b(i)
      IF (.NOT.(temp .LE. 0.0_8 .AND. (temp0 .EQ. 0.0_8 .OR. temp0 .NE. &
&         INT(temp0)))) p_bw%thetam(i) = p_bw%thetam(i) + temp0*temp**(&
&         temp0-1)*p%psi_sat(i)*p_bw%psim(i)/p%fei(i)
      IF (.NOT.temp .LE. 0.0_8) p_bw%b(i) = p_bw%b(i) - temp**temp0*LOG(&
&         temp)*p%psi_sat(i)*p_bw%psim(i)
      p_bw%psim(i) = 0.0_8
    END DO
  END SUBROUTINE SOIL_WATER_FACTOR_V2_BW

  SUBROUTINE SOIL_WATER_FACTOR_V2(p)
    IMPLICIT NONE
    TYPE(SOIL) :: p
    REAL(r8) :: ft(0:max_layers-1), fpsisr(0:max_layers-1)
    REAL(r8) :: dtt(0:max_layers-1)
    REAL(r8), SAVE :: t1=-0.02
    REAL(r8), SAVE :: t2=2.0
!--iLab::changed in order to avoid "implicit save" for these variables
! real(r8):: dtt_sum = 0.,fpsisr_sum = 0.
    REAL(r8) :: dtt_sum, fpsisr_sum
    INTRINSIC MAX
    INTRINSIC EXP
    dtt_sum = 0._8
    fpsisr_sum = 0._8
!! change the rule for updating p%psim @MOUSONG.WU,2018.11
    DO i=0,p%n_layer-1
      p%psim(i) = p%psi_sat(i)*(p%thetam(i)/p%fei(i))**(-p%b(i))
      IF (p%psi_sat(i) .LT. 1.e-6) THEN
        p%psim(i) = 1.e-6
      ELSE
        p%psim(i) = p%psi_sat(i)
      END IF
    END DO
    DO i=0,p%n_layer-1
      IF (p%psim(i) .GT. p%psi_min) THEN
        fpsisr(i) = 1./(1.+((p%psim(i)-p%psi_min)/p%psi_min)**p%alpha)
      ELSE
        fpsisr(i) = 1.
      END IF
      IF (p%temp_soil_p(i) .GT. 0.) THEN
        ft(i) = 1. - EXP(t1*p%temp_soil_p(i)**t2)
      ELSE
        ft(i) = 0.
      END IF
      fpsisr(i) = fpsisr(i)*ft(i)
    END DO
    IF (fw_version .EQ. 1) THEN
      DO i=0,p%n_layer-1
!eq. 14 in Ju 2006
        dtt(i) = p%f_root(i)*fpsisr(i)
      END DO
    ELSE
      DO i=0,p%n_layer-1
        dtt(i) = p%f_root(i)
      END DO
    END IF
    DO i=0,p%n_layer-1
      dtt_sum = dtt_sum + dtt(i)
    END DO
    IF (dtt_sum .LT. 1.e-6) THEN
      p%f_soilwater = 0.1
      DO i=0,p%n_layer-1
        p%dt(i) = 0.
      END DO
    ELSE
      DO i=0,p%n_layer-1
        p%dt(i) = dtt(i)/dtt_sum
        IF (p%dt(i) .LT. 1.e-6) THEN
          p%dt(i) = 1.e-6
        ELSE
          p%dt(i) = p%dt(i)
        END IF
      END DO
!if(isnan(p%dt(i))) then
!p%dt(i) = 0.
!write(*,*) p%dt(i)
!end if
      DO i=0,p%n_layer-1
! eq. 12, in Chen 2012 GBC; eq 15 in JU
        fpsisr_sum = fpsisr_sum + fpsisr(i)*p%dt(i)
      END DO
      IF (0.1 .LT. fpsisr_sum) THEN
        p%f_soilwater = fpsisr_sum
      ELSE
        p%f_soilwater = 0.1
      END IF
    END IF
    RETURN
  END SUBROUTINE SOIL_WATER_FACTOR_V2

!  Differentiation of soil_evaporation in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: gheat_g density_snow mass_snow_g
!                evapo_soil swc_g temp_g evapo_snow_g percent_snow_g
!                mass_water_g evapo_water_g netrad_g
!   with respect to varying inputs: gheat_g density_snow mass_snow_g
!                depth_water swc_g temp_g mass_water_g netrad_g
  SUBROUTINE SOIL_EVAPORATION_BW(temp_air, temp_g, temp_g_bw, rh_air, &
&   netrad_g, netrad_g_bw, gheat_g, gheat_g_bw, percent_snow_g, &
&   percent_snow_g_bw, depth_water, depth_water_bw, depth_snow, &
&   mass_water_g, mass_water_g_bw, mass_snow_g, mass_snow_g_bw, &
&   density_snow, density_snow_bw, swc_g, swc_g_bw, porosity_g, &
&   evapo_soil, evapo_soil_bw, evapo_water_g, evapo_water_g_bw, &
&   evapo_snow_g, evapo_snow_g_bw)
    IMPLICIT NONE
    REAL(r8), INTENT(IN) :: temp_air, temp_g, rh_air
    REAL(r8) :: temp_g_bw
! net radiation on ground
    REAL(r8), INTENT(IN) :: netrad_g
    REAL(r8) :: netrad_g_bw
! aerodynamic conductantce of heat on ground surface
    REAL(r8), INTENT(IN) :: gheat_g
    REAL(r8) :: gheat_g_bw
    REAL(r8), INTENT(INOUT) :: percent_snow_g
    REAL(r8), INTENT(INOUT) :: percent_snow_g_bw
! depth of water and snow on ground after rainfall/snowfall stage1 befor evap
    REAL(r8), INTENT(INOUT) :: depth_water, depth_snow
    REAL(r8), INTENT(INOUT) :: depth_water_bw
! output after substacting evps
    REAL(r8), INTENT(INOUT) :: mass_water_g, mass_snow_g
    REAL(r8), INTENT(INOUT) :: mass_water_g_bw, mass_snow_g_bw
    REAL(r8), INTENT(IN) :: density_snow
    REAL(r8) :: density_snow_bw
! soil water content (from last step) and porosity on ground
    REAL(r8), INTENT(IN) :: swc_g, porosity_g
    REAL(r8) :: swc_g_bw
    REAL(r8) :: evapo_soil, evapo_water_g, evapo_snow_g
    REAL(r8) :: evapo_soil_bw, evapo_water_g_bw, evapo_snow_g_bw
    REAL(r8) :: density_air_g, cp_air_g, vpd_g, slope_vapor_g, psy_air_g
    REAL(r8) :: cp_air_g_bw, vpd_g_bw, slope_vapor_g_bw
!conductance of water on soil surface
    REAL(r8) :: gwater_g
    REAL(r8) :: gwater_g_bw
    REAL(r8) :: lantent_water, latent_snow
    REAL(r8) :: density_water
    REAL(r8) :: length_step
    INTRINSIC EXP
    INTRINSIC MAX
    INTRINSIC MIN
    REAL(r8) :: temp
    REAL(r8) :: temp0
    REAL(r8) :: temp_bw
    REAL(r8) :: temp_bw0
    REAL(r8) :: temp_bw1
    REAL(r8) :: temp1
    REAL(r8) :: temp_bw2
    REAL(r8) :: temp2
    REAL(r8) :: temp_bw3
    REAL(r8) :: temp_bw4
    INTEGER*4 :: branch
    CALL METEO_PACK(temp_g, rh_air)
    density_air_g = density_air
    cp_air_g = cp_air
    vpd_g = vpd
    slope_vapor_g = slope_vapor
    psy_air_g = psy
    latent_water = (2.501-0.00237*temp_air)*1e6
    latent_snow = 2.83*1e6
    density_water = rho_w
    length_step = kstep
! adjust the rs due to CO2 impacts in non-water-limited areas, according to Yang et al., 2019, Nature Climate Change
! rs = rs_300*(1+S_rs(CO2-300)), rs_300=55 s m-1, S_rs=0.09% ppm-1, Mousong.Wu@2019.04
    IF (swc_g/porosity_g .LT. 0.5) THEN
      gwater_g = 1./(4.0*EXP(8.2-4.2*swc_g/porosity_g))
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
      gwater_g = 1./(55*(1+0.09/100.0*(co2_air-300.)))
    END IF
! get the percentage of snow
    IF (depth_snow .GT. 0.02) THEN
      CALL PUSHREAL8ARRAY(percent_snow_g, r8/8)
      percent_snow_g = 1.
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHREAL8ARRAY(percent_snow_g, r8/8)
      percent_snow_g = mass_snow_g/(0.025*density_snow)
      CALL PUSHCONTROL1B(0)
    END IF
    IF (percent_snow_g .LT. 0.) THEN
      percent_snow_g = 0.
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
      percent_snow_g = percent_snow_g
    END IF
    IF (percent_snow_g .GT. 1.) THEN
      percent_snow_g = 1.
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
      percent_snow_g = percent_snow_g
    END IF
! when there are pond water on ground, there is evaporation from the water
    IF (depth_water .GT. 0 .AND. depth_snow .EQ. 0) THEN
      evapo_water_g = 1./latent_water*(slope_vapor_g*(netrad_g*0.8-0)+&
&       density_air_g*cp_air_g*vpd_g*gheat_g)/(slope_vapor_g+psy_air_g*(&
&       1+gheat_g/0.01))
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
      evapo_water_g = 0
    END IF
    IF (0. .LT. evapo_water_g) THEN
      CALL PUSHCONTROL1B(0)
      evapo_water_g = evapo_water_g
    ELSE
      evapo_water_g = 0.
      CALL PUSHCONTROL1B(1)
    END IF
    IF (evapo_water_g .GT. 0) THEN
      IF (evapo_water_g .GT. depth_water*density_water/length_step) THEN
        evapo_water_g = depth_water*density_water/length_step
        CALL PUSHCONTROL2B(2)
      ELSE
        evapo_water_g = evapo_water_g
        CALL PUSHCONTROL2B(1)
      END IF
    ELSE
      CALL PUSHCONTROL2B(0)
    END IF
    depth_water = depth_water - evapo_water_g/density_water*length_step
    IF (0. .LT. depth_water) THEN
      depth_water = depth_water
    ELSE
      depth_water = 0.
    END IF
! when there are snow on ground, there s ony evaporation from the snow
    IF (depth_snow .GT. 0) THEN
      evapo_snow_g = 1./latent_snow*(slope_vapor_g*(netrad_g*0.8-0)+&
&       density_air_g*cp_air_g*vpd_g*gheat_g)/(slope_vapor_g+psy_air_g*(&
&       1+gheat_g/0.01))*percent_snow_g
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
      evapo_snow_g = 0
    END IF
    IF (0. .LT. evapo_snow_g) THEN
      CALL PUSHCONTROL1B(0)
      evapo_snow_g = evapo_snow_g
    ELSE
      evapo_snow_g = 0.
      CALL PUSHCONTROL1B(1)
    END IF
    IF (evapo_snow_g .GT. 0) THEN
      IF (evapo_snow_g .GT. mass_snow_g/length_step) THEN
        evapo_snow_g = mass_snow_g/length_step
        CALL PUSHCONTROL2B(2)
      ELSE
        CALL PUSHCONTROL2B(1)
        evapo_snow_g = evapo_snow_g
      END IF
    ELSE
      CALL PUSHCONTROL2B(0)
    END IF
    CALL PUSHREAL8ARRAY(mass_snow_g, r8/8)
    mass_snow_g = mass_snow_g - evapo_snow_g*length_step
    IF (mass_snow_g .LT. 0.) THEN
      mass_snow_g = 0.
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
      mass_snow_g = mass_snow_g
    END IF
    IF (mass_snow_g .GT. 0) THEN
      depth_snow = depth_snow - evapo_snow_g/density_snow*length_step
    ELSE
      depth_snow = 0
    END IF
    IF (depth_water .GT. 0 .OR. depth_snow .GT. 0) THEN
      vpd_g_bw = 0.0_8
      slope_vapor_g_bw = 0.0_8
      cp_air_g_bw = 0.0_8
      gwater_g_bw = 0.0_8
    ELSE
      evapo_soil = (1.-percent_snow_g)*1/latent_water*(slope_vapor_g*(&
&       netrad_g-0)+density_air_g*cp_air_g*vpd_g*gheat_g)/(slope_vapor_g&
&       +psy_air_g*(1+gheat_g/gwater_g))
      IF (0. .GE. evapo_soil) evapo_soil_bw = 0.0_8
      temp2 = latent_water*(slope_vapor_g+psy_air_g*(gheat_g/gwater_g+1)&
&       )
      temp1 = (-percent_snow_g+1.)/temp2
      temp_bw1 = temp1*evapo_soil_bw
      temp_bw2 = (slope_vapor_g*netrad_g+density_air_g*(cp_air_g*vpd_g*&
&       gheat_g))*evapo_soil_bw/temp2
      percent_snow_g_bw = percent_snow_g_bw - temp_bw2
      temp_bw0 = -(latent_water*temp1*temp_bw2)
      slope_vapor_g_bw = temp_bw0 + netrad_g*temp_bw1
      temp_bw4 = psy_air_g*temp_bw0/gwater_g
      gwater_g_bw = -(gheat_g*temp_bw4/gwater_g)
      netrad_g_bw = netrad_g_bw + slope_vapor_g*temp_bw1
      temp_bw = density_air_g*temp_bw1
      gheat_g_bw = gheat_g_bw + temp_bw4 + cp_air_g*vpd_g*temp_bw
      cp_air_g_bw = vpd_g*gheat_g*temp_bw
      vpd_g_bw = cp_air_g*gheat_g*temp_bw
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) mass_snow_g_bw = 0.0_8
    CALL POPREAL8ARRAY(mass_snow_g, r8/8)
    evapo_snow_g_bw = evapo_snow_g_bw - length_step*mass_snow_g_bw
    CALL POPCONTROL2B(branch)
    IF (branch .NE. 0) THEN
      IF (branch .NE. 1) THEN
        mass_snow_g_bw = mass_snow_g_bw + evapo_snow_g_bw/length_step
        evapo_snow_g_bw = 0.0_8
      END IF
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) evapo_snow_g_bw = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) THEN
      temp1 = latent_snow*(slope_vapor_g+psy_air_g*(gheat_g/0.01+1))
      temp_bw1 = percent_snow_g*evapo_snow_g_bw/temp1
      temp_bw0 = (slope_vapor_g*(0.8*netrad_g)+density_air_g*(cp_air_g*&
&       vpd_g*gheat_g))*evapo_snow_g_bw/temp1
      percent_snow_g_bw = percent_snow_g_bw + temp_bw0
      temp_bw3 = -(latent_snow*percent_snow_g*temp_bw0/temp1)
      slope_vapor_g_bw = slope_vapor_g_bw + temp_bw3 + 0.8*netrad_g*&
&       temp_bw1
      netrad_g_bw = netrad_g_bw + 0.8*slope_vapor_g*temp_bw1
      temp_bw = density_air_g*temp_bw1
      gheat_g_bw = gheat_g_bw + psy_air_g*temp_bw3/0.01 + cp_air_g*vpd_g&
&       *temp_bw
      cp_air_g_bw = cp_air_g_bw + vpd_g*gheat_g*temp_bw
      vpd_g_bw = vpd_g_bw + cp_air_g*gheat_g*temp_bw
    END IF
    evapo_water_g_bw = evapo_water_g_bw - length_step*mass_water_g_bw
    CALL POPCONTROL2B(branch)
    IF (branch .EQ. 0) THEN
      depth_water_bw = 0.0_8
    ELSE IF (branch .EQ. 1) THEN
      depth_water_bw = 0.0_8
    ELSE
      depth_water_bw = density_water*evapo_water_g_bw/length_step
      evapo_water_g_bw = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) evapo_water_g_bw = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) THEN
      temp0 = latent_water*(slope_vapor_g+psy_air_g*(gheat_g/0.01+1))
      temp_bw0 = evapo_water_g_bw/temp0
      netrad_g_bw = netrad_g_bw + 0.8*slope_vapor_g*temp_bw0
      temp_bw1 = density_air_g*temp_bw0
      temp_bw2 = -(latent_water*(slope_vapor_g*(0.8*netrad_g)+&
&       density_air_g*(cp_air_g*vpd_g*gheat_g))*temp_bw0/temp0)
      slope_vapor_g_bw = slope_vapor_g_bw + 0.8*netrad_g*temp_bw0 + &
&       temp_bw2
      gheat_g_bw = gheat_g_bw + psy_air_g*temp_bw2/0.01 + cp_air_g*vpd_g&
&       *temp_bw1
      cp_air_g_bw = cp_air_g_bw + vpd_g*gheat_g*temp_bw1
      vpd_g_bw = vpd_g_bw + cp_air_g*gheat_g*temp_bw1
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) percent_snow_g_bw = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) percent_snow_g_bw = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8ARRAY(percent_snow_g, r8/8)
      temp_bw = percent_snow_g_bw/(0.025*density_snow)
      mass_snow_g_bw = mass_snow_g_bw + temp_bw
      density_snow_bw = density_snow_bw - mass_snow_g*temp_bw/&
&       density_snow
    ELSE
      CALL POPREAL8ARRAY(percent_snow_g, r8/8)
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      temp = -(4.2*swc_g/porosity_g) + 8.2
      temp0 = 4.0*EXP(temp)
      swc_g_bw = swc_g_bw + 4.2*EXP(temp)*4.0*gwater_g_bw/(porosity_g*&
&       temp0**2)
    END IF
    slope_vapor_bw = slope_vapor_g_bw
    vpd_bw = vpd_g_bw
    cp_air_bw = cp_air_g_bw
    CALL METEO_PACK_BW(temp_g, temp_g_bw, rh_air)
  END SUBROUTINE SOIL_EVAPORATION_BW

  SUBROUTINE SOIL_EVAPORATION(temp_air, temp_g, rh_air, netrad_g, &
&   gheat_g, percent_snow_g, depth_water, depth_snow, mass_water_g, &
&   mass_snow_g, density_snow, swc_g, porosity_g, evapo_soil, &
&   evapo_water_g, evapo_snow_g)
    IMPLICIT NONE
    REAL(r8), INTENT(IN) :: temp_air, temp_g, rh_air
! net radiation on ground
    REAL(r8), INTENT(IN) :: netrad_g
! aerodynamic conductantce of heat on ground surface
    REAL(r8), INTENT(IN) :: gheat_g
    REAL(r8), INTENT(INOUT) :: percent_snow_g
! depth of water and snow on ground after rainfall/snowfall stage1 befor evap
    REAL(r8), INTENT(INOUT) :: depth_water, depth_snow
! output after substacting evps
    REAL(r8), INTENT(INOUT) :: mass_water_g, mass_snow_g
    REAL(r8), INTENT(IN) :: density_snow
! soil water content (from last step) and porosity on ground
    REAL(r8), INTENT(IN) :: swc_g, porosity_g
    REAL(r8), INTENT(OUT) :: evapo_soil, evapo_water_g, evapo_snow_g
    REAL(r8) :: density_air_g, cp_air_g, vpd_g, slope_vapor_g, psy_air_g
!conductance of water on soil surface
    REAL(r8) :: gwater_g
    REAL(r8) :: lantent_water, latent_snow
    REAL(r8) :: density_water
    REAL(r8) :: length_step
    INTRINSIC EXP
    INTRINSIC MAX
    INTRINSIC MIN
    CALL METEO_PACK(temp_g, rh_air)
    density_air_g = density_air
    cp_air_g = cp_air
    vpd_g = vpd
    slope_vapor_g = slope_vapor
    psy_air_g = psy
    latent_water = (2.501-0.00237*temp_air)*1e6
    latent_snow = 2.83*1e6
    density_water = rho_w
    length_step = kstep
! adjust the rs due to CO2 impacts in non-water-limited areas, according to Yang et al., 2019, Nature Climate Change
! rs = rs_300*(1+S_rs(CO2-300)), rs_300=55 s m-1, S_rs=0.09% ppm-1, Mousong.Wu@2019.04
    IF (swc_g/porosity_g .LT. 0.5) THEN
      gwater_g = 1./(4.0*EXP(8.2-4.2*swc_g/porosity_g))
    ELSE
      gwater_g = 1./(55*(1+0.09/100.0*(co2_air-300.)))
    END IF
! get the percentage of snow
    IF (depth_snow .GT. 0.02) THEN
      percent_snow_g = 1.
    ELSE
      percent_snow_g = mass_snow_g/(0.025*density_snow)
    END IF
    IF (percent_snow_g .LT. 0.) THEN
      percent_snow_g = 0.
    ELSE
      percent_snow_g = percent_snow_g
    END IF
    IF (percent_snow_g .GT. 1.) THEN
      percent_snow_g = 1.
    ELSE
      percent_snow_g = percent_snow_g
    END IF
! when there are pond water on ground, there is evaporation from the water
    IF (depth_water .GT. 0 .AND. depth_snow .EQ. 0) THEN
      evapo_water_g = 1./latent_water*(slope_vapor_g*(netrad_g*0.8-0)+&
&       density_air_g*cp_air_g*vpd_g*gheat_g)/(slope_vapor_g+psy_air_g*(&
&       1+gheat_g/0.01))
    ELSE
      evapo_water_g = 0
    END IF
    IF (0. .LT. evapo_water_g) THEN
      evapo_water_g = evapo_water_g
    ELSE
      evapo_water_g = 0.
    END IF
    IF (evapo_water_g .GT. 0) THEN
      IF (evapo_water_g .GT. depth_water*density_water/length_step) THEN
        evapo_water_g = depth_water*density_water/length_step
      ELSE
        evapo_water_g = evapo_water_g
      END IF
    END IF
    depth_water = depth_water - evapo_water_g/density_water*length_step
    IF (0. .LT. depth_water) THEN
      depth_water = depth_water
    ELSE
      depth_water = 0.
    END IF
    mass_water_g = mass_water_g - evapo_water_g*length_step
! when there are snow on ground, there s ony evaporation from the snow
    IF (depth_snow .GT. 0) THEN
      evapo_snow_g = 1./latent_snow*(slope_vapor_g*(netrad_g*0.8-0)+&
&       density_air_g*cp_air_g*vpd_g*gheat_g)/(slope_vapor_g+psy_air_g*(&
&       1+gheat_g/0.01))*percent_snow_g
    ELSE
      evapo_snow_g = 0
    END IF
    IF (0. .LT. evapo_snow_g) THEN
      evapo_snow_g = evapo_snow_g
    ELSE
      evapo_snow_g = 0.
    END IF
    IF (evapo_snow_g .GT. 0) THEN
      IF (evapo_snow_g .GT. mass_snow_g/length_step) THEN
        evapo_snow_g = mass_snow_g/length_step
      ELSE
        evapo_snow_g = evapo_snow_g
      END IF
    END IF
    mass_snow_g = mass_snow_g - evapo_snow_g*length_step
    IF (mass_snow_g .LT. 0.) THEN
      mass_snow_g = 0.
    ELSE
      mass_snow_g = mass_snow_g
    END IF
    IF (mass_snow_g .GT. 0) THEN
      depth_snow = depth_snow - evapo_snow_g/density_snow*length_step
    ELSE
      depth_snow = 0
    END IF
    IF (depth_water .GT. 0 .OR. depth_snow .GT. 0) THEN
      evapo_soil = 0
    ELSE
      evapo_soil = (1.-percent_snow_g)*1/latent_water*(slope_vapor_g*(&
&       netrad_g-0)+density_air_g*cp_air_g*vpd_g*gheat_g)/(slope_vapor_g&
&       +psy_air_g*(1+gheat_g/gwater_g))
      IF (0. .LT. evapo_soil) THEN
        evapo_soil = evapo_soil
      ELSE
        evapo_soil = 0.
      END IF
    END IF
    RETURN
  END SUBROUTINE SOIL_EVAPORATION

END MODULE BEPS_SOILMOD_DIFF

MODULE ECORESPMOD_DIFF
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE BEPS_PAR
  USE MID_RESULTS_DIFF
  IMPLICIT NONE
  REAL(r8), PARAMETER :: sec_per_day=86400.

CONTAINS
  SUBROUTINE PLANT_RESP(f_q10, lc, mid_res, lai_yr, lai, temp_air, &
&   temp_soil, coszs)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: lc
    TYPE(RESULTS), INTENT(INOUT) :: mid_res
    REAL(r8), INTENT(IN) :: f_q10, lai_yr
    REAL(r8), INTENT(IN) :: lai, temp_air, temp_soil, coszs
    REAL(r8), SAVE :: temp_opt25=25.0
    REAL(r8) :: biomass, biomass_leaf_o, biomass_stem_o, biomass_root_o&
&   , biomass_leaf_u, biomass_stem_u, biomass_root_u
    REAL(r8) :: respir_croot_o, respir_root_o, respir_stem_o, &
&   respir_leaf_o
    REAL(r8) :: respir_croot_u, respir_root_u, respir_stem_u, &
&   respir_leaf_u
    REAL(r8) :: q10
    REAL(r8) :: exponent1
    REAL(r8) :: lai_u, lai_max_o, lai_max_u
    REAL(r8) :: ra
    REAL(r8) :: coef_leaf_respir, coef_stem_respir, coef_root_respir, &
&   coef_fineroot_respir
    REAL(r8) :: gpp_o, gpp_u, gpp_r, rg, ratio_froot
    INTRINSIC EXP
    INTRINSIC MAX
    INTRINSIC MIN
    IF ((lc .EQ. 25 .OR. lc .EQ. 40) .OR. lc .EQ. 41) THEN
      lai_u = 0.01
    ELSE
      lai_u = 1.18*EXP(-(0.99*lai))
    END IF
    IF (lai_u .GT. lai) lai_u = 0.01
    IF (lc .EQ. 6) THEN
      ra = 0.6
    ELSE
      ra = 1.0
    END IF
! f_q10 default value 0.046
    q10 = 3.22 - f_q10*temp_air
    IF (lc .GE. 1 .AND. lc .LE. 5) THEN
!
      biomass = 0.9097*lai_yr + 0.125*lai_yr*lai_yr
!
      biomass_leaf_o = 0.05*biomass
!
      biomass_stem_o = 0.95*biomass
      biomass_root_o = 0.454*biomass
!
!
      biomass_leaf_u = 0.3*biomass_leaf_o
!
      biomass_stem_u = 0.02*biomass_stem_o
!
      biomass_root_u = 0.05*biomass_root_o
!
      coef_leaf_respir = 0.0015/sec_per_day
!
      coef_stem_respir = 0.0020/sec_per_day
!
      coef_root_respir = 0.0020/sec_per_day
!
      coef_fineroot_respir = 0.003/sec_per_day
! 
      lai_max_o = 4.5
! 
      lai_max_u = 2.4
    ELSE IF (lc .EQ. 6 .OR. lc .EQ. 9) THEN
!!
      biomass = 1.545*lai_yr + 0.183*lai_yr*lai_yr
!
      biomass_leaf_o = 0.04*biomass
!
      biomass_stem_o = 0.96*biomass
!
      biomass_root_o = 1.432*biomass**0.639
!
      biomass_leaf_u = 0.3*biomass_leaf_o
!
      biomass_stem_u = 0.01*biomass_stem_o
!
      biomass_root_u = 0.01*biomass_root_o
!
      coef_leaf_respir = 0.015/sec_per_day
!
      coef_stem_respir = 0.0035/sec_per_day
!
      coef_root_respir = 0.0025/sec_per_day
!
      coef_fineroot_respir = 0.003/sec_per_day
!
      lai_max_o = 4.5
!
      lai_max_u = 2.4
    ELSE IF (lc .EQ. 10) THEN
      biomass = 1.227*lai_yr + 0.154*lai_yr*lai_yr
      biomass_leaf_o = 0.045*biomass
      biomass_stem_o = 0.95*biomass
      biomass_root_o = (0.454*biomass+1.432*biomass**0.639)/2.
      biomass_leaf_u = 0.3*biomass_leaf_o
      biomass_stem_u = 0.015*biomass_stem_o
      biomass_root_u = 0.03*biomass_root_o
      coef_leaf_respir = 0.008/sec_per_day
      coef_stem_respir = 0.0028/sec_per_day
      coef_root_respir = 0.0023/sec_per_day
      coef_fineroot_respir = 0.003/sec_per_day
      lai_max_o = 4.5
      lai_max_u = 2.4
    ELSE IF (lc .EQ. 13) THEN
      biomass = 1.545*lai_yr + 0.183*lai_yr*lai_yr
!
      biomass_leaf_o = 0.1*biomass
!
      biomass_stem_o = 0.90*biomass
!
      biomass_root_o = 1.432*biomass**0.639
!
      biomass_leaf_u = 0.3*biomass_leaf_o
! 
      biomass_stem_u = 0.01*biomass_stem_o
!
      biomass_root_u = 0.01*biomass_root_o
!
      coef_leaf_respir = 0.001/sec_per_day
!
      coef_stem_respir = 0.002/sec_per_day
!
      coef_root_respir = 0.0015/sec_per_day
!
      coef_fineroot_respir = 0.003/sec_per_day
! 
      lai_max_o = 3.3
!
      lai_max_u = 0.01
    ELSE IF ((((lc .EQ. 14 .OR. lc .EQ. 15) .OR. lc .EQ. 25) .OR. lc &
&       .EQ. 40) .OR. lc .EQ. 41) THEN
! 
      biomass_leaf_o = 0.05*lai_yr
!
      biomass_stem_o = 0.0
!
      biomass_root_o = 0.061*lai_yr
      biomass_leaf_u = 0.0
      biomass_stem_u = 0.0
      biomass_root_u = 0.0
      coef_leaf_respir = 0.001/sec_per_day
!
      coef_stem_respir = 0.002/sec_per_day
!
      coef_root_respir = 0.0015/sec_per_day
!
      coef_fineroot_respir = 0.003/sec_per_day
!  
      lai_max_o = 3.3
!  !
      lai_max_u = 0.01
    END IF
!! calculation for overstorey
! stem maintenance respiration
    exponent1 = (temp_air-temp_opt25)/10.0
    respir_stem_o = biomass_stem_o*0.35/(biomass_stem_o+0.35)*&
&     coef_stem_respir*q10**exponent1*ra
    IF (respir_stem_o .LT. 0.0) THEN
      respir_stem_o = 0.0
    ELSE
      respir_stem_o = respir_stem_o
    END IF
! root maintenance
    exponent1 = (temp_soil-temp_opt25)/10.0
    IF ((((lc .EQ. 14 .OR. lc .EQ. 15) .OR. lc .EQ. 25) .OR. lc .EQ. 40)&
&       .OR. lc .EQ. 41) THEN
      respir_root_o = biomass_root_o*coef_root_respir*q10**exponent1*ra
    ELSE
      ratio_froot = EXP(1.007)*biomass_root_o**(-0.841)
      IF (0.9 .GT. ratio_froot) THEN
        ratio_froot = ratio_froot
      ELSE
        ratio_froot = 0.9
      END IF
!
      respir_croot_o = 0.05*biomass_root_o*(1-ratio_froot)*&
&       coef_root_respir*q10**exponent1
! 
      respir_root_o = respir_croot_o + 0.05*biomass_root_o*ratio_froot*&
&       coef_fineroot_respir*q10**exponent1
    END IF
    IF (respir_root_o .LT. 0.0) THEN
      respir_root_o = 0.0
    ELSE
      respir_root_o = respir_root_o
    END IF
!
    IF (coszs .GT. 0.01) THEN
      respir_leaf_o = 0
    ELSE
      exponent1 = (temp_air-temp_opt25)/10.0
!kgC/m2/s
      respir_leaf_o = lai/lai_max_o*biomass_leaf_o*coef_leaf_respir*q10&
&       **exponent1*ra
    END IF
    IF (respir_leaf_o .LT. 0.0) THEN
      respir_leaf_o = 0.0
    ELSE
      respir_leaf_o = respir_leaf_o
    END IF
!   
!kgC/m2/s
    gpp_o = mid_res%gpp_o_sunlit + mid_res%gpp_o_shaded
    gpp_r = gpp_o - (respir_leaf_o+respir_stem_o+respir_root_o)
    IF (gpp_r .LE. 0) THEN
      rg = 0.
    ELSE
      rg = 0.35*gpp_r
    END IF
!mid_res%npp_o  = gpp_r - rg    !kgC/m2/s
!kgC/m2/s @J.Wang
    mid_res%npp_o = gpp_o*0.45
!! calculation for understorey
! 
    exponent1 = (temp_air-temp_opt25)/10.0
    respir_stem_u = biomass_stem_u*0.35/(biomass_stem_u+0.35)*&
&     coef_stem_respir*q10**exponent1*ra
    IF (respir_stem_u .LT. 0.0) THEN
      respir_stem_u = 0.0
    ELSE
      respir_stem_u = respir_stem_u
    END IF
!
    exponent1 = (temp_soil-temp_opt25)/10.0
    IF ((((lc .EQ. 14 .OR. lc .EQ. 15) .OR. lc .EQ. 25) .OR. lc .EQ. 40)&
&       .OR. lc .EQ. 41) THEN
      respir_root_u = biomass_root_u*coef_root_respir*q10**exponent1*ra
    ELSE
      ratio_froot = EXP(1.007)*biomass_root_u**(-0.841)
      IF (0.9 .GT. ratio_froot) THEN
        ratio_froot = ratio_froot
      ELSE
        ratio_froot = 0.9
      END IF
      respir_croot_u = 0.05*biomass_root_u*(1-ratio_froot)*&
&       coef_root_respir*q10**exponent1
      respir_root_u = respir_croot_u + 0.05*biomass_root_u*ratio_froot*&
&       coef_fineroot_respir*q10**exponent1
    END IF
    IF (respir_root_u .LT. 0.0) THEN
      respir_root_u = 0.0
    ELSE
      respir_root_u = respir_root_u
    END IF
    IF (coszs .GT. 0.01) THEN
      respir_leaf_u = 0
    ELSE
      exponent1 = (temp_air-temp_opt25)/10.0
      respir_leaf_u = lai_u/lai_max_u*biomass_leaf_u*coef_leaf_respir*&
&       q10**exponent1*ra*0.5
    END IF
    IF (respir_leaf_u .LT. 0.0) THEN
      respir_leaf_u = 0.0
    ELSE
      respir_leaf_u = respir_leaf_u
    END IF
!!
    gpp_u = mid_res%gpp_u_sunlit + mid_res%gpp_u_shaded
    gpp_r = gpp_u - (respir_leaf_u+respir_stem_u+respir_root_u)
    IF (gpp_r .LE. 0) THEN
      rg = 0
    ELSE
      rg = 0.35*gpp_r
    END IF
!mid_res%npp_u = gpp_r - rg  !kgC/m2/s
!kgC/m2/s
    mid_res%npp_u = gpp_u*0.45
    mid_res%npp = mid_res%npp_u + mid_res%npp_o
  END SUBROUTINE PLANT_RESP

  SUBROUTINE SOIL_RESP(ccd, cssd, csmd, cfsd, cfmd, csm, cm, cs, cp, &
&   npp_yr, coef, soiltype, soilp, mid_res)
    USE BEPS_SOILMOD_DIFF
    USE BEPS_PAR
    IMPLICIT NONE
    REAL(r8), INTENT(INOUT) :: ccd(0:4), cssd(0:4), csmd(0:4), cfsd(0:4)&
&   , cfmd(0:4), csm(0:4), cm(0:4), cs(0:4), cp(0:4)
    REAL(r8), INTENT(IN) :: npp_yr
    REAL(r8), INTENT(IN) :: coef(0:49)
    INTEGER, INTENT(IN) :: soiltype
    TYPE(SOIL), INTENT(IN) :: soilp
    TYPE(RESULTS), INTENT(INOUT) :: mid_res
    REAL(r8) :: fw, fcr, fl, ffr, kw_cd, kcr_cd, kl_sl, kfr_fl, km_p, &
&   ks_p
    REAL(r8) :: kssd_a, kssd_sm, kssd_s, ksmd_a, ksmd_sm, kfsd_a, kfsd_m&
&   , kfsd_s, kfmd_a, kfmd_m
    REAL(r8) :: kcd_a, kcd_m
    REAL(r8) :: kcd_s, ksm_a, ksm_s, km_a, km_s, ks_a, ks_m, kp_a, kp_m
    REAL(r8) :: cw(0:9), ccr(0:9), cl(0:9), cfr(0:9), dcw(0:9), dccr(0:9&
&   ), dcl(0:9), dcfr(0:9)
    REAL(r8) :: dccd(0:9), dcssd(0:9), dcsmd(0:9), dcfsd(0:9), dcfmd(0:9&
&   ), dcsm(0:9), dcm(0:9), dcs(0:9), dcp(0:9)
    REAL(r8) :: part1, part2
    REAL(r8) :: fm(0:9), npp
    REAL(r8) :: lambda(0:layer), lambda_t(0:layer), lambda_w(0:layer)
    REAL(r8) :: lam_u, lam_d
    INTEGER :: ii
    INTRINSIC EXP
    INTRINSIC MIN
    INTRINSIC MAX
    DO ii=1,layer
      IF (308.56*(1/(35.0+46.032)-1/(46.032+soilp%temp_soil_c(ii-1))) &
&         .LT. -2.3) THEN
!! to get rid of enormous value @MOUSONG.WU
        lambda_t(ii) = 0.1
      ELSE IF (308.56*(1/(35.0+46.032)-1/(46.032+soilp%temp_soil_c(ii-1)&
&         )) .GT. 0.) THEN
        lambda_t(ii) = 1.
      ELSE
! Arrenius Equation
        lambda_t(ii) = EXP(308.56*(1/(35.0+46.032)-1/(46.032+soilp%&
&         temp_soil_c(ii-1))))
      END IF
      IF (1.0 .GT. lambda_t(ii)) THEN
        lambda_t(ii) = lambda_t(ii)
      ELSE
        lambda_t(ii) = 1.0
      END IF
      IF (0.3 .LT. lambda_t(ii)) THEN
        lambda_t(ii) = lambda_t(ii)
      ELSE
        lambda_t(ii) = 0.3
      END IF
    END DO
    DO ii=1,layer
      IF (soiltype .GE. 6) THEN
        lambda_w(ii) = 5.44*soilp%thetam(ii-1)/soilp%fei(ii-1) - 5.03*(&
&         soilp%thetam(ii-1)/soilp%fei(ii-1))**2 - 0.472
      ELSE
        lambda_w(ii) = 5.63*soilp%thetam(ii-1)/soilp%fei(ii-1) - 4.64*(&
&         soilp%thetam(ii-1)/soilp%fei(ii-1))**2 - 0.710
      END IF
      IF (0.3 .LT. lambda_w(ii)) THEN
        lambda_w(ii) = lambda_w(ii)
      ELSE
        lambda_w(ii) = 0.3
      END IF
    END DO
    DO ii=1,layer
      lambda(ii) = lambda_t(ii)*lambda_w(ii)
    END DO
! for surface pool
    lam_u = lambda(1)
! for soil pool
    lam_d = lambda(2)
    fw = coef(0)
    fcr = coef(1)
    fl = coef(2)
    ffr = coef(3)
! units?? @J.Wang
    kw_cd = coef(4)/8760
    kcr_cd = coef(5)/8760
    kl_sl = coef(6)/8760
    kfr_fl = coef(7)/8760
    kssd_a = coef(8)/8760
    kssd_sm = coef(9)/8760
    kssd_s = coef(10)/8760
    ksmd_a = coef(11)/8760
    ksmd_sm = coef(12)/8760
    kfsd_a = coef(13)/8760
    kfsd_m = coef(14)/8760
    kfsd_s = coef(15)/8760
    kfmd_a = coef(16)/8760
    kfmd_m = coef(17)/8760
    kcd_a = coef(18)/8760
    kcd_m = coef(19)/8760
    kcd_s = coef(20)/8760
    km_a = coef(21)/8760
    km_p = coef(22)/8760
    km_s = coef(23)/8760
    ksm_a = coef(24)/8760
    ksm_s = coef(25)/8760
    ks_a = coef(26)/8760
    ks_p = coef(27)/8760
    ks_m = coef(28)/8760
    kp_a = coef(29)/8760
    kp_m = coef(30)/8760
!for stem gC.m2
    cw(0) = coef(0)/coef(4)*npp_yr
! for coast root
    ccr(0) = coef(1)/coef(5)*npp_yr
! for leaf
    cl(0) = coef(2)/coef(6)*npp_yr
! for fine root
    cfr(0) = coef(3)/coef(7)*npp_yr
    fm(1) = 0.2
!kg/m2/s
    npp = mid_res%npp_o + mid_res%npp_u
!gC/m2/step return to original units @J.Wang
    npp = npp*1000*step
    dcw(1) = fw*npp - kw_cd*cw(0)
    dccr(1) = fcr*npp - kcr_cd*ccr(0)
    dcl(1) = fl*npp - kl_sl*cl(0)
    dcfr(1) = ffr*npp - kfr_fl*cfr(0)
    cw(1) = cw(0) + dcw(1)
    ccr(1) = ccr(0) + dccr(1)
    cl(1) = cl(0) + dcl(1)
    cfr(1) = cfr(0) + dcfr(1)
    part1 = (kw_cd*cw(1)+kcr_cd*ccr(1))/(1+lam_d*(kcd_a+kcd_m+kcd_s))
    part2 = ccd(0)*lam_d*(kcd_a+kcd_m+kcd_s)
    dccd(1) = part1 - part2
    ccd(1) = ccd(0) + dccd(1)
!Coarse detrius from woody and coarse root
    part1 = (1-fm(1))*kl_sl*cl(1)/(1+lam_u*(kssd_a+kssd_sm+kssd_s))
    part2 = cssd(0)*lam_u*(kssd_a+kssd_sm+kssd_s)
    dcssd(1) = part1 - part2
    cssd(1) = cssd(0) + dcssd(1)
!surface structural litter
    part1 = fm(1)*kl_sl*cl(1)/(1+lam_u*(ksmd_a+ksmd_sm))
    part2 = csmd(0)*lam_u*(ksmd_a+ksmd_sm)
    dcsmd(1) = part1 - part2
    csmd(1) = csmd(0) - dcsmd(1)
!surface metobolic litter
    part1 = (1-fm(1))*kfr_fl*cfr(1)/(1+lam_d*(kfsd_a+kfsd_m+kfsd_s))
    part2 = cfsd(0)*lam_d*(kfsd_a+kfsd_m+kfsd_s)
    dcfsd(1) = part1 - part2
    cfsd(1) = cfsd(0) + dcfsd(1)
!for soil strutural litter pool
    part1 = fm(1)*kfr_fl*cfr(1)/(1+lam_d*(kfmd_a+kfmd_m))
    part2 = lam_d*(kfmd_a+kfmd_m)*cfmd(0)
    dcfmd(1) = part1 - part2
    cfmd(1) = cfmd(0) + dcfmd(1)
! soil metobolic pool
    part1 = lam_u*(cssd(1)*kssd_sm+csmd(1)*ksmd_sm)
    part2 = lam_u*csm(0)*(ksm_a+ksm_s)
    dcsm(1) = part1 - part2
    csm(1) = csm(0) + dcsm(1)
! surface microbe pool
    part1 = lam_d*(kfsd_m*cfsd(1)+kfmd_m*cfmd(1)+ccd(1)*kcd_m) + lam_d*(&
&     cs(0)*ks_m+cp(0)*kp_m)
    part2 = cm(0)*lam_d*(km_a+km_s+km_p)
    dcm(1) = part1 - part2
    cm(1) = cm(0) + dcm(1)
!soil microbe pool
    part1 = lam_d*(cm(1)*km_s+ccd(1)*kcd_s+cfsd(1)*kfsd_s) + lam_u*(csm(&
&     1)*ksm_s+cssd(1)*kssd_s)
    part2 = cs(0)*lam_d*(ks_a+ks_p+ks_m)
    dcs(1) = part1 - part2
    cs(1) = cs(0) + dcs(1)
!for slow carbon pool
    dcp(1) = lam_d*(km_p*cm(1)+ks_p*cs(1)) - lam_d*(kp_m*cp(0)+kp_a*cp(0&
&     ))
    cp(1) = cp(0) + dcp(1)
! passive carbon pool
!NEP
    mid_res%nep = npp + (dcsmd(1)+dcssd(1)+dcfsd(1)+dcfmd(1)+dccd(1)+dcm&
&     (1)+dcsm(1)+dcs(1)+dcp(1))
!kgC/m2/s
    mid_res%nep = mid_res%nep*1e-3/step
    mid_res%npp = npp*1e-3/step
    RETURN
  END SUBROUTINE SOIL_RESP

END MODULE ECORESPMOD_DIFF

MODULE OUTPUTMOD_DIFF
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE BEPSTYPE_DIFF
  USE CONTROLINPUT_MOD_DIFF, ONLY : beps_out_dir, beps_rst_dir, nhtfrq, &
& nstpd, nscale, nlat, nlon, check
!--iLab::avoid beps_time_manager, all temporal information now passed as actual arguments
! use beps_time_manager
  USE BEPS_PAR
  IMPLICIT NONE
!! Here add variables for output by USERS
  REAL(r8), ALLOCATABLE :: nep9(:)
  REAL(r8), ALLOCATABLE :: gpp9(:)
  REAL(r8), ALLOCATABLE :: sif9(:)
  REAL(r8), ALLOCATABLE :: sif9_sat(:)
  REAL(r8), ALLOCATABLE :: npp9(:)
  REAL(r8), ALLOCATABLE :: gpppft9(:, :)
  REAL(r8), ALLOCATABLE :: sifpft9(:, :)
  REAL(r8), ALLOCATABLE :: lhpft9(:, :)
  REAL(r8), ALLOCATABLE :: shpft9(:, :)
  REAL(r8), ALLOCATABLE :: transpft9(:, :)
  REAL(r8), ALLOCATABLE :: evappft9(:, :)
  REAL(r8), ALLOCATABLE :: thetampft9(:, :)
  REAL(r8), ALLOCATABLE :: sifpft9_sat(:, :)
  REAL(r8), ALLOCATABLE :: faparpft9(:, :)
  REAL(r8), ALLOCATABLE :: vodpft9(:, :)
  REAL(r8), ALLOCATABLE :: cos_fluxpft9(:, :)
  REAL(r8), ALLOCATABLE :: temp9(:)
  REAL(r8), ALLOCATABLE :: wind9(:)
  REAL(r8), ALLOCATABLE :: rh9(:)
  REAL(r8), ALLOCATABLE :: rain9(:)
  REAL(r8), ALLOCATABLE :: snow9(:)
  REAL(r8), ALLOCATABLE :: swdr9(:)
  REAL(r8), ALLOCATABLE :: swdf9(:)
  REAL(r8), ALLOCATABLE :: lai9(:)
  REAL(r8), ALLOCATABLE :: lh9(:)
  REAL(r8), ALLOCATABLE :: sh9(:)
  REAL(r8), ALLOCATABLE :: trans9(:)
  REAL(r8), ALLOCATABLE :: evap9(:)
  REAL(r8), ALLOCATABLE :: thetam9(:)
  REAL(r8), ALLOCATABLE :: fapar9(:)
  REAL(r8), ALLOCATABLE :: vod9(:)
  REAL(r8), ALLOCATABLE :: cos_flux9(:)
! for counting the simulation steps for monthly output
  INTEGER, SAVE :: nst=0

CONTAINS
  SUBROUTINE INIT_OUTPUT()
    IMPLICIT NONE
    ALLOCATE(nep9(npoints))
    ALLOCATE(gpp9(npoints))
    ALLOCATE(npp9(npoints))
    ALLOCATE(gpppft9(npoints, pft))
    ALLOCATE(sifpft9(npoints, pft))
    ALLOCATE(lhpft9(npoints, pft))
    ALLOCATE(shpft9(npoints, pft))
    ALLOCATE(transpft9(npoints, pft))
    ALLOCATE(evappft9(npoints, pft))
    ALLOCATE(thetampft9(npoints, pft))
    ALLOCATE(sifpft9_sat(npoints, pft))
    ALLOCATE(sif9(npoints))
    ALLOCATE(sif9_sat(npoints))
    ALLOCATE(faparpft9(npoints, pft))
    ALLOCATE(vodpft9(npoints, pft))
    ALLOCATE(cos_fluxpft9(npoints, pft))
    ALLOCATE(temp9(npoints))
    ALLOCATE(wind9(npoints))
    ALLOCATE(rh9(npoints))
    ALLOCATE(rain9(npoints))
    ALLOCATE(snow9(npoints))
    ALLOCATE(swdr9(npoints))
    ALLOCATE(swdf9(npoints))
    ALLOCATE(lai9(npoints))
    ALLOCATE(lh9(npoints))
    ALLOCATE(sh9(npoints))
    ALLOCATE(trans9(npoints))
    ALLOCATE(evap9(npoints))
    ALLOCATE(thetam9(npoints))
    ALLOCATE(fapar9(npoints))
    ALLOCATE(vod9(npoints))
    ALLOCATE(cos_flux9(npoints))
    nep9(:) = 0.0
    gpp9(:) = 0.
    npp9(:) = 0.
    sif9(:) = 0.
    sif9_sat(:) = 0.
    gpppft9(:, :) = 0.
    sifpft9(:, :) = 0.
    lhpft9(:, :) = 0.
    shpft9(:, :) = 0.
    transpft9(:, :) = 0.
    evappft9(:, :) = 0.
    thetampft9(:, :) = 0.
    sifpft9_sat(:, :) = 0.
    faparpft9(:, :) = 0.
    vodpft9(:, :) = 0.
    cos_fluxpft9(:, :) = 0.
    temp9(:) = 0.
    wind9(:) = 0.
    rh9(:) = 0.
    rain9(:) = 0.
    snow9(:) = 0.
    swdr9(:) = 0.
    swdf9(:) = 0.
    lai9(:) = 0.
    lh9(:) = 0.
    sh9(:) = 0.
    trans9(:) = 0.
    evap9(:) = 0.
    thetam9(:) = 0.
    fapar9(:) = 0.
    vod9(:) = 0.
    cos_flux9(:) = 0.
  END SUBROUTINE INIT_OUTPUT

!! average variables according to user's definition
  SUBROUTINE AV_OUTPUT(yr, mon, day, tod, kount, is_end_curr_month, &
&   ref_date, secs_since_ref)
    IMPLICIT NONE
!deallocate(NEP9)
!deallocate(GPP9)
!deallocate(NPP9)
!deallocate(GPPpft9)
!deallocate(SIFpft9)
!deallocate(Thetampft9)
!deallocate(SIFpft9_sat)
!deallocate(SIF9)
!deallocate(SIF9_sat)
!deallocate(temp9)
!deallocate(Wind9)
!deallocate(Rh9)
!deallocate(Rain9)
!deallocate(Snow9)
!deallocate(Swdr9)
!deallocate(Swdf9)
!deallocate(lai9)
!deallocate(Thetam9)
!-- iLab::turned yr,mon,day,tod to arguments and added the further arguments
    INTEGER, INTENT(IN) :: yr, mon, day, tod
    INTEGER, INTENT(IN) :: kount
    LOGICAL, INTENT(IN) :: is_end_curr_month
    CHARACTER(len=*), INTENT(IN) :: ref_date
    REAL(r8), INTENT(IN) :: secs_since_ref
    INTEGER :: ii, iii
    TYPE(RES), POINTER :: pp
    TYPE(FORC), POINTER :: ff
    TYPE(SURF), POINTER :: ss
    INTRINSIC MOD
    pp => output
    ff => clim
    ss => bound
!! accumulate
    nep9 = nep9 + pp%nep
    gpp9 = gpp9 + pp%gpp
    sif9 = sif9 + pp%sif
    sif9_sat = sif9_sat + pp%sif_sat
    npp9 = npp9 + pp%npp
    gpppft9 = gpppft9 + pp%gpppft
    sifpft9 = sifpft9 + pp%sifpft
    lhpft9 = lhpft9 + pp%lhpft
    shpft9 = shpft9 + pp%shpft
    transpft9 = transpft9 + pp%transpft
    evappft9 = evappft9 + pp%evappft
    thetampft9 = thetampft9 + pp%thetampft
    sifpft9_sat = sifpft9_sat + pp%sifpft_sat
    faparpft9 = faparpft9 + pp%faparpft
    vodpft9 = vodpft9 + pp%vodpft
    cos_fluxpft9 = cos_fluxpft9 + pp%cos_fluxpft
    temp9 = temp9 + ff%temp
    wind9 = wind9 + ff%wind
    rh9 = rh9 + ff%rh
    rain9 = rain9 + ff%rain
    snow9 = snow9 + ff%snow
    swdr9 = swdr9 + ff%swdr
    swdf9 = swdf9 + ff%swdf
    lai9 = lai9 + pp%lai
    lh9 = lh9 + pp%lh
    sh9 = sh9 + pp%sh
    trans9 = trans9 + pp%trans
    evap9 = evap9 + pp%evap
    thetam9 = thetam9 + pp%thetam
    fapar9 = fapar9 + pp%fapar
    vod9 = vod9 + pp%vod
    cos_flux9 = cos_flux9 + pp%cos_flux
!! currently I did not include the satellite SIF when nhtfrq < 0 @J.Wang
    IF (nhtfrq .LT. 0) THEN
! kount  = get_nstep()
      IF (MOD(kount, nstpd) .EQ. 0) THEN
!! average
        nep9 = nep9/nstpd
        gpp9 = gpp9/nstpd
        sif9 = sif9/nstpd
        npp9 = npp9/nstpd
        gpppft9 = gpppft9/nstpd
        sifpft9 = sifpft9/nstpd
        lhpft9 = lhpft9/nstpd
        shpft9 = shpft9/nstpd
        transpft9 = transpft9/nstpd
        evappft9 = evappft9/nstpd
        thetampft9 = thetampft9/nstpd
        faparpft9 = faparpft9/nstpd
        vodpft9 = vodpft9/nstpd
        cos_fluxpft9 = cos_fluxpft9/nstpd
        IF (nhtfrq .EQ. -24) THEN
          sif9_sat = sif9_sat
          sifpft9_sat = sifpft9_sat
        ELSE
          sif9_sat = 0.
          sifpft9_sat = 0.
        END IF
        temp9 = temp9/nstpd
        wind9 = wind9/nstpd
        rh9 = rh9/nstpd
        rain9 = rain9/nstpd
        snow9 = snow9/nstpd
        swdr9 = swdr9/nstpd
        swdf9 = swdf9/nstpd
        lai9 = lai9/nstpd
        lh9 = lh9/nstpd
        sh9 = sh9/nstpd
        trans9 = trans9/nstpd
        evap9 = evap9/nstpd
        thetam9 = thetam9/nstpd
        fapar9 = fapar9/nstpd
        vod9 = vod9/nstpd
        cos_flux9 = cos_flux9/nstpd
        IF (nscale .EQ. 0) THEN
          CALL WRITE_OUTPUT_GLOBAL(yr, mon, day, tod)
        ELSE
          CALL WRITE_OUTPUT_SITE(yr, mon, day, tod, ref_date, &
&                          secs_since_ref)
        END IF
        nep9 = 0.
        gpp9 = 0.
        sif9 = 0.
        npp9 = 0.
        sif9_sat = 0.
        gpppft9 = 0.
        sifpft9 = 0.
        lhpft9 = 0.
        shpft9 = 0.
        transpft9 = 0.
        evappft9 = 0.
        thetampft9 = 0.
        sifpft9_sat = 0.
        faparpft9 = 0.
        vodpft9 = 0.
        cos_fluxpft9 = 0.
        temp9 = 0.
        wind9 = 0.
        rh9 = 0.
        rain9 = 0.
        snow9 = 0.
        swdr9 = 0.
        swdf9 = 0.
        lai9 = 0.
        lh9 = 0.
        sh9 = 0.
        trans9 = 0.
        evap9 = 0.
        thetam9 = 0.
        fapar9 = 0.
        vod9 = 0.
        cos_flux9 = 0.
      END IF
    ELSE IF (nhtfrq .EQ. 0) THEN
!!monthly output
      nst = nst + 1
      IF (is_end_curr_month) THEN
!! average
        nep9 = nep9/nst
        gpp9 = gpp9/nst
        sif9 = sif9/nst
        npp9 = npp9/nst
!kg/m2/s
        gpppft9 = gpppft9/nst
        sifpft9 = sifpft9/nst
        lhpft9 = lhpft9/nst
        shpft9 = shpft9/nst
        transpft9 = transpft9/nst
        evappft9 = evappft9/nst
        thetampft9 = thetampft9/nst
        faparpft9 = faparpft9/nst
        vodpft9 = vodpft9/nst
        cos_fluxpft9 = cos_fluxpft9/nst
        temp9 = temp9/nst
        wind9 = wind9/nst
        rh9 = rh9/nst
        rain9 = rain9/nst
        snow9 = snow9/nst
        swdr9 = swdr9/nst
        swdf9 = swdf9/nst
        lai9 = lai9/nst
        lh9 = lh9/nst
        sh9 = sh9/nst
        trans9 = trans9/nst
        evap9 = evap9/nst
        thetam9 = thetam9/nst
        fapar9 = fapar9/nst
        vod9 = vod9/nst
        cos_flux9 = cos_flux9/nst
!--iLab::yr,mon,day,tod now provided as arguments
! call get_prev_date(yr, mon, day, tod)
!!              write(*,*) "write out data on ",yr,mon,day
        sifpft9_sat = sifpft9_sat/day
        sif9_sat = sif9_sat/day
        IF (nscale .EQ. 0) THEN
          CALL WRITE_OUTPUT_GLOBAL(yr, mon, day, tod)
        ELSE
          CALL WRITE_OUTPUT_SITE(yr, mon, day, tod, ref_date, &
&                          secs_since_ref)
        END IF
        nep9 = 0.
        gpp9 = 0.
        sif9 = 0.
        sif9_sat = 0.
        npp9 = 0.
        gpppft9 = 0.
        sifpft9 = 0.
        lhpft9 = 0.
        shpft9 = 0.
        transpft9 = 0.
        evappft9 = 0.
        thetampft9 = 0.
        sifpft9_sat = 0.
        faparpft9 = 0.
        vodpft9 = 0.
        cos_fluxpft9 = 0.
        temp9 = 0.
        wind9 = 0.
        rh9 = 0.
        rain9 = 0.
        snow9 = 0.
        swdr9 = 0.
        swdf9 = 0.
        lai9 = 0.
        lh9 = 0.
        sh9 = 0.
        trans9 = 0.
        evap9 = 0.
        thetam9 = 0.
        fapar9 = 0.
        vod9 = 0.
        cos_flux9 = 0.
        nst = 0
      END IF
    END IF
  END SUBROUTINE AV_OUTPUT

  SUBROUTINE WRITE_OUTPUT_GLOBAL(yy, mm, dd, tod)
    USE NETCDF
    IMPLICIT NONE
!end if
!call mpi_barrier(mpi_comm_world,ierr)
!--iLab::yy,mm,dd,tod turned to arguments
    INTEGER, INTENT(IN) :: yy, mm, dd, tod
    REAL(r8), DIMENSION(nlp) :: nep1, gpp1, sif1, sif_sat1, npp1, temp1&
&   , wind1, rh1, rain1, snow1, swdr1, swdf1, lai1, lh1, sh1, trans1, &
&   evap1, thetam1, fapar1, vod1, cos_flux1
    REAL(r8), DIMENSION(nlon*nlat) :: nep2, gpp2, sif2, sif_sat2, npp2, &
&   temp2, wind2, rh2, rain2, snow2, swdr2, swdf2, lai2, lh2, sh2, &
&   trans2, evap2, thetam2, fapar2, vod2, cos_flux2
    REAL(r8), DIMENSION(nlon, nlat) :: nep3, gpp3, sif3, sif_sat3, npp3&
&   , temp3, wind3, rh3, rain3, snow3, swdr3, swdf3, lai3, lh3, sh3, &
&   trans3, evap3, thetam3, fapar3, vod3, cos_flux3
    REAL(r8), DIMENSION(nlp, pft) :: gpppft1, lhpft1, shpft1, transpft1&
&   , evappft1, thetampft1, faparpft1, vodpft1, cos_fluxpft1
    REAL(r8), DIMENSION(nlon*nlat, pft) :: gpppft2, lhpft2, shpft2, &
&   transpft2, evappft2, thetampft2, faparpft2, vodpft2, cos_fluxpft2
    REAL(r8), DIMENSION(nlon, nlat, pft) :: gpppft3, lhpft3, shpft3, &
&   transpft3, evappft3, thetampft3, faparpft3, vodpft3, cos_fluxpft3
    REAL(r8) :: lon(nlon), lat(nlat)
    INTEGER :: ierr
    INTEGER :: ncid, dimid_lon, dimid_lat, dimid_time, dimid_pft, varid
    CHARACTER(len=8) :: datestr
    CHARACTER(len=255) :: fln1, fln2, name, unit
    INTEGER :: nt, status
    INTEGER :: i
    INTRINSIC RESHAPE
    INTRINSIC TRIM
    INTEGER :: result1
!call mpi_barrier(mpi_comm_world,ierr)
!call mpi_gatherv(NEP9(1),npoints,mpi_real8,NEP1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(GPP9(1),npoints,mpi_real8,GPP1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(SIF9(1),npoints,mpi_real8,SIF1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(SIF9_sat(1),npoints,mpi_real8,SIF_sat1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(NPP9(1),npoints,mpi_real8,NPP1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(fAPAR9(1),npoints,mpi_real8,fAPAR1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(VOD9(1),npoints,mpi_real8,VOD1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(COS_flux9(1),npoints,mpi_real8,COS_flux1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(temp9(1),npoints,mpi_real8,temp1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(Wind9(1),npoints,mpi_real8,Wind1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(Rh9(1),npoints,mpi_real8,Rh1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(Rain9(1),npoints,mpi_real8,Rain1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(Snow9(1),npoints,mpi_real8,Snow1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(Swdr9(1),npoints,mpi_real8,Swdr1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(Swdf9(1),npoints,mpi_real8,Swdf1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(lai9(1),npoints,mpi_real8,lai1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(LH9(1),npoints,mpi_real8,LH1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(SH9(1),npoints,mpi_real8,SH1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(Trans9(1),npoints,mpi_real8,Trans1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(Evap9(1),npoints,mpi_real8,Evap1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(Thetam9(1),npoints,mpi_real8,Thetam1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!do i = 1,PFT
!   call mpi_gatherv(GPPpft9(1,i),npoints,mpi_real8,GPPpft1(1,i),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!   call mpi_gatherv(Evappft9(1,i),npoints,mpi_real8,Evappft1(1,i),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!   call mpi_gatherv(Thetampft9(1,i),npoints,mpi_real8,Thetampft1(1,i),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!   call mpi_gatherv(fAPARpft9(1,i),npoints,mpi_real8,fAPARpft1(1,i),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!   call mpi_gatherv(VODpft9(1,i),npoints,mpi_real8,VODpft1(1,i),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!   call mpi_gatherv(COS_fluxpft9(1,i),npoints,mpi_real8,COS_fluxpft1(1,i),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!end do
!call mpi_barrier(mpi_comm_world,ierr)
    nep1 = nep9
    gpp1 = gpp9
    sif1 = sif9
    sif_sat1 = sif9_sat
    npp1 = npp9
    fapar1 = fapar9
    vod1 = vod9
    cos_flux1 = cos_flux9
    temp1 = temp9
    wind1 = wind9
    rh1 = rh9
    rain1 = rain9
    snow1 = snow9
    swdr1 = swdr9
    swdf1 = swdf9
    lai1 = lai9
    lh1 = lh9
    sh1 = sh9
    trans1 = trans9
    evap1 = evap9
    thetam1 = thetam9
    gpppft1 = gpppft9
    evappft1 = evappft9
    thetampft1 = thetampft9
    faparpft1 = faparpft9
    vodpft1 = vodpft9
    cos_fluxpft1 = cos_fluxpft9
!if(myid ==0) then
    nep2 = 0.
    gpp2 = 0.
    npp2 = 0.
    gpppft2 = 0.
    lhpft2 = 0.
    shpft2 = 0.
    transpft2 = 0.
    evappft2 = 0.
    thetampft2 = 0.
    faparpft2 = 0.
    vodpft2 = 0.
    cos_fluxpft2 = 0.
    temp2 = 0.
    wind2 = 0.
    rh2 = 0.
    rain2 = 0.
    snow2 = 0.
    swdr2 = 0.
    swdf2 = 0.
    lai2 = 0.
    lh2 = 0.
    sh2 = 0.
    trans2 = 0.
    evap2 = 0.
    thetam2 = 0.
    sif2 = 0.
    sif_sat2 = 0.
    fapar2 = 0.
    vod2 = 0.
    cos_flux2 = 0.
    sif2(mapping) = sif1
    sif_sat2(mapping) = sif_sat1
    nep2(mapping) = nep1
    gpp2(mapping) = gpp1
    npp2(mapping) = npp1
    gpppft2(mapping, :) = gpppft1
    lhpft2(mapping, :) = lhpft1
    shpft2(mapping, :) = shpft1
    transpft2(mapping, :) = transpft1
    evappft2(mapping, :) = evappft1
    thetampft2(mapping, :) = thetampft1
    faparpft2(mapping, :) = faparpft1
    vodpft2(mapping, :) = vodpft1
    cos_fluxpft2(mapping, :) = cos_fluxpft1
    temp2(mapping) = temp1
    wind2(mapping) = wind1
    rh2(mapping) = rh1
    rain2(mapping) = rain1
    snow2(mapping) = snow1
    swdr2(mapping) = swdr1
    swdf2(mapping) = swdf1
    lai2(mapping) = lai1
    lh2(mapping) = lh1
    sh2(mapping) = sh1
    trans2(mapping) = trans1
    evap2(mapping) = evap1
    thetam2(mapping) = thetam1
    fapar2(mapping) = fapar1
    vod2(mapping) = vod1
    cos_flux2(mapping) = cos_flux1
    nep3 = RESHAPE(nep2, (/nlon, nlat/))
    gpp3 = RESHAPE(gpp2, (/nlon, nlat/))
    npp3 = RESHAPE(npp2, (/nlon, nlat/))
    sif3 = RESHAPE(sif2, (/nlon, nlat/))
    sif_sat3 = RESHAPE(sif_sat2, (/nlon, nlat/))
    gpppft3 = RESHAPE(gpppft2, (/nlon, nlat, pft/))
    lhpft3 = RESHAPE(lhpft2, (/nlon, nlat, pft/))
    shpft3 = RESHAPE(shpft2, (/nlon, nlat, pft/))
    transpft3 = RESHAPE(transpft2, (/nlon, nlat, pft/))
    evappft3 = RESHAPE(evappft2, (/nlon, nlat, pft/))
    thetampft3 = RESHAPE(thetampft2, (/nlon, nlat, pft/))
    faparpft3 = RESHAPE(faparpft2, (/nlon, nlat, pft/))
    vodpft3 = RESHAPE(vodpft2, (/nlon, nlat, pft/))
    cos_fluxpft3 = RESHAPE(cos_fluxpft2, (/nlon, nlat, pft/))
    temp3 = RESHAPE(temp2, (/nlon, nlat/))
    wind3 = RESHAPE(wind2, (/nlon, nlat/))
    rh3 = RESHAPE(rh2, (/nlon, nlat/))
    rain3 = RESHAPE(rain2, (/nlon, nlat/))
    snow3 = RESHAPE(snow2, (/nlon, nlat/))
    swdr3 = RESHAPE(swdr2, (/nlon, nlat/))
    swdf3 = RESHAPE(swdf2, (/nlon, nlat/))
    lai3 = RESHAPE(lai2, (/nlon, nlat/))
    lh3 = RESHAPE(lh2, (/nlon, nlat/))
    sh3 = RESHAPE(sh2, (/nlon, nlat/))
    trans3 = RESHAPE(trans2, (/nlon, nlat/))
    evap3 = RESHAPE(evap2, (/nlon, nlat/))
    thetam3 = RESHAPE(thetam2, (/nlon, nlat/))
    fapar3 = RESHAPE(fapar2, (/nlon, nlat/))
    vod3 = RESHAPE(vod2, (/nlon, nlat/))
    cos_flux3 = RESHAPE(cos_flux2, (/nlon, nlat/))
!--iLab::yy,mm,dd,tod are arguments now
! call get_prev_date(yy,mm,dd,tod)
    IF (nhtfrq .LT. 0) THEN
      WRITE(datestr, '(i8)') yy*10000 + mm*100 + dd
      nt = (tod/3600+1)/(-nhtfrq)
    ELSE IF (nhtfrq .EQ. 0) THEN
      WRITE(datestr, '(i6)') yy*100 + mm
      nt = 1
    END IF
    WRITE(*, *) 'Writing out simulation file now!'
    fln1 = TRIM(beps_out_dir)//'beps_global_'//TRIM(datestr)//'.nc'
    status = NF90_OPEN(fln1, nf90_write, ncid)
    IF (status .NE. nf90_noerr) THEN
      result1 = NF90_CREATE(fln1, nf90_share, ncid)
      CALL CHECK(result1)
      result1 = NF90_DEF_DIM(ncid, 'lon', nlon, dimid_lon)
      CALL CHECK(result1)
      result1 = NF90_DEF_DIM(ncid, 'lat', nlat, dimid_lat)
      CALL CHECK(result1)
      result1 = NF90_DEF_DIM(ncid, 'PFT', pft, dimid_pft)
      CALL CHECK(result1)
      result1 = NF90_DEF_DIM(ncid, 'time', nf90_unlimited, dimid_time)
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'time', nf90_double, (/dimid_time/), &
&       varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'calendar', 'Gregorian')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'lon', nf90_double, (/dimid_lon/), &
&       varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'degree_east')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'long_name', 'longitude')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'axis', 'X')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'lat', nf90_double, (/dimid_lat/), &
&       varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'degree_north')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'long_name', 'latitude')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'axis', 'Y')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'NEP', nf90_double, (/dimid_lon, &
&       dimid_lat, dimid_time/), varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'kg/m2/s')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', &
&       'Net Ecosystem Productivity')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'GPP', nf90_double, (/dimid_lon, &
&       dimid_lat, dimid_time/), varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'kg/m2/s')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', &
&       'Gross Primary Productivity')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'VOD', nf90_double, (/dimid_lon, &
&       dimid_lat, dimid_time/), varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', '-')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', &
&       'Vegetation Optical Depth')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'fAPAR', nf90_double, (/dimid_lon, &
&       dimid_lat, dimid_time/), varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', '-')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', &
&       'Fraction of Absorbed Photosynthetically Active Radiation')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'COS_flux', nf90_double, (/dimid_lon&
&       , dimid_lat, dimid_time/), varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'pmol/m2/s')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', &
&       'COS flux for soil and plant')
      CALL CHECK(result1)
!   call check(nf90_def_var(ncid,"SIF_sat",nf90_double,(/dimid_lon,dimid_lat,dimid_time/),varid))
!   call check(nf90_put_att(ncid,varid,"units","mW/m2/nm/sr"))
!   call check(nf90_put_att(ncid,varid,"name","solar-induced SIF over the OCO2 pass-time"))
      result1 = NF90_DEF_VAR(ncid, 'SIF', nf90_double, (/dimid_lon, &
&       dimid_lat, dimid_time/), varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'mW/m2/nm/sr')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', 'solar-induced SIF')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'GPPpft', nf90_double, (/dimid_lon, &
&       dimid_lat, dimid_pft, dimid_time/), varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'kg/m2/s')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', &
&       'Gross Primary Productivity')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, nf90_global, 'model', 'Beps runs')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, nf90_global, 'institution', &
&       'Nanjing University')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'Thetam', nf90_double, (/dimid_lon, &
&       dimid_lat, dimid_time/), varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'm3/m3')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', &
&       'Surface soil moisture')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'LH', nf90_double, (/dimid_lon, &
&       dimid_lat, dimid_time/), varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'W/m2')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', 'Latent heat flux')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'SH', nf90_double, (/dimid_lon, &
&       dimid_lat, dimid_time/), varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'W/m2')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', 'Sensible heat flux')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'Trans', nf90_double, (/dimid_lon, &
&       dimid_lat, dimid_time/), varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'm/s')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', 'Transpiration')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'Evap', nf90_double, (/dimid_lon, &
&       dimid_lat, dimid_time/), varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'm/s')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', 'Evaporation')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'Evappft', nf90_double, (/dimid_lon, &
&       dimid_lat, dimid_pft, dimid_time/), varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'm/s')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', 'Evaporation')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'Thetampft', nf90_double, (/dimid_lon&
&       , dimid_lat, dimid_pft, dimid_time/), varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'm3/m3')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', &
&       'Surface soil moisture')
      CALL CHECK(result1)
      result1 = NF90_ENDDEF(ncid)
      CALL CHECK(result1)
    END IF
!! For temporary output  , Should be improved later @J.Wang
    DO i=1,nlat
      lat(i) = -89.5 + i - 1
    END DO
    result1 = NF90_INQ_VARID(ncid, 'lat', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, lat)
    CALL CHECK(result1)
    DO i=1,nlon
      lon(i) = 0.5 + i - 1.
    END DO
    result1 = NF90_INQ_VARID(ncid, 'lon', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, lon)
    CALL CHECK(result1)
!    call check(nf90_inq_varid(ncid,"time",varid))
!    call check(nf90_put_var(ncid,varid,nt,start=(/nt/),count=(/1/)))
    result1 = NF90_INQ_VARID(ncid, 'NEP', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, nep3, start=(/1, 1, nt/), count=&
&     (/nlon, nlat, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'GPP', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, gpp3, start=(/1, 1, nt/), count=&
&     (/nlon, nlat, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'VOD', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, vod3, start=(/1, 1, nt/), count=&
&     (/nlon, nlat, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'fAPAR', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, fapar3, start=(/1, 1, nt/), &
&     count=(/nlon, nlat, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'COS_flux', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, cos_flux3, start=(/1, 1, nt/), &
&     count=(/nlon, nlat, 1/))
    CALL CHECK(result1)
!    call check(nf90_inq_varid(ncid,"SIF_sat",varid))
!    call check(nf90_put_var(ncid,varid,SIF_sat3,start=(/1,1,nt/),count=(/nlon,nlat,1/)))
    result1 = NF90_INQ_VARID(ncid, 'SIF', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, sif3, start=(/1, 1, nt/), count=&
&     (/nlon, nlat, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'GPPpft', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, gpppft3, start=(/1, 1, 1, nt/), &
&     count=(/nlon, nlat, pft, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'Thetam', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, thetam3, start=(/1, 1, nt/), &
&     count=(/nlon, nlat, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'LH', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, lh3, start=(/1, 1, nt/), count=&
&     (/nlon, nlat, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'SH', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, sh3, start=(/1, 1, nt/), count=&
&     (/nlon, nlat, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'Trans', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, trans3, start=(/1, 1, nt/), &
&     count=(/nlon, nlat, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'Evap', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, evap3, start=(/1, 1, nt/), count&
&     =(/nlon, nlat, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'Thetampft', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, thetampft3, start=(/1, 1, 1, nt&
&     /), count=(/nlon, nlat, pft, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'Evappft', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, evappft3, start=(/1, 1, 1, nt/)&
&     , count=(/nlon, nlat, pft, 1/))
    CALL CHECK(result1)
    result1 = NF90_CLOSE(ncid)
    CALL CHECK(result1)
  END SUBROUTINE WRITE_OUTPUT_GLOBAL

  SUBROUTINE WRITE_OUTPUT_SITE(yy, mm, dd, tod, ref_date, secs_since_ref&
& )
    USE NETCDF
    IMPLICIT NONE
!end if
!call mpi_barrier(mpi_comm_world,ierr)
!--iLab::yy,mm,dd,tod turned into arguments
    INTEGER, INTENT(IN) :: yy, mm, dd, tod
    CHARACTER(len=*), INTENT(IN) :: ref_date
    REAL(r8), INTENT(IN) :: secs_since_ref
    CHARACTER(len=*), PARAMETER :: sub='write_output_site'
    REAL(r8), DIMENSION(nlp) :: nep1, gpp1, sif1, sif_sat1, npp1, temp1&
&   , wind1, rh1, rain1, snow1, swdr1, swdf1, lai1, lh1, sh1, trans1, &
&   evap1, thetam1, fapar1, vod1, cos_flux1
    REAL(r8), DIMENSION(nlp, pft) :: gpppft1, lhpft1, shpft1, transpft1&
&   , evappft1, thetampft1, faparpft1, vodpft1, cos_fluxpft1
    INTEGER :: ierr
    INTEGER :: ncid, dimid_site, dimid_time, dimid_pft, varid
    INTEGER :: nsite(nlp)
    CHARACTER(len=8) :: datestr
    CHARACTER(len=255) :: fln1, fln2, name, unit
    INTEGER :: nt, status
    INTEGER :: i
!-- iLab::reduce amount of terminal output (to be reactivated on purpose)
    LOGICAL, SAVE :: ldebug=.false.
!-- iLab::added for consistent initialisation of NetCDF variables
    REAL(r8), PARAMETER :: fill_value=-99999._r8
    INTRINSIC TRIM
    INTEGER :: result1
!call mpi_barrier(mpi_comm_world,ierr)
!call mpi_gatherv(NEP9(1),npoints,mpi_real8,NEP1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(GPP9(1),npoints,mpi_real8,GPP1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(SIF9(1),npoints,mpi_real8,SIF1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(SIF9_sat(1),npoints,mpi_real8,SIF_sat1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(NPP9(1),npoints,mpi_real8,NPP1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(fAPAR9(1),npoints,mpi_real8,fAPAR1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(VOD9(1),npoints,mpi_real8,VOD1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(COS_flux9(1),npoints,mpi_real8,COS_flux1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(temp9(1),npoints,mpi_real8,temp1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(Wind9(1),npoints,mpi_real8,Wind1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(Rh9(1),npoints,mpi_real8,Rh1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(Rain9(1),npoints,mpi_real8,Rain1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(Snow9(1),npoints,mpi_real8,Snow1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(Swdr9(1),npoints,mpi_real8,Swdr1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(Swdf9(1),npoints,mpi_real8,Swdf1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(lai9(1),npoints,mpi_real8,lai1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(LH9(1),npoints,mpi_real8,LH1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(SH9(1),npoints,mpi_real8,SH1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(Trans9(1),npoints,mpi_real8,Trans1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(Evap9(1),npoints,mpi_real8,Evap1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!call mpi_gatherv(Thetam9(1),npoints,mpi_real8,Thetam1(1),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!do i = 1,PFT
!   call mpi_gatherv(GPPpft9(1,i),npoints,mpi_real8,GPPpft1(1,i),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!   call mpi_gatherv(Evappft9(1,i),npoints,mpi_real8,Evappft1(1,i),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!   call mpi_gatherv(Thetampft9(1,i),npoints,mpi_real8,Thetampft1(1,i),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!   call mpi_gatherv(fAPARpft9(1,i),npoints,mpi_real8,fAPARpft1(1,i),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!   call mpi_gatherv(VODpft9(1,i),npoints,mpi_real8,VODpft1(1,i),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!   call mpi_gatherv(COS_fluxpft9(1,i),npoints,mpi_real8,COS_fluxpft1(1,i),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!end do
!call mpi_barrier(mpi_comm_world,ierr)
    nep1 = nep9
    gpp1 = gpp9
    sif1 = sif9
    sif_sat1 = sif9_sat
    npp1 = npp9
    fapar1 = fapar9
    vod1 = vod9
    cos_flux1 = cos_flux9
    temp1 = temp9
    wind1 = wind9
    rh1 = rh9
    rain1 = rain9
    snow1 = snow9
    swdr1 = swdr9
    swdf1 = swdf9
    lai1 = lai9
    lh1 = lh9
    sh1 = sh9
    trans1 = trans9
    evap1 = evap9
    thetam1 = thetam9
    gpppft1 = gpppft9
    evappft1 = evappft9
    thetampft1 = thetampft9
    faparpft1 = faparpft9
    vodpft1 = vodpft9
    cos_fluxpft1 = cos_fluxpft9
!if(myid ==0) then
!--iLab::yy,mm,dd,tod are arguments now
! call get_prev_date(yy,mm,dd,tod)
    IF (nhtfrq .LT. 0) THEN
      WRITE(datestr, '(i8)') yy*10000 + mm*100 + dd
      nt = (tod/3600+1)/(-nhtfrq)
! !-- iLab::seconds elapsed since reference time (added for time-variable output)
! call timemgr_diff_secs(yy_ref*10000+mm_ref*100+dd_ref, tod_ref, yy*10000+mm*100+dd, tod,&
!      secs_since_ref(1))
    ELSE IF (nhtfrq .EQ. 0) THEN
      WRITE(datestr, '(i6)') yy*100 + mm
      nt = 1
    END IF
!-- iLab::make logging output depend on flag
    IF (ldebug) WRITE(*, *) 'Writing out simulation file now!'
    fln1 = TRIM(beps_out_dir)//'beps_site_'//TRIM(datestr)//'.nc'
    status = NF90_OPEN(fln1, nf90_write, ncid)
    IF (status .NE. nf90_noerr) THEN
      result1 = NF90_CREATE(fln1, nf90_share, ncid)
      CALL CHECK(result1)
      result1 = NF90_DEF_DIM(ncid, 'nsite', nlp, dimid_site)
      CALL CHECK(result1)
      result1 = NF90_DEF_DIM(ncid, 'PFT', pft, dimid_pft)
      CALL CHECK(result1)
      result1 = NF90_DEF_DIM(ncid, 'time', nf90_unlimited, dimid_time)
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'time', nf90_double, (/dimid_time/), &
&       varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'long_name', 'time')
      CALL CHECK(result1)
!-- iLab::added for proper time-variable (hourly output only)
      IF (nhtfrq .LT. 0) THEN
        result1 = NF90_PUT_ATT(ncid, varid, 'units', 'seconds since '//&
&         ref_date)
        CALL CHECK(result1)
      END IF
      result1 = NF90_PUT_ATT(ncid, varid, 'calendar', 'Gregorian')
      CALL CHECK(result1)
!-- iLab::added NetCDF output initialisation with prescribed _FillValue
!         *UPDATE*: disabled for now, since maybe not compatible on
!                   platform which Mousong is using.
      result1 = NF90_DEF_VAR(ncid, 'nsite', nf90_double, (/dimid_site/)&
&       , varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', '-')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'long_name', 'site_number')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'axis', 'X')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'NEP', nf90_double, (/dimid_site, &
&       dimid_time/), varid)
      CALL CHECK(result1)
! call check(nf90_def_var_fill(ncid, varid,  NF90_FILL, fill_value))
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'kg/m2/s')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'missing_value', fill_value)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', &
&       'Net Ecosystem Productivity')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'GPP', nf90_double, (/dimid_site, &
&       dimid_time/), varid)
      CALL CHECK(result1)
! call check(nf90_def_var_fill(ncid, varid,  NF90_FILL, fill_value))
      result1 = NF90_PUT_ATT(ncid, varid, 'missing_value', fill_value)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'kg/m2/s')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', &
&       'Gross Primary Productivity')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'VOD', nf90_double, (/dimid_site, &
&       dimid_time/), varid)
      CALL CHECK(result1)
! call check(nf90_def_var_fill(ncid, varid,  NF90_FILL, fill_value))
      result1 = NF90_PUT_ATT(ncid, varid, 'missing_value', fill_value)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', '-')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', &
&       'Vegetation Optical Depth')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'fAPAR', nf90_double, (/dimid_site, &
&       dimid_time/), varid)
      CALL CHECK(result1)
! call check(nf90_def_var_fill(ncid, varid,  NF90_FILL, fill_value))
      result1 = NF90_PUT_ATT(ncid, varid, 'missing_value', fill_value)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', '-')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', &
&       'Fraction of Absorbed Photosynthetically Active Radiation')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'COS_flux', nf90_double, (/dimid_site&
&       , dimid_time/), varid)
      CALL CHECK(result1)
! call check(nf90_def_var_fill(ncid, varid,  NF90_FILL, fill_value))
      result1 = NF90_PUT_ATT(ncid, varid, 'missing_value', fill_value)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'pmol/m2/s')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', &
&       'COS flux for soil and plant')
      CALL CHECK(result1)
!   call check(nf90_def_var(ncid,"SIF_sat",nf90_double,(/dimid_site,dimid_time/),varid))
!   call check(nf90_put_att(ncid,varid,"units","mW/m2/nm/sr"))
!   call check(nf90_put_att(ncid,varid,"name","solar-induced SIF over the OCO2 pass-time"))
      result1 = NF90_DEF_VAR(ncid, 'SIF', nf90_double, (/dimid_site, &
&       dimid_time/), varid)
      CALL CHECK(result1)
! call check(nf90_def_var_fill(ncid, varid,  NF90_FILL, fill_value))
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'mW/m2/nm/sr')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'missing_value', fill_value)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', 'solar-induced SIF')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'GPPpft', nf90_double, (/dimid_site, &
&       dimid_pft, dimid_time/), varid)
      CALL CHECK(result1)
! call check(nf90_def_var_fill(ncid, varid,  NF90_FILL, fill_value))
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'kg/m2/s')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'missing_value', fill_value)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', &
&       'Gross Primary Productivity')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, nf90_global, 'model', 'Beps runs')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, nf90_global, 'institution', &
&       'Nanjing University')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'Thetam', nf90_double, (/dimid_site, &
&       dimid_time/), varid)
      CALL CHECK(result1)
! call check(nf90_def_var_fill(ncid, varid,  NF90_FILL, fill_value))
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'm3/m3')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'missing_value', fill_value)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', &
&       'Surface soil moisture')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'LH', nf90_double, (/dimid_site, &
&       dimid_time/), varid)
      CALL CHECK(result1)
! call check(nf90_def_var_fill(ncid, varid,  NF90_FILL, fill_value))
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'W/m2')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'missing_value', fill_value)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', 'Latent heat flux')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'SH', nf90_double, (/dimid_site, &
&       dimid_time/), varid)
      CALL CHECK(result1)
! call check(nf90_def_var_fill(ncid, varid,  NF90_FILL, fill_value))
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'W/m2')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'missing_value', fill_value)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', 'Sensible heat flux')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'Trans', nf90_double, (/dimid_site, &
&       dimid_time/), varid)
      CALL CHECK(result1)
! call check(nf90_def_var_fill(ncid, varid,  NF90_FILL, fill_value))
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'm/s')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'missing_value', fill_value)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', 'Transpiration')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'Evap', nf90_double, (/dimid_site, &
&       dimid_time/), varid)
      CALL CHECK(result1)
! call check(nf90_def_var_fill(ncid, varid,  NF90_FILL, fill_value))
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'm/s')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'missing_value', fill_value)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', 'Evaporation')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'Evappft', nf90_double, (/dimid_site&
&       , dimid_pft, dimid_time/), varid)
      CALL CHECK(result1)
! call check(nf90_def_var_fill(ncid, varid,  NF90_FILL, fill_value))
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'm/s')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'missing_value', fill_value)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', 'Evaporation')
      CALL CHECK(result1)
      result1 = NF90_DEF_VAR(ncid, 'Thetampft', nf90_double, (/&
&       dimid_site, dimid_pft, dimid_time/), varid)
      CALL CHECK(result1)
! call check(nf90_def_var_fill(ncid, varid,  NF90_FILL, fill_value))
      result1 = NF90_PUT_ATT(ncid, varid, 'units', 'm3/m3')
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'missing_value', fill_value)
      CALL CHECK(result1)
      result1 = NF90_PUT_ATT(ncid, varid, 'name', &
&       'Surface soil moisture')
      CALL CHECK(result1)
      result1 = NF90_ENDDEF(ncid)
      CALL CHECK(result1)
    END IF
!! For temporary output  , Should be improved later @J.Wang
    DO i=1,nlp
      nsite(i) = i
    END DO
    result1 = NF90_INQ_VARID(ncid, 'nsite', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, nsite)
    CALL CHECK(result1)
!-- iLab::added writing of time-values (hourly output only)
    IF (nhtfrq .LT. 0) THEN
      result1 = NF90_INQ_VARID(ncid, 'time', varid)
      CALL CHECK(result1)
      result1 = NF90_PUT_VAR(ncid, varid, (/secs_since_ref/), start=(/nt&
&       /), count=(/1/))
      CALL CHECK(result1)
    END IF
!    call check(nf90_inq_varid(ncid,"time",varid))
!    call check(nf90_put_var(ncid,varid,nt,start=(/nt/),count=(/1/)))
    result1 = NF90_INQ_VARID(ncid, 'NEP', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, nep1, start=(/1, nt/), count=(/&
&     nlp, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'GPP', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, gpp1, start=(/1, nt/), count=(/&
&     nlp, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'VOD', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, vod1, start=(/1, nt/), count=(/&
&     nlp, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'fAPAR', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, fapar1, start=(/1, nt/), count=&
&     (/nlp, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'COS_flux', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, cos_flux1, start=(/1, nt/), &
&     count=(/nlp, 1/))
    CALL CHECK(result1)
!    call check(nf90_inq_varid(ncid,"SIF_sat",varid))
!    call check(nf90_put_var(ncid,varid,SIF_sat1,start=(/1,nt/),count=(/nlp,1/)))
    result1 = NF90_INQ_VARID(ncid, 'SIF', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, sif1, start=(/1, nt/), count=(/&
&     nlp, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'GPPpft', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, gpppft1, start=(/1, 1, nt/), &
&     count=(/nlp, pft, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'Thetam', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, thetam1, start=(/1, nt/), count=&
&     (/nlp, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'LH', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, lh1, start=(/1, nt/), count=(/&
&     nlp, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'SH', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, sh1, start=(/1, nt/), count=(/&
&     nlp, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'Trans', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, trans1, start=(/1, nt/), count=&
&     (/nlp, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'Evap', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, evap1, start=(/1, nt/), count=(/&
&     nlp, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'Thetampft', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, thetampft1, start=(/1, 1, nt/), &
&     count=(/nlp, pft, 1/))
    CALL CHECK(result1)
    result1 = NF90_INQ_VARID(ncid, 'Evappft', varid)
    CALL CHECK(result1)
    result1 = NF90_PUT_VAR(ncid, varid, evappft1, start=(/1, 1, nt/), &
&     count=(/nlp, pft, 1/))
    CALL CHECK(result1)
    result1 = NF90_CLOSE(ncid)
    CALL CHECK(result1)
  END SUBROUTINE WRITE_OUTPUT_SITE

END MODULE OUTPUTMOD_DIFF

MODULE RAINSNOWMOD_DIFF
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE BEPS_CON, ONLY : cp_ice, latent_fusion, density_water => rho_w
  USE BEPS_PAR
  IMPLICIT NONE
  PUBLIC :: rainfall_stage1, rainfall_stage2, snowpack_stage1, &
& snowpack_stage2, snowpack_stage3
  PUBLIC :: rainfall_stage1_bw, rainfall_stage2_bw, snowpack_stage1_bw, &
& snowpack_stage2_bw, snowpack_stage3_bw

CONTAINS
!  Differentiation of rainfall_stage1 in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: precipitation_g lai_o percent_water_o
!                mass_water_o_last lai_u percent_water_u mass_water_u_last
!                mass_water_o mass_water_u
!   with respect to varying inputs: lai_o mass_water_o_last lai_u
!                mass_water_u_last
!!rainfall_stage1 happens before evporation of intercepted water from canopy (supply)
!!rainfall_stage2 happens after evaporation of intercepted water from canopy (demand)
!*output:
!percentage of canopy covered by rainfall,overstorey and understorey (provided to evaporation_canopy)
!mass of water available for evaporation on canopy in this step
!precipitation on ground
!optical output:intercepted mass of rainfall in this step
!*input:
!air temperature
!precipitation (m/s)
!remain of water on leaves from last step(kg/m2) per leaf area
!lead area index of overstorey and understorey,excluding stem
!length of this step(s),if 10min,then it is set as 600
!air temperature and humidity
!*
  SUBROUTINE RAINFALL_STAGE1_BW(temp_air, precipitation, &
&   mass_water_o_last, mass_water_o_last_bw, mass_water_u_last, &
&   mass_water_u_last_bw, lai_o, lai_o_bw, lai_u, lai_u_bw, clumping, &
&   mass_water_o, mass_water_o_bw, mass_water_u, mass_water_u_bw, &
&   percent_water_o, percent_water_o_bw, percent_water_u, &
&   percent_water_u_bw, precipitation_g, precipitation_g_bw)
    IMPLICIT NONE
!(oC,m/s)  precipitation=liquidwater @J.Wang
    REAL(r8), INTENT(IN) :: temp_air, precipitation
!remins of water from last step
    REAL(r8), INTENT(IN) :: mass_water_o_last, mass_water_u_last
    REAL(r8) :: mass_water_o_last_bw, mass_water_u_last_bw
    REAL(r8), INTENT(IN) :: lai_o, lai_u, clumping
    REAL(r8) :: lai_o_bw, lai_u_bw
!mass of water on leaves kg/m2 per ground area
    REAL(r8) :: mass_water_o, mass_water_u
    REAL(r8) :: mass_water_o_bw, mass_water_u_bw
    REAL(r8) :: percent_water_o, percent_water_u
    REAL(r8) :: percent_water_o_bw, percent_water_u_bw
    REAL(r8) :: precipitation_g
    REAL(r8) :: precipitation_g_bw
    REAL(r8) :: precipitation_o, precipitation_u
    REAL(r8) :: precipitation_u_bw
!Maximum mass of water could be intercepted per leaf area(kg/m2)
    REAL(r8) :: massmax_water_o, massmax_water_u
    REAL(r8) :: massmax_water_o_bw, massmax_water_u_bw
! mass of water intercepted in this step per leaf area
    REAL(r8) :: massstep_water_o, massstep_water_u
    REAL(r8) :: massstep_water_o_bw, massstep_water_u_bw
    REAL(r8) :: length_step
    INTRINSIC EXP
    INTRINSIC MAX
    INTRINSIC MIN
    REAL(r8) :: temp_bw
    INTEGER*4 :: branch
    length_step = kstep
!! overstorey
    precipitation_o = precipitation
    CALL PUSHREAL8ARRAY(mass_water_o, r8/8)
    mass_water_o = mass_water_o_last + precipitation_o*length_step*&
&     density_water*(1-EXP(-(lai_o*clumping)))
    massmax_water_o = 0.1*lai_o
    IF (0. .LT. mass_water_o) THEN
      CALL PUSHCONTROL1B(0)
      mass_water_o = mass_water_o
    ELSE
      mass_water_o = 0.
      CALL PUSHCONTROL1B(1)
    END IF
    IF (massmax_water_o .GT. mass_water_o) THEN
      CALL PUSHCONTROL1B(0)
      mass_water_o = mass_water_o
    ELSE
      mass_water_o = massmax_water_o
      CALL PUSHCONTROL1B(1)
    END IF
    massstep_water_o = mass_water_o - mass_water_o_last
    IF (0. .LT. massstep_water_o) THEN
      CALL PUSHCONTROL1B(0)
      massstep_water_o = massstep_water_o
    ELSE
      massstep_water_o = 0.
      CALL PUSHCONTROL1B(1)
    END IF
    IF (1. .GT. mass_water_o/massmax_water_o) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
!! understorey
    precipitation_u = precipitation_o - massstep_water_o/density_water/&
&     length_step
    CALL PUSHREAL8ARRAY(mass_water_u, r8/8)
    mass_water_u = mass_water_u_last + precipitation_u*length_step*&
&     density_water*(1-EXP(-(lai_u*clumping)))
    massmax_water_u = 0.1*lai_u
    IF (0. .LT. mass_water_u) THEN
      CALL PUSHCONTROL1B(0)
      mass_water_u = mass_water_u
    ELSE
      mass_water_u = 0.
      CALL PUSHCONTROL1B(1)
    END IF
    IF (mass_water_u .GT. massmax_water_u) THEN
      mass_water_u = massmax_water_u
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
      mass_water_u = mass_water_u
    END IF
    massstep_water_u = mass_water_u - mass_water_u_last
    IF (massstep_water_u .LT. 0.) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (1. .GT. mass_water_u/massmax_water_u) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    precipitation_u_bw = precipitation_g_bw
    massstep_water_u_bw = -(precipitation_g_bw/(density_water*&
&     length_step))
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      mass_water_u_bw = mass_water_u_bw + percent_water_u_bw/&
&       massmax_water_u
      massmax_water_u_bw = -(mass_water_u*percent_water_u_bw/&
&       massmax_water_u**2)
    ELSE
      massmax_water_u_bw = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) massstep_water_u_bw = 0.0_8
    mass_water_u_bw = mass_water_u_bw + massstep_water_u_bw
    mass_water_u_last_bw = mass_water_u_last_bw - massstep_water_u_bw
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      massmax_water_u_bw = massmax_water_u_bw + mass_water_u_bw
      mass_water_u_bw = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) mass_water_u_bw = 0.0_8
    temp_bw = length_step*density_water*mass_water_u_bw
    lai_u_bw = lai_u_bw + 0.1*massmax_water_u_bw + clumping*EXP(-(&
&     clumping*lai_u))*precipitation_u*temp_bw
    CALL POPREAL8ARRAY(mass_water_u, r8/8)
    mass_water_u_last_bw = mass_water_u_last_bw + mass_water_u_bw
    precipitation_u_bw = precipitation_u_bw + (1-EXP(-(clumping*lai_u)))&
&     *temp_bw
    massstep_water_o_bw = -(precipitation_u_bw/(density_water*&
&     length_step))
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      mass_water_o_bw = mass_water_o_bw + percent_water_o_bw/&
&       massmax_water_o
      massmax_water_o_bw = -(mass_water_o*percent_water_o_bw/&
&       massmax_water_o**2)
    ELSE
      massmax_water_o_bw = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) massstep_water_o_bw = 0.0_8
    mass_water_o_bw = mass_water_o_bw + massstep_water_o_bw
    mass_water_o_last_bw = mass_water_o_last_bw - massstep_water_o_bw
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) THEN
      massmax_water_o_bw = massmax_water_o_bw + mass_water_o_bw
      mass_water_o_bw = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) mass_water_o_bw = 0.0_8
    lai_o_bw = lai_o_bw + 0.1*massmax_water_o_bw + clumping*EXP(-(&
&     clumping*lai_o))*precipitation_o*length_step*density_water*&
&     mass_water_o_bw
    CALL POPREAL8ARRAY(mass_water_o, r8/8)
    mass_water_o_last_bw = mass_water_o_last_bw + mass_water_o_bw
  END SUBROUTINE RAINFALL_STAGE1_BW

!!rainfall_stage1 happens before evporation of intercepted water from canopy (supply)
!!rainfall_stage2 happens after evaporation of intercepted water from canopy (demand)
!*output:
!percentage of canopy covered by rainfall,overstorey and understorey (provided to evaporation_canopy)
!mass of water available for evaporation on canopy in this step
!precipitation on ground
!optical output:intercepted mass of rainfall in this step
!*input:
!air temperature
!precipitation (m/s)
!remain of water on leaves from last step(kg/m2) per leaf area
!lead area index of overstorey and understorey,excluding stem
!length of this step(s),if 10min,then it is set as 600
!air temperature and humidity
!*
  SUBROUTINE RAINFALL_STAGE1(temp_air, precipitation, mass_water_o_last&
&   , mass_water_u_last, lai_o, lai_u, clumping, mass_water_o, &
&   mass_water_u, percent_water_o, percent_water_u, precipitation_g)
    IMPLICIT NONE
!(oC,m/s)  precipitation=liquidwater @J.Wang
    REAL(r8), INTENT(IN) :: temp_air, precipitation
!remins of water from last step
    REAL(r8), INTENT(IN) :: mass_water_o_last, mass_water_u_last
    REAL(r8), INTENT(IN) :: lai_o, lai_u, clumping
!mass of water on leaves kg/m2 per ground area
    REAL(r8), INTENT(OUT) :: mass_water_o, mass_water_u
    REAL(r8), INTENT(OUT) :: percent_water_o, percent_water_u
    REAL(r8), INTENT(OUT) :: precipitation_g
    REAL(r8) :: precipitation_o, precipitation_u
!Maximum mass of water could be intercepted per leaf area(kg/m2)
    REAL(r8) :: massmax_water_o, massmax_water_u
! mass of water intercepted in this step per leaf area
    REAL(r8) :: massstep_water_o, massstep_water_u
    REAL(r8) :: length_step
    INTRINSIC EXP
    INTRINSIC MAX
    INTRINSIC MIN
    length_step = kstep
    precipitation_g = 0.
!! overstorey
    precipitation_o = precipitation
    mass_water_o = mass_water_o_last + precipitation_o*length_step*&
&     density_water*(1-EXP(-(lai_o*clumping)))
    massmax_water_o = 0.1*lai_o
    IF (0. .LT. mass_water_o) THEN
      mass_water_o = mass_water_o
    ELSE
      mass_water_o = 0.
    END IF
    IF (massmax_water_o .GT. mass_water_o) THEN
      mass_water_o = mass_water_o
    ELSE
      mass_water_o = massmax_water_o
    END IF
    massstep_water_o = mass_water_o - mass_water_o_last
    IF (0. .LT. massstep_water_o) THEN
      massstep_water_o = massstep_water_o
    ELSE
      massstep_water_o = 0.
    END IF
    IF (1. .GT. mass_water_o/massmax_water_o) THEN
      percent_water_o = mass_water_o/massmax_water_o
    ELSE
      percent_water_o = 1.
    END IF
!! understorey
    precipitation_u = precipitation_o - massstep_water_o/density_water/&
&     length_step
    mass_water_u = mass_water_u_last + precipitation_u*length_step*&
&     density_water*(1-EXP(-(lai_u*clumping)))
    massmax_water_u = 0.1*lai_u
    IF (0. .LT. mass_water_u) THEN
      mass_water_u = mass_water_u
    ELSE
      mass_water_u = 0.
    END IF
    IF (mass_water_u .GT. massmax_water_u) THEN
      mass_water_u = massmax_water_u
    ELSE
      mass_water_u = mass_water_u
    END IF
    massstep_water_u = mass_water_u - mass_water_u_last
    IF (massstep_water_u .LT. 0.) THEN
      massstep_water_u = 0.
    ELSE
      massstep_water_u = massstep_water_u
    END IF
    IF (1. .GT. mass_water_u/massmax_water_u) THEN
      percent_water_u = mass_water_u/massmax_water_u
    ELSE
      percent_water_u = 1.
    END IF
!! ground
    precipitation_g = precipitation_u - massstep_water_u/density_water/&
&     length_step
    RETURN
  END SUBROUTINE RAINFALL_STAGE1

!  Differentiation of rainfall_stage2 in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: mass_water_o mass_water_u evapo_water_o
!                evapo_water_u
!   with respect to varying inputs: mass_water_o mass_water_u evapo_water_o
!                evapo_water_u
!!this module will calculate the water remained on canopy surface after evaporation in this step
  SUBROUTINE RAINFALL_STAGE2_BW(evapo_water_o, evapo_water_o_bw, &
&   evapo_water_u, evapo_water_u_bw, mass_water_o, mass_water_o_bw, &
&   mass_water_u, mass_water_u_bw)
    IMPLICIT NONE
    REAL(r8), INTENT(IN) :: evapo_water_o, evapo_water_u
    REAL(r8) :: evapo_water_o_bw, evapo_water_u_bw
    REAL(r8), INTENT(INOUT) :: mass_water_o, mass_water_u
    REAL(r8), INTENT(INOUT) :: mass_water_o_bw, mass_water_u_bw
    INTRINSIC MAX
    INTEGER*4 :: branch
    CALL PUSHREAL8ARRAY(mass_water_o, r8/8)
    mass_water_o = mass_water_o - evapo_water_o*kstep
    IF (0. .LT. mass_water_o) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL8ARRAY(mass_water_u, r8/8)
    mass_water_u = mass_water_u - evapo_water_u*kstep
    IF (0. .GE. mass_water_u) mass_water_u_bw = 0.0_8
    CALL POPREAL8ARRAY(mass_water_u, r8/8)
    evapo_water_u_bw = evapo_water_u_bw - kstep*mass_water_u_bw
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) mass_water_o_bw = 0.0_8
    CALL POPREAL8ARRAY(mass_water_o, r8/8)
    evapo_water_o_bw = evapo_water_o_bw - kstep*mass_water_o_bw
  END SUBROUTINE RAINFALL_STAGE2_BW

!!this module will calculate the water remained on canopy surface after evaporation in this step
  SUBROUTINE RAINFALL_STAGE2(evapo_water_o, evapo_water_u, mass_water_o&
&   , mass_water_u)
    IMPLICIT NONE
    REAL(r8), INTENT(IN) :: evapo_water_o, evapo_water_u
    REAL(r8), INTENT(INOUT) :: mass_water_o, mass_water_u
    INTRINSIC MAX
    mass_water_o = mass_water_o - evapo_water_o*kstep
    IF (0. .LT. mass_water_o) THEN
      mass_water_o = mass_water_o
    ELSE
      mass_water_o = 0.
    END IF
    mass_water_u = mass_water_u - evapo_water_u*kstep
    IF (0. .LT. mass_water_u) THEN
      mass_water_u = mass_water_u
    ELSE
      mass_water_u = 0.
    END IF
    RETURN
  END SUBROUTINE RAINFALL_STAGE2

!  Differentiation of snowpack_stage1 in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: area_snow_o_last albedo_n_snow
!                density_snow_last mass_snow_o_last area_snow_u_last
!                area_snow_o mass_snow_u_last albedo_v_snow area_snow_u
!                density_snow mass_snow_g mass_snow_o mass_snow_u
!                lai_o percent_snow_g lai_u percent_snow_o percent_snow_u
!                mass_snow_g_last
!   with respect to varying inputs: area_snow_o_last albedo_n_snow
!                density_snow_last mass_snow_o_last area_snow_u_last
!                mass_snow_u_last albedo_v_snow lai_o lai_u depth_snow
!                mass_snow_g_last
!*****************************************************
!     Snow Pack
!*****************************************************
!! this module will calculate the percentage of canopy and ground covered by snow
!! and output albedo of snow (used in enverge balance) and density of snow in this step
!! by XZ Luo, May 25,2015
!! snowpack_stage1 happens before any consumption of snow in this step, after the snow fall (supply)
!! snowpack_stage2 happens after sublimation from ground and canopy (demand)
!! snowpack_stage3 happens after frozen and melt of snow pack (demand)
!*input:
! air temperature,preciipitation, depth of snow from last step
! density of snow from last step,mass of snow on canopy and ground  from last step
! length of step, LAI_o/u and albedo of snow from last step
!*output
! mass of snow on canopy and ground accululation of snowfall
! albedo of snow in this step
! density of snow in this step
  SUBROUTINE SNOWPACK_STAGE1_BW(temp_air, precipitation, &
&   mass_snow_o_last, mass_snow_o_last_bw, mass_snow_u_last, &
&   mass_snow_u_last_bw, mass_snow_g_last, mass_snow_g_last_bw, &
&   density_snow_last, density_snow_last_bw, area_snow_o_last, &
&   area_snow_o_last_bw, area_snow_u_last, area_snow_u_last_bw, &
&   mass_snow_o, mass_snow_o_bw, mass_snow_u, mass_snow_u_bw, &
&   mass_snow_g, mass_snow_g_bw, lai_o, lai_o_bw, lai_u, lai_u_bw, &
&   clumping, area_snow_o, area_snow_o_bw, area_snow_u, area_snow_u_bw, &
&   percent_snow_o, percent_snow_o_bw, percent_snow_u, percent_snow_u_bw&
&   , percent_snow_g, percent_snow_g_bw, density_snow, density_snow_bw, &
&   depth_snow, depth_snow_bw, albedo_v_snow, albedo_v_snow_bw, &
&   albedo_n_snow, albedo_n_snow_bw)
    IMPLICIT NONE
! here precipitation = solid water @J.Wang
    REAL(r8), INTENT(IN) :: temp_air, precipitation
    REAL(r8), INTENT(IN) :: mass_snow_o_last, mass_snow_u_last, &
&   mass_snow_g_last, density_snow_last, area_snow_o_last, &
&   area_snow_u_last
    REAL(r8) :: mass_snow_o_last_bw, mass_snow_u_last_bw, &
&   mass_snow_g_last_bw, density_snow_last_bw, area_snow_o_last_bw, &
&   area_snow_u_last_bw
    REAL(r8), INTENT(IN) :: lai_o, lai_u, clumping
    REAL(r8) :: lai_o_bw, lai_u_bw
! mass of intercepted snow on canopy and gournd 
    REAL(r8) :: mass_snow_o, mass_snow_u, mass_snow_g
    REAL(r8) :: mass_snow_o_bw, mass_snow_u_bw, mass_snow_g_bw
    REAL(r8) :: area_snow_o, area_snow_u
    REAL(r8) :: area_snow_o_bw, area_snow_u_bw
!percentage of snow cover on canopy and ground
    REAL(r8) :: percent_snow_o, percent_snow_u, percent_snow_g
    REAL(r8) :: percent_snow_o_bw, percent_snow_u_bw, percent_snow_g_bw
    REAL(r8), INTENT(INOUT) :: density_snow
    REAL(r8), INTENT(INOUT) :: density_snow_bw
    REAL(r8), INTENT(INOUT) :: depth_snow, albedo_v_snow, albedo_n_snow
    REAL(r8), INTENT(INOUT) :: depth_snow_bw, albedo_v_snow_bw, &
&   albedo_n_snow_bw
    REAL(r8) :: massmax_snow_o, massmax_snow_u
    REAL(r8) :: massmax_snow_o_bw, massmax_snow_u_bw
    REAL(r8) :: massstep_snow_o, massstep_snow_u
    REAL(r8) :: massstep_snow_o_bw, massstep_snow_u_bw
!Maximum area of snow at overstorey and understorey
    REAL(r8) :: areamax_snow_o, areamax_snow_u
    REAL(r8) :: areamax_snow_o_bw, areamax_snow_u_bw
!change of snow depth on ground
    REAL(r8) :: change_depth_snow
    REAL(r8) :: change_depth_snow_bw
!density of water, density of newly fallen snow
    REAL(r8) :: density_water, density_new_snow
    REAL(r8) :: snowrate, snowrate_o, snowrate_u, snowrate_g
    REAL(r8) :: snowrate_u_bw, snowrate_g_bw
! albedo of newly fallen snow in visible and near infrared band
    REAL(r8) :: albedo_v_newsnow, albedo_n_newsnow
    INTRINSIC EXP
    INTRINSIC MAX
    INTRINSIC MIN
    REAL(r8) :: temp_bw
    REAL(r8) :: temp_bw0
    INTEGER*4 :: branch
    density_new_snow = 67.9 + 51.3*EXP(temp_air/2.6)
    massmax_snow_o = 0.1*lai_o
    massmax_snow_u = 0.1*lai_u
    areamax_snow_o = lai_o*0.01
    areamax_snow_u = lai_u*0.01
!!@J.Wang
    snowrate = precipitation
    IF (snowrate .LT. 1.e-6) THEN
      snowrate_o = 1.e-6
    ELSE
      snowrate_o = snowrate
    END IF
    IF (temp_air .LT. 0) THEN
!! overstorey
!  snowrate_o   = max(snowrate,1.e-6)         !! @MOUSONG.WU
!  write(*,*) 'snowrate_o: ', snowrate_o
      CALL PUSHREAL8ARRAY(mass_snow_o, r8/8)
      mass_snow_o = mass_snow_o_last + snowrate_o*kstep*density_new_snow&
&       *(1-EXP(-(lai_o*clumping)))
!  write(*,*) 'mass_snow_o', mass_snow_o, massMax_snow_o
      percent_snow_o = mass_snow_o/massmax_snow_o
      IF (0. .LT. percent_snow_o) THEN
        CALL PUSHCONTROL1B(0)
        percent_snow_o = percent_snow_o
      ELSE
        percent_snow_o = 0.
        CALL PUSHCONTROL1B(1)
      END IF
      IF (1. .GT. percent_snow_o) THEN
        CALL PUSHCONTROL1B(0)
        percent_snow_o = percent_snow_o
      ELSE
        percent_snow_o = 1.
        CALL PUSHCONTROL1B(1)
      END IF
      massstep_snow_o = mass_snow_o - mass_snow_o_last
!! understorey
      snowrate_u = snowrate - massstep_snow_o/density_new_snow/kstep
      IF (0. .LT. snowrate_u) THEN
        CALL PUSHCONTROL1B(0)
        snowrate_u = snowrate_u
      ELSE
        snowrate_u = 0.
        CALL PUSHCONTROL1B(1)
      END IF
      CALL PUSHREAL8ARRAY(mass_snow_u, r8/8)
      mass_snow_u = mass_snow_u_last + snowrate_u*kstep*density_new_snow&
&       *(1-EXP(-(lai_u*clumping)))
      percent_snow_u = mass_snow_u/massmax_snow_u
      IF (0. .LT. percent_snow_u) THEN
        CALL PUSHCONTROL1B(0)
        percent_snow_u = percent_snow_u
      ELSE
        percent_snow_u = 0.
        CALL PUSHCONTROL1B(1)
      END IF
      IF (1. .GT. percent_snow_u) THEN
        CALL PUSHCONTROL1B(0)
        percent_snow_u = percent_snow_u
      ELSE
        percent_snow_u = 1.
        CALL PUSHCONTROL1B(1)
      END IF
      massstep_snow_u = mass_snow_u - mass_snow_u_last
!! ground
      snowrate_g = snowrate_u - massstep_snow_u/density_new_snow/kstep
      IF (0. .LT. snowrate_g) THEN
        CALL PUSHCONTROL1B(0)
        snowrate_g = snowrate_g
      ELSE
        snowrate_g = 0.
        CALL PUSHCONTROL1B(1)
      END IF
      change_depth_snow = snowrate_g*kstep
      CALL PUSHCONTROL1B(1)
    ELSE
!! overstorey
      CALL PUSHREAL8ARRAY(mass_snow_o, r8/8)
      mass_snow_o = mass_snow_o_last
      percent_snow_o = mass_snow_o/massmax_snow_o
      IF (0. .LT. percent_snow_o) THEN
        CALL PUSHCONTROL1B(0)
        percent_snow_o = percent_snow_o
      ELSE
        percent_snow_o = 0.
        CALL PUSHCONTROL1B(1)
      END IF
      IF (1. .GT. percent_snow_o) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
!! understorey
      CALL PUSHREAL8ARRAY(mass_snow_u, r8/8)
      mass_snow_u = mass_snow_u_last
      percent_snow_u = mass_snow_u/massmax_snow_u
      IF (0. .LT. percent_snow_u) THEN
        CALL PUSHCONTROL1B(0)
        percent_snow_u = percent_snow_u
      ELSE
        percent_snow_u = 0.
        CALL PUSHCONTROL1B(1)
      END IF
      IF (1. .GT. percent_snow_u) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
!!ground 
      change_depth_snow = 0.
      CALL PUSHCONTROL1B(0)
    END IF
    IF (0. .LT. change_depth_snow) THEN
      CALL PUSHCONTROL1B(0)
      change_depth_snow = change_depth_snow
    ELSE
      change_depth_snow = 0.
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL8ARRAY(mass_snow_g, r8/8)
    mass_snow_g = mass_snow_g_last + change_depth_snow*density_new_snow
    IF (0. .LT. mass_snow_g) THEN
      CALL PUSHCONTROL1B(0)
      mass_snow_g = mass_snow_g
    ELSE
      mass_snow_g = 0.
      CALL PUSHCONTROL1B(1)
    END IF
!  write(*,*) 'change_depth_snow', change_depth_snow
!  write(*,*) 'density_snow', density_snow_last
    IF (change_depth_snow .GT. 0.) THEN
      CALL PUSHREAL8ARRAY(density_snow, r8/8)
      density_snow = (density_snow_last*depth_snow+density_new_snow*&
&       change_depth_snow)/(depth_snow+change_depth_snow)
      CALL PUSHCONTROL1B(0)
    ELSE
!!@J.Wang ???
      CALL PUSHREAL8ARRAY(density_snow, r8/8)
      density_snow = (density_snow_last-250.)*EXP(-(0.001*kstep/3600.)) &
&       + 250.0
!    density_snow= 250.
      CALL PUSHCONTROL1B(1)
    END IF
    percent_snow_g = mass_snow_g/(0.05*density_snow)
    IF (percent_snow_g .GT. 1.) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
!! albedo of snow in this step 
    IF (snowrate_o .GT. 0.) THEN
      albedo_n_snow_bw = EXP(-(kstep*(0.005/3600.)))*albedo_n_snow_bw
      albedo_v_snow_bw = EXP(-(kstep*(0.005/3600.)))*albedo_v_snow_bw
    ELSE
      albedo_n_snow_bw = 0.0_8
      albedo_v_snow_bw = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) percent_snow_g_bw = 0.0_8
    temp_bw0 = percent_snow_g_bw/(0.05*density_snow)
    mass_snow_g_bw = mass_snow_g_bw + temp_bw0
    density_snow_bw = density_snow_bw - mass_snow_g*temp_bw0/&
&     density_snow
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8ARRAY(density_snow, r8/8)
      temp_bw = density_snow_bw/(depth_snow+change_depth_snow)
      density_snow_last_bw = density_snow_last_bw + depth_snow*temp_bw
      temp_bw0 = -((density_snow_last*depth_snow+density_new_snow*&
&       change_depth_snow)*temp_bw/(depth_snow+change_depth_snow))
      depth_snow_bw = density_snow_last*temp_bw + temp_bw0
      change_depth_snow_bw = density_new_snow*temp_bw + temp_bw0
    ELSE
      CALL POPREAL8ARRAY(density_snow, r8/8)
      density_snow_last_bw = density_snow_last_bw + EXP(-(kstep*(0.001/&
&       3600.)))*density_snow_bw
      depth_snow_bw = 0.0_8
      change_depth_snow_bw = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) mass_snow_g_bw = 0.0_8
    CALL POPREAL8ARRAY(mass_snow_g, r8/8)
    mass_snow_g_last_bw = mass_snow_g_last_bw + mass_snow_g_bw
    change_depth_snow_bw = change_depth_snow_bw + density_new_snow*&
&     mass_snow_g_bw
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) change_depth_snow_bw = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      area_snow_u_last_bw = area_snow_u_last_bw + area_snow_u_bw
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) percent_snow_u_bw = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) percent_snow_u_bw = 0.0_8
      mass_snow_u_bw = mass_snow_u_bw + percent_snow_u_bw/massmax_snow_u
      massmax_snow_u_bw = -(mass_snow_u*percent_snow_u_bw/massmax_snow_u&
&       **2)
      CALL POPREAL8ARRAY(mass_snow_u, r8/8)
      mass_snow_u_last_bw = mass_snow_u_last_bw + mass_snow_u_bw
      area_snow_o_last_bw = area_snow_o_last_bw + area_snow_o_bw
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) percent_snow_o_bw = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) percent_snow_o_bw = 0.0_8
      mass_snow_o_bw = mass_snow_o_bw + percent_snow_o_bw/massmax_snow_o
      massmax_snow_o_bw = -(mass_snow_o*percent_snow_o_bw/massmax_snow_o&
&       **2)
      CALL POPREAL8ARRAY(mass_snow_o, r8/8)
      mass_snow_o_last_bw = mass_snow_o_last_bw + mass_snow_o_bw
      areamax_snow_o_bw = 0.0_8
      areamax_snow_u_bw = 0.0_8
    ELSE
      snowrate_g_bw = kstep*change_depth_snow_bw
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) snowrate_g_bw = 0.0_8
      snowrate_u_bw = snowrate_g_bw
      massstep_snow_u_bw = -(snowrate_g_bw/(density_new_snow*kstep))
      mass_snow_u_bw = mass_snow_u_bw + massstep_snow_u_bw
      mass_snow_u_last_bw = mass_snow_u_last_bw - massstep_snow_u_bw
      percent_snow_u_bw = percent_snow_u_bw + areamax_snow_u*&
&       area_snow_u_bw
      areamax_snow_u_bw = percent_snow_u*area_snow_u_bw
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) percent_snow_u_bw = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) percent_snow_u_bw = 0.0_8
      mass_snow_u_bw = mass_snow_u_bw + percent_snow_u_bw/massmax_snow_u
      massmax_snow_u_bw = -(mass_snow_u*percent_snow_u_bw/massmax_snow_u&
&       **2)
      CALL POPREAL8ARRAY(mass_snow_u, r8/8)
      mass_snow_u_last_bw = mass_snow_u_last_bw + mass_snow_u_bw
      temp_bw = kstep*density_new_snow*mass_snow_u_bw
      snowrate_u_bw = snowrate_u_bw + (1-EXP(-(clumping*lai_u)))*temp_bw
      lai_u_bw = lai_u_bw + clumping*EXP(-(clumping*lai_u))*snowrate_u*&
&       temp_bw
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) snowrate_u_bw = 0.0_8
      massstep_snow_o_bw = -(snowrate_u_bw/(density_new_snow*kstep))
      mass_snow_o_bw = mass_snow_o_bw + massstep_snow_o_bw
      mass_snow_o_last_bw = mass_snow_o_last_bw - massstep_snow_o_bw
      percent_snow_o_bw = percent_snow_o_bw + areamax_snow_o*&
&       area_snow_o_bw
      areamax_snow_o_bw = percent_snow_o*area_snow_o_bw
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) percent_snow_o_bw = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) percent_snow_o_bw = 0.0_8
      mass_snow_o_bw = mass_snow_o_bw + percent_snow_o_bw/massmax_snow_o
      massmax_snow_o_bw = -(mass_snow_o*percent_snow_o_bw/massmax_snow_o&
&       **2)
      CALL POPREAL8ARRAY(mass_snow_o, r8/8)
      mass_snow_o_last_bw = mass_snow_o_last_bw + mass_snow_o_bw
      lai_o_bw = lai_o_bw + clumping*EXP(-(clumping*lai_o))*snowrate_o*&
&       kstep*density_new_snow*mass_snow_o_bw
    END IF
    lai_u_bw = lai_u_bw + 0.01*areamax_snow_u_bw + 0.1*massmax_snow_u_bw
    lai_o_bw = lai_o_bw + 0.01*areamax_snow_o_bw + 0.1*massmax_snow_o_bw
  END SUBROUTINE SNOWPACK_STAGE1_BW

!*****************************************************
!     Snow Pack
!*****************************************************
!! this module will calculate the percentage of canopy and ground covered by snow
!! and output albedo of snow (used in enverge balance) and density of snow in this step
!! by XZ Luo, May 25,2015
!! snowpack_stage1 happens before any consumption of snow in this step, after the snow fall (supply)
!! snowpack_stage2 happens after sublimation from ground and canopy (demand)
!! snowpack_stage3 happens after frozen and melt of snow pack (demand)
!*input:
! air temperature,preciipitation, depth of snow from last step
! density of snow from last step,mass of snow on canopy and ground  from last step
! length of step, LAI_o/u and albedo of snow from last step
!*output
! mass of snow on canopy and ground accululation of snowfall
! albedo of snow in this step
! density of snow in this step
  SUBROUTINE SNOWPACK_STAGE1(temp_air, precipitation, mass_snow_o_last, &
&   mass_snow_u_last, mass_snow_g_last, density_snow_last, &
&   area_snow_o_last, area_snow_u_last, mass_snow_o, mass_snow_u, &
&   mass_snow_g, lai_o, lai_u, clumping, area_snow_o, area_snow_u, &
&   percent_snow_o, percent_snow_u, percent_snow_g, density_snow, &
&   depth_snow, albedo_v_snow, albedo_n_snow)
    IMPLICIT NONE
! here precipitation = solid water @J.Wang
    REAL(r8), INTENT(IN) :: temp_air, precipitation
    REAL(r8), INTENT(IN) :: mass_snow_o_last, mass_snow_u_last, &
&   mass_snow_g_last, density_snow_last, area_snow_o_last, &
&   area_snow_u_last
    REAL(r8), INTENT(IN) :: lai_o, lai_u, clumping
! mass of intercepted snow on canopy and gournd 
    REAL(r8), INTENT(OUT) :: mass_snow_o, mass_snow_u, mass_snow_g
    REAL(r8), INTENT(OUT) :: area_snow_o, area_snow_u
!percentage of snow cover on canopy and ground
    REAL(r8), INTENT(OUT) :: percent_snow_o, percent_snow_u, &
&   percent_snow_g
    REAL(r8), INTENT(INOUT) :: density_snow
    REAL(r8), INTENT(INOUT) :: depth_snow, albedo_v_snow, albedo_n_snow
    REAL(r8) :: massmax_snow_o, massmax_snow_u
    REAL(r8) :: massstep_snow_o, massstep_snow_u
!Maximum area of snow at overstorey and understorey
    REAL(r8) :: areamax_snow_o, areamax_snow_u
!change of snow depth on ground
    REAL(r8) :: change_depth_snow
!density of water, density of newly fallen snow
    REAL(r8) :: density_water, density_new_snow
    REAL(r8) :: snowrate, snowrate_o, snowrate_u, snowrate_g
! albedo of newly fallen snow in visible and near infrared band
    REAL(r8) :: albedo_v_newsnow, albedo_n_newsnow
    INTRINSIC EXP
    INTRINSIC MAX
    INTRINSIC MIN
    density_new_snow = 67.9 + 51.3*EXP(temp_air/2.6)
    albedo_v_newsnow = 0.94
    albedo_n_newsnow = 0.8
    massmax_snow_o = 0.1*lai_o
    massmax_snow_u = 0.1*lai_u
    areamax_snow_o = lai_o*0.01
    areamax_snow_u = lai_u*0.01
!!@J.Wang
    snowrate = precipitation
    IF (snowrate .LT. 1.e-6) THEN
      snowrate_o = 1.e-6
    ELSE
      snowrate_o = snowrate
    END IF
    IF (temp_air .LT. 0) THEN
!! overstorey
!  snowrate_o   = max(snowrate,1.e-6)         !! @MOUSONG.WU
!  write(*,*) 'snowrate_o: ', snowrate_o
      mass_snow_o = mass_snow_o_last + snowrate_o*kstep*density_new_snow&
&       *(1-EXP(-(lai_o*clumping)))
!  write(*,*) 'mass_snow_o', mass_snow_o, massMax_snow_o
      percent_snow_o = mass_snow_o/massmax_snow_o
      IF (0. .LT. percent_snow_o) THEN
        percent_snow_o = percent_snow_o
      ELSE
        percent_snow_o = 0.
      END IF
      IF (1. .GT. percent_snow_o) THEN
        percent_snow_o = percent_snow_o
      ELSE
        percent_snow_o = 1.
      END IF
      area_snow_o = percent_snow_o*areamax_snow_o
      massstep_snow_o = mass_snow_o - mass_snow_o_last
!! understorey
      snowrate_u = snowrate - massstep_snow_o/density_new_snow/kstep
      IF (0. .LT. snowrate_u) THEN
        snowrate_u = snowrate_u
      ELSE
        snowrate_u = 0.
      END IF
      mass_snow_u = mass_snow_u_last + snowrate_u*kstep*density_new_snow&
&       *(1-EXP(-(lai_u*clumping)))
      percent_snow_u = mass_snow_u/massmax_snow_u
      IF (0. .LT. percent_snow_u) THEN
        percent_snow_u = percent_snow_u
      ELSE
        percent_snow_u = 0.
      END IF
      IF (1. .GT. percent_snow_u) THEN
        percent_snow_u = percent_snow_u
      ELSE
        percent_snow_u = 1.
      END IF
      area_snow_u = percent_snow_u*areamax_snow_u
      massstep_snow_u = mass_snow_u - mass_snow_u_last
!! ground
      snowrate_g = snowrate_u - massstep_snow_u/density_new_snow/kstep
      IF (0. .LT. snowrate_g) THEN
        snowrate_g = snowrate_g
      ELSE
        snowrate_g = 0.
      END IF
      change_depth_snow = snowrate_g*kstep
    ELSE
!! overstorey
      mass_snow_o = mass_snow_o_last
      percent_snow_o = mass_snow_o/massmax_snow_o
      IF (0. .LT. percent_snow_o) THEN
        percent_snow_o = percent_snow_o
      ELSE
        percent_snow_o = 0.
      END IF
      IF (1. .GT. percent_snow_o) THEN
        percent_snow_o = percent_snow_o
      ELSE
        percent_snow_o = 1.
      END IF
      area_snow_o = area_snow_o_last
!! understorey
      mass_snow_u = mass_snow_u_last
      percent_snow_u = mass_snow_u/massmax_snow_u
      IF (0. .LT. percent_snow_u) THEN
        percent_snow_u = percent_snow_u
      ELSE
        percent_snow_u = 0.
      END IF
      IF (1. .GT. percent_snow_u) THEN
        percent_snow_u = percent_snow_u
      ELSE
        percent_snow_u = 1.
      END IF
      area_snow_u = area_snow_u_last
!!ground 
      change_depth_snow = 0.
    END IF
    IF (0. .LT. change_depth_snow) THEN
      change_depth_snow = change_depth_snow
    ELSE
      change_depth_snow = 0.
    END IF
    mass_snow_g = mass_snow_g_last + change_depth_snow*density_new_snow
    IF (0. .LT. mass_snow_g) THEN
      mass_snow_g = mass_snow_g
    ELSE
      mass_snow_g = 0.
    END IF
!  write(*,*) 'change_depth_snow', change_depth_snow
!  write(*,*) 'density_snow', density_snow_last
    IF (change_depth_snow .GT. 0.) THEN
      density_snow = (density_snow_last*depth_snow+density_new_snow*&
&       change_depth_snow)/(depth_snow+change_depth_snow)
    ELSE
!!@J.Wang ???
      density_snow = (density_snow_last-250.)*EXP(-(0.001*kstep/3600.)) &
&       + 250.0
!    density_snow= 250.
    END IF
    IF (mass_snow_g .GT. 0.) THEN
      depth_snow = mass_snow_g/density_snow
    ELSE
      depth_snow = 0.
    END IF
    percent_snow_g = mass_snow_g/(0.05*density_snow)
    IF (percent_snow_g .GT. 1.) THEN
      percent_snow_g = 1.
    ELSE
      percent_snow_g = percent_snow_g
    END IF
!! albedo of snow in this step 
    IF (snowrate_o .GT. 0.) THEN
!!@J.Wang cannot understand clearly
      albedo_v_snow = (albedo_v_snow-0.70)*EXP(-(0.005*kstep/3600.)) + &
&       0.7
      albedo_n_snow = (albedo_n_snow-0.42)*EXP(-(0.005*kstep/3600.)) + &
&       0.42
    ELSE
      albedo_v_snow = albedo_v_newsnow
      albedo_n_snow = albedo_n_newsnow
    END IF
    RETURN
  END SUBROUTINE SNOWPACK_STAGE1

!  Differentiation of snowpack_stage2 in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: mass_snow_o mass_snow_u evapo_snow_o
!                evapo_snow_u
!   with respect to varying inputs: mass_snow_o mass_snow_u evapo_snow_o
!                evapo_snow_u
!this module will calculate the snow remained on canopy surface after evaporation in this step
  SUBROUTINE SNOWPACK_STAGE2_BW(evapo_snow_o, evapo_snow_o_bw, &
&   evapo_snow_u, evapo_snow_u_bw, mass_snow_o, mass_snow_o_bw, &
&   mass_snow_u, mass_snow_u_bw)
    IMPLICIT NONE
    REAL(r8), INTENT(IN) :: evapo_snow_o, evapo_snow_u
    REAL(r8) :: evapo_snow_o_bw, evapo_snow_u_bw
    REAL(r8), INTENT(INOUT) :: mass_snow_o, mass_snow_u
    REAL(r8), INTENT(INOUT) :: mass_snow_o_bw, mass_snow_u_bw
    INTRINSIC MAX
    INTEGER*4 :: branch
    IF (0. .LT. mass_snow_o - evapo_snow_o*kstep) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (0. .LT. mass_snow_u - evapo_snow_u*kstep) THEN
      evapo_snow_u_bw = evapo_snow_u_bw - kstep*mass_snow_u_bw
    ELSE
      mass_snow_u_bw = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      evapo_snow_o_bw = evapo_snow_o_bw - kstep*mass_snow_o_bw
    ELSE
      mass_snow_o_bw = 0.0_8
    END IF
  END SUBROUTINE SNOWPACK_STAGE2_BW

!this module will calculate the snow remained on canopy surface after evaporation in this step
  SUBROUTINE SNOWPACK_STAGE2(evapo_snow_o, evapo_snow_u, mass_snow_o, &
&   mass_snow_u)
    IMPLICIT NONE
    REAL(r8), INTENT(IN) :: evapo_snow_o, evapo_snow_u
    REAL(r8), INTENT(INOUT) :: mass_snow_o, mass_snow_u
    INTRINSIC MAX
    IF (0. .LT. mass_snow_o - evapo_snow_o*kstep) THEN
      mass_snow_o = mass_snow_o - evapo_snow_o*kstep
    ELSE
      mass_snow_o = 0.
    END IF
    IF (0. .LT. mass_snow_u - evapo_snow_u*kstep) THEN
      mass_snow_u = mass_snow_u - evapo_snow_u*kstep
    ELSE
      mass_snow_u = 0.
    END IF
    RETURN
  END SUBROUTINE SNOWPACK_STAGE2

!  Differentiation of snowpack_stage3 in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: mass_snow_g density_snow depth_water
!                temp_snow depth_snow
!   with respect to varying inputs: mass_snow_g density_snow depth_water
!                temp_snow depth_snow
!This module simulates the process of snow melting and water frozen in this step
!*input
! depth of snow on ground after stage 1,
! air temperature
! ground surface temperature
! // output:
! the amount of the melted snow, frozen snow
!
  SUBROUTINE SNOWPACK_STAGE3_BW(temp_air, temp_snow, temp_snow_bw, &
&   temp_snow_last, density_snow, density_snow_bw, depth_snow, &
&   depth_snow_bw, depth_water, depth_water_bw, mass_snow_g, &
&   mass_snow_g_bw)
    IMPLICIT NONE
    REAL(r8), INTENT(IN) :: temp_air, temp_snow, temp_snow_last, &
&   density_snow
    REAL(r8) :: temp_snow_bw, density_snow_bw
    REAL(r8), INTENT(INOUT) :: depth_snow, depth_water, mass_snow_g
    REAL(r8), INTENT(INOUT) :: depth_snow_bw, depth_water_bw, &
&   mass_snow_g_bw
! depth and mass of snow after stage1, and minus the amount of sublimation
    REAL(r8) :: depth_snow_sup, mass_snow_sup
    REAL(r8) :: depth_snow_sup_bw, mass_snow_sup_bw
    REAL(r8) :: mass_snow_melt, mass_water_frozen
    REAL(r8) :: mass_snow_melt_bw, mass_water_frozen_bw
    REAL(r8) :: melt_depth_snow, frozen_depth_snow
    REAL(r8) :: melt_depth_snow_bw, frozen_depth_snow_bw
    REAL(r8) :: melt_depth_water, frozen_depth_water
    REAL(r8) :: melt_depth_water_bw, frozen_depth_water_bw
    INTRINSIC MIN
    INTRINSIC MAX
    INTRINSIC ISNAN
    REAL(r8) :: temp_bw
    REAL(r8) :: temp_bw0
    INTEGER*4 :: branch
!! assumed sublimation happens before the melting and freezing 
    depth_snow_sup = depth_snow
    mass_snow_sup = mass_snow_g
!!simulate snow melt and freeze process
    mass_snow_melt = 0.
    mass_water_frozen = 0.
    IF (depth_snow_sup .LE. 0.02) THEN
      IF (temp_air .GT. 0. .AND. depth_snow_sup .GT. 0.) THEN
        mass_snow_melt = temp_air*0.0075*kstep/3600*0.3
        IF (mass_snow_sup .GT. mass_snow_melt) THEN
          mass_snow_melt = mass_snow_melt
          CALL PUSHCONTROL4B(5)
        ELSE
          mass_snow_melt = mass_snow_sup
          CALL PUSHCONTROL4B(4)
        END IF
      ELSE
        mass_snow_melt = 0.
        CALL PUSHCONTROL4B(3)
      END IF
    ELSE IF (depth_snow_sup .GT. 0.02 .AND. depth_snow_sup .LE. 0.05) &
&   THEN
      IF (temp_snow .GT. 0. .AND. temp_snow_last .LT. 0. .AND. &
&         mass_snow_sup .GT. 0.) THEN
        mass_snow_melt = temp_snow*cp_ice*density_snow*depth_snow_sup/&
&         latent_fusion
        IF (mass_snow_sup .GT. mass_snow_melt) THEN
          mass_snow_melt = mass_snow_melt
          CALL PUSHCONTROL2B(2)
        ELSE
          mass_snow_melt = mass_snow_sup
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        mass_snow_melt = 0.
        CALL PUSHCONTROL2B(0)
      END IF
      IF (temp_snow .LE. 0. .AND. temp_snow_last .GT. 0. .AND. &
&         depth_water .GT. 0.) THEN
        mass_water_frozen = (0.-temp_snow)*cp_ice*density_snow*&
&         depth_snow_sup/latent_fusion
        IF (mass_water_frozen .LT. depth_water*density_water) THEN
          mass_water_frozen = depth_water*density_water
          CALL PUSHCONTROL4B(7)
        ELSE
          CALL PUSHCONTROL4B(6)
          mass_water_frozen = mass_water_frozen
        END IF
      ELSE
        CALL PUSHCONTROL4B(2)
        mass_water_frozen = 0.
      END IF
    ELSE IF (depth_snow_sup .GT. 0.05) THEN
      IF (temp_snow .GT. 0. .AND. temp_snow_last .LE. 0. .AND. &
&         mass_snow_sup .GT. 0.) THEN
        mass_snow_melt = temp_snow*cp_ice*density_snow*depth_snow_sup*&
&         0.02/latent_fusion
        IF (mass_snow_sup .GT. mass_snow_melt) THEN
          mass_snow_melt = mass_snow_melt
          CALL PUSHCONTROL2B(2)
        ELSE
          mass_snow_melt = mass_snow_sup
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        mass_snow_melt = 0.
        CALL PUSHCONTROL2B(0)
      END IF
      IF (temp_snow .LE. 0. .AND. temp_snow_last .GT. 0. .AND. &
&         depth_water .GT. 0.) THEN
        mass_water_frozen = (0.-temp_snow)*cp_ice*density_snow*&
&         depth_snow_sup*0.02/latent_fusion
        IF (mass_water_frozen .LT. depth_water*density_water) THEN
          mass_water_frozen = depth_water*density_water
          CALL PUSHCONTROL4B(9)
        ELSE
          CALL PUSHCONTROL4B(8)
          mass_water_frozen = mass_water_frozen
        END IF
      ELSE
        CALL PUSHCONTROL4B(1)
        mass_water_frozen = 0.
      END IF
    ELSE
      CALL PUSHCONTROL4B(0)
    END IF
!!change in mass of snow on ground
    CALL PUSHREAL8ARRAY(mass_snow_g, r8/8)
    mass_snow_g = mass_snow_g - mass_snow_melt + mass_water_frozen
    IF (0. .LT. mass_snow_g) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
!!change of depth in snow
    melt_depth_snow = mass_snow_melt/density_snow
    frozen_depth_snow = mass_water_frozen/density_snow
    CALL PUSHREAL8ARRAY(depth_snow, r8/8)
    depth_snow = depth_snow_sup - melt_depth_snow + frozen_depth_snow
    IF (ISNAN(depth_snow)) THEN
      depth_snow = 0.
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    IF (0. .LT. depth_snow) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
!!channge of depth in water
    melt_depth_water = mass_snow_melt/density_water
    frozen_depth_water = mass_water_frozen/density_water
    CALL PUSHREAL8ARRAY(depth_water, r8/8)
    depth_water = depth_water + melt_depth_water - frozen_depth_water
    IF (0. .GE. depth_water) depth_water_bw = 0.0_8
    CALL POPREAL8ARRAY(depth_water, r8/8)
    melt_depth_water_bw = depth_water_bw
    frozen_depth_water_bw = -depth_water_bw
    mass_water_frozen_bw = frozen_depth_water_bw/density_water
    mass_snow_melt_bw = melt_depth_water_bw/density_water
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) depth_snow_bw = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) depth_snow_bw = 0.0_8
    CALL POPREAL8ARRAY(depth_snow, r8/8)
    depth_snow_sup_bw = depth_snow_bw
    melt_depth_snow_bw = -depth_snow_bw
    frozen_depth_snow_bw = depth_snow_bw
    mass_water_frozen_bw = mass_water_frozen_bw + frozen_depth_snow_bw/&
&     density_snow
    density_snow_bw = density_snow_bw - mass_water_frozen*&
&     frozen_depth_snow_bw/density_snow**2 - mass_snow_melt*&
&     melt_depth_snow_bw/density_snow**2
    mass_snow_melt_bw = mass_snow_melt_bw + melt_depth_snow_bw/&
&     density_snow
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) mass_snow_g_bw = 0.0_8
    CALL POPREAL8ARRAY(mass_snow_g, r8/8)
    mass_snow_melt_bw = mass_snow_melt_bw - mass_snow_g_bw
    mass_water_frozen_bw = mass_water_frozen_bw + mass_snow_g_bw
    CALL POPCONTROL4B(branch)
    IF (branch .LT. 5) THEN
      IF (branch .LT. 2) THEN
        IF (branch .EQ. 0) THEN
          mass_snow_sup_bw = 0.0_8
          GOTO 110
        ELSE
          GOTO 100
        END IF
      ELSE IF (branch .NE. 2) THEN
        IF (branch .EQ. 3) THEN
          mass_snow_sup_bw = 0.0_8
        ELSE
          mass_snow_sup_bw = mass_snow_melt_bw
        END IF
        GOTO 110
      END IF
    ELSE
      IF (branch .LT. 7) THEN
        IF (branch .EQ. 5) THEN
          mass_snow_sup_bw = 0.0_8
          GOTO 110
        END IF
      ELSE IF (branch .EQ. 7) THEN
        depth_water_bw = depth_water_bw + density_water*&
&         mass_water_frozen_bw
        mass_water_frozen_bw = 0.0_8
      ELSE
        IF (branch .NE. 8) THEN
          depth_water_bw = depth_water_bw + density_water*&
&           mass_water_frozen_bw
          mass_water_frozen_bw = 0.0_8
        END IF
        temp_bw0 = cp_ice*0.02*mass_water_frozen_bw
        temp_snow_bw = temp_snow_bw - density_snow*depth_snow_sup*&
&         temp_bw0/latent_fusion
        temp_bw = -(temp_snow*temp_bw0/latent_fusion)
        density_snow_bw = density_snow_bw + depth_snow_sup*temp_bw
        depth_snow_sup_bw = depth_snow_sup_bw + density_snow*temp_bw
        GOTO 100
      END IF
      temp_snow_bw = temp_snow_bw - density_snow*depth_snow_sup*cp_ice*&
&       mass_water_frozen_bw/latent_fusion
      temp_bw = -(temp_snow*cp_ice*mass_water_frozen_bw/latent_fusion)
      density_snow_bw = density_snow_bw + depth_snow_sup*temp_bw
      depth_snow_sup_bw = depth_snow_sup_bw + density_snow*temp_bw
    END IF
    CALL POPCONTROL2B(branch)
    IF (branch .EQ. 0) THEN
      mass_snow_sup_bw = 0.0_8
    ELSE
      IF (branch .EQ. 1) THEN
        mass_snow_sup_bw = mass_snow_melt_bw
        mass_snow_melt_bw = 0.0_8
      ELSE
        mass_snow_sup_bw = 0.0_8
      END IF
      temp_bw = depth_snow_sup*cp_ice*mass_snow_melt_bw/latent_fusion
      depth_snow_sup_bw = depth_snow_sup_bw + temp_snow*density_snow*&
&       cp_ice*mass_snow_melt_bw/latent_fusion
      temp_snow_bw = temp_snow_bw + density_snow*temp_bw
      density_snow_bw = density_snow_bw + temp_snow*temp_bw
    END IF
    GOTO 110
 100 CALL POPCONTROL2B(branch)
    IF (branch .EQ. 0) THEN
      mass_snow_sup_bw = 0.0_8
    ELSE
      IF (branch .EQ. 1) THEN
        mass_snow_sup_bw = mass_snow_melt_bw
        mass_snow_melt_bw = 0.0_8
      ELSE
        mass_snow_sup_bw = 0.0_8
      END IF
      temp_bw = cp_ice*0.02*mass_snow_melt_bw
      temp_bw0 = depth_snow_sup*temp_bw/latent_fusion
      depth_snow_sup_bw = depth_snow_sup_bw + temp_snow*density_snow*&
&       temp_bw/latent_fusion
      temp_snow_bw = temp_snow_bw + density_snow*temp_bw0
      density_snow_bw = density_snow_bw + temp_snow*temp_bw0
    END IF
 110 mass_snow_g_bw = mass_snow_g_bw + mass_snow_sup_bw
    depth_snow_bw = depth_snow_sup_bw
  END SUBROUTINE SNOWPACK_STAGE3_BW

!This module simulates the process of snow melting and water frozen in this step
!*input
! depth of snow on ground after stage 1,
! air temperature
! ground surface temperature
! // output:
! the amount of the melted snow, frozen snow
!
  SUBROUTINE SNOWPACK_STAGE3(temp_air, temp_snow, temp_snow_last, &
&   density_snow, depth_snow, depth_water, mass_snow_g)
    IMPLICIT NONE
    REAL(r8), INTENT(IN) :: temp_air, temp_snow, temp_snow_last, &
&   density_snow
    REAL(r8), INTENT(INOUT) :: depth_snow, depth_water, mass_snow_g
! depth and mass of snow after stage1, and minus the amount of sublimation
    REAL(r8) :: depth_snow_sup, mass_snow_sup
    REAL(r8) :: mass_snow_melt, mass_water_frozen
    REAL(r8) :: melt_depth_snow, frozen_depth_snow
    REAL(r8) :: melt_depth_water, frozen_depth_water
    INTRINSIC MIN
    INTRINSIC MAX
    INTRINSIC ISNAN
!! assumed sublimation happens before the melting and freezing 
    depth_snow_sup = depth_snow
    mass_snow_sup = mass_snow_g
!!simulate snow melt and freeze process
    mass_snow_melt = 0.
    mass_water_frozen = 0.
    IF (depth_snow_sup .LE. 0.02) THEN
      IF (temp_air .GT. 0. .AND. depth_snow_sup .GT. 0.) THEN
        mass_snow_melt = temp_air*0.0075*kstep/3600*0.3
        IF (mass_snow_sup .GT. mass_snow_melt) THEN
          mass_snow_melt = mass_snow_melt
        ELSE
          mass_snow_melt = mass_snow_sup
        END IF
      ELSE
        mass_snow_melt = 0.
      END IF
    ELSE IF (depth_snow_sup .GT. 0.02 .AND. depth_snow_sup .LE. 0.05) &
&   THEN
      IF (temp_snow .GT. 0. .AND. temp_snow_last .LT. 0. .AND. &
&         mass_snow_sup .GT. 0.) THEN
        mass_snow_melt = temp_snow*cp_ice*density_snow*depth_snow_sup/&
&         latent_fusion
        IF (mass_snow_sup .GT. mass_snow_melt) THEN
          mass_snow_melt = mass_snow_melt
        ELSE
          mass_snow_melt = mass_snow_sup
        END IF
      ELSE
        mass_snow_melt = 0.
      END IF
      IF (temp_snow .LE. 0. .AND. temp_snow_last .GT. 0. .AND. &
&         depth_water .GT. 0.) THEN
        mass_water_frozen = (0.-temp_snow)*cp_ice*density_snow*&
&         depth_snow_sup/latent_fusion
        IF (mass_water_frozen .LT. depth_water*density_water) THEN
          mass_water_frozen = depth_water*density_water
        ELSE
          mass_water_frozen = mass_water_frozen
        END IF
      ELSE
        mass_water_frozen = 0.
      END IF
    ELSE IF (depth_snow_sup .GT. 0.05) THEN
      IF (temp_snow .GT. 0. .AND. temp_snow_last .LE. 0. .AND. &
&         mass_snow_sup .GT. 0.) THEN
        mass_snow_melt = temp_snow*cp_ice*density_snow*depth_snow_sup*&
&         0.02/latent_fusion
        IF (mass_snow_sup .GT. mass_snow_melt) THEN
          mass_snow_melt = mass_snow_melt
        ELSE
          mass_snow_melt = mass_snow_sup
        END IF
      ELSE
        mass_snow_melt = 0.
      END IF
      IF (temp_snow .LE. 0. .AND. temp_snow_last .GT. 0. .AND. &
&         depth_water .GT. 0.) THEN
        mass_water_frozen = (0.-temp_snow)*cp_ice*density_snow*&
&         depth_snow_sup*0.02/latent_fusion
        IF (mass_water_frozen .LT. depth_water*density_water) THEN
          mass_water_frozen = depth_water*density_water
        ELSE
          mass_water_frozen = mass_water_frozen
        END IF
      ELSE
        mass_water_frozen = 0.
      END IF
    END IF
!!change in mass of snow on ground
    mass_snow_g = mass_snow_g - mass_snow_melt + mass_water_frozen
    IF (0. .LT. mass_snow_g) THEN
      mass_snow_g = mass_snow_g
    ELSE
      mass_snow_g = 0.
    END IF
!!change of depth in snow
    melt_depth_snow = mass_snow_melt/density_snow
    frozen_depth_snow = mass_water_frozen/density_snow
    depth_snow = depth_snow_sup - melt_depth_snow + frozen_depth_snow
    IF (ISNAN(depth_snow)) depth_snow = 0.
    IF (0. .LT. depth_snow) THEN
      depth_snow = depth_snow
    ELSE
      depth_snow = 0.
    END IF
!!channge of depth in water
    melt_depth_water = mass_snow_melt/density_water
    frozen_depth_water = mass_water_frozen/density_water
    depth_water = depth_water + melt_depth_water - frozen_depth_water
    IF (0. .LT. depth_water) THEN
      depth_water = depth_water
    ELSE
      depth_water = 0.
    END IF
    RETURN
  END SUBROUTINE SNOWPACK_STAGE3

END MODULE RAINSNOWMOD_DIFF

MODULE RESTART_DIFF
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE BEPS_PAR
  USE OUTPUTMOD_DIFF
  USE BEPSTYPE_DIFF
!--iLab::can avoid beps_time_manager, date information now passed as actual arguments
! use beps_time_manager, only:get_curr_date
  USE BEPS_SOILMOD_DIFF
  IMPLICIT NONE
  INTEGER :: rst_icdate
  INTEGER :: rst_icsec

CONTAINS
  SUBROUTINE RESTART_IO(flag, yy, mm, dd, tod)
    IMPLICIT NONE
    CHARACTER(len=*) :: flag
!-- iLab::yy,mm,dd,tod turned to input arguments
!         (can be omitted when in  flag=='read')
    INTEGER, INTENT(IN), OPTIONAL :: yy, mm, dd, tod
    REAL(r8) :: v2last1(nlp, 0:40, pft)
    INTEGER :: i, j, ierr
    CHARACTER(len=255) :: fln1, fln2
! integer          :: yy,mm,dd,tod
    CHARACTER(len=8) :: datestr
    INTRINSIC TRIM
    INTRINSIC PRESENT
    IF (TRIM(flag) .EQ. 'write') THEN
      IF (.NOT.PRESENT(yy)) THEN
        WRITE(*, '(a)') &
&       ' FATAL::restart_io::yy must be given in write mode!'
        STOP
      ELSE IF (.NOT.PRESENT(mm)) THEN
        WRITE(*, '(a)') &
&       ' FATAL::restart_io::mm must be given in write mode!'
        STOP
      ELSE IF (.NOT.PRESENT(dd)) THEN
        WRITE(*, '(a)') &
&       ' FATAL::restart_io::dd must be given in write mode!'
        STOP
      ELSE IF (.NOT.PRESENT(tod)) THEN
        WRITE(*, '(a)') &
&       ' FATAL::restart_io::tod must be given in write mode!'
        STOP
      ELSE
!   call mpi_barrier(mpi_comm_world,ierr)
!   do i = 1,PFT
!      do j = 0,40
!         call mpi_gatherv(v2last(1,j,i),npoints,mpi_real8,v2last1(1,j,i),dp,sp,mpi_real8,0,mpi_comm_world,ierr)
!      end do
!   end do
!   call mpi_barrier(mpi_comm_world,ierr)
        v2last1 = v2last
! call get_curr_date(yy,mm,dd,tod)
        WRITE(datestr, '(i8)') yy*10000 + mm*100 + dd
!   if(myid ==0) 
        WRITE(*, *) 'restart file on ', tod
!   if(myid ==0) then
        fln1 = TRIM(beps_rst_dir)//'beps.restart.'//TRIM(datestr)
        rst_icdate = yy*10000 + mm*100 + dd
        rst_icsec = tod
        OPEN(80, file=fln1, form='unformatted', status='unknown') 
        WRITE(80) rst_icdate, rst_icsec, v2last1
        CLOSE(80) 
        fln2 = TRIM(beps_rst_dir)//'rpointer'
        OPEN(81, file=fln2, form='formatted', status='REPLACE') 
        WRITE(81, '(A)') fln1
        CLOSE(81) 
!    end if
!    call mpi_barrier(mpi_comm_world,ierr)
      END IF
    ELSE IF (TRIM(flag) .EQ. 'read') THEN
!   if(myid ==0) then
      fln2 = TRIM(beps_rst_dir)//'rpointer'
      OPEN(81, file=fln2, form='formatted') 
      READ(81, '(A)') fln1
      CLOSE(81) 
      OPEN(80, file=trim(fln1), form='unformatted') 
      READ(80) rst_icdate, rst_icsec, v2last1
      CLOSE(80) 
!   end if
!   call mpi_barrier(mpi_comm_world,ierr)
!   do i = 1,PFT
!     do j = 0,40
!        call mpi_scatterv(v2last1(1,j,i),dp,sp,mpi_real8,v2last(1,j,i),npoints,mpi_real8,0,mpi_comm_world,ierr)
!     end do
!   end do
!   call mpi_bcast(rst_icdate,1,mpi_integer,0,mpi_comm_world,ierr)
!   call mpi_bcast(rst_icsec,1,mpi_integer,0,mpi_comm_world,ierr)
!   call mpi_barrier(mpi_comm_world,ierr)
      v2last = v2last1
    END IF
  END SUBROUTINE RESTART_IO

END MODULE RESTART_DIFF

!  Differentiation of cost in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: f
!   with respect to varying inputs: f x
!   RW status of diff variables: f:in-zero x:out (global)*v2last[_:_,_:_,_:_]:(loc)
!                (global)*(assim.p_f_leaf):(loc) (global)*(assim.p_b_scalar)[_:_]:(loc)
!                (global)*(assim.p_ksat_scalar)[_:_]:(loc) (global)*(assim.p_sif_beta)[_:_]:(loc)
!                (global)*(assim.p_sif_alpha)[_:_]:(loc) (global)*(assim.p_vj_slope)[_:_]:(loc)
!                (global)*(assim.p_vcmax)[_:_]:(loc) (global)*(output.cos_flux)[_:_]:(loc)
!                (global)*(output.cos_fluxpft)[_:_,_:_]:(loc) (global)*(output.thetam)[_:_]:(loc)
!                (global)*(output.thetampft)[_:_,_:_]:(loc) (global)*(output.sif)[_:_]:(loc)
!                (global)*(output.sifpft)[_:_,_:_]:(loc) (global)*(soilstat.dt)[_:_,_:_,_:_]:(loc)
!                (global)*(soilstat.ksat)[_:_,_:_,_:_]:(loc) (global)*(soilstat.b)[_:_,_:_,_:_]:(loc)
!                (global)*(soilstat.ice_ratio)[_:_,_:_,_:_]:(loc)
!                (global)*(soilstat.thetam)[_:_,_:_,_:_]:(loc)
!                (global)*(soilstat.thetam_prev)[_:_,_:_,_:_]:(loc)
!                (global)*(soilstat.temp_soil_p)[_:_,_:_,_:_]:(loc)
!                (global)*(soilstat.temp_soil_c)[_:_,_:_,_:_]:(loc)
!                (global)*(soilstat.f_ice)[_:_,_:_,_:_]:(loc) (global)*(soilstat.psim)[_:_,_:_,_:_]:(loc)
!                (global)*(soilstat.thetab)[_:_,_:_,_:_]:(loc)
!                (global)*(soilstat.psib)[_:_,_:_,_:_]:(loc) (global)*(soilstat.r_waterflow)[_:_,_:_,_:_]:(loc)
!                (global)*(soilstat.km)[_:_,_:_,_:_]:(loc) (global)*(soilstat.kb)[_:_,_:_,_:_]:(loc)
!                (global)*(soilstat.kk)[_:_,_:_,_:_]:(loc) (global)*(soilstat.cs)[_:_,_:_,_:_]:(loc)
!                (global)*(soilstat.lambda)[_:_,_:_,_:_]:(loc)
!                (global)*(soilstat.ett)[_:_,_:_,_:_]:(loc) (global)*(soilstat.g)[_:_,_:_,_:_]:(loc)
!                (global)bound_layer_res.vapor:(loc) (global)fact.latent:(loc)
!                (global)e_actual:(loc) (global)cp_air:(loc) (global)e_saturate:(loc)
!                (global)sp_humidity:(loc) (global)vpd:(loc) (global)slope_vapor:(loc)
!   Plus diff mem management of: (global)v2last:in (global)assim.p_f_leaf:in
!                (global)assim.p_b_scalar:in (global)assim.p_ksat_scalar:in
!                (global)assim.p_sif_beta:in (global)assim.p_sif_alpha:in
!                (global)assim.p_vj_slope:in (global)assim.p_vcmax:in
!                (global)output.cos_flux:in (global)output.cos_fluxpft:in
!                (global)output.thetam:in (global)output.thetampft:in
!                (global)output.sif:in (global)output.sifpft:in
!                (global)soilstat.zp:in (global)soilstat.zsp:in
!                (global)soilstat.r_rain_g:in (global)soilstat.r_drainage:in
!                (global)soilstat.r_root_decay:in (global)soilstat.psi_min:in
!                (global)soilstat.alpha:in (global)soilstat.f_soilwater:in
!                (global)soilstat.d_soil:in (global)soilstat.f_root:in
!                (global)soilstat.dt:in (global)soilstat.thermal_cond:in
!                (global)soilstat.theta_vfc:in (global)soilstat.theta_vwp:in
!                (global)soilstat.fei:in (global)soilstat.ksat:in
!                (global)soilstat.psi_sat:in (global)soilstat.b:in
!                (global)soilstat.density_soil:in (global)soilstat.f_org:in
!                (global)soilstat.ice_ratio:in (global)soilstat.thetam:in
!                (global)soilstat.thetam_prev:in (global)soilstat.temp_soil_p:in
!                (global)soilstat.temp_soil_c:in (global)soilstat.f_ice:in
!                (global)soilstat.psim:in (global)soilstat.thetab:in
!                (global)soilstat.psib:in (global)soilstat.r_waterflow:in
!                (global)soilstat.km:in (global)soilstat.kb:in
!                (global)soilstat.kk:in (global)soilstat.cs:in
!                (global)soilstat.lambda:in (global)soilstat.ett:in
!                (global)soilstat.g:in
!       module to compute cost function
!       ilab march 2021
SUBROUTINE COST_BW(n, x, x_bw, m, f, f_bw)
  IMPLICIT NONE
! arguments
  INTEGER(kind=4), INTENT(IN) :: n, m
  REAL(kind=8), INTENT(IN) :: x(n)
  REAL(kind=8) :: x_bw(n)
  REAL(kind=8) :: f
  REAL(kind=8) :: f_bw
! local
  REAL(kind=8) :: obsdiff(m), priordiff(n)
  REAL(kind=8) :: obsdiff_bw(m), priordiff_bw(n)
  INTRINSIC SUM
  CALL MISFIT_CD(n, x, m, obsdiff)
  CALL DEVPRIOR(n, x, priordiff)
  priordiff_bw = 0.0_8
  obsdiff_bw = 0.0_8
  obsdiff_bw = 2*obsdiff*0.5*f_bw
  priordiff_bw = 2*priordiff*0.5*f_bw
  CALL DEVPRIOR_BW(n, x, x_bw, priordiff, priordiff_bw)
  CALL MISFIT_BW(n, x, x_bw, m, obsdiff, obsdiff_bw)
  f_bw = 0.0_8
END SUBROUTINE COST_BW

!  Differentiation of misfit in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: x obsdiff
!   with respect to varying inputs: x
!   Plus diff mem management of: (global)soilstat.g:in (global)soilstat.ett:in
!                (global)soilstat.lambda:in (global)soilstat.cs:in
!                (global)soilstat.kk:in (global)soilstat.kb:in
!                (global)soilstat.km:in (global)soilstat.r_waterflow:in
!                (global)soilstat.psib:in (global)soilstat.thetab:in
!                (global)soilstat.psim:in (global)soilstat.f_ice:in
!                (global)soilstat.temp_soil_c:in (global)soilstat.temp_soil_p:in
!                (global)soilstat.thetam_prev:in (global)soilstat.thetam:in
!                (global)soilstat.ice_ratio:in (global)soilstat.f_org:in
!                (global)soilstat.density_soil:in (global)soilstat.b:in
!                (global)soilstat.psi_sat:in (global)soilstat.ksat:in
!                (global)soilstat.fei:in (global)soilstat.theta_vwp:in
!                (global)soilstat.theta_vfc:in (global)soilstat.thermal_cond:in
!                (global)soilstat.dt:in (global)soilstat.f_root:in
!                (global)soilstat.d_soil:in (global)soilstat.f_soilwater:in
!                (global)soilstat.alpha:in (global)soilstat.psi_min:in
!                (global)soilstat.r_root_decay:in (global)soilstat.r_drainage:in
!                (global)soilstat.r_rain_g:in (global)soilstat.zsp:in
!                (global)soilstat.zp:in (global)output.sifpft:in
!                (global)output.sif:in (global)output.thetampft:in
!                (global)output.thetam:in (global)output.cos_fluxpft:in
!                (global)output.cos_flux:in (global)assim.p_vcmax:in
!                (global)assim.p_vj_slope:in (global)assim.p_sif_alpha:in
!                (global)assim.p_sif_beta:in (global)assim.p_ksat_scalar:in
!                (global)assim.p_b_scalar:in (global)assim.p_f_leaf:in
!                (global)v2last:in
!       module to compute model-data misfit
!       ilab march 2021
!       last: 06/2022
SUBROUTINE MISFIT_BW(n, x, x_bw, m, obsdiff, obsdiff_bw)
  IMPLICIT NONE
! arguments
  INTEGER(kind=4), INTENT(IN) :: n, m
  REAL(kind=8), INTENT(IN) :: x(n)
  REAL(kind=8) :: x_bw(n)
  REAL(kind=8) :: obsdiff(m)
  REAL(kind=8) :: obsdiff_bw(m)
! local
  REAL(kind=8) :: y(m), yobs(m), syobs(m), obs_missing_value
  REAL(kind=8) :: y_bw(m)
  EXTERNAL GETOBS
  LOGICAL, DIMENSION(m) :: mask
! read obs
  CALL GETOBS(m, yobs, syobs, obs_missing_value)
! simulate obs
! difference
  mask = yobs .NE. obs_missing_value
  WHERE (.NOT.mask) obsdiff_bw = 0.0_8
  y_bw = 0.0_8
  WHERE (mask) y_bw = obsdiff_bw/syobs
  CALL EVALF_BW(n, x, x_bw, m, y, y_bw)
END SUBROUTINE MISFIT_BW

!  Differentiation of evalf in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: x y
!   with respect to varying inputs: x
!   Plus diff mem management of: output.gpppft:in output.sifpft:in
!                output.sifpft_sat:in output.npppft:in output.neppft:in
!                output.shpft:in output.lhpft:in output.transpft:in
!                output.evappft:in output.net_radpft:in output.sif:in
!                output.laipft:in output.thetampft:in output.thetam:in
!                output.faparpft:in output.vodpft:in output.cos_fluxpft:in
!                output.cos_flux:in assim.p_vcmax:in assim.p_vj_slope:in
!                assim.p_sif_alpha:in assim.p_sif_beta:in assim.p_ksat_scalar:in
!                assim.p_b_scalar:in assim.p_f_leaf:in v2last:in
!                (global)soilstat.zp:in (global)soilstat.zsp:in
!                (global)soilstat.r_rain_g:in (global)soilstat.r_drainage:in
!                (global)soilstat.r_root_decay:in (global)soilstat.psi_min:in
!                (global)soilstat.alpha:in (global)soilstat.f_soilwater:in
!                (global)soilstat.d_soil:in (global)soilstat.f_root:in
!                (global)soilstat.dt:in (global)soilstat.thermal_cond:in
!                (global)soilstat.theta_vfc:in (global)soilstat.theta_vwp:in
!                (global)soilstat.fei:in (global)soilstat.ksat:in
!                (global)soilstat.psi_sat:in (global)soilstat.b:in
!                (global)soilstat.density_soil:in (global)soilstat.f_org:in
!                (global)soilstat.ice_ratio:in (global)soilstat.thetam:in
!                (global)soilstat.thetam_prev:in (global)soilstat.temp_soil_p:in
!                (global)soilstat.temp_soil_c:in (global)soilstat.f_ice:in
!                (global)soilstat.psim:in (global)soilstat.thetab:in
!                (global)soilstat.psib:in (global)soilstat.r_waterflow:in
!                (global)soilstat.km:in (global)soilstat.kb:in
!                (global)soilstat.kk:in (global)soilstat.cs:in
!                (global)soilstat.lambda:in (global)soilstat.ett:in
!                (global)soilstat.g:in
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!> \file bepsfunc.F90
!> \brief defines a functional implementation for running BEPS model,
!>        and defines the interface for using BEPS within
!>        a sensitivity and/or optimisation framework.
!>        It defines the top-level interface 'evalf' that maps
!>        a one-dimensional control vector (normalised coordinates)
!>        to a one-dimensional simulation vector.
!>        Please note, that the implementation core of this routine
!>        was taken/transferrred from the original BEPS driver.
!>
!> \authors The Inversion Lab (Michael Vossbeck, Thomas Kaminski) 
!> \date  January 2020 (with several updates applied thereafter)
!                               
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!***********************************************************
!     evalf
!
!> @brief function like BEPS model evaluation (or simulation)
!>        that maps a given one-dimensional control vector x ("independents")
!>        in normalised units to a one-dimensional simulation vector y ("dependents")
!>        The 1D control vector captures 3 BEPS quantities (SIF, Thetam, COSflux),
!>        ordering in the 1D vector is (varying slowest to fastest)
!>        time (hourly), site, BEPS-quantity.
!>
!> @param[in]   n   length of control vector
!> @param[in]   x   control vector (in normalised units)
!> @param[in]   m   length of simulation vector
!> @param[out]  y   simulation vector
!
!> \authors Michael Vossbeck, The Inversion Lab
!> \date    January 2020
!> \last    June 2022
!>
SUBROUTINE EVALF_BW(n, x, x_bw, m, y, y_bw)
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE BEPS_CON, ONLY : pi
  USE CONTROLINPUT_MOD_DIFF, ONLY : lai_input, meteo_input, sim_duration&
& , restart_frq, nscale, read_meteo_site, read_meteo_daily, &
& read_meteo_hourly, read_lai_site, read_lai
! use controlInput_mod
  USE BEPSTYPE_DIFF, ONLY : bound, clim, assim, assim_bw
  USE ECORESPMOD_DIFF, ONLY : plant_resp, soil_resp
  USE MID_RESULTS_DIFF
  USE BEPS_SOILMOD_DIFF, ONLY : soil, soil_diff, init_soil_parameters, &
& init_soil_parameters_bw, init_soil_status, init_soil_status_bw
  USE BEPS_PAR
  USE OUTPUTMOD_DIFF, ONLY : output, output_bw, av_output
  USE RESTART_DIFF, ONLY : v2last, v2last_bw, restart_io
  USE MO_BEPSFUNC_CTL
  IMPLICIT NONE
! arguments
  INTEGER, INTENT(IN) :: n, m
  REAL(kind=8), INTENT(IN) :: x(n)
  REAL(kind=8) :: x_bw(n)
  REAL(kind=8) :: y(m)
  REAL(kind=8) :: y_bw(m)
! local declarations
  CHARACTER(len=*), PARAMETER :: sub='evalf_bw'
  TYPE(CLIMATEDATA) :: meteo
  TYPE(RESULTS) :: mid_res
  TYPE(RESULTS_DIFF) :: mid_res_bw
!! solar zenith angle, local time, local time arc
  REAL(r8) :: coszs, hr_loc, hr_arc
  INTEGER :: i, j, k, jj, ii, kk
!! at single point
  TYPE(SOIL) :: soilp
  TYPE(SOIL_DIFF) :: soilp_bw
  REAL(r8) :: ccd(0:4), cssd(0:4), csmd(0:4), cfsd(0:4), cfmd(0:4), csm(&
& 0:4), cm(0:4), cs(0:4), cp(0:4)
  REAL(r8) :: param(0:49), var_o(0:40), var_n(0:40), coef(0:49)
  REAL(r8) :: var_o_bw(0:40), var_n_bw(0:40)
  REAL(r8) :: lai
  REAL(r8) :: lai_bw
  REAL(r8) :: ratio_cloud, shortrad_df, shortrad_dir
!-- iLab::similar changes as in driver.F90 by MSWU@2020-09-21
! real(r8)             :: NPP_yr_acc           !! for storing yearly accumulated NPP, Mh/ha/s
! real(r8)             :: agb2vod
! real(r8)             :: D0(1:9)
! real(r8)             :: taweff(1:9)
  INTEGER :: kount, rst_nstep
  INTEGER :: yr, mn, dy, tod, caldy
  INTEGER :: yr_next, mn_next, dy_next, tod_next
  REAL(r8) :: daylen
! .. Parameters for model-internal use
  REAL(r8), SAVE :: pio180=pi/180.
! variables for daily input, used in climin and getmonth
  REAL(r8) :: spds, cpds
! .. Local Arrays
  REAL(r8) :: atmean, atrange
! .. Local Scalars ..
! real(r8)             :: r
  REAL(r8) :: rdaymid, delta, arg, h0, h1, sd, sd1, dhour, tmin, tmp1
  REAL(r8) :: a, b, sunset_arc
!! for counting the time-step number, i.e. ith step
  INTEGER :: nd
!-- iLab::ported from MSWU changes () in driver.f90
!-- index being passed to read_meteo_site
  INTEGER :: n_meteo
! .. Intrinsic Functions ..
  INTRINSIC ACOS, COS, SIN, MOD, ATAN, REAL
!-- counter for 1D simulation vector
  INTEGER :: jcnt
!-- number of days in (actual) year
  INTEGER :: doys
  LOGICAL :: is_end_curr_year, is_end_curr_month, is_end_curr_day, &
& is_first_step
  LOGICAL, SAVE :: bepsf_debug=.false.
  INTRINSIC MIN
  INTRINSIC MAX
  INTRINSIC SUM
  REAL(r8) :: temp_bw
  INTEGER*4 :: branch
!-- consistency
  IF (nscale .NE. 1) THEN
    STOP
  ELSE IF (meteo_input .LT. 0) THEN
    STOP
  ELSE IF (lai_input .LT. 0) THEN
    STOP
  ELSE
! parameters used for calculating VOD,@MOUSONG.WU,2019-11
!-- iLab::similar changes as in driver.F90 by MSWU@2020-09-21
! NPP_yr_acc = 0.
! agb2vod = 0.9517
! D0 = (/0.05,0.05,0.05,0.05,0.05,0.05,0.05,0.05,0.05/)
! taweff = (/15.0, 15.0, 0., 0., 0., 15., 0., 0., 15./)
!-- initialise simulation vector
!-- map actual control vector to model parameter
    CALL X2BEPS_CD(n, x)
    jcnt = 1
!! end time loop
!! start time looping
timeloop:DO nd=1,ntp
      yr = time_points(1, nd)
      mn = time_points(2, nd)
      dy = time_points(3, nd)
      CALL PUSHINTEGER4(tod)
      tod = time_points(4, nd)
      caldy = time_points(5, nd)
      doys = time_points(6, nd)
      is_first_step = nd .EQ. 1
!--iLab::equations taken from beps_time_manager
      is_end_curr_day = tod .EQ. 0
      CALL PUSHREAL8ARRAY(co2_air, r8/8)
      CALL GET_CO2_CONCENTRATION(yr, co2_air)
      CALL PUSHREAL8ARRAY(cos_air, r8/8)
      CALL GET_COS_CONCENTRATION(yr, cos_air)
!! change hourly input into daily input for further using model for long-term simulations, @MOUSONG.WU, 201905
      IF (meteo_input .GE. 0) THEN
! call hourly meteo. input
        IF (nscale .EQ. 0) THEN
          CALL PUSHREAL8ARRAY(clim%temp, r8*SIZE(clim%temp, 1)/8)
          CALL READ_METEO_HOURLY(yr, mn, dy, tod)
          CALL PUSHCONTROL2B(0)
        ELSE
!-- iLab::adapted index (similar to changes in driver.f90 by MSWU,bepspkg_2020-09-21_essi)
          CALL GET_NMETEO_CD(yr, mn, dy, tod, n_meteo)
          CALL PUSHREAL8ARRAY(clim%temp, r8*SIZE(clim%temp, 1)/8)
          CALL READ_METEO_SITE(n_meteo)
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE IF (is_first_step .OR. is_end_curr_day) THEN
        CALL PUSHCONTROL2B(2)
        CALL READ_METEO_DAILY(yr, mn, dy, tod)
      ELSE
        CALL PUSHCONTROL2B(2)
      END IF
      IF (lai_input .GE. 0) THEN
! print *, 'lai is input!'
        IF (is_first_step .OR. is_end_curr_day) THEN
          IF (nscale .EQ. 0) THEN
            CALL PUSHCONTROL2B(2)
            CALL READ_LAI(yr, mn, dy, tod, caldy)
          ELSE
            CALL PUSHCONTROL2B(2)
            CALL READ_LAI_SITE(caldy)
          END IF
        ELSE
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B(0)
      END IF
! print *, 'lai is simulated with phenology scheme!'
!! end spatial loop
! Reading the Vcmax here for assimilation usage @J.Wang
!if(is_first_step() .or. is_end_curr_month()) then
!   if (nscale == 0) then
!    call read_Vcmax(yr, mn, dy, tod)
!   else
!    call read_Vcmax_site(yr, mn, dy, tod)
!   end if
!end if
!    call mpi_barrier(mpi_comm_world,ierr)
!! spatial iteration
pointloop:DO i=1,npoints
!! calculate the solar zenith
        CALL PUSHREAL8ARRAY(coszs, r8/8)
        CALL S_COSZS(yr, mn, dy, tod, caldy, doys, bound%latitude(i), &
&              bound%longitude(i), coszs, hr_loc, hr_arc)
!!if(myid == 0) write(*,*) "hr_loc=",hr_loc
!! retrieve meteo for this point
        CALL PUSHREAL8ARRAY(meteo%srad, r8/8)
        meteo%srad = clim%srad(i)
        CALL PUSHREAL8ARRAY(meteo%wind, r8/8)
        meteo%wind = clim%wind(i)
        CALL PUSHREAL8ARRAY(meteo%rainfall, r8/8)
        meteo%rainfall = clim%rain(i)
        CALL PUSHREAL8ARRAY(meteo%snow, r8/8)
        meteo%snow = clim%snow(i)
        CALL PUSHREAL8ARRAY(meteo%rh, r8/8)
        meteo%rh = clim%rh(i)
        IF (meteo_input .LT. 0) THEN
          CALL PUSHCONTROL1B(0)
! read daily max and min temperatures instead
          meteo%tempmx = clim%tempmx(i)
          meteo%tempmn = clim%tempmn(i)
        ELSE
          CALL PUSHREAL8ARRAY(meteo%temp, r8/8)
          meteo%temp = clim%temp(i)
          CALL PUSHCONTROL1B(1)
        END IF
! .. compute daily course of temperature and daylength
        rdaymid = REAL(sim_duration+1)/2.
        delta = -(23.4*COS(2.*pi*(rdaymid+10.)/365.))
        spds = SIN(bound%latitude(i)*pio180)*SIN(delta*pio180)
        cpds = COS(bound%latitude(i)*pio180)*COS(delta*pio180)
        arg = -(spds/cpds)
        IF (arg .GT. 1.) THEN
!        polar night:
          CALL PUSHREAL8ARRAY(daylen, r8/8)
          daylen = 0.
          CALL PUSHCONTROL2B(0)
        ELSE IF (arg .LT. -1) THEN
!        polar day:
          CALL PUSHREAL8ARRAY(daylen, r8/8)
          daylen = 24.
          CALL PUSHCONTROL2B(1)
        ELSE
!        normal day / night:
          CALL PUSHREAL8ARRAY(daylen, r8/8)
          daylen = ACOS(arg)/pi*24.
          CALL PUSHCONTROL2B(2)
        END IF
!###########Compute subdaily temperature based on daily input,@MOUSONG.WU,201905#####################
        IF (meteo_input .LT. 0) THEN
! .. compute average conditions
          atmean = (meteo%tempmx+meteo%tempmn)/2.
          atrange = meteo%tempmx - meteo%tempmn
!  hour angle at sunset, added by MOUSONG.WU, 201905
          sunset_arc = daylen/2.*2.0*pi/24.0
          IF (daylen .GE. 4. .AND. daylen .LE. 20.) THEN
!        sunrise
            h0 = 12. - daylen/2.
!        sundown
            h1 = 12. + daylen/2.
!        at sundown:
            sd1 = SIN(pi*(2.*h1+(daylen-52.)/2.)/(daylen+4.))
!! unroll zum vektorisieren
            IF (hr_loc .GT. h0 .AND. hr_loc .LT. h1) THEN
              sd = SIN(pi*(2.*hr_loc+(daylen-52.)/2.)/(daylen+4.))
              CALL PUSHREAL8ARRAY(meteo%temp, r8/8)
              meteo%temp = atmean + atrange/2.*sd
              CALL PUSHCONTROL2B(0)
            ELSE
! temperature at sundown
              tmp1 = atmean + atrange/2.*sd1
! hours since sundown
              dhour = MOD(hr_loc - h1 + 24., 24.)
              tmin = atmean - atrange/2.
              CALL PUSHREAL8ARRAY(meteo%temp, r8/8)
              meteo%temp = tmp1 - (tmp1-tmin)*(dhour/(24.-daylen))
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE IF (daylen .GT. 20.) THEN
            sd = COS(pi*(hr_loc-14.)/(daylen/2.+2.))
            CALL PUSHREAL8ARRAY(meteo%temp, r8/8)
            meteo%temp = atmean + atrange/2.*sd
            CALL PUSHCONTROL2B(2)
          ELSE
            CALL PUSHREAL8ARRAY(meteo%temp, r8/8)
            meteo%temp = atmean
            CALL PUSHCONTROL2B(3)
          END IF
          CALL PUSHREAL8ARRAY(clim%temp(i), r8/8)
          clim%temp(i) = meteo%temp
! convert daily solar radiation into hourly using the method by M. Collares-Pereira and A. Rabl,
! The average distribution of solar radiation-correlations between diffuse and hemispherical
!and between daily and hourly insolation values, Solar Energy,vol. 22, no. 2, pp. 155164, 1979.
          a = 0.409 + 0.5016*SIN(sunset_arc-60.)
          b = 0.6609 - 0.4767*SIN(sunset_arc-60.)
          meteo%srad = meteo%srad*(a+b*COS(hr_arc))*(pi/24.)*(COS(hr_arc&
&           )-COS(sunset_arc))/(SIN(sunset_arc)-2*pi*sunset_arc/360.*COS&
&           (sunset_arc))
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
! Calculate cloud fraction, separate shortwave radiation
        IF (coszs .LT. 0.001) THEN
          ratio_cloud = 0.
        ELSE
          ratio_cloud = meteo%srad/(1367.*coszs)
        END IF
        IF (ratio_cloud .GT. 0.8) THEN
          shortrad_df = 0.13*meteo%srad
        ELSE
          shortrad_df = (0.943+0.734*ratio_cloud-4.9*ratio_cloud**2+&
&           1.796*ratio_cloud**3+2.058*ratio_cloud**4)*meteo%srad
        END IF
        IF (shortrad_df .GT. meteo%srad) THEN
          shortrad_df = meteo%srad
        ELSE
          shortrad_df = shortrad_df
        END IF
        IF (shortrad_df .LT. 0.) THEN
          shortrad_df = 0.
        ELSE
          shortrad_df = shortrad_df
        END IF
        shortrad_dir = meteo%srad - shortrad_df
        CALL PUSHREAL8ARRAY(meteo%s_dff, r8/8)
        meteo%s_dff = shortrad_df
        CALL PUSHREAL8ARRAY(meteo%s_dir, r8/8)
        meteo%s_dir = shortrad_dir
!! end PFT loop
!! PFT iteration
pftloop:DO j=1,pft
          IF (bound%lcno(i, j) .GT. 0 .AND. bound%sw(i) .GT. 0. .AND. &
&             bound%stext(i) .GT. 0 .AND. bound%clumping(i) .GT. 0.5) &
&         THEN
            CALL PUSHREAL8ARRAY(param, r8*50/8)
            CALL READPARAM(bound%lcno(i, j), param)
            IF (lai_input .GE. 0) THEN
              CALL PUSHCONTROL2B(0)
              lai = bound%lai(i, j)
            ELSE IF (is_first_step) THEN
              lai = bound%laiyr(i, j)
              mid_res%lai_old = lai
              CALL PUSHCONTROL2B(1)
            ELSE
              lai = mid_res%lai_new
              CALL PUSHCONTROL2B(2)
            END IF
            lai = lai*param(2)/bound%clumping(i)
            IF (nsrest .EQ. nsrstartup .AND. is_first_step) THEN
              CALL INIT_SOIL_PARAMETERS(bound%lcno(i, j), bound%stext(i)&
&                                 , param(27), soilp)
!-- iLab::applied similar changes as in driver.F90 (MSWU@2020-09-21)
              soilp%r_drainage = param(26)
! soilp%r_drainage = assim%p_drainage(j)            ! read this
!para from NC file,@MOUSONG.WU,2019-11
              ii = bound%stext(i)
! write(*,*) 'p_Ksat = ',assim%p_Ksat(ii) 
! write(*,*) 'Ksat_old = ',soilp%Ksat(0)
              DO kk=0,4
                CALL PUSHREAL8ARRAY(soilp%ksat(kk), r8/8)
                soilp%ksat(kk) = assim%p_ksat_scalar(ii)*soilp%ksat(kk)
                CALL PUSHREAL8ARRAY(soilp%b(kk), r8/8)
                soilp%b(kk) = assim%p_b_scalar(ii)*soilp%b(kk)
              END DO
! replace these three para. above with values from nc
! file,@MOUSONG.WU,2019-11
              CALL PUSHREAL8ARRAY(soilp%temp_soil_c, r8*10/8)
              CALL INIT_SOIL_STATUS(soilp, bound%st(i), clim%temp(i), &
&                             bound%sw(i), bound%sdp(i))
              DO k=0,40
                CALL PUSHREAL8ARRAY(var_o(k), r8/8)
                var_o(k) = 0.
              END DO
              DO k=3,8
                var_o(k) = clim%temp(i)
              END DO
              DO k=9,14
                var_o(k) = soilp%temp_soil_p(k-9)
              END DO
              DO k=21,26
                var_o(k) = soilp%thetam_prev(k-21)
              END DO
              DO k=27,32
                var_o(k) = soilp%ice_ratio(k-27)
              END DO
              CALL PUSHCONTROL2B(0)
            ELSE IF (nsrest .EQ. nsrcontinue .AND. is_first_step) THEN
              CALL INIT_SOIL_PARAMETERS(bound%lcno(i, j), bound%stext(i)&
&                                 , param(27), soilp)
!-- iLab::applied similar changes as in driver.F90 (MSWU@2020-09-21)
              soilp%r_drainage = param(26)
! soilp%r_drainage = assim%p_drainage(j)  ! read from nc
!                                         ! file,MOUSONG.WU@2019-11
              ii = bound%stext(i)
              DO kk=0,4
                CALL PUSHREAL8ARRAY(soilp%ksat(kk), r8/8)
                soilp%ksat(kk) = assim%p_ksat_scalar(ii)*soilp%ksat(kk)
                CALL PUSHREAL8ARRAY(soilp%b(kk), r8/8)
                soilp%b(kk) = assim%p_b_scalar(ii)*soilp%b(kk)
              END DO
!Replace with NC values,for optimization
!purpose,@MOUSONG.WU,2019-11
              CALL PUSHREAL8ARRAY(var_o, r8*41/8)
              var_o(:) = v2last(i, :, j)
              DO k=9,14
                soilp%temp_soil_c(k-9) = var_o(k)
              END DO
              DO k=21,26
                soilp%thetam(k-21) = var_o(k)
              END DO
              CALL PUSHCONTROL2B(1)
            ELSE
!                 do k = 27,32
!                    soilp%ice_ratio(k-27)   = var_o(k)
!                 end do
              CALL PUSHREAL8ARRAY(var_o, r8*41/8)
              var_o(:) = v2last(i, :, j)
              CALL RETRIVE_SOILP_CD(soilp, i, j, 0)
              CALL PUSHCONTROL2B(2)
            END IF
!!! simulating photosynthesis
!              do llll = 0,40
!                 write(*,*)  "DG004: Var_o = ",llll, var_o(llll)
!              end do
            CALL PUSHREAL8ARRAY(soilp%dt, r8*10/8)
            CALL PUSHREAL8ARRAY(soilp%ice_ratio, r8*10/8)
            CALL PUSHREAL8ARRAY(soilp%thetam, r8*10/8)
            CALL PUSHREAL8ARRAY(soilp%thetam_prev, r8*10/8)
            CALL PUSHREAL8ARRAY(soilp%temp_soil_p, r8*10/8)
            CALL PUSHREAL8ARRAY(soilp%temp_soil_c, r8*10/8)
            CALL PUSHREAL8ARRAY(soilp%f_ice, r8*10/8)
            CALL PUSHREAL8ARRAY(soilp%psim, r8*10/8)
            CALL PUSHREAL8ARRAY(soilp%thetab, r8*10/8)
            CALL PUSHREAL8ARRAY(soilp%psib, r8*10/8)
            CALL PUSHREAL8ARRAY(soilp%r_waterflow, r8*10/8)
            CALL PUSHREAL8ARRAY(soilp%km, r8*10/8)
            CALL PUSHREAL8ARRAY(soilp%kb, r8*10/8)
            CALL PUSHREAL8ARRAY(soilp%kk, r8*10/8)
            CALL PUSHREAL8ARRAY(soilp%cs, r8*10/8)
            CALL PUSHREAL8ARRAY(soilp%lambda, r8*10/8)
            CALL PUSHREAL8ARRAY(soilp%ett, r8*10/8)
            CALL PUSHREAL8ARRAY(soilp%g, r8*10/8)
            CALL PUSHREAL8ARRAY(lai, r8/8)
            CALL INTER_PRG_CD(yr, mn, dy, tod, lai, lai_input, bound%&
&                       lcno(i, j), bound%clumping(i), assim%p_vcmax(j)&
&                       , assim%p_vj_slope(j), assim%p_f_leaf, assim%&
&                       p_kc25, assim%p_ko25, assim%p_tau25, assim%&
&                       p_sif_alpha(j), assim%p_sif_beta(j), param, &
&                       meteo, coszs, var_o, var_n, soilp, mid_res, &
&                       daylen)
! CHANGE Vcmax read from Vcmax file with the Vcmax read from initial para. NC
! file, for optimization purpose,@MOUSONG.WU,2019-11
!              do llll =0,40
!                write(*,*)  "DG004: Var_n = ",llll,var_n(llll)
!             end do
            v2last(i, :, j) = var_n(:)
            CALL PUSHINTEGER4(soilp%n_layer)
            CALL PUSHREAL8ARRAY(soilp%r_drainage, r8/8)
            CALL PUSHREAL8ARRAY(soilp%psi_min, r8/8)
            CALL PUSHREAL8ARRAY(soilp%alpha, r8/8)
            CALL PUSHREAL8ARRAY(soilp%d_soil, r8*10/8)
            CALL PUSHREAL8ARRAY(soilp%f_root, r8*10/8)
            CALL PUSHREAL8ARRAY(soilp%thermal_cond, r8*10/8)
            CALL PUSHREAL8ARRAY(soilp%theta_vfc, r8*10/8)
            CALL PUSHREAL8ARRAY(soilp%theta_vwp, r8*10/8)
            CALL PUSHREAL8ARRAY(soilp%fei, r8*10/8)
            CALL PUSHREAL8ARRAY(soilp%ksat, r8*10/8)
            CALL PUSHREAL8ARRAY(soilp%psi_sat, r8*10/8)
            CALL PUSHREAL8ARRAY(soilp%b, r8*10/8)
            CALL PUSHREAL8ARRAY(soilp%density_soil, r8*10/8)
            CALL PUSHREAL8ARRAY(soilp%f_org, r8*10/8)
            CALL RETRIVE_SOILP_CD(soilp, i, j, 1)
!!! simluating Ra
!USE p_q10 here to adjust q10,p_q10 is read from initial para. NC file, for
!optimization purpose,@MOUSONG.WU,2019-11
!!! simulating Rh
! to get soil texture for this point,@MOUSONG.WU,2019-11
!-- iLab::similar changes as in driver.F90 (MSWU@2020-09-21),
!         'beta' no longer parameter
! call soil_resp(Ccd,Cssd,Csmd,Cfsd,Cfmd,Csm,Cm,Cs,&
!      Cp,bound%nppyr(i,j),coef,bound%stext(i),assim%p_beta(jj),soilp,mid_res)
! !! use p_beta read from initial para. NC file, to adjust slow
! !carbon pool, for optimization purpose,@MOUSONG.WU,2019-11
! mid_res%COS_grnd2 = mid_res%COS_grnd2 * (mid_res%NPP - mid_res%NEP)
! ! COS_flux_buf = mid_res%COS_plant + max(mid_res%COS_grnd1,mid_res%COS_grnd2)
! mid_res%COS_flux  = mid_res%COS_plant + max(mid_res%COS_grnd1,mid_res%COS_grnd2)
!! for output variables
! remove 100. for site since the PCT_PFT is fraction, @MOUSONG.WU,2019-11
            output%sifpft(i, j) = mid_res%sif*bound%pct_pft(i, j)/100.
            output%thetampft(i, j) = mid_res%thetam_surf*bound%pct_pft(i&
&             , j)/100.
!-- iLab::COS_flux computation now similar as in driver.F90 (MSWU@2020-09-21)
            output%cos_fluxpft(i, j) = (mid_res%cos_plant+mid_res%&
&             cos_grnd)*bound%pct_pft(i, j)/100.
!-- iLab::annual NPP, VOD computation now similar as in driver.F90 (MSWU@2020-09-21)
! convert NPP to Mg/ha for calculation of VOD
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO pftloop
!output%SIFpft_sat(i,j) = max(output%SIFpft_sat(i,j),0.)
!write(*,*) 'SIFpft_sat = ', output%SIFpft_sat(i,j)
!--iLab::mapping to target vector:SIF/Thetam/COSflux ->per time ->per point
!        (see mo_bepsfunc_ctl.f90 for order of simulated BEPS quantities)
        CALL PUSHINTEGER4(jcnt)
        jcnt = jcnt + 3
      END DO pointloop
    END DO timeloop
    output_bw%sifpft = 0.0_8
    output_bw%sif = 0.0_8
    output_bw%thetampft = 0.0_8
    output_bw%thetam = 0.0_8
    output_bw%cos_fluxpft = 0.0_8
    output_bw%cos_flux = 0.0_8
    assim_bw%p_vcmax = 0.0_8
    assim_bw%p_vj_slope = 0.0_8
    assim_bw%p_sif_alpha = 0.0_8
    assim_bw%p_sif_beta = 0.0_8
    assim_bw%p_ksat_scalar = 0.0_8
    assim_bw%p_b_scalar = 0.0_8
    assim_bw%p_f_leaf = 0.0_8
    IF (ALLOCATED(v2last_bw)) v2last_bw = 0.0_8
    var_n_bw = 0.0_8
    var_o_bw = 0.0_8
    mid_res_bw%lai_old = 0.0_8
    mid_res_bw%lai_new = 0.0_8
    soilp_bw%dt = 0.0_8
    soilp_bw%ksat = 0.0_8
    soilp_bw%b = 0.0_8
    soilp_bw%ice_ratio = 0.0_8
    soilp_bw%thetam = 0.0_8
    soilp_bw%thetam_prev = 0.0_8
    soilp_bw%temp_soil_p = 0.0_8
    soilp_bw%temp_soil_c = 0.0_8
    soilp_bw%f_ice = 0.0_8
    soilp_bw%psim = 0.0_8
    soilp_bw%thetab = 0.0_8
    soilp_bw%psib = 0.0_8
    soilp_bw%r_waterflow = 0.0_8
    soilp_bw%km = 0.0_8
    soilp_bw%kb = 0.0_8
    soilp_bw%kk = 0.0_8
    soilp_bw%cs = 0.0_8
    soilp_bw%lambda = 0.0_8
    soilp_bw%ett = 0.0_8
    soilp_bw%g = 0.0_8
    DO nd=ntp,1,-1
      DO i=npoints,1,-1
        CALL POPINTEGER4(jcnt)
        output_bw%cos_flux(i) = output_bw%cos_flux(i) + y_bw(jcnt+2)
        y_bw(jcnt+2) = 0.0_8
        output_bw%thetam(i) = output_bw%thetam(i) + y_bw(jcnt+1)
        y_bw(jcnt+1) = 0.0_8
        output_bw%sif(i) = output_bw%sif(i) + y_bw(jcnt)
        y_bw(jcnt) = 0.0_8
        output_bw%cos_fluxpft(i, :) = output_bw%cos_fluxpft(i, :) + &
&         output_bw%cos_flux(i)
        output_bw%cos_flux(i) = 0.0_8
        output_bw%thetampft(i, :) = output_bw%thetampft(i, :) + &
&         output_bw%thetam(i)
        output_bw%thetam(i) = 0.0_8
        output_bw%sifpft(i, :) = output_bw%sifpft(i, :) + output_bw%sif(&
&         i)
        output_bw%sif(i) = 0.0_8
        DO j=pft,1,-1
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            temp_bw = bound%pct_pft(i, j)*output_bw%cos_fluxpft(i, j)/&
&             100.
            output_bw%cos_fluxpft(i, j) = 0.0_8
            mid_res_bw%cos_plant = temp_bw
            mid_res_bw%cos_grnd = temp_bw
            mid_res_bw%thetam_surf = bound%pct_pft(i, j)*output_bw%&
&             thetampft(i, j)/100.
            output_bw%thetampft(i, j) = 0.0_8
            mid_res_bw%sif = bound%pct_pft(i, j)*output_bw%sifpft(i, j)/&
&             100.
            output_bw%sifpft(i, j) = 0.0_8
            CALL POPREAL8ARRAY(soilp%f_org, r8*10/8)
            CALL POPREAL8ARRAY(soilp%density_soil, r8*10/8)
            CALL POPREAL8ARRAY(soilp%b, r8*10/8)
            CALL POPREAL8ARRAY(soilp%psi_sat, r8*10/8)
            CALL POPREAL8ARRAY(soilp%ksat, r8*10/8)
            CALL POPREAL8ARRAY(soilp%fei, r8*10/8)
            CALL POPREAL8ARRAY(soilp%theta_vwp, r8*10/8)
            CALL POPREAL8ARRAY(soilp%theta_vfc, r8*10/8)
            CALL POPREAL8ARRAY(soilp%thermal_cond, r8*10/8)
            CALL POPREAL8ARRAY(soilp%f_root, r8*10/8)
            CALL POPREAL8ARRAY(soilp%d_soil, r8*10/8)
            CALL POPREAL8ARRAY(soilp%alpha, r8/8)
            CALL POPREAL8ARRAY(soilp%psi_min, r8/8)
            CALL POPREAL8ARRAY(soilp%r_drainage, r8/8)
            CALL POPINTEGER4(soilp%n_layer)
            CALL RETRIVE_SOILP_BW(soilp, soilp_bw, i, j, 1)
            var_n_bw = var_n_bw + v2last_bw(i, :, j)
            v2last_bw(i, :, j) = 0.0_8
            CALL POPREAL8ARRAY(lai, r8/8)
            CALL POPREAL8ARRAY(soilp%g, r8*10/8)
            CALL POPREAL8ARRAY(soilp%ett, r8*10/8)
            CALL POPREAL8ARRAY(soilp%lambda, r8*10/8)
            CALL POPREAL8ARRAY(soilp%cs, r8*10/8)
            CALL POPREAL8ARRAY(soilp%kk, r8*10/8)
            CALL POPREAL8ARRAY(soilp%kb, r8*10/8)
            CALL POPREAL8ARRAY(soilp%km, r8*10/8)
            CALL POPREAL8ARRAY(soilp%r_waterflow, r8*10/8)
            CALL POPREAL8ARRAY(soilp%psib, r8*10/8)
            CALL POPREAL8ARRAY(soilp%thetab, r8*10/8)
            CALL POPREAL8ARRAY(soilp%psim, r8*10/8)
            CALL POPREAL8ARRAY(soilp%f_ice, r8*10/8)
            CALL POPREAL8ARRAY(soilp%temp_soil_c, r8*10/8)
            CALL POPREAL8ARRAY(soilp%temp_soil_p, r8*10/8)
            CALL POPREAL8ARRAY(soilp%thetam_prev, r8*10/8)
            CALL POPREAL8ARRAY(soilp%thetam, r8*10/8)
            CALL POPREAL8ARRAY(soilp%ice_ratio, r8*10/8)
            CALL POPREAL8ARRAY(soilp%dt, r8*10/8)
            CALL INTER_PRG_BW(yr, mn, dy, tod, lai, lai_bw, lai_input, &
&                       bound%lcno(i, j), bound%clumping(i), assim%&
&                       p_vcmax(j), assim_bw%p_vcmax(j), assim%&
&                       p_vj_slope(j), assim_bw%p_vj_slope(j), assim%&
&                       p_f_leaf, assim_bw%p_f_leaf, assim%p_kc25, assim&
&                       %p_ko25, assim%p_tau25, assim%p_sif_alpha(j), &
&                       assim_bw%p_sif_alpha(j), assim%p_sif_beta(j), &
&                       assim_bw%p_sif_beta(j), param, meteo, coszs, &
&                       var_o, var_o_bw, var_n, var_n_bw, soilp, &
&                       soilp_bw, mid_res, mid_res_bw, daylen)
            CALL POPCONTROL2B(branch)
            IF (branch .EQ. 0) THEN
              DO k=32,27,-1
                soilp_bw%ice_ratio(k-27) = soilp_bw%ice_ratio(k-27) + &
&                 var_o_bw(k)
                var_o_bw(k) = 0.0_8
              END DO
              DO k=26,21,-1
                soilp_bw%thetam_prev(k-21) = soilp_bw%thetam_prev(k-21) &
&                 + var_o_bw(k)
                var_o_bw(k) = 0.0_8
              END DO
              DO k=14,9,-1
                soilp_bw%temp_soil_p(k-9) = soilp_bw%temp_soil_p(k-9) + &
&                 var_o_bw(k)
                var_o_bw(k) = 0.0_8
              END DO
              DO k=8,3,-1
                var_o_bw(k) = 0.0_8
              END DO
              DO k=40,0,-1
                CALL POPREAL8ARRAY(var_o(k), r8/8)
                var_o_bw(k) = 0.0_8
              END DO
              CALL POPREAL8ARRAY(soilp%temp_soil_c, r8*10/8)
              CALL INIT_SOIL_STATUS_BW(soilp, soilp_bw, bound%st(i), &
&                                clim%temp(i), bound%sw(i), bound%sdp(i)&
&                               )
              ii = bound%stext(i)
              DO kk=4,0,-1
                CALL POPREAL8ARRAY(soilp%b(kk), r8/8)
                assim_bw%p_b_scalar(ii) = assim_bw%p_b_scalar(ii) + &
&                 soilp%b(kk)*soilp_bw%b(kk)
                soilp_bw%b(kk) = assim%p_b_scalar(ii)*soilp_bw%b(kk)
                CALL POPREAL8ARRAY(soilp%ksat(kk), r8/8)
                assim_bw%p_ksat_scalar(ii) = assim_bw%p_ksat_scalar(ii) &
&                 + soilp%ksat(kk)*soilp_bw%ksat(kk)
                soilp_bw%ksat(kk) = assim%p_ksat_scalar(ii)*soilp_bw%&
&                 ksat(kk)
              END DO
              CALL INIT_SOIL_PARAMETERS_BW(bound%lcno(i, j), bound%stext&
&                                    (i), param(27), soilp, soilp_bw)
            ELSE
              IF (branch .EQ. 1) THEN
                DO k=26,21,-1
                  var_o_bw(k) = var_o_bw(k) + soilp_bw%thetam(k-21)
                  soilp_bw%thetam(k-21) = 0.0_8
                END DO
                DO k=14,9,-1
                  var_o_bw(k) = var_o_bw(k) + soilp_bw%temp_soil_c(k-9)
                  soilp_bw%temp_soil_c(k-9) = 0.0_8
                END DO
                CALL POPREAL8ARRAY(var_o, r8*41/8)
                v2last_bw(i, :, j) = v2last_bw(i, :, j) + var_o_bw
                ii = bound%stext(i)
                DO kk=4,0,-1
                  CALL POPREAL8ARRAY(soilp%b(kk), r8/8)
                  assim_bw%p_b_scalar(ii) = assim_bw%p_b_scalar(ii) + &
&                   soilp%b(kk)*soilp_bw%b(kk)
                  soilp_bw%b(kk) = assim%p_b_scalar(ii)*soilp_bw%b(kk)
                  CALL POPREAL8ARRAY(soilp%ksat(kk), r8/8)
                  assim_bw%p_ksat_scalar(ii) = assim_bw%p_ksat_scalar(ii&
&                   ) + soilp%ksat(kk)*soilp_bw%ksat(kk)
                  soilp_bw%ksat(kk) = assim%p_ksat_scalar(ii)*soilp_bw%&
&                   ksat(kk)
                END DO
                CALL INIT_SOIL_PARAMETERS_BW(bound%lcno(i, j), bound%&
&                                      stext(i), param(27), soilp, &
&                                      soilp_bw)
              ELSE
                CALL RETRIVE_SOILP_BW(soilp, soilp_bw, i, j, 0)
                CALL POPREAL8ARRAY(var_o, r8*41/8)
                v2last_bw(i, :, j) = v2last_bw(i, :, j) + var_o_bw
              END IF
              var_o_bw = 0.0_8
            END IF
            lai_bw = param(2)*lai_bw/bound%clumping(i)
            CALL POPCONTROL2B(branch)
            IF (branch .NE. 0) THEN
              IF (branch .EQ. 1) THEN
                mid_res_bw%lai_old = 0.0_8
              ELSE
                mid_res_bw%lai_new = mid_res_bw%lai_new + lai_bw
              END IF
            END IF
            CALL POPREAL8ARRAY(param, r8*50/8)
          END IF
        END DO
        CALL POPREAL8ARRAY(meteo%s_dir, r8/8)
        CALL POPREAL8ARRAY(meteo%s_dff, r8/8)
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8ARRAY(clim%temp(i), r8/8)
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              CALL POPREAL8ARRAY(meteo%temp, r8/8)
            ELSE
              CALL POPREAL8ARRAY(meteo%temp, r8/8)
            END IF
          ELSE IF (branch .EQ. 2) THEN
            CALL POPREAL8ARRAY(meteo%temp, r8/8)
          ELSE
            CALL POPREAL8ARRAY(meteo%temp, r8/8)
          END IF
        END IF
        CALL POPCONTROL2B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8ARRAY(daylen, r8/8)
        ELSE IF (branch .EQ. 1) THEN
          CALL POPREAL8ARRAY(daylen, r8/8)
        ELSE
          CALL POPREAL8ARRAY(daylen, r8/8)
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) CALL POPREAL8ARRAY(meteo%temp, r8/8)
        CALL POPREAL8ARRAY(meteo%rh, r8/8)
        CALL POPREAL8ARRAY(meteo%snow, r8/8)
        CALL POPREAL8ARRAY(meteo%rainfall, r8/8)
        CALL POPREAL8ARRAY(meteo%wind, r8/8)
        CALL POPREAL8ARRAY(meteo%srad, r8/8)
        CALL POPREAL8ARRAY(coszs, r8/8)
      END DO
      CALL POPCONTROL2B(branch)
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8ARRAY(clim%temp, r8*SIZE(clim%temp, 1)/8)
      ELSE IF (branch .EQ. 1) THEN
        CALL POPREAL8ARRAY(clim%temp, r8*SIZE(clim%temp, 1)/8)
      END IF
      CALL POPREAL8ARRAY(cos_air, r8/8)
      CALL POPREAL8ARRAY(co2_air, r8/8)
      CALL POPINTEGER4(tod)
    END DO
    CALL X2BEPS_BW(n, x, x_bw)
  END IF
END SUBROUTINE EVALF_BW

!  Differentiation of inter_prg in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: vcmax0 var_n var_o sif_alpha
!                mid_res.sif mid_res.thetam_surf mid_res.lai_old
!                mid_res.lai_new mid_res.cos_plant mid_res.cos_grnd
!                vj_slope sif_beta soilp.dt soilp.ksat soilp.b
!                soilp.ice_ratio soilp.thetam soilp.thetam_prev
!                soilp.temp_soil_p soilp.temp_soil_c soilp.f_ice
!                soilp.psim soilp.thetab soilp.psib soilp.r_waterflow
!                soilp.km soilp.kb soilp.kk soilp.cs soilp.lambda
!                soilp.ett soilp.g f_leaf
!   with respect to varying inputs: lai vcmax0 var_n var_o sif_alpha
!                mid_res.lai_old mid_res.lai_new vj_slope sif_beta
!                soilp.dt soilp.ksat soilp.b soilp.ice_ratio soilp.thetam
!                soilp.thetam_prev soilp.temp_soil_p soilp.temp_soil_c
!                soilp.f_ice soilp.psim soilp.thetab soilp.psib
!                soilp.r_waterflow soilp.km soilp.kb soilp.kk soilp.cs
!                soilp.lambda soilp.ett soilp.g f_leaf
!! Last update: July,2015
!! Fortran version: 3/5/2017 @J.Wang
SUBROUTINE INTER_PRG_BW(yr, mn, dy, tod, lai, lai_bw, lai_input, lc, &
& clumping, vcmax0, vcmax0_bw, vj_slope, vj_slope_bw, f_leaf, f_leaf_bw&
& , p_kc25, p_ko25, p_tau25, sif_alpha, sif_alpha_bw, sif_beta, &
& sif_beta_bw, param, meteo, coszs, var_o, var_o_bw, var_n, var_n_bw, &
& soilp, soilp_bw, mid_res, mid_res_bw, daylen)
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
!--iLab::restrict use of beps_time_manager to required entities  
!--iLab-update::extended arguments to avoid time manager completely
! use beps_time_manager, only:is_end_curr_day, get_curr_date
  USE BEPS_SOILMOD_DIFF
  USE BEPSTYPE_DIFF
  USE MID_RESULTS_DIFF
  USE BEPS_PAR
  USE ANGSMOD_DIFF
  USE RAINSNOWMOD_DIFF
  IMPLICIT NONE
!--iLab::added date-elements as argument to avoid 'call get_curr_date' further below
  INTEGER, INTENT(IN) :: yr, mn, dy, tod
  INTEGER, INTENT(IN) :: lc
!!J.Wang
  REAL(r8), INTENT(IN) :: clumping, vcmax0, vj_slope, f_leaf, p_ko25, &
& p_kc25, p_tau25, sif_alpha, sif_beta, coszs, daylen
  REAL(r8) :: vcmax0_bw, vj_slope_bw, f_leaf_bw, sif_alpha_bw, &
& sif_beta_bw
  REAL(r8), INTENT(IN) :: param(0:49)
  TYPE(CLIMATEDATA), INTENT(IN) :: meteo
  REAL(r8), INTENT(IN) :: var_o(0:40)
  REAL(r8) :: var_o_bw(0:40)
  REAL(r8) :: var_n(0:40)
  REAL(r8) :: var_n_bw(0:40)
  REAL(r8), INTENT(INOUT) :: lai
  REAL(r8), INTENT(INOUT) :: lai_bw
  TYPE(SOIL) :: soilp
  TYPE(SOIL_DIFF) :: soilp_bw
  TYPE(RESULTS) :: mid_res
  TYPE(RESULTS_DIFF) :: mid_res_bw
  INTEGER, INTENT(IN) :: lai_input
!real(r8),intent(out) :: gs_h2o,G_o_b
  INTEGER :: num, kkk, i, j
  INTEGER, PARAMETER :: iter_max=20
  INTEGER :: landcover
  REAL(r8) :: lai_o, lai_u, stem_o, stem_u
  REAL(r8) :: lai_o_bw, lai_u_bw
  REAL(r8) :: d_soil(0:layer)
!the depth of snow on the surface
  REAL(r8) :: zsp
  REAL(r8) :: zsp_bw
!depth of pounded water on the surface
  REAL(r8) :: zp
  REAL(r8) :: zp_bw
  REAL(r8), SAVE :: zp1=0.
  REAL(r8), SAVE :: zp2=0.
!height of the Va measured for calculation of L
  REAL(r8) :: height_wind_sp
!sensible heating
  REAL(r8) :: qhc_o(0:iter_max), qhc_u(0:iter_max), qhg(0:iter_max)
  REAL(r8) :: qhc_o_bw(0:iter_max)
!the heat flux into the canopy of over story --in W/m^2
  REAL(r8) :: g(0:layer+1, 0:iter_max)
  REAL(r8) :: g_bw(0:layer+1, 0:iter_max)
!the masses od rain and snow on the canopy
  REAL(r8) :: wcl_o(0:iter_max), wcs_o(0:iter_max)
  REAL(r8) :: wcl_o_bw(0:iter_max), wcs_o_bw(0:iter_max)
!the fractoion of canopy coverd by liquid water and snow
  REAL(r8) :: xcl_o(0:iter_max), xcs_o(0:iter_max)
  REAL(r8) :: xcl_o_bw(0:iter_max), xcs_o_bw(0:iter_max)
  REAL(r8) :: wcl_u(0:iter_max), wcs_u(0:iter_max)
  REAL(r8) :: wcl_u_bw(0:iter_max), wcs_u_bw(0:iter_max)
  REAL(r8) :: xcl_u(0:iter_max), xcs_u(0:iter_max)
  REAL(r8) :: xcl_u_bw(0:iter_max), xcs_u_bw(0:iter_max)
!the rainfall rate on ground surface m/s
  REAL(r8) :: r_rain_g(0:iter_max)
  REAL(r8) :: r_rain_g_bw(0:iter_max)
!density of snow
  REAL(r8) :: rho_snow(0:iter_max)
  REAL(r8) :: rho_snow_bw(0:iter_max)
!albedo of snow
  REAL(r8) :: alpha_v_sw(0:iter_max), alpha_n_sw(0:iter_max)
  REAL(r8) :: alpha_v_sw_bw(0:iter_max), alpha_n_sw_bw(0:iter_max)
! amount of snow on ground
  REAL(r8) :: wg_snow(0:iter_max)
  REAL(r8) :: wg_snow_bw(0:iter_max)
! fraction of the ground surface overed by snow
  REAL(r8) :: xg_snow(0:iter_max)
  REAL(r8) :: xg_snow_bw(0:iter_max)
! area of canopy covered by snow
  REAL(r8) :: ac_snow_o(0:iter_max), ac_snow_u(0:iter_max)
  REAL(r8) :: ac_snow_o_bw(0:iter_max), ac_snow_u_bw(0:iter_max)
!surface temperature
  REAL(r8) :: ts0(0:iter_max), tsn0(0:iter_max), tsm0(0:iter_max), tsn1(&
& 0:iter_max), tsn2(0:iter_max)
  REAL(r8) :: ts0_bw(0:iter_max), tsn0_bw(0:iter_max), tsm0_bw(0:&
& iter_max), tsn1_bw(0:iter_max), tsn2_bw(0:iter_max)
!effective canopy temperature in K
  REAL(r8) :: tc_u(0:iter_max)
  REAL(r8) :: tc_u_bw(0:iter_max)
!soil temperature at the bottom and middle of each layer
  REAL(r8) :: tm(0:layer+1, 0:iter_max)
  REAL(r8) :: tm_bw(0:layer+1, 0:iter_max)
!thermal conductivity of each soil layer
  REAL(r8) :: lambda_soil(0:layer+1)
  REAL(r8) :: lambda_soil_bw(0:layer+1)
! soil volumetric hear capacity of each soil layer J/m3/K
  REAL(r8) :: cs(0:layer+1, 0:iter_max)
  REAL(r8) :: cs_bw(0:layer+1, 0:iter_max)
  REAL(r8) :: temp_air, temp_grd
!%,m/s,m/s @J.Wang  make original precipitation into rainfall and snow
  REAL(r8) :: rh_air, wind_sp, snow, rainfall
!the evaporation rate of intercepted water of overstory--in kg/m^2/s
  REAL(r8) :: eil_o(0:iter_max), eis_o(0:iter_max)
  REAL(r8) :: eil_o_bw(0:iter_max), eis_o_bw(0:iter_max)
  REAL(r8) :: eil_u(0:iter_max), eis_u(0:iter_max)
  REAL(r8) :: eil_u_bw(0:iter_max), eis_u_bw(0:iter_max)
!transpiration
  REAL(r8) :: trans_o(0:iter_max), trans_u(0:iter_max)
  REAL(r8) :: trans_o_bw(0:iter_max), trans_u_bw(0:iter_max)
  REAL(r8) :: evap_soil(0:iter_max)
  REAL(r8) :: evap_soil_bw(0:iter_max)
!evaporation from water pond
  REAL(r8) :: evap_sw(0:iter_max)
  REAL(r8) :: evap_sw_bw(0:iter_max)
!evaporation from snow pack
  REAL(r8) :: evap_ss(0:iter_max)
  REAL(r8) :: evap_ss_bw(0:iter_max)
!effective thermal conductivity of snow in m2/s
  REAL(r8) :: lambda_snow(0:iter_max)
! vapour partial pressure of water in kPa
  REAL(r8) :: e_a10
! the latent heat of vaporation from liquid at air temperature=Ta
  REAL(r8) :: lv_liquid
! the latent heat of vaporation from solid (snow/ice) at air temperature
  REAL(r8), SAVE :: lv_solid=2.83*1e6
! instantaneous total short wave radiation (Global radiation)
  REAL(r8) :: ks
  REAL(r8) :: alpha_sat, alpha_dry
!visible albedo of overstory,  o--overstory, u--understory
  REAL(r8) :: alpha_v_o, alpha_v_u
!near_infrared albedo
  REAL(r8) :: alpha_n_o, alpha_n_u
! all-wave ground surface albedo
  REAL(r8) :: alpha_g
  REAL(r8) :: alpha_g_bw
  REAL(r8) :: alpha_v_g, alpha_n_g
  REAL(r8) :: alpha_v_g_bw, alpha_n_g_bw
! specific heat of moist air above the canopy
  REAL(r8) :: cp_ca
! the aerodynamic resistance of overstory, understory and ground surface
  REAL(r8) :: ra_o, ra_u, ra_g
  REAL(r8) :: ra_g_bw
! actural canopy stomatal resistance  --in s/m
  REAL(r8) :: q_ca
  REAL(r8) :: radiation_o, radiation_u, radiation_g
  REAL(r8) :: radiation_g_bw
!the cumulative infiltration at the time of ponding   --in m/s
  REAL(r8), SAVE :: ip=0.
  REAL(r8), SAVE :: infil=0.
  REAL(r8), SAVE :: zr=0.8
  REAL(r8), SAVE :: cpd=1004.65
  REAL(r8) :: cs_o_sunlit_old, cs_o_shaded_old, cs_u_sunlit_old, &
& cs_u_shaded_old
! CO2 concentration on the surfaces of leaves
  REAL(r8) :: coss_o_sunlit_old, coss_o_shaded_old, coss_u_sunlit_old, &
& coss_u_shaded_old
! COS concentration on the surfaces of leaves
  REAL(r8) :: tc_o_sunlit_old, tc_o_shaded_old, tc_u_sunlit_old, &
& tc_u_shaded_old
  REAL(r8) :: tc_o_sunlit_old_bw, tc_o_shaded_old_bw, tc_u_sunlit_old_bw&
& , tc_u_shaded_old_bw
! the effective canopy temperature in K
  REAL(r8) :: gs_o_sunlit_new, gs_o_shaded_new, gs_u_sunlit_new, &
& gs_u_shaded_new
  REAL(r8) :: gs_o_sunlit_new_bw, gs_o_shaded_new_bw, gs_u_sunlit_new_bw&
& , gs_u_shaded_new_bw
!stomatal conductance of the big leaf     for water
  REAL(r8) :: gs_o_sunlit_old, gs_o_shaded_old, gs_u_sunlit_old, &
& gs_u_shaded_old
  REAL(r8) :: gs_o_sunlit_old_bw, gs_o_shaded_old_bw, gs_u_sunlit_old_bw&
& , gs_u_shaded_old_bw
! net photosynthesis rate
  REAL(r8) :: ac_o_sunlit, ac_o_shaded, ac_u_sunlit, ac_u_shaded
  REAL(r8) :: ac_o_sunlit_bw, ac_o_shaded_bw, ac_u_sunlit_bw, &
& ac_u_shaded_bw
  REAL(r8) :: cs_o_sunlit_new, cs_o_shaded_new, cs_u_sunlit_new, &
& cs_u_shaded_new
! CO2 concentration on the surfaces of     leaves
  REAL(r8) :: coss_o_sunlit_new, coss_o_shaded_new, coss_u_sunlit_new, &
& coss_u_shaded_new
! COS concentration on the surfaces of     leaves
  REAL(r8) :: ci_o_sunlit_new, ci_o_shaded_new, ci_u_sunlit_new, &
& ci_u_shaded_new
! intercellular CO2 concentration pn th    e leaf
  REAL(r8) :: cosi_o_sunlit_new, cosi_o_shaded_new, cosi_u_sunlit_new, &
& cosi_u_shaded_new
  REAL(r8) :: cosi_o_sunlit_new_bw, cosi_o_shaded_new_bw, &
& cosi_u_sunlit_new_bw, cosi_u_shaded_new_bw
! intercellular COS concentration pn the leaf
  REAL(r8) :: ci_o_sunlit_old, ci_o_shaded_old, ci_u_sunlit_old, &
& ci_u_shaded_old
  REAL(r8) :: cosi_o_sunlit_old, cosi_o_shaded_old, cosi_u_sunlit_old, &
& cosi_u_shaded_old
  REAL(r8) :: cosi_o_sunlit_old_bw, cosi_o_shaded_old_bw, &
& cosi_u_sunlit_old_bw, cosi_u_shaded_old_bw
  REAL(r8) :: cc_o_sunlit_new, cc_o_shaded_new, cc_u_sunlit_new, &
& cc_u_shaded_new
! CO2 concentration in the chloroplast
  REAL(r8) :: cosc_o_sunlit_new, cosc_o_shaded_new, cosc_u_sunlit_new, &
& cosc_u_shaded_new
! COS concentration in the chloroplast
  REAL(r8) :: tc_o_sunlit_new, tc_o_shaded_new, tc_u_sunlit_new, &
& tc_u_shaded_new
  REAL(r8) :: tc_o_sunlit_new_bw, tc_o_shaded_new_bw, tc_u_sunlit_new_bw&
& , tc_u_shaded_new_bw
! the effective canopy temperature in K
! an emperical parameter describin    g the relative availability of soil water for plants
  REAL(r8) :: f_soilwater
  REAL(r8) :: f_soilwater_bw
! the total conductance for water from     the intercellular space of the leaves to the reference height above the canopy
  REAL(r8) :: gw_o_sunlit, gw_o_shaded, gw_u_sunlit, gw_u_shaded
  REAL(r8) :: gw_o_sunlit_bw, gw_o_shaded_bw, gw_u_sunlit_bw, &
& gw_u_shaded_bw
! the total conductance for CO2 from th    e intercellular space of the leaves to the reference height above the canopy
  REAL(r8) :: gc_o_sunlit, gc_o_shaded, gc_u_sunlit, gc_u_shaded
! the total conductance for water from     the surface of the leaves to the reference height above the canopy
  REAL(r8) :: gww_o_sunlit, gww_o_shaded, gww_u_sunlit, gww_u_shaded
  REAL(r8) :: gww_o_sunlit_bw, gww_o_shaded_bw, gww_u_sunlit_bw, &
& gww_u_shaded_bw
!total conductance for heat transfer f    rom the leaf surface to the reference height above the canopy
  REAL(r8) :: gh_o_sunlit, gh_o_shaded, gh_u_sunlit, gh_u_shaded
  REAL(r8) :: gh_o_sunlit_bw, gh_o_shaded_bw, gh_u_sunlit_bw, &
& gh_u_shaded_bw
  REAL(r8) :: psychrometer
!solar radiation absorbed by sunlit, s    haded leaves
  REAL(r8) :: r_o_sunlit, r_o_shaded, r_u_sunlit, r_u_shaded
  REAL(r8) :: r_o_sunlit_bw, r_o_shaded_bw, r_u_sunlit_bw, r_u_shaded_bw
  REAL(r8) :: tco, tcu, slope
  REAL(r8) :: tco_bw, tcu_bw
!sensible heat flux from leaves
  REAL(r8) :: h_o_sunlit, h_o_shaded
  REAL(r8) :: h_o_sunlit_bw, h_o_shaded_bw
  REAL(r8) :: lai_o_sunlit, lai_o_shaded, lai_u_sunlit, lai_u_shaded
  REAL(r8) :: lai_o_sunlit_bw, lai_o_shaded_bw, lai_u_sunlit_bw, &
& lai_u_shaded_bw
  REAL(r8) :: laio_sunlit, laio_shaded, laiu_sunlit, laiu_shaded
  REAL(r8) :: laio_sunlit_bw, laio_shaded_bw, laiu_sunlit_bw, &
& laiu_shaded_bw
! net radiation of leaves
  REAL(r8) :: radiation_o_sun, radiation_o_shaded, radiation_u_sun, &
& radiation_u_shaded
  REAL(r8) :: radiation_o_sun_bw, radiation_o_shaded_bw, &
& radiation_u_sun_bw, radiation_u_shaded_bw
  REAL(r8) :: gpp_o_sunlit, gpp_o_shaded, gpp_u_sunlit, gpp_u_shaded
!canopy level
  REAL(r8) :: sif_o_sunlit, sif_o_shaded, sif_u_sunlit, sif_u_shaded
  REAL(r8) :: sif_o_sunlit_bw, sif_o_shaded_bw, sif_u_sunlit_bw, &
& sif_u_shaded_bw
!leaf level
  REAL(r8) :: lsif_o_sunlit, lsif_o_shaded, lsif_u_sunlit, lsif_u_shaded
  REAL(r8) :: lsif_o_sunlit_bw, lsif_o_shaded_bw, lsif_u_sunlit_bw, &
& lsif_u_shaded_bw
!scat
  REAL(r8) :: stsif_o_sunlit, stsif_o_shaded, stsif_u_sunlit, &
& stsif_u_shaded
  REAL(r8) :: stsif_o_sunlit_bw, stsif_o_shaded_bw, stsif_u_sunlit_bw, &
& stsif_u_shaded_bw
  REAL(r8) :: cos_o_sunlit, cos_o_shaded, cos_u_sunlit, cos_u_shaded
  REAL(r8) :: cos_o_sunlit_bw, cos_o_shaded_bw, cos_u_sunlit_bw, &
& cos_u_shaded_bw
  REAL(r8) :: lcos_o_sunlit, lcos_o_shaded, lcos_u_sunlit, lcos_u_shaded
  REAL(r8) :: lcos_o_sunlit_bw, lcos_o_shaded_bw, lcos_u_sunlit_bw, &
& lcos_u_shaded_bw
  REAL(r8) :: vps_air
  REAL(r8) :: gs_h2o
  REAL(r8) :: gh_o, g_o_a, g_o_b, g_u_a, g_u_b
  REAL(r8) :: gh_o_bw, g_o_a_bw, g_o_b_bw, g_u_a_bw, g_u_b_bw
  REAL(r8) :: canopyh_o, canopyh_u
  REAL(r8) :: vpd_air
  REAL(r8) :: mass_water_g
  REAL(r8) :: mass_water_g_bw
  REAL(r8) :: percentarea_snow_o, percentarea_snow_u
  REAL(r8) :: percentarea_snow_o_bw, percentarea_snow_u_bw
  REAL(r8) :: gheat_g
  REAL(r8) :: gheat_g_bw
!the intercept term in BWB model (mol H2O m-2 s-1)
  REAL(r8) :: b_h2o
! the slope in BWB model
  REAL(r8) :: m_h2o
!leaf latent heat flux (mol/m2/s)
  REAL(r8) :: leleaf_o_sunlit, leleaf_o_shaded, leleaf_u_sunlit, &
& leleaf_u_shaded
  REAL(r8) :: leleaf_o_sunlit_bw, leleaf_o_shaded_bw, leleaf_u_sunlit_bw&
& , leleaf_u_shaded_bw
!for the Vcmax-Nitrogen calculation
  REAL(r8), SAVE :: kn=0.3
  REAL(r8), SAVE :: g_theta=0.5
!real(r8)             :: K,Vcmax0,Vcmax_sunlit,Vcmax_shaded,expr1,expr2,expr3
!Vcmax0 as an input from outside
  REAL(r8) :: k, vcmax_sunlit, vcmax_shaded, expr1, expr2, expr3
  REAL(r8) :: vcmax_sunlit_bw, vcmax_shaded_bw
  REAL(r8) :: slope_vcmax_n, leaf_n, jmax_sunlit, jmax_shaded
! for SIF simulation @JWang
  REAL(r8) :: ffpa
  REAL(r8) :: ffpa_bw
! for storing daily mean temperature
  REAL(r8) :: temp_day
! for storing daily mean surface soil moisture
  REAL(r8) :: theta_day
! for storing daily mean transpiration
  REAL(r8) :: trans_day
  REAL(r8) :: trans_day_bw
  REAL(r8) :: cosa
  REAL(r8) :: cos_soil
  REAL(r8) :: cos_soil_bw
!--iLab::introduced to avoid calling is_end_curr_day() from beps_time_manager
  LOGICAL :: is_end_curr_day
  INTRINSIC EXP
  INTRINSIC INT
  INTRINSIC MAX
  INTRINSIC MIN
  INTRINSIC ABS
  REAL(r8) :: abs0
  REAL(r8) :: abs1
  REAL(r8) :: abs2
  REAL(r8) :: abs3
  REAL(r8) :: arg1
  REAL(r8) :: arg1_bw
  REAL(r8) :: arg2
  REAL(r8) :: arg2_bw
  REAL(r8) :: temp
  REAL(r8) :: temp_bw
  REAL(r8) :: temp0
  REAL(r8) :: temp_bw0
  INTEGER*4 :: branch
  INTEGER :: ad_count
  INTEGER :: i0
!--iLab: taken from BEPS time manager
  is_end_curr_day = tod .EQ. 0
  temp_day = 0.
  theta_day = 0.
  trans_day = 0.
  psychrometer = 0.066
  alpha_sat = param(24)
  alpha_dry = param(25)
! to be used for module aerodynamic_conductance
  canopyh_o = param(29)
  canopyh_u = param(30)
  height_wind_sp = param(31)
!height_wind_sp   = 30.
! used for photosynthesis
  m_h2o = param(33)
  b_h2o = param(34)
!-- iLab::g2_h2o is *only* set from other routines in case 'CosZs>0.',
!         so we *must* initialise it and have uncommented the initialiser
!         that was already present.
!gs_h2o      = 0.
! Vcmax-Nitrogen calculations by G,Mo 2011.04
!! LAI calculation module by B.Chen
  lai_o = lai
  IF (lai .LT. 0.1) THEN
    lai_o = 0.1
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  landcover = INT(param(4))
! Calculate ffpa as a function of lai, this makes the ffpa vary with time, instead of being a constant as below,@MOUSONG WU, 2020
!-09-14
  ffpa = 1. - EXP(-(0.45*lai))
  IF (1.e-2 .LT. ffpa) THEN
    CALL PUSHCONTROL1B(0)
    ffpa = ffpa
  ELSE
    ffpa = 1.e-2
    CALL PUSHCONTROL1B(1)
  END IF
  IF (1.0 .GT. ffpa) THEN
    CALL PUSHCONTROL1B(0)
    ffpa = ffpa
  ELSE
    ffpa = 1.0
    CALL PUSHCONTROL1B(1)
  END IF
! added for sif simulation @J. Wang
!select case (landcover)
!   case (1)    !conifer evergreen
!    ffpa = 0.6
!   case(2)      !conifer decidous
!    ffpa = 0.6
!   case(6)      !broadleaf decidous
!    ffpa = 0.8
!   case(9)      !broadleaf evergreen
!    ffpa = 0.8
!   case(10)     !mix
!    ffpa = 0.4
!   case(13)     !shrub
!    ffpa = 0.8
!   case(14)     ! grass
!    ffpa = 0.8
!   case(15)     ! crop
!    ffpa = 0.6
!   case(40)     ! c4 grass
!    ffpa = 0.6  
!   case(41)     ! C4 crop
!    ffpa = 0.6
!end select
!if(landcover == 25 .or. landcover ==40) then
  IF (((landcover .EQ. 14 .OR. landcover .EQ. 15) .OR. landcover .EQ. 40&
&     ) .OR. landcover .EQ. 41) THEN
    CALL PUSHCONTROL1B(0)
!14->grass 15->crop @JWang
    lai_u = 0.01
  ELSE
    lai_u = 1.18*EXP(-(0.99*lai_o))
    CALL PUSHCONTROL1B(1)
  END IF
  IF (lai_u .GT. lai_o) THEN
    lai_u = 0.01
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  stem_o = param(8)*0.2
  stem_u = param(9)*0.2
!Bing Chen
  CALL LAI_CAL(stem_o, stem_u, landcover, coszs, lai_o, clumping, lai_u&
&        , laio_sunlit, laio_shaded, laiu_sunlit, laiu_shaded, &
&        lai_o_sunlit, lai_o_shaded, lai_u_sunlit, lai_u_shaded)
!-------initalization of this time step
  ks = meteo%srad
  rh_air = meteo%rh
  wind_sp = meteo%wind
!m/s   liquid water
  rainfall = meteo%rainfall
!m/s   snow
  snow = meteo%snow
  temp_air = meteo%temp
  IF (ks .LE. 0) THEN
    alpha_v_o = 0.
    alpha_n_o = 0.
    alpha_v_u = 0.
    alpha_n_u = 0.
  ELSE
    alpha_v_o = param(22)
    alpha_n_o = param(23)
    alpha_v_u = param(22)
    alpha_n_u = param(23)
  END IF
  qhc_o(0) = var_o(1)
  ts0(0) = var_o(3)
  IF (ts0(0) - temp_air .GT. 2.0) THEN
    ts0(0) = temp_air + 2.0
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  IF (ts0(0) - temp_air .LT. -2.0) THEN
    ts0(0) = temp_air - 2.0
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  tsn0(0) = var_o(4)
  IF (tsn0(0) - temp_air .GT. 2.0) THEN
    tsn0(0) = temp_air + 2.0
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  IF (tsn0(0) - temp_air .LT. -2.0) THEN
    tsn0(0) = temp_air - 2.0
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  tsm0(0) = var_o(5)
  IF (tsm0(0) - temp_air .GT. 2.) THEN
    tsm0(0) = temp_air + 2.0
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  IF (tsm0(0) - temp_air .LT. -2.) THEN
    tsm0(0) = temp_air - 2.0
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  tsn1(0) = var_o(6)
  IF (tsn1(0) - temp_air .GT. 2.0) THEN
    tsn1(0) = temp_air + 2.0
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  IF (tsn1(0) - temp_air .LT. -2.) THEN
    tsn1(0) = temp_air - 2.0
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  tsn2(0) = var_o(7)
  IF (tsn2(0) - temp_air .GT. 2.0) THEN
    tsn2(0) = temp_air + 2.0
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  IF (tsn2(0) - temp_air .LT. -2.) THEN
    tsn2(0) = temp_air - 2.0
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
!the mass of intercepted liquid water and snow, overstory
  wcl_o(0) = var_o(15)
  wcs_o(0) = var_o(16)
  wcl_u(0) = var_o(18)
  wcs_u(0) = var_o(19)
!  fraction of ground surface covered by snow and snow mass
  wg_snow(0) = var_o(20)
  soilp%zsp = var_o(33)
  soilp%zp = var_o(34)
!-- iLab::*must* at least initialise arrays for complete number of iterations
!          (and not only the first element),
!         since elements are input/output(!) arguments to called routines
!         (snowpack_stage1,netRadiation)
  ac_snow_o(0:iter_max) = var_o(36)
  ac_snow_u(0:iter_max) = var_o(37)
  rho_snow(0:iter_max) = var_o(38)
  alpha_v_sw(0:iter_max) = var_o(39)
  alpha_n_sw(0:iter_max) = var_o(40)
! Ac_snow_o(0)    = var_o(36)
! Ac_snow_u(0)    = var_o(37)
! rho_snow(0)     = var_o(38)
! alpha_v_sw(0)   = var_o(39)
! alpha_n_sw(0)   = var_o(40)
  zsp = soilp%zsp
  zp = soilp%zp
  IF (zp .LT. 0.001) THEN
    zp = 0.
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
!if(Zp < 1.e-6) Zp = 0.
  DO i=9,14
    soilp%temp_soil_p(i-9) = var_o(i)
  END DO
  DO i=21,26
    soilp%thetam_prev(i-21) = var_o(i)
  END DO
  DO i=27,32
    soilp%ice_ratio(i-27) = var_o(i)
  END DO
! vcmax jmax module  by L. He
  slope_vcmax_n = param(47)
  leaf_n = param(46)
  CALL PUSHREAL8ARRAY(lai_o, r8/8)
  CALL VCMAX_JMAX(lai_o, clumping, vcmax0, vj_slope, slope_vcmax_n, &
&           leaf_n, coszs, vcmax_sunlit, vcmax_shaded, jmax_sunlit, &
&           jmax_shaded)
! temperatures of overstorey and understorey canopies
  tc_o_sunlit_old = temp_air - 0.5
  tc_o_shaded_old = temp_air - 0.5
  tc_u_sunlit_old = temp_air - 0.5
  tc_u_shaded_old = temp_air - 0.5
!sub-time iteration @J.Wang
  DO kkk=1,kloop
! Snow pack stage 1  by R.Luo
    CALL PUSHREAL8ARRAY(zsp, r8/8)
    CALL PUSHREAL8ARRAY(rho_snow(kkk), r8/8)
    CALL PUSHREAL8ARRAY(ac_snow_u(kkk), r8/8)
    CALL PUSHREAL8ARRAY(ac_snow_o(kkk), r8/8)
    CALL PUSHREAL8ARRAY(wg_snow(kkk), r8/8)
    CALL PUSHREAL8ARRAY(wcs_u(kkk), r8/8)
    CALL PUSHREAL8ARRAY(wcs_o(kkk), r8/8)
    CALL SNOWPACK_STAGE1(temp_air, snow, wcs_o(kkk-1), wcs_u(kkk-1), &
&                  wg_snow(kkk-1), rho_snow(kkk-1), ac_snow_o(kkk-1), &
&                  ac_snow_u(kkk-1), wcs_o(kkk), wcs_u(kkk), wg_snow(kkk&
&                  ), lai_o, lai_u, clumping, ac_snow_o(kkk), ac_snow_u(&
&                  kkk), xcs_o(kkk), xcs_u(kkk), xg_snow(kkk), rho_snow(&
&                  kkk), zsp, alpha_v_sw(kkk), alpha_n_sw(kkk))
!    write(*,*) "DG01: Ac_snow_o(kkk) =",Ac_snow_o(kkk)
! rainfall stag 1
    CALL PUSHREAL8ARRAY(wcl_u(kkk), r8/8)
    CALL PUSHREAL8ARRAY(wcl_o(kkk), r8/8)
    CALL RAINFALL_STAGE1(temp_air, rainfall, wcl_o(kkk-1), wcl_u(kkk-1)&
&                  , lai_o, lai_u, clumping, wcl_o(kkk), wcl_u(kkk), &
&                  xcl_o(kkk), xcl_u(kkk), r_rain_g(kkk))
    IF (soilp%thetam_prev(1) .LT. soilp%theta_vwp(1)*0.5) THEN
      CALL PUSHCONTROL1B(0)
      alpha_g = alpha_dry
    ELSE
      alpha_g = (soilp%thetam_prev(1)-soilp%theta_vwp(1)*0.5)/(soilp%fei&
&       (1)-soilp%theta_vwp(1)*0.5)*(alpha_sat-alpha_dry) + alpha_dry
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL8ARRAY(alpha_v_g, r8/8)
    alpha_v_g = 2./3.*alpha_g
    CALL PUSHREAL8ARRAY(alpha_n_g, r8/8)
    alpha_n_g = 4./3.*alpha_g
! soil water factor module
    CALL PUSHREAL8ARRAY(soilp%dt, r8*10/8)
    CALL PUSHREAL8ARRAY(soilp%psim, r8*10/8)
    CALL SOIL_WATER_FACTOR_V2(soilp)
    CALL PUSHREAL8ARRAY(f_soilwater, r8/8)
    f_soilwater = soilp%f_soilwater
    IF (f_soilwater .GT. 1.0) THEN
      f_soilwater = 1.0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
!used as the init. for module aerodynamic_conductance
    gh_o = qhc_o(kkk-1)
    vps_air = 0.61078*EXP(17.3*temp_air/(237.3+temp_air))
    CALL PUSHREAL8ARRAY(e_a10, r8/8)
    e_a10 = vps_air*rh_air/100.
!water vapor deficit at the reference height @J.Wang maybe directly use meteo_pack
    CALL PUSHREAL8ARRAY(vpd_air, r8/8)
    vpd_air = vps_air - e_a10
!g/g  no dimention
    q_ca = 0.622*e_a10/(101.35-0.378*e_a10)
    CALL PUSHREAL8ARRAY(cp_ca, r8/8)
    cp_ca = cpd*(1.+0.84*q_ca)
    CALL PUSHREAL8ARRAY(slope, r8/8)
    slope = 2503.0/(temp_air+237.3)**2*EXP(17.27*temp_air/(temp_air+&
&     237.3))
    gs_o_sunlit_old = 1./200.0
    ci_o_sunlit_old = 0.7*co2_air
    gs_o_shaded_old = 1./200.0
    ci_o_shaded_old = 0.7*co2_air
    gs_u_sunlit_old = 1./300.0
    ci_u_sunlit_old = 0.7*co2_air
    gs_u_shaded_old = 1./300.0
    ci_u_shaded_old = 0.7*co2_air
    cosi_o_sunlit_old = 0.7*cos_air
    cosi_o_shaded_old = 0.7*cos_air
    cosi_u_sunlit_old = 0.7*cos_air
    cosi_u_shaded_old = 0.7*cos_air
    CALL PUSHREAL8ARRAY(percentarea_snow_o, r8/8)
    percentarea_snow_o = ac_snow_o(kkk)/lai_o/2.
    CALL PUSHREAL8ARRAY(percentarea_snow_u, r8/8)
    percentarea_snow_u = ac_snow_u(kkk)/lai_u/2.
!ground temperature substituted by air temperature
    temp_grd = temp_air
    num = 0
    ad_count = 1
    DO WHILE (.true.)
      num = num + 1
! aerodynamic_conductance module by G.Mo
      arg1 = lai_o + stem_o
      CALL PUSHREAL8ARRAY(g_u_b, r8/8)
      CALL PUSHREAL8ARRAY(g_u_a, r8/8)
      CALL PUSHREAL8ARRAY(g_o_b, r8/8)
      CALL PUSHREAL8ARRAY(g_o_a, r8/8)
      CALL PUSHREAL8ARRAY(ra_g, r8/8)
      CALL AERODYNAMIC_CONDUCTANCE(canopyh_o, canopyh_u, height_wind_sp&
&                            , clumping, temp_air, wind_sp, gh_o, arg1, &
&                            arg2, ra_o, ra_u, ra_g, g_o_a, g_o_b, g_u_a&
&                            , g_u_b)
!heat conductance of sunlit leaves of overstorey
      CALL PUSHREAL8ARRAY(gh_o_sunlit, r8/8)
      gh_o_sunlit = 1.0/(1.0/g_o_a+0.5/g_o_b)
      CALL PUSHREAL8ARRAY(gh_o_shaded, r8/8)
      gh_o_shaded = 1.0/(1.0/g_o_a+0.5/g_o_b)
      CALL PUSHREAL8ARRAY(gh_u_sunlit, r8/8)
      gh_u_sunlit = 1.0/(1.0/g_u_a+0.5/g_u_b)
      CALL PUSHREAL8ARRAY(gh_u_shaded, r8/8)
      gh_u_shaded = 1.0/(1.0/g_u_a+0.5/g_u_b)
! conductance for intercepted water of sunlit leaves of overstorey
      CALL PUSHREAL8ARRAY(gww_o_sunlit, r8/8)
      gww_o_sunlit = 1.0/(1.0/g_o_a+1.0/g_o_b+100.)
      CALL PUSHREAL8ARRAY(gww_o_shaded, r8/8)
      gww_o_shaded = 1.0/(1.0/g_o_a+1.0/g_o_b+100.)
      CALL PUSHREAL8ARRAY(gww_u_sunlit, r8/8)
      gww_u_sunlit = 1.0/(1.0/g_u_a+1.0/g_u_b+100.)
      CALL PUSHREAL8ARRAY(gww_u_shaded, r8/8)
      gww_u_shaded = 1.0/(1.0/g_u_a+1.0/g_u_b+100.)
! temperatures of overstorey and understorey canopies
      tco = (tc_o_sunlit_old*lai_o_sunlit+tc_o_shaded_old*lai_o_shaded)/&
&       (lai_o_sunlit+lai_o_shaded)
      CALL PUSHREAL8ARRAY(tcu, r8/8)
      tcu = (tc_u_sunlit_old*lai_u_sunlit+tc_u_shaded_old*lai_u_shaded)/&
&       (lai_u_sunlit+lai_u_shaded)
! net Radiation at canopy and leaf level module by X.Luo
      arg1 = lai_o + stem_o
      arg2 = lai_u + stem_u
      CALL PUSHREAL8ARRAY(r_u_shaded, r8/8)
      CALL PUSHREAL8ARRAY(r_u_sunlit, r8/8)
      CALL PUSHREAL8ARRAY(r_o_shaded, r8/8)
      CALL PUSHREAL8ARRAY(r_o_sunlit, r8/8)
      CALL PUSHREAL8ARRAY(radiation_u_shaded, r8/8)
      CALL PUSHREAL8ARRAY(radiation_u_sun, r8/8)
      CALL PUSHREAL8ARRAY(radiation_o_shaded, r8/8)
      CALL PUSHREAL8ARRAY(radiation_o_sun, r8/8)
      CALL PUSHREAL8ARRAY(radiation_g, r8/8)
      CALL NETRADIATION_CD(meteo%s_dff, meteo%s_dir, coszs, tco, tcu, &
&                    temp_grd, lai_o, lai_u, arg1, arg2, lai_o_sunlit, &
&                    lai_o_shaded, lai_u_sunlit, lai_u_shaded, clumping&
&                    , temp_air, rh_air, alpha_v_sw(kkk), alpha_n_sw(kkk&
&                    ), percentarea_snow_o, percentarea_snow_u, xg_snow(&
&                    kkk), alpha_v_o, alpha_n_o, alpha_v_u, alpha_n_u, &
&                    alpha_v_g, alpha_n_g, radiation_o, radiation_u, &
&                    radiation_g, radiation_o_sun, radiation_o_shaded, &
&                    radiation_u_sun, radiation_u_shaded, r_o_sunlit, &
&                    r_o_shaded, r_u_sunlit, r_u_shaded)
! photosynthesis module by B. Chen
!conductance of sunlit leaves of overstorey for water
      CALL PUSHREAL8ARRAY(gw_o_sunlit, r8/8)
      gw_o_sunlit = 1.0/(1.0/g_o_a+1.0/g_o_b+1.0/gs_o_sunlit_old)
      CALL PUSHREAL8ARRAY(gw_o_shaded, r8/8)
      gw_o_shaded = 1.0/(1.0/g_o_a+1.0/g_o_b+1.0/gs_o_shaded_old)
      CALL PUSHREAL8ARRAY(gw_u_sunlit, r8/8)
      gw_u_sunlit = 1.0/(1.0/g_u_a+1.0/g_u_b+1.0/gs_u_sunlit_old)
      CALL PUSHREAL8ARRAY(gw_u_shaded, r8/8)
      gw_u_shaded = 1.0/(1.0/g_u_a+1.0/g_u_b+1.0/gs_u_shaded_old)
      leleaf_o_sunlit = gw_o_sunlit*(vpd_air+slope*(tc_o_sunlit_old-&
&       temp_air))*rho_a*cp_ca/psychrometer
      leleaf_o_shaded = gw_o_shaded*(vpd_air+slope*(tc_o_shaded_old-&
&       temp_air))*rho_a*cp_ca/psychrometer
      leleaf_u_sunlit = gw_u_sunlit*(vpd_air+slope*(tc_u_sunlit_old-&
&       temp_air))*rho_a*cp_ca/psychrometer
      leleaf_u_shaded = gw_u_shaded*(vpd_air+slope*(tc_u_shaded_old-&
&       temp_air))*rho_a*cp_ca/psychrometer
      IF (coszs .GT. 0.) THEN
        CALL PUSHREAL8ARRAY(lcos_o_sunlit, r8/8)
        CALL PUSHREAL8ARRAY(lsif_o_sunlit, r8/8)
        CALL PUSHREAL8ARRAY(ac_o_sunlit, r8/8)
        CALL PUSHREAL8ARRAY(gs_o_sunlit_new, r8/8)
        CALL PHOTOSYNTHESIS(landcover, tc_o_sunlit_old, f_leaf, p_kc25, &
&                     p_ko25, p_tau25, r_o_sunlit, e_a10, g_o_b, &
&                     vcmax_sunlit, vj_slope, f_soilwater, b_h2o, m_h2o&
&                     , ci_o_sunlit_old, temp_air, leleaf_o_sunlit, &
&                     gs_o_sunlit_new, gs_h2o, ac_o_sunlit, &
&                     ci_o_sunlit_new, ffpa, sif_alpha, sif_beta, &
&                     lsif_o_sunlit, cosi_o_sunlit_old, &
&                     cosi_o_sunlit_new, lcos_o_sunlit)
        CALL PUSHREAL8ARRAY(lcos_o_shaded, r8/8)
        CALL PUSHREAL8ARRAY(lsif_o_shaded, r8/8)
        CALL PUSHREAL8ARRAY(ac_o_shaded, r8/8)
        CALL PUSHREAL8ARRAY(gs_o_shaded_new, r8/8)
        CALL PHOTOSYNTHESIS(landcover, tc_o_shaded_old, f_leaf, p_kc25, &
&                     p_ko25, p_tau25, r_o_shaded, e_a10, g_o_b, &
&                     vcmax_shaded, vj_slope, f_soilwater, b_h2o, m_h2o&
&                     , ci_o_shaded_old, temp_air, leleaf_o_shaded, &
&                     gs_o_shaded_new, gs_h2o, ac_o_shaded, &
&                     ci_o_shaded_new, ffpa, sif_alpha, sif_beta, &
&                     lsif_o_shaded, cosi_o_shaded_old, &
&                     cosi_o_shaded_new, lcos_o_shaded)
        CALL PUSHREAL8ARRAY(lcos_u_sunlit, r8/8)
        CALL PUSHREAL8ARRAY(lsif_u_sunlit, r8/8)
        CALL PUSHREAL8ARRAY(ac_u_sunlit, r8/8)
        CALL PUSHREAL8ARRAY(gs_u_sunlit_new, r8/8)
        CALL PHOTOSYNTHESIS(landcover, tc_u_sunlit_old, f_leaf, p_kc25, &
&                     p_ko25, p_tau25, r_u_sunlit, e_a10, g_u_b, &
&                     vcmax_sunlit, vj_slope, f_soilwater, b_h2o, m_h2o&
&                     , ci_u_sunlit_old, temp_air, leleaf_u_sunlit, &
&                     gs_u_sunlit_new, gs_h2o, ac_u_sunlit, &
&                     ci_u_sunlit_new, ffpa, sif_alpha, sif_beta, &
&                     lsif_u_sunlit, cosi_u_sunlit_old, &
&                     cosi_u_sunlit_new, lcos_u_sunlit)
        CALL PUSHREAL8ARRAY(lcos_u_shaded, r8/8)
        CALL PUSHREAL8ARRAY(lsif_u_shaded, r8/8)
        CALL PUSHREAL8ARRAY(ac_u_shaded, r8/8)
        CALL PUSHREAL8ARRAY(gs_u_shaded_new, r8/8)
        CALL PHOTOSYNTHESIS(landcover, tc_u_shaded_old, f_leaf, p_kc25, &
&                     p_ko25, p_tau25, r_u_shaded, e_a10, g_u_b, &
&                     vcmax_shaded, vj_slope, f_soilwater, b_h2o, m_h2o&
&                     , ci_u_shaded_old, temp_air, leleaf_u_shaded, &
&                     gs_u_shaded_new, gs_h2o, ac_u_shaded, &
&                     ci_u_shaded_new, ffpa, sif_alpha, sif_beta, &
&                     lsif_u_shaded, cosi_u_shaded_old, &
&                     cosi_u_shaded_new, lcos_u_shaded)
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHREAL8ARRAY(gs_o_sunlit_new, r8/8)
        gs_o_sunlit_new = 0.0001
        ac_o_sunlit = 0.0
        CALL PUSHREAL8ARRAY(lsif_o_sunlit, r8/8)
        lsif_o_sunlit = 0.0
        CALL PUSHREAL8ARRAY(lcos_o_sunlit, r8/8)
        lcos_o_sunlit = 0.0
        ci_o_sunlit_new = co2_air*0.7
        cosi_o_sunlit_new = cos_air*0.7
        CALL PUSHREAL8ARRAY(gs_o_shaded_new, r8/8)
        gs_o_shaded_new = 0.0001
        ac_o_shaded = 0.0
        CALL PUSHREAL8ARRAY(lsif_o_shaded, r8/8)
        lsif_o_shaded = 0.0
        CALL PUSHREAL8ARRAY(lcos_o_shaded, r8/8)
        lcos_o_shaded = 0.0
        ci_o_shaded_new = co2_air*0.7
        cosi_o_shaded_new = cos_air*0.7
        CALL PUSHREAL8ARRAY(gs_u_sunlit_new, r8/8)
        gs_u_sunlit_new = 0.0001
        ac_u_sunlit = 0.0
        CALL PUSHREAL8ARRAY(lsif_u_sunlit, r8/8)
        lsif_u_sunlit = 0.
        CALL PUSHREAL8ARRAY(lcos_u_sunlit, r8/8)
        lcos_u_sunlit = 0.
        CALL PUSHREAL8ARRAY(gs_u_shaded_new, r8/8)
        gs_u_shaded_new = 0.0001
        ac_u_shaded = 0.0
        CALL PUSHREAL8ARRAY(lsif_u_shaded, r8/8)
        lsif_u_shaded = 0.
        CALL PUSHREAL8ARRAY(lcos_u_shaded, r8/8)
        lcos_u_shaded = 0.
        ci_u_shaded_new = co2_air*0.7
        cosi_u_shaded_new = cos_air*0.7
        CALL PUSHCONTROL1B(0)
      END IF
!       write(*,*) G_o_b,gs_h2o
      CALL PUSHREAL8ARRAY(ci_o_sunlit_old, r8/8)
      ci_o_sunlit_old = ci_o_sunlit_new
      CALL PUSHREAL8ARRAY(cosi_o_sunlit_old, r8/8)
      cosi_o_sunlit_old = cosi_o_sunlit_new
      CALL PUSHREAL8ARRAY(gs_o_sunlit_old, r8/8)
      gs_o_sunlit_old = gs_o_sunlit_new
!conductance of sunlit leaves of overstorey for water
      CALL PUSHREAL8ARRAY(gw_o_sunlit, r8/8)
      gw_o_sunlit = 1.0/(1.0/g_o_a+1.0/g_o_b+1.0/gs_o_sunlit_new)
!conductance of sunlit leaves of overstorey for CO2
      CALL PUSHREAL8ARRAY(ci_o_shaded_old, r8/8)
      ci_o_shaded_old = ci_o_shaded_new
      CALL PUSHREAL8ARRAY(cosi_o_shaded_old, r8/8)
      cosi_o_shaded_old = cosi_o_shaded_new
      CALL PUSHREAL8ARRAY(gs_o_shaded_old, r8/8)
      gs_o_shaded_old = gs_o_shaded_new
      CALL PUSHREAL8ARRAY(gw_o_shaded, r8/8)
      gw_o_shaded = 1.0/(1.0/g_o_a+1.0/g_o_b+1.0/gs_o_shaded_new)
      CALL PUSHREAL8ARRAY(ci_u_sunlit_old, r8/8)
      ci_u_sunlit_old = ci_o_sunlit_new
      CALL PUSHREAL8ARRAY(cosi_u_sunlit_old, r8/8)
      cosi_u_sunlit_old = cosi_o_sunlit_new
      CALL PUSHREAL8ARRAY(gs_u_sunlit_old, r8/8)
      gs_u_sunlit_old = gs_o_sunlit_new
      CALL PUSHREAL8ARRAY(gw_u_sunlit, r8/8)
      gw_u_sunlit = 1.0/(1.0/g_u_a+1.0/g_u_b+1.0/gs_u_sunlit_new)
      CALL PUSHREAL8ARRAY(ci_u_shaded_old, r8/8)
      ci_u_shaded_old = ci_u_shaded_new
      CALL PUSHREAL8ARRAY(cosi_u_shaded_old, r8/8)
      cosi_u_shaded_old = cosi_u_shaded_new
      CALL PUSHREAL8ARRAY(gs_u_shaded_old, r8/8)
      gs_u_shaded_old = gs_u_shaded_new
      CALL PUSHREAL8ARRAY(gw_u_shaded, r8/8)
      gw_u_shaded = 1.0/(1.0/g_u_a+1.0/g_u_b+1.0/gs_u_shaded_new)
! leaf tempratures module by L. He
      CALL PUSHREAL8ARRAY(tc_u_shaded_new, r8/8)
      CALL PUSHREAL8ARRAY(tc_u_sunlit_new, r8/8)
      CALL PUSHREAL8ARRAY(tc_o_shaded_new, r8/8)
      CALL PUSHREAL8ARRAY(tc_o_sunlit_new, r8/8)
      CALL LEAF_TEMPERATURES(temp_air, slope, psychrometer, vpd_air, &
&                      cp_ca, gw_o_sunlit, gw_o_shaded, gw_u_sunlit, &
&                      gw_u_shaded, gww_o_sunlit, gww_o_shaded, &
&                      gww_u_sunlit, gww_u_shaded, gh_o_sunlit, &
&                      gh_o_shaded, gh_u_sunlit, gh_u_shaded, xcs_o(kkk)&
&                      , xcl_o(kkk), xcs_u(kkk), xcl_u(kkk), &
&                      radiation_o_sun, radiation_o_shaded, &
&                      radiation_u_sun, radiation_u_shaded, &
&                      tc_o_sunlit_new, tc_o_shaded_new, tc_u_sunlit_new&
&                      , tc_u_shaded_new)
      CALL PUSHREAL8ARRAY(h_o_sunlit, r8/8)
      h_o_sunlit = (tc_o_sunlit_new-temp_air)*rho_a*cp_ca*gh_o_sunlit
      CALL PUSHREAL8ARRAY(h_o_shaded, r8/8)
      h_o_shaded = (tc_o_shaded_new-temp_air)*rho_a*cp_ca*gh_o_shaded
!for next num aerodynamic conductance calculation
      CALL PUSHREAL8ARRAY(gh_o, r8/8)
      gh_o = h_o_sunlit*lai_o_sunlit + h_o_shaded*lai_o_shaded
      IF (tc_o_sunlit_new - tc_o_sunlit_old .GE. 0.) THEN
        abs0 = tc_o_sunlit_new - tc_o_sunlit_old
      ELSE
        abs0 = -(tc_o_sunlit_new-tc_o_sunlit_old)
      END IF
      IF (tc_o_shaded_new - tc_o_shaded_old .GE. 0.) THEN
        abs1 = tc_o_shaded_new - tc_o_shaded_old
      ELSE
        abs1 = -(tc_o_shaded_new-tc_o_shaded_old)
      END IF
      IF (tc_u_sunlit_new - tc_u_sunlit_old .GE. 0.) THEN
        abs2 = tc_u_sunlit_new - tc_u_sunlit_old
      ELSE
        abs2 = -(tc_u_sunlit_new-tc_u_sunlit_old)
      END IF
      IF (tc_u_shaded_new - tc_u_shaded_old .GE. 0.) THEN
        abs3 = tc_u_shaded_new - tc_u_shaded_old
      ELSE
        abs3 = -(tc_u_shaded_new-tc_u_shaded_old)
      END IF
      IF (abs0 .LT. 0.02 .AND. abs1 .LT. 0.02 .AND. abs2 .LT. 0.02 .AND.&
&         abs3 .LT. 0.02) THEN
        GOTO 100
      ELSE IF (num .GT. 22) THEN
        GOTO 110
      ELSE
        CALL PUSHREAL8ARRAY(tc_o_sunlit_old, r8/8)
        tc_o_sunlit_old = tc_o_sunlit_new
        CALL PUSHREAL8ARRAY(tc_o_shaded_old, r8/8)
        tc_o_shaded_old = tc_o_shaded_new
        CALL PUSHREAL8ARRAY(tc_u_sunlit_old, r8/8)
        tc_u_sunlit_old = tc_u_sunlit_new
        CALL PUSHREAL8ARRAY(tc_u_shaded_old, r8/8)
        tc_u_shaded_old = tc_u_shaded_new
        ad_count = ad_count + 1
      END IF
    END DO
    CALL PUSHCONTROL2B(0)
    CALL PUSHINTEGER4(ad_count)
    CALL PUSHCONTROL1B(0)
    GOTO 120
 100 CALL PUSHCONTROL2B(1)
    CALL PUSHINTEGER4(ad_count)
    CALL PUSHCONTROL1B(0)
    GOTO 120
 110 CALL PUSHCONTROL2B(2)
    CALL PUSHINTEGER4(ad_count)
!iteration does not converge.
    CALL PUSHREAL8ARRAY(tc_o_sunlit_old, r8/8)
    tc_o_sunlit_old = temp_air
    CALL PUSHREAL8ARRAY(tc_o_shaded_old, r8/8)
    tc_o_shaded_old = temp_air
    CALL PUSHREAL8ARRAY(tc_u_sunlit_old, r8/8)
    tc_u_sunlit_old = temp_air
    CALL PUSHREAL8ARRAY(tc_u_shaded_old, r8/8)
    tc_u_shaded_old = temp_air
    CALL PUSHCONTROL1B(1)
! end do while
!    write(*,*) G_o_b,gs_h2o
!    stSIF_o_sunlit=lSIF_o_sunlit*0.5*clumping*(1.1-0.1*LAIo_sunlit)*exp(-CosZs)*LAIo_sunlit
!    stSIF_o_shaded=lSIF_o_shaded*0.5*clumping*(1.1-0.1*LAIo_shaded)*exp(-CosZs)*LAIo_shaded
!    stSIF_u_sunlit=lSIF_u_sunlit*0.5*clumping*(1.1-0.1*LAIu_sunlit)*exp(-CosZs)*LAIu_sunlit
!    stSIF_u_shaded=lSIF_u_shaded*0.5*clumping*(1.1-0.1*LAIu_shaded)*exp(-CosZs)*LAIu_shaded
!    SIF_o_sunlit=lSIF_o_sunlit*exp(-0.5*clumping*LAIo_sunlit/CosZs)*LAIo_sunlit+stSIF_o_sunlit
!    SIF_o_shaded=lSIF_o_shaded*exp(-0.5*clumping*LAIo_shaded/CosZs)*LAIo_shaded+stSIF_o_shaded
!    SIF_u_sunlit=lSIF_u_sunlit*exp(-0.5*clumping*LAIu_sunlit/CosZs)*LAIu_sunlit+stSIF_u_sunlit
!    SIF_u_shaded=lSIF_u_shaded*exp(-0.5*clumping*LAIu_shaded/CosZs)*LAIu_shaded+stSIF_u_shaded
 120 CALL PUSHREAL8ARRAY(stsif_o_sunlit, r8/8)
    stsif_o_sunlit = lsif_o_sunlit*0.3*clumping*(1.1-0.1*laio_sunlit)*&
&     EXP(-coszs)
    CALL PUSHREAL8ARRAY(stsif_o_shaded, r8/8)
    stsif_o_shaded = lsif_o_shaded*0.3*clumping*(1.1-0.1*laio_shaded)*&
&     EXP(-coszs)
    CALL PUSHREAL8ARRAY(stsif_u_sunlit, r8/8)
    stsif_u_sunlit = lsif_u_sunlit*0.3*clumping*(1.1-0.1*laiu_sunlit)*&
&     EXP(-coszs)
    CALL PUSHREAL8ARRAY(stsif_u_shaded, r8/8)
    stsif_u_shaded = lsif_u_shaded*0.3*clumping*(1.1-0.1*laiu_shaded)*&
&     EXP(-coszs)
!    stSIF_o_sunlit = 0.0   !!@JWang  for scattering correction,@MOUSONG,make sure this is correct???
!    stSIF_o_shaded = 0.0
!    stSIF_u_sunlit = 0.0
!    stSIF_u_shaded = 0.0
!Transpiration module by X. Luo
    CALL TRANSPIRATION(tc_o_sunlit_new, tc_o_shaded_new, tc_u_sunlit_new&
&                , tc_u_shaded_new, temp_air, rh_air, gw_o_sunlit, &
&                gw_o_shaded, gw_u_sunlit, gw_u_shaded, lai_o_sunlit, &
&                lai_o_shaded, lai_u_sunlit, lai_u_shaded, trans_o(kkk)&
&                , trans_u(kkk))
! Evaporation and sublimation from canopy by X. Luo
    CALL EVAPORATION_CANOPY(tc_o_sunlit_new, tc_o_shaded_new, &
&                     tc_u_sunlit_new, tc_u_shaded_new, temp_air, rh_air&
&                     , gww_o_sunlit, gww_o_shaded, gww_u_sunlit, &
&                     gww_u_shaded, lai_o_sunlit, lai_o_shaded, &
&                     lai_u_sunlit, lai_u_shaded, xcl_o(kkk), xcl_u(kkk)&
&                     , xcs_o(kkk), xcs_u(kkk), eil_o(kkk), eil_u(kkk), &
&                     eis_o(kkk), eis_u(kkk))
! Rainfall stage 2 by X. Luo
    CALL PUSHREAL8ARRAY(wcl_u(kkk), r8/8)
    CALL PUSHREAL8ARRAY(wcl_o(kkk), r8/8)
    CALL RAINFALL_STAGE2(eil_o(kkk), eil_u(kkk), wcl_o(kkk), wcl_u(kkk))
! Snow pack stage2
    CALL PUSHREAL8ARRAY(wcs_u(kkk), r8/8)
    CALL PUSHREAL8ARRAY(wcs_o(kkk), r8/8)
    CALL SNOWPACK_STAGE2(eis_o(kkk), eis_u(kkk), wcs_o(kkk), wcs_u(kkk))
! Evaporation from soil module
    gheat_g = 1./ra_g
    mass_water_g = rho_w*zp
    CALL PUSHREAL8ARRAY(wg_snow(kkk), r8/8)
    CALL PUSHREAL8ARRAY(zsp, r8/8)
    CALL PUSHREAL8ARRAY(zp, r8/8)
    CALL PUSHREAL8ARRAY(xg_snow(kkk), r8/8)
    CALL SOIL_EVAPORATION(temp_grd, ts0(kkk-1), rh_air, radiation_g, &
&                   gheat_g, xg_snow(kkk), zp, zsp, mass_water_g, &
&                   wg_snow(kkk), rho_snow(kkk), soilp%thetam_prev(0), &
&                   soilp%fei(0), evap_soil(kkk), evap_sw(kkk), evap_ss(&
&                   kkk))
! update surface ponding after ponding evaporation calculation
    zp = mass_water_g/rho_w
! update snow depth as well after snow evaporation calculation
    zsp = wg_snow(kkk)/rho_snow(kkk)
! to be checked later:  why set these 4 to 0
! soil Thermal Conductivity module by L. He
    CALL PUSHREAL8ARRAY(soilp%lambda, r8*10/8)
    CALL UPDATESOILTHERMALCONDUCTIVITY(soilp)
    CALL PUSHREAL8ARRAY(soilp%cs, r8*10/8)
    CALL UPDATE_CS(soilp)
! Surface temperature
    cs(0, kkk) = soilp%cs(0)
    cs(1, kkk) = soilp%cs(0)
    tc_u(kkk) = tcu
    CALL PUSHREAL8ARRAY(lambda_soil(1), r8/8)
    lambda_soil(1) = soilp%lambda(0)
    CALL PUSHREAL8ARRAY(d_soil(1), r8/8)
    d_soil(1) = soilp%d_soil(0)
    CALL PUSHREAL8ARRAY(tm(1, kkk-1), r8/8)
    tm(1, kkk-1) = soilp%temp_soil_p(1)
    CALL PUSHREAL8ARRAY(tm(0, kkk-1), r8/8)
    tm(0, kkk-1) = soilp%temp_soil_p(0)
    g(1, kkk) = soilp%g(0)
    CALL PUSHREAL8ARRAY(tsn2(kkk), r8/8)
    CALL PUSHREAL8ARRAY(tsn1(kkk), r8/8)
    CALL PUSHREAL8ARRAY(tsm0(kkk), r8/8)
    CALL PUSHREAL8ARRAY(tsn0(kkk), r8/8)
    CALL PUSHREAL8ARRAY(tm(0, kkk), r8/8)
    CALL PUSHREAL8ARRAY(ts0(kkk), r8/8)
    CALL SURFACETEMPERATURE(temp_air, rh_air, zsp, zp, cs(1, kkk), cs(0&
&                     , kkk), gheat_g, d_soil(1), rho_snow(kkk), tc_u(&
&                     kkk), radiation_g, evap_soil(kkk), evap_sw(kkk), &
&                     evap_ss(kkk), lambda_soil(1), xg_snow(kkk), g(1, &
&                     kkk), ts0(kkk-1), tm(1, kkk-1), tm(0, kkk-1), tsn0&
&                     (kkk-1), tsm0(kkk-1), tsn1(kkk-1), tsn2(kkk-1), &
&                     ts0(kkk), tm(0, kkk), tsn0(kkk), tsm0(kkk), tsn1(&
&                     kkk), tsn2(kkk), g(0, kkk))
    CALL PUSHREAL8ARRAY(soilp%temp_soil_c(0), r8/8)
    soilp%temp_soil_c(0) = tm(0, kkk)
! Snow pack stage3 module
    CALL PUSHREAL8ARRAY(wg_snow(kkk), r8/8)
    CALL PUSHREAL8ARRAY(zp, r8/8)
    CALL PUSHREAL8ARRAY(zsp, r8/8)
    CALL SNOWPACK_STAGE3(temp_air, tsn0(kkk), tsn0(kkk-1), rho_snow(kkk)&
&                  , zsp, zp, wg_snow(kkk))
    CALL SENSIBLEHEAT_CD(tc_o_sunlit_new, tc_o_shaded_new, &
&                  tc_u_sunlit_new, tc_u_shaded_new, ts0(kkk), temp_air&
&                  , rh_air, gh_o_sunlit, gh_o_shaded, gh_u_sunlit, &
&                  gh_u_shaded, gheat_g, lai_o_sunlit, lai_o_shaded, &
&                  lai_u_sunlit, lai_u_shaded, qhc_o(kkk), qhc_u(kkk), &
&                  qhg(kkk))
! soil water module
    soilp%g(0) = g(0, kkk)
    CALL PUSHREAL8ARRAY(soilp%ice_ratio, r8*10/8)
    CALL PUSHREAL8ARRAY(soilp%temp_soil_p, r8*10/8)
    CALL PUSHREAL8ARRAY(soilp%temp_soil_c, r8*10/8)
    CALL PUSHREAL8ARRAY(soilp%g, r8*10/8)
    CALL UPDATEHEATFLUX(soilp, xg_snow(kkk), lambda_snow(kkk), tsn0(kkk)&
&                 , temp_air, kstep)
    CALL PUSHREAL8ARRAY(soilp%ett, r8*10/8)
    CALL SOIL_WATER_UPTAKE(soilp, trans_o(kkk), trans_u(kkk), evap_soil(&
&                    kkk))
    soilp%r_rain_g = r_rain_g(kkk)
    soilp%zp = zp
    CALL PUSHREAL8ARRAY(soilp%zp, r8/8)
    CALL PUSHREAL8ARRAY(soilp%ice_ratio, r8*10/8)
    CALL PUSHREAL8ARRAY(soilp%thetam, r8*10/8)
    CALL PUSHREAL8ARRAY(soilp%thetam_prev, r8*10/8)
    CALL PUSHREAL8ARRAY(soilp%f_ice, r8*10/8)
    CALL PUSHREAL8ARRAY(soilp%psim, r8*10/8)
    CALL PUSHREAL8ARRAY(soilp%thetab, r8*10/8)
    CALL PUSHREAL8ARRAY(soilp%psib, r8*10/8)
    CALL PUSHREAL8ARRAY(soilp%r_waterflow, r8*10/8)
    CALL PUSHREAL8ARRAY(soilp%km, r8*10/8)
    CALL PUSHREAL8ARRAY(soilp%kb, r8*10/8)
    CALL PUSHREAL8ARRAY(soilp%kk, r8*10/8)
    CALL UPDATESOILMOISTURE(soilp)
    zp = soilp%zp
  END DO
!END kkk iteration
!    write(*,*) G_o_b,gs_h2o
  kkk = kloop
!True? or Tsn1 @J.Wang
  IF (tsn1(kkk) .GT. 40.) THEN
    CALL PUSHREAL8ARRAY(tsn2(kkk), r8/8)
    tsn2(kkk) = 40.
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  IF (tsn1(kkk) .LT. -40.) THEN
    CALL PUSHREAL8ARRAY(tsn2(kkk), r8/8)
    tsn2(kkk) = -40.
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  IF (tsn2(kkk) .GT. 40.) THEN
    CALL PUSHREAL8ARRAY(tsn2(kkk), r8/8)
    tsn2(kkk) = 40.
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  IF (tsn2(kkk) .LT. -40.) THEN
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
!the mass of intercepted liquid water and snow, overstory
! fraction of ground surface covered by snow and snow mass
!laten heat of water vaporization in j/kg
!for output
  mid_res%trans = (trans_o(kkk)+trans_u(kkk))/rho_w
!J.Wang kg/m2/s// umol C/m2/s
! pmol/m2/s
!    write(*,*) "thetam_surf = ", mid_res%thetam_surf
  IF (lai_input .LT. 0) THEN
    temp_day = temp_day + meteo%temp
    theta_day = theta_day + (soilp%theta_vfc(0)-soilp%theta_vwp(0))
    trans_day = trans_day + mid_res%trans
    IF (is_end_curr_day) THEN
      temp_day = temp_day/24.
      theta_day = theta_day/24.
      trans_day = trans_day/24.
! use the method in BETHY to calculate phenology, with a little modification, @Mousong.Wu,201905
      CALL PUSHCONTROL2B(0)
    ELSE
      CALL PUSHCONTROL2B(1)
    END IF
  ELSE
    CALL PUSHCONTROL2B(2)
  END IF
  cos_soil_bw = mid_res_bw%cos_grnd
  CALL COS_GRND_BW(soilp, soilp_bw, cos_soil, cos_soil_bw)
  CALL POPCONTROL2B(branch)
  IF (branch .EQ. 0) THEN
    mid_res_bw%lai_old = mid_res_bw%lai_old + mid_res_bw%lai_new
    CALL BEPS_PHENOLOGY_BW(lc, daylen, temp_day, theta_day, trans_day, &
&                    trans_day_bw, mid_res%lai_old, mid_res_bw%lai_old)
    trans_day_bw = trans_day_bw/24.
    mid_res_bw%lai_old = 0.0_8
  ELSE IF (branch .EQ. 1) THEN
    mid_res_bw%lai_old = mid_res_bw%lai_old + mid_res_bw%lai_new
    trans_day_bw = 0.0_8
  ELSE
    mid_res_bw%trans = 0.0_8
    GOTO 130
  END IF
  mid_res_bw%trans = trans_day_bw
  mid_res_bw%lai_new = 0.0_8
 130 cos_o_sunlit_bw = mid_res_bw%cos_plant
  cos_o_shaded_bw = mid_res_bw%cos_plant
  cos_u_sunlit_bw = mid_res_bw%cos_plant
  cos_u_shaded_bw = mid_res_bw%cos_plant
  soilp_bw%thetam(0) = soilp_bw%thetam(0) + mid_res_bw%thetam_surf
  sif_o_sunlit_bw = mid_res_bw%sif
  sif_o_shaded_bw = mid_res_bw%sif
  sif_u_sunlit_bw = mid_res_bw%sif
  sif_u_shaded_bw = mid_res_bw%sif
  trans_o_bw = 0.0_8
  trans_u_bw = 0.0_8
  trans_o_bw(kkk) = trans_o_bw(kkk) + mid_res_bw%trans/rho_w
  trans_u_bw(kkk) = trans_u_bw(kkk) + mid_res_bw%trans/rho_w
  alpha_n_sw_bw = 0.0_8
  alpha_n_sw_bw(kkk) = alpha_n_sw_bw(kkk) + var_n_bw(40)
  var_n_bw(40) = 0.0_8
  alpha_v_sw_bw = 0.0_8
  alpha_v_sw_bw(kkk) = alpha_v_sw_bw(kkk) + var_n_bw(39)
  var_n_bw(39) = 0.0_8
  rho_snow_bw = 0.0_8
  rho_snow_bw(kkk) = rho_snow_bw(kkk) + var_n_bw(38)
  var_n_bw(38) = 0.0_8
  ac_snow_u_bw = 0.0_8
  ac_snow_u_bw(kkk) = ac_snow_u_bw(kkk) + var_n_bw(37)
  var_n_bw(37) = 0.0_8
  ac_snow_o_bw = 0.0_8
  ac_snow_o_bw(kkk) = ac_snow_o_bw(kkk) + var_n_bw(36)
  var_n_bw(36) = 0.0_8
  soilp_bw%r_rain_g = var_n_bw(35)
  var_n_bw(35) = 0.0_8
  soilp_bw%zp = var_n_bw(34)
  var_n_bw(34) = 0.0_8
  soilp_bw%zsp = var_n_bw(33)
  var_n_bw(33) = 0.0_8
  wg_snow_bw = 0.0_8
  wg_snow_bw(kkk) = wg_snow_bw(kkk) + var_n_bw(20)
  var_n_bw(20) = 0.0_8
  wcs_u_bw = 0.0_8
  wcs_u_bw(kkk) = wcs_u_bw(kkk) + var_n_bw(19)
  var_n_bw(19) = 0.0_8
  wcl_u_bw = 0.0_8
  wcl_u_bw(kkk) = wcl_u_bw(kkk) + var_n_bw(18)
  var_n_bw(18) = 0.0_8
  wcs_o_bw = 0.0_8
  wcs_o_bw(kkk) = wcs_o_bw(kkk) + var_n_bw(16)
  var_n_bw(16) = 0.0_8
  wcl_o_bw = 0.0_8
  wcl_o_bw(kkk) = wcl_o_bw(kkk) + var_n_bw(15)
  var_n_bw(15) = 0.0_8
  DO i=32,27,-1
    soilp_bw%ice_ratio(i-27) = soilp_bw%ice_ratio(i-27) + var_n_bw(i)
    var_n_bw(i) = 0.0_8
  END DO
  DO i=26,21,-1
    soilp_bw%thetam(i-21) = soilp_bw%thetam(i-21) + var_n_bw(i)
    var_n_bw(i) = 0.0_8
  END DO
  DO i=14,9,-1
    soilp_bw%temp_soil_c(i-9) = soilp_bw%temp_soil_c(i-9) + var_n_bw(i)
    var_n_bw(i) = 0.0_8
  END DO
  tsn2_bw = 0.0_8
  tsn2_bw(kkk) = tsn2_bw(kkk) + var_n_bw(7)
  var_n_bw(7) = 0.0_8
  tsn1_bw = 0.0_8
  tsn1_bw(kkk) = tsn1_bw(kkk) + var_n_bw(6)
  var_n_bw(6) = 0.0_8
  tsm0_bw = 0.0_8
  tsm0_bw(kkk) = tsm0_bw(kkk) + var_n_bw(5)
  var_n_bw(5) = 0.0_8
  tsn0_bw = 0.0_8
  tsn0_bw(kkk) = tsn0_bw(kkk) + var_n_bw(4)
  var_n_bw(4) = 0.0_8
  ts0_bw = 0.0_8
  ts0_bw(kkk) = ts0_bw(kkk) + var_n_bw(3)
  var_n_bw(3) = 0.0_8
  qhc_o_bw = 0.0_8
  qhc_o_bw(kkk) = qhc_o_bw(kkk) + var_n_bw(1)
  var_n_bw(1) = 0.0_8
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) tsn2_bw(kkk) = 0.0_8
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    CALL POPREAL8ARRAY(tsn2(kkk), r8/8)
    tsn2_bw(kkk) = 0.0_8
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    CALL POPREAL8ARRAY(tsn2(kkk), r8/8)
    tsn2_bw(kkk) = 0.0_8
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    CALL POPREAL8ARRAY(tsn2(kkk), r8/8)
    tsn2_bw(kkk) = 0.0_8
  END IF
  xcs_o_bw = 0.0_8
  lcos_u_shaded_bw = 0.0_8
  gh_o_sunlit_bw = 0.0_8
  lsif_o_sunlit_bw = 0.0_8
  laio_shaded_bw = 0.0_8
  g_bw = 0.0_8
  ac_o_shaded_bw = 0.0_8
  laiu_sunlit_bw = 0.0_8
  tm_bw = 0.0_8
  xcs_u_bw = 0.0_8
  xg_snow_bw = 0.0_8
  ac_u_sunlit_bw = 0.0_8
  tc_o_sunlit_old_bw = 0.0_8
  lambda_soil_bw = 0.0_8
  gh_o_shaded_bw = 0.0_8
  r_rain_g_bw = 0.0_8
  lsif_o_shaded_bw = 0.0_8
  gww_o_sunlit_bw = 0.0_8
  zsp_bw = 0.0_8
  lsif_u_sunlit_bw = 0.0_8
  eil_o_bw = 0.0_8
  laiu_shaded_bw = 0.0_8
  lai_o_sunlit_bw = 0.0_8
  gw_o_sunlit_bw = 0.0_8
  tc_o_shaded_new_bw = 0.0_8
  ac_u_shaded_bw = 0.0_8
  eil_u_bw = 0.0_8
  tc_u_sunlit_old_bw = 0.0_8
  evap_soil_bw = 0.0_8
  gww_o_shaded_bw = 0.0_8
  lsif_u_shaded_bw = 0.0_8
  lai_o_shaded_bw = 0.0_8
  gw_o_shaded_bw = 0.0_8
  tc_u_shaded_new_bw = 0.0_8
  ra_g_bw = 0.0_8
  gw_u_sunlit_bw = 0.0_8
  gww_u_sunlit_bw = 0.0_8
  lai_u_sunlit_bw = 0.0_8
  eis_o_bw = 0.0_8
  tc_o_sunlit_new_bw = 0.0_8
  eis_u_bw = 0.0_8
  gw_u_shaded_bw = 0.0_8
  lai_o_bw = 0.0_8
  gww_u_shaded_bw = 0.0_8
  tc_u_bw = 0.0_8
  lai_u_shaded_bw = 0.0_8
  tcu_bw = 0.0_8
  lai_u_bw = 0.0_8
  lcos_o_sunlit_bw = 0.0_8
  tc_u_sunlit_new_bw = 0.0_8
  vcmax_sunlit_bw = 0.0_8
  ffpa_bw = 0.0_8
  xcl_o_bw = 0.0_8
  radiation_g_bw = 0.0_8
  lcos_o_shaded_bw = 0.0_8
  xcl_u_bw = 0.0_8
  tc_o_shaded_old_bw = 0.0_8
  cs_bw = 0.0_8
  lcos_u_sunlit_bw = 0.0_8
  vcmax_shaded_bw = 0.0_8
  laio_sunlit_bw = 0.0_8
  ac_o_sunlit_bw = 0.0_8
  evap_ss_bw = 0.0_8
  zp_bw = 0.0_8
  evap_sw_bw = 0.0_8
  tc_u_shaded_old_bw = 0.0_8
  DO kkk=kloop,1,-1
    soilp_bw%zp = soilp_bw%zp + zp_bw
    soilp%r_rain_g = r_rain_g(kkk)
    CALL POPREAL8ARRAY(soilp%kk, r8*10/8)
    CALL POPREAL8ARRAY(soilp%kb, r8*10/8)
    CALL POPREAL8ARRAY(soilp%km, r8*10/8)
    CALL POPREAL8ARRAY(soilp%r_waterflow, r8*10/8)
    CALL POPREAL8ARRAY(soilp%psib, r8*10/8)
    CALL POPREAL8ARRAY(soilp%thetab, r8*10/8)
    CALL POPREAL8ARRAY(soilp%psim, r8*10/8)
    CALL POPREAL8ARRAY(soilp%f_ice, r8*10/8)
    CALL POPREAL8ARRAY(soilp%thetam_prev, r8*10/8)
    CALL POPREAL8ARRAY(soilp%thetam, r8*10/8)
    CALL POPREAL8ARRAY(soilp%ice_ratio, r8*10/8)
    CALL POPREAL8ARRAY(soilp%zp, r8/8)
    CALL UPDATESOILMOISTURE_BW(soilp, soilp_bw)
    zp_bw = soilp_bw%zp
    r_rain_g_bw(kkk) = r_rain_g_bw(kkk) + soilp_bw%r_rain_g
    CALL POPREAL8ARRAY(soilp%ett, r8*10/8)
    CALL SOIL_WATER_UPTAKE_BW(soilp, soilp_bw, trans_o(kkk), trans_o_bw(&
&                       kkk), trans_u(kkk), trans_u_bw(kkk), evap_soil(&
&                       kkk), evap_soil_bw(kkk))
    CALL POPREAL8ARRAY(soilp%g, r8*10/8)
    CALL POPREAL8ARRAY(soilp%temp_soil_c, r8*10/8)
    CALL POPREAL8ARRAY(soilp%temp_soil_p, r8*10/8)
    CALL POPREAL8ARRAY(soilp%ice_ratio, r8*10/8)
    CALL UPDATEHEATFLUX_BW(soilp, soilp_bw, xg_snow(kkk), lambda_snow(&
&                    kkk), tsn0(kkk), temp_air, kstep)
    g_bw(0, kkk) = g_bw(0, kkk) + soilp_bw%g(0)
    zsp_bw = zsp_bw + soilp_bw%zsp
    gheat_g = 1./ra_g
    CALL SENSIBLEHEAT_BW(tc_o_sunlit_new, tc_o_sunlit_new_bw, &
&                  tc_o_shaded_new, tc_o_shaded_new_bw, tc_u_sunlit_new&
&                  , tc_u_shaded_new, ts0(kkk), temp_air, rh_air, &
&                  gh_o_sunlit, gh_o_sunlit_bw, gh_o_shaded, &
&                  gh_o_shaded_bw, gh_u_sunlit, gh_u_shaded, gheat_g, &
&                  lai_o_sunlit, lai_o_sunlit_bw, lai_o_shaded, &
&                  lai_o_shaded_bw, lai_u_sunlit, lai_u_shaded, qhc_o(&
&                  kkk), qhc_o_bw(kkk), qhc_u(kkk), qhg(kkk))
    qhc_o_bw(kkk) = 0.0_8
    CALL POPREAL8ARRAY(zsp, r8/8)
    CALL POPREAL8ARRAY(zp, r8/8)
    CALL POPREAL8ARRAY(wg_snow(kkk), r8/8)
    CALL SNOWPACK_STAGE3_BW(temp_air, tsn0(kkk), tsn0_bw(kkk), tsn0(kkk-&
&                     1), rho_snow(kkk), rho_snow_bw(kkk), zsp, zsp_bw, &
&                     zp, zp_bw, wg_snow(kkk), wg_snow_bw(kkk))
    CALL POPREAL8ARRAY(soilp%temp_soil_c(0), r8/8)
    tm_bw(0, kkk) = tm_bw(0, kkk) + soilp_bw%temp_soil_c(0)
    soilp_bw%temp_soil_c(0) = 0.0_8
    CALL POPREAL8ARRAY(ts0(kkk), r8/8)
    CALL POPREAL8ARRAY(tm(0, kkk), r8/8)
    CALL POPREAL8ARRAY(tsn0(kkk), r8/8)
    CALL POPREAL8ARRAY(tsm0(kkk), r8/8)
    CALL POPREAL8ARRAY(tsn1(kkk), r8/8)
    CALL POPREAL8ARRAY(tsn2(kkk), r8/8)
    CALL SURFACETEMPERATURE_BW(temp_air, rh_air, zsp, zsp_bw, zp, cs(1, &
&                        kkk), cs_bw(1, kkk), cs(0, kkk), cs_bw(0, kkk)&
&                        , gheat_g, gheat_g_bw, d_soil(1), rho_snow(kkk)&
&                        , rho_snow_bw(kkk), tc_u(kkk), tc_u_bw(kkk), &
&                        radiation_g, radiation_g_bw, evap_soil(kkk), &
&                        evap_soil_bw(kkk), evap_sw(kkk), evap_sw_bw(kkk&
&                        ), evap_ss(kkk), evap_ss_bw(kkk), lambda_soil(1&
&                        ), lambda_soil_bw(1), xg_snow(kkk), xg_snow_bw(&
&                        kkk), g(1, kkk), g_bw(1, kkk), ts0(kkk-1), &
&                        ts0_bw(kkk-1), tm(1, kkk-1), tm_bw(1, kkk-1), &
&                        tm(0, kkk-1), tm_bw(0, kkk-1), tsn0(kkk-1), &
&                        tsn0_bw(kkk-1), tsm0(kkk-1), tsm0_bw(kkk-1), &
&                        tsn1(kkk-1), tsn1_bw(kkk-1), tsn2(kkk-1), &
&                        tsn2_bw(kkk-1), ts0(kkk), ts0_bw(kkk), tm(0, &
&                        kkk), tm_bw(0, kkk), tsn0(kkk), tsn0_bw(kkk), &
&                        tsm0(kkk), tsm0_bw(kkk), tsn1(kkk), tsn1_bw(kkk&
&                        ), tsn2(kkk), tsn2_bw(kkk), g(0, kkk), g_bw(0, &
&                        kkk))
    soilp_bw%g(0) = g_bw(1, kkk)
    g_bw(1, kkk) = 0.0_8
    CALL POPREAL8ARRAY(tm(0, kkk-1), r8/8)
    soilp_bw%temp_soil_p(0) = soilp_bw%temp_soil_p(0) + tm_bw(0, kkk-1)
    tm_bw(0, kkk-1) = 0.0_8
    CALL POPREAL8ARRAY(tm(1, kkk-1), r8/8)
    soilp_bw%temp_soil_p(1) = soilp_bw%temp_soil_p(1) + tm_bw(1, kkk-1)
    tm_bw(1, kkk-1) = 0.0_8
    CALL POPREAL8ARRAY(d_soil(1), r8/8)
    CALL POPREAL8ARRAY(lambda_soil(1), r8/8)
    soilp_bw%lambda(0) = soilp_bw%lambda(0) + lambda_soil_bw(1)
    lambda_soil_bw(1) = 0.0_8
    tcu_bw = tcu_bw + tc_u_bw(kkk)
    tc_u_bw(kkk) = 0.0_8
    soilp_bw%cs(0) = soilp_bw%cs(0) + cs_bw(1, kkk) + cs_bw(0, kkk)
    cs_bw(1, kkk) = 0.0_8
    cs_bw(0, kkk) = 0.0_8
    CALL POPREAL8ARRAY(soilp%cs, r8*10/8)
    CALL UPDATE_CS_BW(soilp, soilp_bw)
    CALL POPREAL8ARRAY(soilp%lambda, r8*10/8)
    CALL UPDATESOILTHERMALCONDUCTIVITY_BW(soilp, soilp_bw)
    eis_u_bw(kkk) = 0.0_8
    eil_u_bw(kkk) = 0.0_8
    eis_o_bw(kkk) = 0.0_8
    eil_o_bw(kkk) = 0.0_8
    temp_bw0 = zsp_bw/rho_snow(kkk)
    wg_snow_bw(kkk) = wg_snow_bw(kkk) + temp_bw0
    rho_snow_bw(kkk) = rho_snow_bw(kkk) - wg_snow(kkk)*temp_bw0/rho_snow&
&     (kkk)
    mass_water_g_bw = zp_bw/rho_w
    temp_grd = temp_air
    CALL POPREAL8ARRAY(xg_snow(kkk), r8/8)
    CALL POPREAL8ARRAY(zp, r8/8)
    CALL POPREAL8ARRAY(zsp, r8/8)
    CALL POPREAL8ARRAY(wg_snow(kkk), r8/8)
    CALL SOIL_EVAPORATION_BW(temp_grd, ts0(kkk-1), ts0_bw(kkk-1), rh_air&
&                      , radiation_g, radiation_g_bw, gheat_g, &
&                      gheat_g_bw, xg_snow(kkk), xg_snow_bw(kkk), zp, &
&                      zp_bw, zsp, mass_water_g, mass_water_g_bw, &
&                      wg_snow(kkk), wg_snow_bw(kkk), rho_snow(kkk), &
&                      rho_snow_bw(kkk), soilp%thetam_prev(0), soilp_bw%&
&                      thetam_prev(0), soilp%fei(0), evap_soil(kkk), &
&                      evap_soil_bw(kkk), evap_sw(kkk), evap_sw_bw(kkk)&
&                      , evap_ss(kkk), evap_ss_bw(kkk))
    xg_snow_bw(kkk) = 0.0_8
    evap_soil_bw(kkk) = 0.0_8
    evap_sw_bw(kkk) = 0.0_8
    evap_ss_bw(kkk) = 0.0_8
    zp_bw = zp_bw + rho_w*mass_water_g_bw
    ra_g_bw = ra_g_bw - gheat_g_bw/ra_g**2
    CALL POPREAL8ARRAY(wcs_o(kkk), r8/8)
    CALL POPREAL8ARRAY(wcs_u(kkk), r8/8)
    CALL SNOWPACK_STAGE2_BW(eis_o(kkk), eis_o_bw(kkk), eis_u(kkk), &
&                     eis_u_bw(kkk), wcs_o(kkk), wcs_o_bw(kkk), wcs_u(&
&                     kkk), wcs_u_bw(kkk))
    CALL POPREAL8ARRAY(wcl_o(kkk), r8/8)
    CALL POPREAL8ARRAY(wcl_u(kkk), r8/8)
    CALL RAINFALL_STAGE2_BW(eil_o(kkk), eil_o_bw(kkk), eil_u(kkk), &
&                     eil_u_bw(kkk), wcl_o(kkk), wcl_o_bw(kkk), wcl_u(&
&                     kkk), wcl_u_bw(kkk))
    CALL EVAPORATION_CANOPY_BW(tc_o_sunlit_new, tc_o_sunlit_new_bw, &
&                        tc_o_shaded_new, tc_o_shaded_new_bw, &
&                        tc_u_sunlit_new, tc_u_sunlit_new_bw, &
&                        tc_u_shaded_new, tc_u_shaded_new_bw, temp_air, &
&                        rh_air, gww_o_sunlit, gww_o_sunlit_bw, &
&                        gww_o_shaded, gww_o_shaded_bw, gww_u_sunlit, &
&                        gww_u_sunlit_bw, gww_u_shaded, gww_u_shaded_bw&
&                        , lai_o_sunlit, lai_o_sunlit_bw, lai_o_shaded, &
&                        lai_o_shaded_bw, lai_u_sunlit, lai_u_sunlit_bw&
&                        , lai_u_shaded, lai_u_shaded_bw, xcl_o(kkk), &
&                        xcl_o_bw(kkk), xcl_u(kkk), xcl_u_bw(kkk), xcs_o&
&                        (kkk), xcs_o_bw(kkk), xcs_u(kkk), xcs_u_bw(kkk)&
&                        , eil_o(kkk), eil_o_bw(kkk), eil_u(kkk), &
&                        eil_u_bw(kkk), eis_o(kkk), eis_o_bw(kkk), eis_u&
&                        (kkk), eis_u_bw(kkk))
    eil_o_bw(kkk) = 0.0_8
    eil_u_bw(kkk) = 0.0_8
    eis_o_bw(kkk) = 0.0_8
    eis_u_bw(kkk) = 0.0_8
    CALL TRANSPIRATION_BW(tc_o_sunlit_new, tc_o_sunlit_new_bw, &
&                   tc_o_shaded_new, tc_o_shaded_new_bw, tc_u_sunlit_new&
&                   , tc_u_sunlit_new_bw, tc_u_shaded_new, &
&                   tc_u_shaded_new_bw, temp_air, rh_air, gw_o_sunlit, &
&                   gw_o_sunlit_bw, gw_o_shaded, gw_o_shaded_bw, &
&                   gw_u_sunlit, gw_u_sunlit_bw, gw_u_shaded, &
&                   gw_u_shaded_bw, lai_o_sunlit, lai_o_sunlit_bw, &
&                   lai_o_shaded, lai_o_shaded_bw, lai_u_sunlit, &
&                   lai_u_sunlit_bw, lai_u_shaded, lai_u_shaded_bw, &
&                   trans_o(kkk), trans_o_bw(kkk), trans_u(kkk), &
&                   trans_u_bw(kkk))
    trans_o_bw(kkk) = 0.0_8
    trans_u_bw(kkk) = 0.0_8
    temp_bw0 = laiu_shaded*0.1*sif_u_shaded_bw
    lsif_u_shaded_bw = lsif_u_shaded_bw + temp_bw0
    stsif_u_shaded_bw = temp_bw0
    temp_bw0 = laiu_sunlit*0.1*sif_u_sunlit_bw
    lsif_u_sunlit_bw = lsif_u_sunlit_bw + temp_bw0
    stsif_u_sunlit_bw = temp_bw0
    temp_bw0 = laio_shaded*0.1*sif_o_shaded_bw
    lsif_o_shaded_bw = lsif_o_shaded_bw + temp_bw0
    stsif_o_shaded_bw = temp_bw0
    temp_bw0 = laio_sunlit*0.1*sif_o_sunlit_bw
    lsif_o_sunlit_bw = lsif_o_sunlit_bw + temp_bw0
    stsif_o_sunlit_bw = temp_bw0
    temp_bw0 = clumping*0.3*EXP(-coszs)*stsif_u_shaded_bw
    laiu_shaded_bw = laiu_shaded_bw + (lsif_u_shaded+stsif_u_shaded)*0.1&
&     *sif_u_shaded_bw + lcos_u_shaded*cos_u_shaded_bw - 0.1*&
&     lsif_u_shaded*temp_bw0
    CALL POPREAL8ARRAY(stsif_u_shaded, r8/8)
    lsif_u_shaded_bw = lsif_u_shaded_bw + (1.1-0.1*laiu_shaded)*temp_bw0
    temp_bw0 = clumping*0.3*EXP(-coszs)*stsif_u_sunlit_bw
    laiu_sunlit_bw = laiu_sunlit_bw + (lsif_u_sunlit+stsif_u_sunlit)*0.1&
&     *sif_u_sunlit_bw + lcos_u_sunlit*cos_u_sunlit_bw - 0.1*&
&     lsif_u_sunlit*temp_bw0
    CALL POPREAL8ARRAY(stsif_u_sunlit, r8/8)
    lsif_u_sunlit_bw = lsif_u_sunlit_bw + (1.1-0.1*laiu_sunlit)*temp_bw0
    temp_bw0 = clumping*0.3*EXP(-coszs)*stsif_o_shaded_bw
    laio_shaded_bw = laio_shaded_bw + (lsif_o_shaded+stsif_o_shaded)*0.1&
&     *sif_o_shaded_bw + lcos_o_shaded*cos_o_shaded_bw - 0.1*&
&     lsif_o_shaded*temp_bw0
    CALL POPREAL8ARRAY(stsif_o_shaded, r8/8)
    lsif_o_shaded_bw = lsif_o_shaded_bw + (1.1-0.1*laio_shaded)*temp_bw0
    temp_bw0 = clumping*0.3*EXP(-coszs)*stsif_o_sunlit_bw
    laio_sunlit_bw = laio_sunlit_bw + (lsif_o_sunlit+stsif_o_sunlit)*0.1&
&     *sif_o_sunlit_bw + lcos_o_sunlit*cos_o_sunlit_bw - 0.1*&
&     lsif_o_sunlit*temp_bw0
    CALL POPREAL8ARRAY(stsif_o_sunlit, r8/8)
    lsif_o_sunlit_bw = lsif_o_sunlit_bw + (1.1-0.1*laio_sunlit)*temp_bw0
    lcos_u_shaded_bw = lcos_u_shaded_bw + laiu_shaded*cos_u_shaded_bw
    lcos_u_sunlit_bw = lcos_u_sunlit_bw + laiu_sunlit*cos_u_sunlit_bw
    lcos_o_shaded_bw = lcos_o_shaded_bw + laio_shaded*cos_o_shaded_bw
    lcos_o_sunlit_bw = lcos_o_sunlit_bw + laio_sunlit*cos_o_sunlit_bw
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) THEN
      CALL POPREAL8ARRAY(tc_u_shaded_old, r8/8)
      CALL POPREAL8ARRAY(tc_u_sunlit_old, r8/8)
      CALL POPREAL8ARRAY(tc_o_shaded_old, r8/8)
      CALL POPREAL8ARRAY(tc_o_sunlit_old, r8/8)
      percentarea_snow_o = ac_snow_o(kkk)/lai_o/2.
      percentarea_snow_u = ac_snow_u(kkk)/lai_u/2.
    END IF
    CALL POPINTEGER4(ad_count)
    DO 150 i0=1,ad_count
      IF (i0 .EQ. 1) THEN
        CALL POPCONTROL2B(branch)
        IF (branch .EQ. 0) THEN
          gs_o_shaded_old_bw = 0.0_8
          percentarea_snow_o_bw = 0.0_8
          percentarea_snow_u_bw = 0.0_8
          cosi_o_shaded_old_bw = 0.0_8
          gs_u_shaded_old_bw = 0.0_8
          cosi_u_shaded_old_bw = 0.0_8
          gs_o_sunlit_old_bw = 0.0_8
          gh_o_bw = 0.0_8
          cosi_o_sunlit_old_bw = 0.0_8
          alpha_v_g_bw = 0.0_8
          gs_u_sunlit_old_bw = 0.0_8
          cosi_u_sunlit_old_bw = 0.0_8
          alpha_n_g_bw = 0.0_8
          f_soilwater_bw = 0.0_8
          GOTO 150
        ELSE IF (branch .EQ. 1) THEN
          gs_o_shaded_old_bw = 0.0_8
          percentarea_snow_o_bw = 0.0_8
          percentarea_snow_u_bw = 0.0_8
          cosi_o_shaded_old_bw = 0.0_8
          gs_u_shaded_old_bw = 0.0_8
          cosi_u_shaded_old_bw = 0.0_8
          gs_o_sunlit_old_bw = 0.0_8
          gh_o_bw = 0.0_8
          cosi_o_sunlit_old_bw = 0.0_8
          alpha_v_g_bw = 0.0_8
          gs_u_sunlit_old_bw = 0.0_8
          cosi_u_sunlit_old_bw = 0.0_8
          alpha_n_g_bw = 0.0_8
          f_soilwater_bw = 0.0_8
          GOTO 140
        ELSE
          gs_o_shaded_old_bw = 0.0_8
          percentarea_snow_o_bw = 0.0_8
          percentarea_snow_u_bw = 0.0_8
          cosi_o_shaded_old_bw = 0.0_8
          gs_u_shaded_old_bw = 0.0_8
          cosi_u_shaded_old_bw = 0.0_8
          gs_o_sunlit_old_bw = 0.0_8
          gh_o_bw = 0.0_8
          cosi_o_sunlit_old_bw = 0.0_8
          alpha_v_g_bw = 0.0_8
          gs_u_sunlit_old_bw = 0.0_8
          cosi_u_sunlit_old_bw = 0.0_8
          alpha_n_g_bw = 0.0_8
          f_soilwater_bw = 0.0_8
        END IF
      ELSE
        CALL POPREAL8ARRAY(tc_u_shaded_old, r8/8)
        tc_u_shaded_new_bw = tc_u_shaded_new_bw + tc_u_shaded_old_bw
        CALL POPREAL8ARRAY(tc_u_sunlit_old, r8/8)
        tc_u_sunlit_new_bw = tc_u_sunlit_new_bw + tc_u_sunlit_old_bw
        CALL POPREAL8ARRAY(tc_o_shaded_old, r8/8)
        tc_o_shaded_new_bw = tc_o_shaded_new_bw + tc_o_shaded_old_bw
        CALL POPREAL8ARRAY(tc_o_sunlit_old, r8/8)
        tc_o_sunlit_new_bw = tc_o_sunlit_new_bw + tc_o_sunlit_old_bw
      END IF
      tc_o_sunlit_old_bw = 0.0_8
      tc_u_sunlit_old_bw = 0.0_8
      tc_o_shaded_old_bw = 0.0_8
      tc_u_shaded_old_bw = 0.0_8
 140  CALL POPREAL8ARRAY(gh_o, r8/8)
      h_o_sunlit_bw = lai_o_sunlit*gh_o_bw
      lai_o_sunlit_bw = lai_o_sunlit_bw + h_o_sunlit*gh_o_bw
      h_o_shaded_bw = lai_o_shaded*gh_o_bw
      lai_o_shaded_bw = lai_o_shaded_bw + h_o_shaded*gh_o_bw
      CALL POPREAL8ARRAY(h_o_shaded, r8/8)
      temp_bw0 = rho_a*cp_ca*h_o_shaded_bw
      tc_o_shaded_new_bw = tc_o_shaded_new_bw + gh_o_shaded*temp_bw0
      gh_o_shaded_bw = gh_o_shaded_bw + (tc_o_shaded_new-temp_air)*&
&       temp_bw0
      CALL POPREAL8ARRAY(h_o_sunlit, r8/8)
      temp_bw0 = rho_a*cp_ca*h_o_sunlit_bw
      tc_o_sunlit_new_bw = tc_o_sunlit_new_bw + gh_o_sunlit*temp_bw0
      gh_o_sunlit_bw = gh_o_sunlit_bw + (tc_o_sunlit_new-temp_air)*&
&       temp_bw0
      CALL POPREAL8ARRAY(tc_o_sunlit_new, r8/8)
      CALL POPREAL8ARRAY(tc_o_shaded_new, r8/8)
      CALL POPREAL8ARRAY(tc_u_sunlit_new, r8/8)
      CALL POPREAL8ARRAY(tc_u_shaded_new, r8/8)
      CALL LEAF_TEMPERATURES_BW(temp_air, slope, psychrometer, vpd_air, &
&                         cp_ca, gw_o_sunlit, gw_o_sunlit_bw, &
&                         gw_o_shaded, gw_o_shaded_bw, gw_u_sunlit, &
&                         gw_u_sunlit_bw, gw_u_shaded, gw_u_shaded_bw, &
&                         gww_o_sunlit, gww_o_sunlit_bw, gww_o_shaded, &
&                         gww_o_shaded_bw, gww_u_sunlit, gww_u_sunlit_bw&
&                         , gww_u_shaded, gww_u_shaded_bw, gh_o_sunlit, &
&                         gh_o_sunlit_bw, gh_o_shaded, gh_o_shaded_bw, &
&                         gh_u_sunlit, gh_u_sunlit_bw, gh_u_shaded, &
&                         gh_u_shaded_bw, xcs_o(kkk), xcs_o_bw(kkk), &
&                         xcl_o(kkk), xcl_o_bw(kkk), xcs_u(kkk), &
&                         xcs_u_bw(kkk), xcl_u(kkk), xcl_u_bw(kkk), &
&                         radiation_o_sun, radiation_o_sun_bw, &
&                         radiation_o_shaded, radiation_o_shaded_bw, &
&                         radiation_u_sun, radiation_u_sun_bw, &
&                         radiation_u_shaded, radiation_u_shaded_bw, &
&                         tc_o_sunlit_new, tc_o_sunlit_new_bw, &
&                         tc_o_shaded_new, tc_o_shaded_new_bw, &
&                         tc_u_sunlit_new, tc_u_sunlit_new_bw, &
&                         tc_u_shaded_new, tc_u_shaded_new_bw)
      CALL POPREAL8ARRAY(gw_u_shaded, r8/8)
      temp0 = 1.0/g_u_a + 1.0/g_u_b + 1.0/gs_u_shaded_new
      temp_bw0 = -(gw_u_shaded_bw/temp0**2)
      g_u_a_bw = -(temp_bw0/g_u_a**2)
      g_u_b_bw = -(temp_bw0/g_u_b**2)
      gs_u_shaded_new_bw = gs_u_shaded_old_bw - temp_bw0/gs_u_shaded_new&
&       **2
      CALL POPREAL8ARRAY(gs_u_shaded_old, r8/8)
      CALL POPREAL8ARRAY(cosi_u_shaded_old, r8/8)
      cosi_u_shaded_new_bw = cosi_u_shaded_old_bw
      CALL POPREAL8ARRAY(ci_u_shaded_old, r8/8)
      CALL POPREAL8ARRAY(gw_u_sunlit, r8/8)
      temp0 = 1.0/g_u_a + 1.0/g_u_b + 1.0/gs_u_sunlit_new
      temp_bw0 = -(gw_u_sunlit_bw/temp0**2)
      g_u_a_bw = g_u_a_bw - temp_bw0/g_u_a**2
      g_u_b_bw = g_u_b_bw - temp_bw0/g_u_b**2
      gs_u_sunlit_new_bw = -(temp_bw0/gs_u_sunlit_new**2)
      CALL POPREAL8ARRAY(gs_u_sunlit_old, r8/8)
      CALL POPREAL8ARRAY(cosi_u_sunlit_old, r8/8)
      cosi_o_sunlit_new_bw = cosi_u_sunlit_old_bw + cosi_o_sunlit_old_bw
      CALL POPREAL8ARRAY(ci_u_sunlit_old, r8/8)
      CALL POPREAL8ARRAY(gw_o_shaded, r8/8)
      temp0 = 1.0/g_o_a + 1.0/g_o_b + 1.0/gs_o_shaded_new
      temp_bw0 = -(gw_o_shaded_bw/temp0**2)
      g_o_a_bw = -(temp_bw0/g_o_a**2)
      g_o_b_bw = -(temp_bw0/g_o_b**2)
      gs_o_shaded_new_bw = gs_o_shaded_old_bw - temp_bw0/gs_o_shaded_new&
&       **2
      CALL POPREAL8ARRAY(gs_o_shaded_old, r8/8)
      CALL POPREAL8ARRAY(cosi_o_shaded_old, r8/8)
      cosi_o_shaded_new_bw = cosi_o_shaded_old_bw
      CALL POPREAL8ARRAY(ci_o_shaded_old, r8/8)
      CALL POPREAL8ARRAY(gw_o_sunlit, r8/8)
      temp0 = 1.0/g_o_a + 1.0/g_o_b + 1.0/gs_o_sunlit_new
      temp_bw0 = -(gw_o_sunlit_bw/temp0**2)
      gs_o_sunlit_new_bw = gs_u_sunlit_old_bw + gs_o_sunlit_old_bw - &
&       temp_bw0/gs_o_sunlit_new**2
      g_o_a_bw = g_o_a_bw - temp_bw0/g_o_a**2
      g_o_b_bw = g_o_b_bw - temp_bw0/g_o_b**2
      CALL POPREAL8ARRAY(gs_o_sunlit_old, r8/8)
      CALL POPREAL8ARRAY(cosi_o_sunlit_old, r8/8)
      CALL POPREAL8ARRAY(ci_o_sunlit_old, r8/8)
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8ARRAY(lcos_u_shaded, r8/8)
        CALL POPREAL8ARRAY(lsif_u_shaded, r8/8)
        CALL POPREAL8ARRAY(gs_u_shaded_new, r8/8)
        CALL POPREAL8ARRAY(lcos_u_sunlit, r8/8)
        CALL POPREAL8ARRAY(lsif_u_sunlit, r8/8)
        CALL POPREAL8ARRAY(gs_u_sunlit_new, r8/8)
        CALL POPREAL8ARRAY(lcos_o_shaded, r8/8)
        CALL POPREAL8ARRAY(lsif_o_shaded, r8/8)
        CALL POPREAL8ARRAY(gs_o_shaded_new, r8/8)
        CALL POPREAL8ARRAY(lcos_o_sunlit, r8/8)
        CALL POPREAL8ARRAY(lsif_o_sunlit, r8/8)
        CALL POPREAL8ARRAY(gs_o_sunlit_new, r8/8)
        ac_o_shaded_bw = 0.0_8
        leleaf_u_shaded_bw = 0.0_8
        ac_u_sunlit_bw = 0.0_8
        r_o_shaded_bw = 0.0_8
        r_u_sunlit_bw = 0.0_8
        ac_u_shaded_bw = 0.0_8
        r_u_shaded_bw = 0.0_8
        cosi_o_shaded_old_bw = 0.0_8
        cosi_u_shaded_old_bw = 0.0_8
        leleaf_o_sunlit_bw = 0.0_8
        cosi_o_sunlit_old_bw = 0.0_8
        leleaf_o_shaded_bw = 0.0_8
        ac_o_sunlit_bw = 0.0_8
        leleaf_u_sunlit_bw = 0.0_8
        cosi_u_sunlit_old_bw = 0.0_8
        r_o_sunlit_bw = 0.0_8
      ELSE
        gw_u_shaded = 1.0/(1.0/g_u_a+1.0/g_u_b+1.0/gs_u_shaded_old)
        leleaf_u_shaded = gw_u_shaded*(vpd_air+slope*(tc_u_shaded_old-&
&         temp_air))*rho_a*cp_ca/psychrometer
        CALL POPREAL8ARRAY(gs_u_shaded_new, r8/8)
        CALL POPREAL8ARRAY(ac_u_shaded, r8/8)
        CALL POPREAL8ARRAY(lsif_u_shaded, r8/8)
        CALL POPREAL8ARRAY(lcos_u_shaded, r8/8)
        CALL PHOTOSYNTHESIS_BW(landcover, tc_u_shaded_old, &
&                        tc_u_shaded_old_bw, f_leaf, f_leaf_bw, p_kc25, &
&                        p_ko25, p_tau25, r_u_shaded, r_u_shaded_bw, &
&                        e_a10, g_u_b, g_u_b_bw, vcmax_shaded, &
&                        vcmax_shaded_bw, vj_slope, vj_slope_bw, &
&                        f_soilwater, f_soilwater_bw, b_h2o, m_h2o, &
&                        ci_u_shaded_old, temp_air, leleaf_u_shaded, &
&                        leleaf_u_shaded_bw, gs_u_shaded_new, &
&                        gs_u_shaded_new_bw, gs_h2o, ac_u_shaded, &
&                        ac_u_shaded_bw, ci_u_shaded_new, ffpa, ffpa_bw&
&                        , sif_alpha, sif_alpha_bw, sif_beta, &
&                        sif_beta_bw, lsif_u_shaded, lsif_u_shaded_bw, &
&                        cosi_u_shaded_old, cosi_u_shaded_old_bw, &
&                        cosi_u_shaded_new, cosi_u_shaded_new_bw, &
&                        lcos_u_shaded, lcos_u_shaded_bw)
        gw_u_sunlit = 1.0/(1.0/g_u_a+1.0/g_u_b+1.0/gs_u_sunlit_old)
        leleaf_u_sunlit = gw_u_sunlit*(vpd_air+slope*(tc_u_sunlit_old-&
&         temp_air))*rho_a*cp_ca/psychrometer
        CALL POPREAL8ARRAY(gs_u_sunlit_new, r8/8)
        CALL POPREAL8ARRAY(ac_u_sunlit, r8/8)
        CALL POPREAL8ARRAY(lsif_u_sunlit, r8/8)
        CALL POPREAL8ARRAY(lcos_u_sunlit, r8/8)
        cosi_u_sunlit_new_bw = 0.0_8
        CALL PHOTOSYNTHESIS_BW(landcover, tc_u_sunlit_old, &
&                        tc_u_sunlit_old_bw, f_leaf, f_leaf_bw, p_kc25, &
&                        p_ko25, p_tau25, r_u_sunlit, r_u_sunlit_bw, &
&                        e_a10, g_u_b, g_u_b_bw, vcmax_sunlit, &
&                        vcmax_sunlit_bw, vj_slope, vj_slope_bw, &
&                        f_soilwater, f_soilwater_bw, b_h2o, m_h2o, &
&                        ci_u_sunlit_old, temp_air, leleaf_u_sunlit, &
&                        leleaf_u_sunlit_bw, gs_u_sunlit_new, &
&                        gs_u_sunlit_new_bw, gs_h2o, ac_u_sunlit, &
&                        ac_u_sunlit_bw, ci_u_sunlit_new, ffpa, ffpa_bw&
&                        , sif_alpha, sif_alpha_bw, sif_beta, &
&                        sif_beta_bw, lsif_u_sunlit, lsif_u_sunlit_bw, &
&                        cosi_u_sunlit_old, cosi_u_sunlit_old_bw, &
&                        cosi_u_sunlit_new, cosi_u_sunlit_new_bw, &
&                        lcos_u_sunlit, lcos_u_sunlit_bw)
        gw_o_shaded = 1.0/(1.0/g_o_a+1.0/g_o_b+1.0/gs_o_shaded_old)
        leleaf_o_shaded = gw_o_shaded*(vpd_air+slope*(tc_o_shaded_old-&
&         temp_air))*rho_a*cp_ca/psychrometer
        CALL POPREAL8ARRAY(gs_o_shaded_new, r8/8)
        CALL POPREAL8ARRAY(ac_o_shaded, r8/8)
        CALL POPREAL8ARRAY(lsif_o_shaded, r8/8)
        CALL POPREAL8ARRAY(lcos_o_shaded, r8/8)
        CALL PHOTOSYNTHESIS_BW(landcover, tc_o_shaded_old, &
&                        tc_o_shaded_old_bw, f_leaf, f_leaf_bw, p_kc25, &
&                        p_ko25, p_tau25, r_o_shaded, r_o_shaded_bw, &
&                        e_a10, g_o_b, g_o_b_bw, vcmax_shaded, &
&                        vcmax_shaded_bw, vj_slope, vj_slope_bw, &
&                        f_soilwater, f_soilwater_bw, b_h2o, m_h2o, &
&                        ci_o_shaded_old, temp_air, leleaf_o_shaded, &
&                        leleaf_o_shaded_bw, gs_o_shaded_new, &
&                        gs_o_shaded_new_bw, gs_h2o, ac_o_shaded, &
&                        ac_o_shaded_bw, ci_o_shaded_new, ffpa, ffpa_bw&
&                        , sif_alpha, sif_alpha_bw, sif_beta, &
&                        sif_beta_bw, lsif_o_shaded, lsif_o_shaded_bw, &
&                        cosi_o_shaded_old, cosi_o_shaded_old_bw, &
&                        cosi_o_shaded_new, cosi_o_shaded_new_bw, &
&                        lcos_o_shaded, lcos_o_shaded_bw)
        gw_o_sunlit = 1.0/(1.0/g_o_a+1.0/g_o_b+1.0/gs_o_sunlit_old)
        leleaf_o_sunlit = gw_o_sunlit*(vpd_air+slope*(tc_o_sunlit_old-&
&         temp_air))*rho_a*cp_ca/psychrometer
        CALL POPREAL8ARRAY(gs_o_sunlit_new, r8/8)
        CALL POPREAL8ARRAY(ac_o_sunlit, r8/8)
        CALL POPREAL8ARRAY(lsif_o_sunlit, r8/8)
        CALL POPREAL8ARRAY(lcos_o_sunlit, r8/8)
        CALL PHOTOSYNTHESIS_BW(landcover, tc_o_sunlit_old, &
&                        tc_o_sunlit_old_bw, f_leaf, f_leaf_bw, p_kc25, &
&                        p_ko25, p_tau25, r_o_sunlit, r_o_sunlit_bw, &
&                        e_a10, g_o_b, g_o_b_bw, vcmax_sunlit, &
&                        vcmax_sunlit_bw, vj_slope, vj_slope_bw, &
&                        f_soilwater, f_soilwater_bw, b_h2o, m_h2o, &
&                        ci_o_sunlit_old, temp_air, leleaf_o_sunlit, &
&                        leleaf_o_sunlit_bw, gs_o_sunlit_new, &
&                        gs_o_sunlit_new_bw, gs_h2o, ac_o_sunlit, &
&                        ac_o_sunlit_bw, ci_o_sunlit_new, ffpa, ffpa_bw&
&                        , sif_alpha, sif_alpha_bw, sif_beta, &
&                        sif_beta_bw, lsif_o_sunlit, lsif_o_sunlit_bw, &
&                        cosi_o_sunlit_old, cosi_o_sunlit_old_bw, &
&                        cosi_o_sunlit_new, cosi_o_sunlit_new_bw, &
&                        lcos_o_sunlit, lcos_o_sunlit_bw)
      END IF
      temp_bw0 = rho_a*cp_ca*leleaf_u_shaded_bw
      tc_u_shaded_old_bw = tc_u_shaded_old_bw + slope*gw_u_shaded*&
&       temp_bw0/psychrometer
      gw_u_shaded_bw = (vpd_air+slope*(tc_u_shaded_old-temp_air))*&
&       temp_bw0/psychrometer
      temp_bw0 = rho_a*cp_ca*leleaf_u_sunlit_bw
      tc_u_sunlit_old_bw = tc_u_sunlit_old_bw + slope*gw_u_sunlit*&
&       temp_bw0/psychrometer
      gw_u_sunlit_bw = (vpd_air+slope*(tc_u_sunlit_old-temp_air))*&
&       temp_bw0/psychrometer
      temp_bw0 = rho_a*cp_ca*leleaf_o_shaded_bw
      tc_o_shaded_old_bw = tc_o_shaded_old_bw + slope*gw_o_shaded*&
&       temp_bw0/psychrometer
      gw_o_shaded_bw = (vpd_air+slope*(tc_o_shaded_old-temp_air))*&
&       temp_bw0/psychrometer
      temp_bw0 = rho_a*cp_ca*leleaf_o_sunlit_bw
      tc_o_sunlit_old_bw = tc_o_sunlit_old_bw + slope*gw_o_sunlit*&
&       temp_bw0/psychrometer
      gw_o_sunlit_bw = (vpd_air+slope*(tc_o_sunlit_old-temp_air))*&
&       temp_bw0/psychrometer
      CALL POPREAL8ARRAY(gw_u_shaded, r8/8)
      temp0 = 1.0/g_u_a + 1.0/g_u_b + 1.0/gs_u_shaded_old
      temp_bw0 = -(gw_u_shaded_bw/temp0**2)
      g_u_a_bw = g_u_a_bw - temp_bw0/g_u_a**2
      g_u_b_bw = g_u_b_bw - temp_bw0/g_u_b**2
      gs_u_shaded_old_bw = -(temp_bw0/gs_u_shaded_old**2)
      CALL POPREAL8ARRAY(gw_u_sunlit, r8/8)
      temp0 = 1.0/g_u_a + 1.0/g_u_b + 1.0/gs_u_sunlit_old
      temp_bw0 = -(gw_u_sunlit_bw/temp0**2)
      g_u_a_bw = g_u_a_bw - temp_bw0/g_u_a**2
      g_u_b_bw = g_u_b_bw - temp_bw0/g_u_b**2
      gs_u_sunlit_old_bw = -(temp_bw0/gs_u_sunlit_old**2)
      CALL POPREAL8ARRAY(gw_o_shaded, r8/8)
      temp0 = 1.0/g_o_a + 1.0/g_o_b + 1.0/gs_o_shaded_old
      temp_bw0 = -(gw_o_shaded_bw/temp0**2)
      g_o_a_bw = g_o_a_bw - temp_bw0/g_o_a**2
      g_o_b_bw = g_o_b_bw - temp_bw0/g_o_b**2
      gs_o_shaded_old_bw = -(temp_bw0/gs_o_shaded_old**2)
      CALL POPREAL8ARRAY(gw_o_sunlit, r8/8)
      temp0 = 1.0/g_o_a + 1.0/g_o_b + 1.0/gs_o_sunlit_old
      temp_bw0 = -(gw_o_sunlit_bw/temp0**2)
      g_o_a_bw = g_o_a_bw - temp_bw0/g_o_a**2
      g_o_b_bw = g_o_b_bw - temp_bw0/g_o_b**2
      gs_o_sunlit_old_bw = -(temp_bw0/gs_o_sunlit_old**2)
      arg1 = lai_o + stem_o
      arg2 = lai_u + stem_u
      tco = (tc_o_sunlit_old*lai_o_sunlit+tc_o_shaded_old*lai_o_shaded)/&
&       (lai_o_sunlit+lai_o_shaded)
      CALL POPREAL8ARRAY(radiation_g, r8/8)
      CALL POPREAL8ARRAY(radiation_o_sun, r8/8)
      CALL POPREAL8ARRAY(radiation_o_shaded, r8/8)
      CALL POPREAL8ARRAY(radiation_u_sun, r8/8)
      CALL POPREAL8ARRAY(radiation_u_shaded, r8/8)
      CALL POPREAL8ARRAY(r_o_sunlit, r8/8)
      CALL POPREAL8ARRAY(r_o_shaded, r8/8)
      CALL POPREAL8ARRAY(r_u_sunlit, r8/8)
      CALL POPREAL8ARRAY(r_u_shaded, r8/8)
      CALL NETRADIATION_BW(meteo%s_dff, meteo%s_dir, coszs, tco, tco_bw&
&                    , tcu, tcu_bw, temp_grd, lai_o, lai_o_bw, lai_u, &
&                    lai_u_bw, arg1, arg1_bw, arg2, arg2_bw, &
&                    lai_o_sunlit, lai_o_shaded, lai_u_sunlit, &
&                    lai_u_shaded, clumping, temp_air, rh_air, &
&                    alpha_v_sw(kkk), alpha_v_sw_bw(kkk), alpha_n_sw(kkk&
&                    ), alpha_n_sw_bw(kkk), percentarea_snow_o, &
&                    percentarea_snow_o_bw, percentarea_snow_u, &
&                    percentarea_snow_u_bw, xg_snow(kkk), xg_snow_bw(kkk&
&                    ), alpha_v_o, alpha_n_o, alpha_v_u, alpha_n_u, &
&                    alpha_v_g, alpha_v_g_bw, alpha_n_g, alpha_n_g_bw, &
&                    radiation_o, radiation_u, radiation_g, &
&                    radiation_g_bw, radiation_o_sun, radiation_o_sun_bw&
&                    , radiation_o_shaded, radiation_o_shaded_bw, &
&                    radiation_u_sun, radiation_u_sun_bw, &
&                    radiation_u_shaded, radiation_u_shaded_bw, &
&                    r_o_sunlit, r_o_sunlit_bw, r_o_shaded, &
&                    r_o_shaded_bw, r_u_sunlit, r_u_sunlit_bw, &
&                    r_u_shaded, r_u_shaded_bw)
      lai_u_bw = lai_u_bw + arg2_bw
      lai_o_bw = lai_o_bw + arg1_bw
      CALL POPREAL8ARRAY(tcu, r8/8)
      temp_bw0 = tcu_bw/(lai_u_sunlit+lai_u_shaded)
      tc_u_sunlit_old_bw = tc_u_sunlit_old_bw + lai_u_sunlit*temp_bw0
      tc_u_shaded_old_bw = tc_u_shaded_old_bw + lai_u_shaded*temp_bw0
      temp_bw = -((tc_u_sunlit_old*lai_u_sunlit+tc_u_shaded_old*&
&       lai_u_shaded)*temp_bw0/(lai_u_sunlit+lai_u_shaded))
      lai_u_sunlit_bw = lai_u_sunlit_bw + tc_u_sunlit_old*temp_bw0 + &
&       temp_bw
      lai_u_shaded_bw = lai_u_shaded_bw + tc_u_shaded_old*temp_bw0 + &
&       temp_bw
      temp_bw = tco_bw/(lai_o_sunlit+lai_o_shaded)
      tc_o_sunlit_old_bw = tc_o_sunlit_old_bw + lai_o_sunlit*temp_bw
      tc_o_shaded_old_bw = tc_o_shaded_old_bw + lai_o_shaded*temp_bw
      temp_bw0 = -((tc_o_sunlit_old*lai_o_sunlit+tc_o_shaded_old*&
&       lai_o_shaded)*temp_bw/(lai_o_sunlit+lai_o_shaded))
      lai_o_sunlit_bw = lai_o_sunlit_bw + tc_o_sunlit_old*temp_bw + &
&       temp_bw0
      lai_o_shaded_bw = lai_o_shaded_bw + tc_o_shaded_old*temp_bw + &
&       temp_bw0
      CALL POPREAL8ARRAY(gww_u_shaded, r8/8)
      temp = 1.0/g_u_a + 1.0/g_u_b + 100.
      temp_bw = -(gww_u_shaded_bw/temp**2)
      g_u_a_bw = g_u_a_bw - temp_bw/g_u_a**2
      g_u_b_bw = g_u_b_bw - temp_bw/g_u_b**2
      CALL POPREAL8ARRAY(gww_u_sunlit, r8/8)
      temp = 1.0/g_u_a + 1.0/g_u_b + 100.
      temp_bw = -(gww_u_sunlit_bw/temp**2)
      g_u_a_bw = g_u_a_bw - temp_bw/g_u_a**2
      g_u_b_bw = g_u_b_bw - temp_bw/g_u_b**2
      CALL POPREAL8ARRAY(gww_o_shaded, r8/8)
      temp = 1.0/g_o_a + 1.0/g_o_b + 100.
      temp_bw = -(gww_o_shaded_bw/temp**2)
      g_o_a_bw = g_o_a_bw - temp_bw/g_o_a**2
      g_o_b_bw = g_o_b_bw - temp_bw/g_o_b**2
      CALL POPREAL8ARRAY(gww_o_sunlit, r8/8)
      temp = 1.0/g_o_a + 1.0/g_o_b + 100.
      temp_bw = -(gww_o_sunlit_bw/temp**2)
      g_o_a_bw = g_o_a_bw - temp_bw/g_o_a**2
      g_o_b_bw = g_o_b_bw - temp_bw/g_o_b**2
      CALL POPREAL8ARRAY(gh_u_shaded, r8/8)
      temp = 1.0/g_u_a + 0.5/g_u_b
      temp_bw = -(gh_u_shaded_bw/temp**2)
      g_u_a_bw = g_u_a_bw - temp_bw/g_u_a**2
      g_u_b_bw = g_u_b_bw - 0.5*temp_bw/g_u_b**2
      CALL POPREAL8ARRAY(gh_u_sunlit, r8/8)
      temp = 1.0/g_u_a + 0.5/g_u_b
      temp_bw = -(gh_u_sunlit_bw/temp**2)
      g_u_a_bw = g_u_a_bw - temp_bw/g_u_a**2
      g_u_b_bw = g_u_b_bw - 0.5*temp_bw/g_u_b**2
      CALL POPREAL8ARRAY(gh_o_shaded, r8/8)
      temp = 1.0/g_o_a + 0.5/g_o_b
      temp_bw = -(gh_o_shaded_bw/temp**2)
      g_o_a_bw = g_o_a_bw - temp_bw/g_o_a**2
      g_o_b_bw = g_o_b_bw - 0.5*temp_bw/g_o_b**2
      CALL POPREAL8ARRAY(gh_o_sunlit, r8/8)
      temp = 1.0/g_o_a + 0.5/g_o_b
      temp_bw = -(gh_o_sunlit_bw/temp**2)
      g_o_a_bw = g_o_a_bw - temp_bw/g_o_a**2
      g_o_b_bw = g_o_b_bw - 0.5*temp_bw/g_o_b**2
      arg1 = lai_o + stem_o
      CALL POPREAL8ARRAY(ra_g, r8/8)
      CALL POPREAL8ARRAY(g_o_a, r8/8)
      CALL POPREAL8ARRAY(g_o_b, r8/8)
      CALL POPREAL8ARRAY(g_u_a, r8/8)
      CALL POPREAL8ARRAY(g_u_b, r8/8)
      CALL AERODYNAMIC_CONDUCTANCE_BW(canopyh_o, canopyh_u, &
&                               height_wind_sp, clumping, temp_air, &
&                               wind_sp, gh_o, gh_o_bw, arg1, arg1_bw, &
&                               arg2, ra_o, ra_u, ra_g, ra_g_bw, g_o_a, &
&                               g_o_a_bw, g_o_b, g_o_b_bw, g_u_a, &
&                               g_u_a_bw, g_u_b, g_u_b_bw)
      lai_o_bw = lai_o_bw + arg1_bw
      lcos_u_shaded_bw = 0.0_8
      gh_o_sunlit_bw = 0.0_8
      lsif_o_sunlit_bw = 0.0_8
      gh_o_shaded_bw = 0.0_8
      lsif_o_shaded_bw = 0.0_8
      gww_o_sunlit_bw = 0.0_8
      lsif_u_sunlit_bw = 0.0_8
      gw_o_sunlit_bw = 0.0_8
      tc_o_shaded_new_bw = 0.0_8
      gww_o_shaded_bw = 0.0_8
      lsif_u_shaded_bw = 0.0_8
      gw_o_shaded_bw = 0.0_8
      tc_u_shaded_new_bw = 0.0_8
      ra_g_bw = 0.0_8
      gw_u_sunlit_bw = 0.0_8
      gww_u_sunlit_bw = 0.0_8
      tc_o_sunlit_new_bw = 0.0_8
      gw_u_shaded_bw = 0.0_8
      gww_u_shaded_bw = 0.0_8
      tcu_bw = 0.0_8
      lcos_o_sunlit_bw = 0.0_8
      tc_u_sunlit_new_bw = 0.0_8
      radiation_g_bw = 0.0_8
      lcos_o_shaded_bw = 0.0_8
      lcos_u_sunlit_bw = 0.0_8
 150 CONTINUE
    CALL POPREAL8ARRAY(percentarea_snow_u, r8/8)
    temp_bw = percentarea_snow_u_bw/(2.*lai_u)
    ac_snow_u_bw(kkk) = ac_snow_u_bw(kkk) + temp_bw
    lai_u_bw = lai_u_bw - ac_snow_u(kkk)*temp_bw/lai_u
    CALL POPREAL8ARRAY(percentarea_snow_o, r8/8)
    temp_bw = percentarea_snow_o_bw/(2.*lai_o)
    ac_snow_o_bw(kkk) = ac_snow_o_bw(kkk) + temp_bw
    lai_o_bw = lai_o_bw - ac_snow_o(kkk)*temp_bw/lai_o
    CALL POPREAL8ARRAY(slope, r8/8)
    CALL POPREAL8ARRAY(cp_ca, r8/8)
    CALL POPREAL8ARRAY(vpd_air, r8/8)
    CALL POPREAL8ARRAY(e_a10, r8/8)
    qhc_o_bw(kkk-1) = qhc_o_bw(kkk-1) + gh_o_bw
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) f_soilwater_bw = 0.0_8
    CALL POPREAL8ARRAY(f_soilwater, r8/8)
    soilp_bw%f_soilwater = f_soilwater_bw
    CALL POPREAL8ARRAY(soilp%psim, r8*10/8)
    CALL POPREAL8ARRAY(soilp%dt, r8*10/8)
    CALL SOIL_WATER_FACTOR_V2_BW(soilp, soilp_bw)
    CALL POPREAL8ARRAY(alpha_n_g, r8/8)
    alpha_g_bw = 4.*alpha_n_g_bw/3. + 2.*alpha_v_g_bw/3.
    CALL POPREAL8ARRAY(alpha_v_g, r8/8)
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) soilp_bw%thetam_prev(1) = soilp_bw%thetam_prev(1)&
&       + (alpha_sat-alpha_dry)*alpha_g_bw/(soilp%fei(1)-soilp%theta_vwp&
&       (1)*0.5)
    CALL POPREAL8ARRAY(wcl_o(kkk), r8/8)
    CALL POPREAL8ARRAY(wcl_u(kkk), r8/8)
    CALL RAINFALL_STAGE1_BW(temp_air, rainfall, wcl_o(kkk-1), wcl_o_bw(&
&                     kkk-1), wcl_u(kkk-1), wcl_u_bw(kkk-1), lai_o, &
&                     lai_o_bw, lai_u, lai_u_bw, clumping, wcl_o(kkk), &
&                     wcl_o_bw(kkk), wcl_u(kkk), wcl_u_bw(kkk), xcl_o(&
&                     kkk), xcl_o_bw(kkk), xcl_u(kkk), xcl_u_bw(kkk), &
&                     r_rain_g(kkk), r_rain_g_bw(kkk))
    wcl_o_bw(kkk) = 0.0_8
    wcl_u_bw(kkk) = 0.0_8
    xcl_o_bw(kkk) = 0.0_8
    xcl_u_bw(kkk) = 0.0_8
    r_rain_g_bw(kkk) = 0.0_8
    CALL POPREAL8ARRAY(wcs_o(kkk), r8/8)
    CALL POPREAL8ARRAY(wcs_u(kkk), r8/8)
    CALL POPREAL8ARRAY(wg_snow(kkk), r8/8)
    CALL POPREAL8ARRAY(ac_snow_o(kkk), r8/8)
    CALL POPREAL8ARRAY(ac_snow_u(kkk), r8/8)
    CALL POPREAL8ARRAY(rho_snow(kkk), r8/8)
    CALL POPREAL8ARRAY(zsp, r8/8)
    CALL SNOWPACK_STAGE1_BW(temp_air, snow, wcs_o(kkk-1), wcs_o_bw(kkk-1&
&                     ), wcs_u(kkk-1), wcs_u_bw(kkk-1), wg_snow(kkk-1), &
&                     wg_snow_bw(kkk-1), rho_snow(kkk-1), rho_snow_bw(&
&                     kkk-1), ac_snow_o(kkk-1), ac_snow_o_bw(kkk-1), &
&                     ac_snow_u(kkk-1), ac_snow_u_bw(kkk-1), wcs_o(kkk)&
&                     , wcs_o_bw(kkk), wcs_u(kkk), wcs_u_bw(kkk), &
&                     wg_snow(kkk), wg_snow_bw(kkk), lai_o, lai_o_bw, &
&                     lai_u, lai_u_bw, clumping, ac_snow_o(kkk), &
&                     ac_snow_o_bw(kkk), ac_snow_u(kkk), ac_snow_u_bw(&
&                     kkk), xcs_o(kkk), xcs_o_bw(kkk), xcs_u(kkk), &
&                     xcs_u_bw(kkk), xg_snow(kkk), xg_snow_bw(kkk), &
&                     rho_snow(kkk), rho_snow_bw(kkk), zsp, zsp_bw, &
&                     alpha_v_sw(kkk), alpha_v_sw_bw(kkk), alpha_n_sw(&
&                     kkk), alpha_n_sw_bw(kkk))
    wcs_o_bw(kkk) = 0.0_8
    wcs_u_bw(kkk) = 0.0_8
    wg_snow_bw(kkk) = 0.0_8
    ac_snow_o_bw(kkk) = 0.0_8
    ac_snow_u_bw(kkk) = 0.0_8
    xcs_o_bw(kkk) = 0.0_8
    xcs_u_bw(kkk) = 0.0_8
    xg_snow_bw(kkk) = 0.0_8
    rho_snow_bw(kkk) = 0.0_8
    soilp_bw%zp = 0.0_8
    soilp_bw%zsp = 0.0_8
    soilp_bw%r_rain_g = 0.0_8
    sif_o_shaded_bw = 0.0_8
    sif_u_sunlit_bw = 0.0_8
    sif_u_shaded_bw = 0.0_8
    cos_o_sunlit_bw = 0.0_8
    cos_o_shaded_bw = 0.0_8
    cos_u_sunlit_bw = 0.0_8
    cos_u_shaded_bw = 0.0_8
    sif_o_sunlit_bw = 0.0_8
  END DO
  CALL POPREAL8ARRAY(lai_o, r8/8)
  CALL VCMAX_JMAX_BW(lai_o, lai_o_bw, clumping, vcmax0, vcmax0_bw, &
&              vj_slope, slope_vcmax_n, leaf_n, coszs, vcmax_sunlit, &
&              vcmax_sunlit_bw, vcmax_shaded, vcmax_shaded_bw, &
&              jmax_sunlit, jmax_shaded)
  DO i=32,27,-1
    var_o_bw(i) = var_o_bw(i) + soilp_bw%ice_ratio(i-27)
    soilp_bw%ice_ratio(i-27) = 0.0_8
  END DO
  DO i=26,21,-1
    var_o_bw(i) = var_o_bw(i) + soilp_bw%thetam_prev(i-21)
    soilp_bw%thetam_prev(i-21) = 0.0_8
  END DO
  DO i=14,9,-1
    var_o_bw(i) = var_o_bw(i) + soilp_bw%temp_soil_p(i-9)
    soilp_bw%temp_soil_p(i-9) = 0.0_8
  END DO
  CALL POPCONTROL1B(branch)
  IF (branch .NE. 0) zp_bw = 0.0_8
  soilp_bw%zp = soilp_bw%zp + zp_bw
  soilp_bw%zsp = soilp_bw%zsp + zsp_bw
  var_o_bw(40) = var_o_bw(40) + SUM(alpha_n_sw_bw(0:iter_max))
  var_o_bw(39) = var_o_bw(39) + SUM(alpha_v_sw_bw(0:iter_max))
  var_o_bw(38) = var_o_bw(38) + SUM(rho_snow_bw(0:iter_max))
  var_o_bw(37) = var_o_bw(37) + SUM(ac_snow_u_bw(0:iter_max))
  var_o_bw(36) = var_o_bw(36) + SUM(ac_snow_o_bw(0:iter_max))
  var_o_bw(35) = var_o_bw(35) + soilp_bw%r_rain_g
  var_o_bw(34) = var_o_bw(34) + soilp_bw%zp
  var_o_bw(33) = var_o_bw(33) + soilp_bw%zsp
  var_o_bw(20) = var_o_bw(20) + wg_snow_bw(0)
  var_o_bw(19) = var_o_bw(19) + wcs_u_bw(0)
  var_o_bw(18) = var_o_bw(18) + wcl_u_bw(0)
  var_o_bw(16) = var_o_bw(16) + wcs_o_bw(0)
  var_o_bw(15) = var_o_bw(15) + wcl_o_bw(0)
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) tsn2_bw(0) = 0.0_8
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) tsn2_bw(0) = 0.0_8
  var_o_bw(7) = var_o_bw(7) + tsn2_bw(0)
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) tsn1_bw(0) = 0.0_8
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) tsn1_bw(0) = 0.0_8
  var_o_bw(6) = var_o_bw(6) + tsn1_bw(0)
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) tsm0_bw(0) = 0.0_8
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) tsm0_bw(0) = 0.0_8
  var_o_bw(5) = var_o_bw(5) + tsm0_bw(0)
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) tsn0_bw(0) = 0.0_8
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) tsn0_bw(0) = 0.0_8
  var_o_bw(4) = var_o_bw(4) + tsn0_bw(0)
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) ts0_bw(0) = 0.0_8
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) ts0_bw(0) = 0.0_8
  var_o_bw(3) = var_o_bw(3) + ts0_bw(0)
  var_o_bw(1) = var_o_bw(1) + qhc_o_bw(0)
  CALL LAI_CAL_BW(stem_o, stem_u, landcover, coszs, lai_o, lai_o_bw, &
&           clumping, lai_u, lai_u_bw, laio_sunlit, laio_sunlit_bw, &
&           laio_shaded, laio_shaded_bw, laiu_sunlit, laiu_sunlit_bw, &
&           laiu_shaded, laiu_shaded_bw, lai_o_sunlit, lai_o_sunlit_bw, &
&           lai_o_shaded, lai_o_shaded_bw, lai_u_sunlit, lai_u_sunlit_bw&
&           , lai_u_shaded, lai_u_shaded_bw)
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) lai_u_bw = 0.0_8
  CALL POPCONTROL1B(branch)
  IF (branch .NE. 0) lai_o_bw = lai_o_bw - 0.99*EXP(-(0.99*lai_o))*1.18*&
&     lai_u_bw
  CALL POPCONTROL1B(branch)
  IF (branch .NE. 0) ffpa_bw = 0.0_8
  CALL POPCONTROL1B(branch)
  IF (branch .NE. 0) ffpa_bw = 0.0_8
  lai_bw = 0.45*EXP(-(0.45*lai))*ffpa_bw
  CALL POPCONTROL1B(branch)
  IF (branch .NE. 0) lai_o_bw = 0.0_8
  lai_bw = lai_bw + lai_o_bw
END SUBROUTINE INTER_PRG_BW

!  Differentiation of aerodynamic_conductance in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: g_o_a g_o_b ra_g g_u_a g_u_b
!   with respect to varying inputs: sh_o_p lai_o
!! calculate aerodynamic resistance/conductance
!! Written by: J. Liu, and W. Ju, Modified by G. MO
!! Last update : May 2015
SUBROUTINE AERODYNAMIC_CONDUCTANCE_BW(canopy_height_o, canopy_height_u, &
& zz, clumping, temp_air, wind_sp, sh_o_p, sh_o_p_bw, lai_o, lai_o_bw, &
& lai_u, rm, ra_u, ra_g, ra_g_bw, g_o_a, g_o_a_bw, g_o_b, g_o_b_bw, &
& g_u_a, g_u_a_bw, g_u_b, g_u_b_bw)
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  IMPLICIT NONE
  REAL(r8), INTENT(IN) :: canopy_height_o, canopy_height_u, zz, clumping&
& , temp_air, wind_sp
  REAL(r8), INTENT(IN) :: sh_o_p, lai_o, lai_u
  REAL(r8) :: sh_o_p_bw, lai_o_bw
  REAL(r8) :: rm, ra_u, ra_g, g_o_a, g_o_b, g_u_a, g_u_b
  REAL(r8) :: ra_g_bw, g_o_a_bw, g_o_b_bw, g_u_a_bw, g_u_b_bw
  REAL(r8) :: kh_o
  REAL(r8) :: kh_o_bw
!leaf characteristic width  = 0.3 for BS
  REAL(r8), SAVE :: lw=0.3
!shelter factor = 5 for BS
  REAL(r8), SAVE :: sigma=5
  REAL(r8) :: rb_o, rb_u
  REAL(r8) :: rb_o_bw, rb_u_bw
! von Karman's constant
  REAL(r8), SAVE :: k=0.4
! Bowen's ratio
  REAL(r8), SAVE :: beta=0.5
!specific heat of air  J/kg/K
  REAL(r8), SAVE :: cp=1010
  REAL(r8), SAVE :: density_air=1.225
  REAL(r8), SAVE :: gg=9.8
  REAL(r8), SAVE :: n=5.0
! viscosity (cm2/s)
  REAL(r8) :: nu_lower
  REAL(r8) :: uf, psi
  REAL(r8) :: psi_bw
!displacement height (m)
  REAL(r8) :: d
!roughness length    (m)
  REAL(r8) :: z0
!friction velocity (m/s)
  REAL(r8) :: ustar
  REAL(r8) :: l, le
  REAL(r8) :: l_bw, le_bw
!wind speed at height h
  REAL(r8) :: uh
!wind speed at height d
  REAL(r8) :: ud
  REAL(r8) :: ud_bw
! wind speed at height 50 m, @mousong.wu, to correct the calculation of ustar 
  REAL(r8) :: u_50
! from 2 m wind speed but the canopy height is around 30 m,which leads to negative value in log function.
  REAL(r8) :: gamma1, re, nu, alfac, alfaw, ram, un_d, un_t, kh_u, z_50
  REAL(r8) :: gamma1_bw, re_bw, nu_bw, ram_bw, un_d_bw
  INTRINSIC LOG
  INTRINSIC MAX
  INTRINSIC MIN
  INTRINSIC EXP
  REAL(r8) :: ra_u_bw
  REAL(r8) :: temp
  REAL(r8) :: temp_bw
  REAL(r8) :: temp0
  REAL(r8) :: temp_bw0
  INTEGER*4 :: branch
  nu_lower = (13.3+temp_air*0.07)/1000000.
! for CO2
  alfaw = (18.9+temp_air*0.07)/1000000.
! for calculation of windspeed at 50 m height
  z_50 = 50.
  IF (wind_sp .EQ. 0.) THEN
    sh_o_p_bw = 0.0_8
    lai_o_bw = 0.0_8
  ELSE
    d = 0.8*canopy_height_o
    z0 = 0.08*canopy_height_o
    u_50 = wind_sp*LOG((z_50-zz)/z0)
    ustar = u_50*k/LOG((z_50-d)/z0)
    l = -(k*gg*sh_o_p/(density_air*cp*(temp_air+273.3)*ustar**3))
    IF (-2. .LT. l) THEN
      CALL PUSHCONTROL1B(0)
      l = l
    ELSE
      l = -2.
      CALL PUSHCONTROL1B(1)
    END IF
    ram = 1./(k*ustar)*(LOG((z_50-d)/z0)+n*(z_50-d)*l)
    IF (2. .LT. ram) THEN
      CALL PUSHCONTROL1B(0)
      ram = ram
    ELSE
      ram = 2.
      CALL PUSHCONTROL1B(1)
    END IF
    IF (100. .GT. ram) THEN
      CALL PUSHCONTROL1B(0)
      ram = ram
    ELSE
      ram = 100.
      CALL PUSHCONTROL1B(1)
    END IF
    IF (l .GT. 0.) THEN
      psi = 1. + 5.*(z_50-d)*l
      CALL PUSHCONTROL1B(1)
    ELSE
      psi = (1.-16.*(z_50-d)*l)**(-0.5)
      CALL PUSHCONTROL1B(0)
    END IF
    IF (10.0 .GT. psi) THEN
      CALL PUSHCONTROL1B(0)
      psi = psi
    ELSE
      psi = 10.0
      CALL PUSHCONTROL1B(1)
    END IF
!! Leaf boundary layer resistance
!! wind speed at tree top
    uh = 1.1*ustar/k
    le = lai_o*clumping
    gamma1 = (0.167+0.179*uh)*le**(1./3.)
!! wind speed at d ,taking as the mean wind speed inside a stand
    ud = uh*EXP(-(gamma1*(1.-d/canopy_height_o)))
!! Reynold's number
    re = ud*0.1/nu_lower
!!Nusselt number
    nu = 1.0*re**0.5
    IF (40. .GT. 0.5*0.1/(alfaw*nu)) THEN
      rb_o = 0.5*0.1/(alfaw*nu)
      CALL PUSHCONTROL1B(0)
    ELSE
      rb_o = 40.
      CALL PUSHCONTROL1B(1)
    END IF
    kh_o = 0.41*ustar*(canopy_height_o-canopy_height_o*0.8)/psi
    gamma1 = 0.1 + lai_o**0.75
!!wind speed at the zero displancement of canopy
    un_d = uh*EXP(-(gamma1*(1.-canopy_height_u*0.8/canopy_height_o)))
    re = un_d*0.1/nu_lower
    nu = 1.0*re**0.5
    rb_u = 0.5*0.1/(alfaw*nu)
    IF (40. .GT. rb_u) THEN
      CALL PUSHCONTROL1B(0)
      rb_u = rb_u
    ELSE
      rb_u = 40.
      CALL PUSHCONTROL1B(1)
    END IF
    ra_u = canopy_height_o/(gamma1*kh_o)*(EXP(gamma1*(1.-canopy_height_u&
&     /canopy_height_o))-1.)
    gamma1 = 4.0
    CALL PUSHREAL8ARRAY(ra_g, r8/8)
    ra_g = canopy_height_o/(gamma1*kh_o)*(EXP(gamma1*(1.-canopy_height_o&
&     ))-EXP(gamma1*(1.-canopy_height_u/canopy_height_o)))
    ra_g = ra_g + ra_u + ram
    IF (120. .GE. ra_g) ra_g_bw = 0.0_8
    temp_bw0 = -(g_u_a_bw/(ram+ra_u)**2)
    ra_u_bw = ra_g_bw + temp_bw0
    ram_bw = ra_g_bw + temp_bw0
    CALL POPREAL8ARRAY(ra_g, r8/8)
    kh_o_bw = -(canopy_height_o*(EXP(gamma1*(1.-canopy_height_o))-EXP(&
&     gamma1*(1.-canopy_height_u/canopy_height_o)))*ra_g_bw/(kh_o**2*&
&     gamma1))
    gamma1 = 0.1 + lai_o**0.75
    temp0 = -(canopy_height_u/canopy_height_o) + 1.
    temp_bw = canopy_height_o*ra_u_bw/(gamma1*kh_o)
    temp_bw0 = -((EXP(temp0*gamma1)-1.)*temp_bw/(gamma1*kh_o))
    gamma1_bw = temp0*EXP(temp0*gamma1)*temp_bw + kh_o*temp_bw0
    kh_o_bw = kh_o_bw + gamma1*temp_bw0
    rb_u_bw = -(g_u_b_bw/rb_u**2)
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) rb_u_bw = 0.0_8
    nu_bw = -(0.1*0.5*rb_u_bw/(nu**2*alfaw))
    re_bw = 0.5*re**(-0.5)*nu_bw
    un_d_bw = 0.1*re_bw/nu_lower
    temp = -(0.8*canopy_height_u/canopy_height_o) + 1.
    gamma1_bw = gamma1_bw - temp*EXP(-(temp*gamma1))*uh*un_d_bw
    lai_o_bw = 0.75*lai_o**(-0.25)*gamma1_bw
    psi_bw = -(ustar*0.41*(canopy_height_o-canopy_height_o*0.8)*kh_o_bw/&
&     psi**2)
    rb_o_bw = -(g_o_b_bw/rb_o**2)
    ram_bw = ram_bw - g_o_a_bw/ram**2
    re = ud*0.1/nu_lower
    nu = 1.0*re**0.5
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      nu_bw = -(0.1*0.5*rb_o_bw/(nu**2*alfaw))
    ELSE
      nu_bw = 0.0_8
    END IF
    re_bw = 0.5*re**(-0.5)*nu_bw
    ud_bw = 0.1*re_bw/nu_lower
    gamma1 = (0.167+0.179*uh)*le**(1./3.)
    temp = -(d/canopy_height_o) + 1.
    gamma1_bw = -(temp*EXP(-(temp*gamma1))*uh*ud_bw)
    IF (le .LE. 0.0_8 .AND. (1.0/3. .EQ. 0.0_8 .OR. 1.0/3. .NE. INT(1.0/&
&       3.))) THEN
      le_bw = 0.0_8
    ELSE
      le_bw = le**(1.0/3.-1)*(uh*0.179+0.167)*gamma1_bw/3.
    END IF
    lai_o_bw = lai_o_bw + clumping*le_bw
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) psi_bw = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      l_bw = 16.*(z_50-d)*0.5*(1.-(z_50-d)*(16.*l))**(-1.5)*psi_bw
    ELSE
      l_bw = 5.*(z_50-d)*psi_bw
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) ram_bw = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) ram_bw = 0.0_8
    l_bw = l_bw + n*(z_50-d)*ram_bw/(k*ustar)
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) l_bw = 0.0_8
    sh_o_p_bw = -(k*gg*l_bw/(density_air*cp*(temp_air+273.3)*ustar**3))
  END IF
END SUBROUTINE AERODYNAMIC_CONDUCTANCE_BW

!  Differentiation of cos_grnd in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: cos_soil soilp.thetam soilp.temp_soil_c
!   with respect to varying inputs: soilp.thetam soilp.temp_soil_c
SUBROUTINE COS_GRND_BW(soilp, soilp_bw, cos_soil, cos_soil_bw)
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE BEPS_SOILMOD_DIFF
  IMPLICIT NONE
!Input Variables
  TYPE(SOIL), INTENT(IN) :: soilp
  TYPE(SOIL_DIFF) :: soilp_bw
!Local Variables
! local ground COS flux (pmol/m2/sec)
  REAL(r8) :: cos_soil
  REAL(r8) :: cos_soil_bw
  REAL(r8) :: f_opt, s_opt, f_g, s_g, a
  REAL(r8) :: f_opt_bw, s_opt_bw, f_g_bw, a_bw
  REAL(r8), PARAMETER :: k_cos_soil=1.2e-4
!Misc Variables
  INTEGER :: j
  REAL(r8) :: soil_t, soil_s, dsoil, soil_ice
  REAL(r8) :: soil_t_bw, soil_s_bw
  REAL(r8) :: cos_soil_abiotic, cos_soil_biotic
  REAL(r8) :: cos_soil_abiotic_bw, cos_soil_biotic_bw
  INTRINSIC LOG, DBLE, EXP
  REAL(r8) :: temp
  REAL(r8) :: temp0
  REAL(r8) :: temp_bw
  REAL(r8) :: temp_bw0
  REAL(r8) :: temp1
  REAL(r8) :: temp2
  REAL(r8) :: temp_bw1
  REAL(r8) :: temp_bw2
  soil_t = 0.
  soil_s = 0.
  dsoil = 0.
!...ground uptake of COS, calculated from Whelan et al., 2016, ACP. calculate the abiotic and biotic part of ground uptake separa
!tely.
  DO j=1,3
    soil_t = soil_t + soilp%temp_soil_c(j-1)*soilp%d_soil(j-1)
    soil_s = soil_s + soilp%thetam(j-1)*soilp%d_soil(j-1)
    dsoil = dsoil + soilp%d_soil(j-1)
  END DO
  soil_t = soil_t/dsoil
  f_opt = -(0.00986*soil_t*soil_t) + 0.197*soil_t - 9.32
  s_opt = 0.28*soil_t + 14.5
  f_g = -(0.0119*soil_t*soil_t) + 0.110*soil_t - 1.18
  s_g = 35.0
  a = LOG(f_opt/f_g)*(LOG(s_opt/s_g)+(s_g/s_opt-1.))**(-1)
  cos_soil_abiotic_bw = cos_soil_bw
  cos_soil_biotic_bw = cos_soil_bw
  temp0 = soil_s/s_opt
  temp1 = soil_s/s_opt
  temp2 = temp1**a
  temp_bw0 = EXP(-(a*(temp0-1.)))*cos_soil_biotic_bw
  temp_bw2 = EXP(-(a*(temp0-1.)))*f_opt*temp2*cos_soil_biotic_bw
  IF (temp1 .LE. 0.0_8) THEN
    a_bw = -((temp0-1.)*temp_bw2)
  ELSE
    a_bw = temp2*LOG(temp1)*f_opt*temp_bw0 - (temp0-1.)*temp_bw2
  END IF
  temp_bw = -(a*temp_bw2/s_opt)
  s_opt_bw = -(temp0*temp_bw)
  IF (temp1 .LE. 0.0_8 .AND. (a .EQ. 0.0_8 .OR. a .NE. INT(a))) THEN
    temp_bw1 = 0.0_8
  ELSE
    temp_bw1 = a*temp1**(a-1)*f_opt*temp_bw0/s_opt
  END IF
  soil_s_bw = temp_bw + temp_bw1
  temp = LOG(s_opt/s_g) + s_g/s_opt - 1.
  temp0 = f_opt/f_g
  temp_bw = a_bw/(f_g*temp0*temp)
  f_opt_bw = temp2*temp_bw0 + temp_bw
  temp_bw0 = -(LOG(temp0)*a_bw/temp**2)
  s_opt_bw = s_opt_bw + (1.0/s_opt-s_g/s_opt**2)*temp_bw0 - temp1*&
&   temp_bw1
  f_g_bw = -(temp0*temp_bw)
  soil_t_bw = (0.110-2*soil_t*0.0119)*f_g_bw + 0.28*s_opt_bw + (0.197-2*&
&   soil_t*0.00986)*f_opt_bw + 0.0984*EXP(0.0984*soil_t)*0.437*&
&   cos_soil_abiotic_bw
  soil_t_bw = soil_t_bw/dsoil
  DO j=3,1,-1
    soilp_bw%thetam(j-1) = soilp_bw%thetam(j-1) + soilp%d_soil(j-1)*&
&     soil_s_bw
    soilp_bw%temp_soil_c(j-1) = soilp_bw%temp_soil_c(j-1) + soilp%d_soil&
&     (j-1)*soil_t_bw
  END DO
END SUBROUTINE COS_GRND_BW

!  Differentiation of beps_phenology in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: lai
!   with respect to varying inputs: trans
SUBROUTINE BEPS_PHENOLOGY_BW(lc, daylen, dt, theta, trans, trans_bw, lai&
& , lai_bw)
!***********************************************************
!* WOK, 2008-07-30
!* IMPLIFIED PHENOLOGY MODEL
!* simplified phenology model
!***********************************************************
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE MO_HELPER_DIFF, ONLY : errf, mins, maxs, minx, maxx, maxx_bw0, &
& fominef_ss, fominef_ss_bw0, fomaxef_ss
  IMPLICIT NONE
!  REAL, ALLOCATABLE, DIMENSION (:,:,:) :: mlai ! monthly LAI fields from external data
  INTEGER, INTENT(IN) :: lc
  REAL, INTENT(IN) :: daylen
  REAL, INTENT(IN) :: dt
  REAL, INTENT(IN) :: theta
  REAL, INTENT(IN) :: trans
  REAL :: trans_bw
  REAL, INTENT(INOUT) :: lai
  REAL, INTENT(INOUT) :: lai_bw
! air-temperature memory [deg C]
  REAL :: tmpm
! water limited LAI memory
  REAL :: laim
  REAL :: laim_bw
! highest recorded LAI (with a decay rate, for setting 'zfc')
  REAL :: laihi
! WOK-ADD-070723 litter production to be calculated directly in phenology (not in cbalance indirectly)
! auxiliary fields
  REAL :: tmpmmult, laimmult
! output field
  REAL :: leafshed
  REAL :: laihimult
! memory time for updating fractional cover
  REAL, PARAMETER :: taulaihi=5.0
!  REAL, PARAMETER :: laimin = 1e-6            ! minimum LAI for pot. transpiration per LAI estimates
! curvature parameter for mins/maxs
  REAL, PARAMETER :: eta=0.99999
! WOK-ADD-070723 the list of controlling parameters
! FREE PARAMETERS
! maximum LAI
  REAL :: plaimax(10)
! rootdepth
  REAL :: rootdepth(10)
! leaf onset temperature [deg C]
  REAL :: ptphen(10)
! range of leaf onset temperature [1/deg C]
  REAL :: ptphenr(10)
! leaf shedding daylength [hours]
  REAL :: pdphen
! range of leaf shedding daylength [hours]
  REAL :: pdphenr
!  REAL, ALLOCATABLE, DIMENSION (:) :: PTSHD   ! leaf shedding temperature [deg C]
!  REAL, ALLOCATABLE, DIMENSION (:) :: PTSHDS  ! spread of leaf shedding temperature [1/deg C]
! leaf growth factor [1/days]
  REAL :: plgr
! inverse leaf longevity from start of senescense [1/days]
  REAL :: pkl(10)
! target survival time at current soil moisture [days]
  REAL :: ptauw(10)
! PARAMETERS LEFT FIXED
! inverse memory time for soil moisture-limited LAI [1/days]
  REAL :: pks
! inverse memory time for air temperature [1/days]
  REAL :: pkm
  REAL :: pasm
  REAL :: zfc, zlai
  REAL :: fcmax0, lailim0, cdrm
  REAL :: xdtmp, lait, laiw, fx, t0, ts, ft, fd, fg
  REAL :: lailast
  REAL :: laimaxw, laimax, r, lailim, wai
  REAL :: laimax_bw, lailim_bw
  REAL :: dptrp
  REAL :: dptrp_bw
  INTEGER :: plt
! WOK-090309 'ph' is now only used in nscale
! xph     1: warm-evergreen; 2: cold-evergreen; 3: summergreen; 4: raingreen; 5: grass; 6: annual crop;
! INTEGER, DIMENSION (0:13), PARAMETER :: xph= &
!PFT:0  1  2  3  4  5  6  7  8  9 10 11 12 13
!  (/5, 1, 4, 1, 3, 2, 3, 1, 4, 5, 5, 2, 5, 6/)
  REAL :: sla(10)
  INTRINSIC EXP
  REAL :: result1
  REAL :: result1_bw
  REAL :: arg1
  REAL :: arg1_bw
  REAL :: arg2
  REAL :: temp_bw
  INTEGER*4 :: branch
  SELECT CASE  (lc) 
  CASE (1) 
!conifer evergreen
    plt = 1
  CASE (2) 
!conifer decidous
    plt = 2
  CASE (6) 
!broadleaf decidous
    plt = 3
  CASE (9) 
!broadleaf evergreen
    plt = 4
  CASE (10) 
!mix
    plt = 5
  CASE (13) 
!shrub
    plt = 6
  CASE (14) 
! grass
    plt = 7
  CASE (15) 
! crop
    plt = 8
  CASE (40) 
! C4 grass
    plt = 9
  CASE (41) 
! C4 crop
    plt = 10
  END SELECT
!sla(0:13)=(/0., 9.9, 14.1, 5.7, 11.5, 4.1, 11.3, 6.9, &
!		& 11.5, 16.9, 16.9, 6.9, 16.9, 25.3/)
  ptphen = (/10.0, 10.0, 5.0, 0., 5., 4.0, 2.0, 15.0, 2.0, 2.0/)
!  ptphen(0:13)=(/0.,0.,0., 0., 10.0, 10.0, 10.0, 0., 8.0, &
!       & 2.0, 2.0, 2.0, 2.0, 15.0/)
  ptphenr = (/2.0, 2.0, 2., 2., 2., 2.0, 2., 2., 2., 2./)
!  ptphenr(0:13)=(/0.,0., 0., 0., 2.0, 2.0, 2.0, 0., 2.0, &
!        & 2.0, 2.0, 2.0, 2.0, 2.0/)
  pdphen = 10.5
  pdphenr = 0.5
  plgr = 0.5
  pkl = (/0.1, 0., 5.e-3, 0.1, 0.1, 0.1, 5.e-3, 0.1, 5.e-3, 5.e-3/)
! pkl(0:13) = (/0.,0.1, 0., 0.1, 5.e-3, 0.1, 0., 0.1, &
!       & 0.1, 0.1, 5.e-3, 0.1, 0.1, 0.1/)
  ptauw = (/30., 30., 30., 30., 30., 30., 30., 30., 30., 30./)
!  ptauw(1:13) = (/0., 30., 30., 30., 30., 30., 30., &
!        & 30., 30., 30., 30., 30., 30./)
!  LIST OF PFTs in BETHY:
!  1:  tropical broadleaf evergreen tree
!  2:  tropical broadleaf deciduous tree
!  3:  temperate broadleaf evergreen tree
!  4:  temperate broadleaf deciduous tree
!  5:  evergreen coniferous tree
!  6:  deciduous coniferous tree
!  7:  evergreen shrub
!  8:  deciduous shrub
!  9:  C3 grass
! 10:  C4 grass
! 11:  tundra
! 12:  swamp
! 13:  arable crop
  rootdepth = (/0.6, 0.6, 0.8, 0.8, 0.7, 0.5, 0.3, 0.3, 0.3, 0.3/)
  plaimax = (/4.5, 4.5, 4.5, 4.5, 4.5, 3.3, 3.0, 4.5, 3.0, 3.0/)
  pkm = 1./30.
  pks = 1./30.
!   multiplier for advancing temperature memory by one day
  tmpmmult = EXP(-pkm)
!   multiplier for advancing soil-water limited LAI memory by one day
  laimmult = EXP(-pks)
!   decay multiplier for evergreen LAI
!    laimult = exp (-pkl)
!   the air-temperature memory
  tmpm = 0.
!   the water stress index memory
  laim = 0.
  lai = plaimax(plt)
!   decay multiplier for maximum LAI used to set fractional cover
!   control for fractional cover 'zfc'
!   output field
!   spin-up of temperature memory
  tmpm = dt*(1.-tmpmmult) + tmpm*tmpmmult
!   calculate plant available soil moisture and daily potential transpiration, @MOUSONG.WU, 201905
! convert from m3/m3 to mm
  pasm = theta*rootdepth(plt)*1000.
! convert from m/s to mm
  dptrp = trans*86400.*1000.
  lailast = lai
!------------------------------------------------------------------
! advances LAI and fractional cover by one day
! from its current state to the state at day 'iday'
!------------------------------------------------------------------
  DO plt=1,9
!      IF (ph(k)==1.or.ph(k)==4) THEN ! warm-evergreen and warm-deciduous phenology
    IF (((plt .EQ. 3 .OR. plt .EQ. 4) .OR. plt .EQ. 5) .OR. plt .EQ. 6) &
&   THEN
! warm-evergreen and warm-deciduous phenology
! effective maximum LAI, taking into account structural limiations
!        laimax = plaimax(k) * (1. - exp(-laimaxw/plaimax(k)))
!   initialize LAI
      result1 = MAXX(dptrp, 1.e-3, 2.e-2)
      laimax = pasm*lailast/ptauw(plt)/result1
!        laimax = mins (laimax, plaimax(k), 0.9)
!snb, test
      CALL PUSHREAL8(result1)
      result1 = FOMINEF_SS(laimax, plaimax(plt), 2.e-1)
      CALL PUSHREAL8(laimax)
      laimax = result1 + 1.e-1
! update water limited LAI memory
      laim = laimax*(1.-laimmult) + laim*laimmult
! rate of change of LAI towards limit
      CALL PUSHREAL8(r)
      r = plgr
! limit LAI
! update LAI
!        lai(k) = lailim - (lailim - lai(k)) * exp (-r)
!      ELSE IF (ph(k)==2.or.ph(k)==3) THEN ! cold-evergreen and cold-deciduous phenology
      CALL PUSHCONTROL2B(0)
    ELSE IF (plt .EQ. 1 .OR. plt .EQ. 2) THEN
! cold-evergreen and cold-deciduous phenology
! update memory of daily mean temperature
      tmpm = dt*(1.-tmpmmult) + tmpm*tmpmmult
! fraction of vegetation above temperature threshold
      CALL PUSHREAL8(arg1)
      arg1 = (tmpm-ptphen(plt))/ptphenr(plt)
      CALL PUSHREAL8(ft)
      ft = ERRF(arg1)
! fraction of vegetation above daylength threshold
      arg1 = (daylen-pdphen)/pdphenr
      fd = ERRF(arg1)
      CALL PUSHREAL8(r)
      r = ft*fd*plgr + (1.-ft*fd)*pkl(plt) + 1.e-9
!        lai(k) = plaimax(k) - (plaimax(k) - lai(k)) * exp (-r)
!        lai(k) = lailim - (lailim - lai(k)) * exp (-r)
      CALL PUSHCONTROL2B(1)
    ELSE
! grass and annual crop phenology
      tmpm = dt*(1.-tmpmmult) + tmpm*tmpmmult
      CALL PUSHREAL8(arg1)
      arg1 = (tmpm-ptphen(plt))/ptphenr(plt)
      CALL PUSHREAL8(ft)
      ft = ERRF(arg1)
      result1 = MAXX(dptrp, 1.e-3, 2.e-2)
      laimax = pasm*lailast/ptauw(plt)/result1
!        laimax = mins (laimax, plaimax(k), 0.9)
!        if(pft(k)==9) print '(a,8g30.14)','PFT9-a: iday,tmpm(k),ft,laimax,pasm(k),zlai(k),dptrp(k),lai(k)',iday,tmpm(k),ft,laima
!x,pasm(k),zlai(k),dptrp(k),lai(k)
!snb, test
      CALL PUSHREAL8(result1)
      result1 = FOMINEF_SS(laimax, plaimax(plt), 2.e-1)
      CALL PUSHREAL8(laimax)
      laimax = result1 + 1.e-1
      laim = laimax*(1.-laimmult) + laim*laimmult
      CALL PUSHREAL8(r)
      r = ft*plgr + (1.-ft)*pkl(plt) + 1.e-9
      arg1 = ft*plgr*laim/r
!        lai(k) = lailim - (lailim - lai(k)) * exp (-r)
      CALL PUSHCONTROL2B(2)
    END IF
  END DO
  laim_bw = 0.0_8
  dptrp_bw = 0.0_8
  DO plt=9,1,-1
    temp_bw = -(EXP(-r)*lai_bw)
    lailim_bw = lai_bw + temp_bw
    lai_bw = -temp_bw
    CALL POPCONTROL2B(branch)
    IF (branch .EQ. 0) THEN
      laim_bw = laim_bw + lailim_bw
      CALL POPREAL8(r)
      laimax_bw = (1.-laimmult)*laim_bw
      laim_bw = laimmult*laim_bw
      CALL POPREAL8(laimax)
      result1_bw = laimax_bw
      CALL POPREAL8(result1)
      CALL FOMINEF_SS_BW0(laimax, laimax_bw, plaimax(plt), 2.e-1, &
&                   result1_bw)
      result1_bw = -(pasm*lailast*laimax_bw/(result1**2*ptauw(plt)))
      CALL MAXX_BW0(dptrp, dptrp_bw, 1.e-3, 2.e-2, result1_bw)
    ELSE IF (branch .EQ. 1) THEN
      CALL POPREAL8(r)
      CALL POPREAL8(ft)
      CALL POPREAL8(arg1)
    ELSE
      arg1_bw = 0.0_8
      CALL MAXX_BW0(arg1, arg1_bw, 1.e-9, 5.e-3, lailim_bw)
      laim_bw = laim_bw + ft*plgr*arg1_bw/r
      CALL POPREAL8(r)
      laimax_bw = (1.-laimmult)*laim_bw
      laim_bw = laimmult*laim_bw
      CALL POPREAL8(laimax)
      result1_bw = laimax_bw
      CALL POPREAL8(result1)
      CALL FOMINEF_SS_BW0(laimax, laimax_bw, plaimax(plt), 2.e-1, &
&                   result1_bw)
      result1_bw = -(pasm*lailast*laimax_bw/(result1**2*ptauw(plt)))
      CALL MAXX_BW0(dptrp, dptrp_bw, 1.e-3, 2.e-2, result1_bw)
      CALL POPREAL8(ft)
      CALL POPREAL8(arg1)
    END IF
  END DO
  trans_bw = 1000.*86400.*dptrp_bw
END SUBROUTINE BEPS_PHENOLOGY_BW

!  Differentiation of netradiation in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: albedo_n_g netradleaf_o_sunlit
!                netradleaf_o_shaded netshortradleaf_o_sunlit netradleaf_u_sunlit
!                percentarea_snow_o netshortradleaf_o_shaded netradleaf_u_shaded
!                percentarea_snow_u netshortradleaf_u_sunlit albedo_snow_n
!                temp_u lai_o percent_snow_g albedo_snow_v lai_u
!                netshortradleaf_u_shaded netrad_g albedo_v_g
!   with respect to varying inputs: albedo_n_g percentarea_snow_o
!                lai_us percentarea_snow_u temp_o albedo_snow_n
!                temp_u lai_os lai_o percent_snow_g albedo_snow_v
!                lai_u albedo_v_g
! This module calculate net radiation at both canopy level and leaf level XZ luo may23 2015
! output: net radiation for canopy,over/under storey and ground
!         ............. on sunlit/shaded leaves of over/understorey
!
! inputs: global solar radiation,cosine value for solar zenith angle,albedo of leaves
!         albedo of snow,percentage of snow cover
!         leaf area index 
!         temperature of over/under storey and ground
!         temperature of air/rh
SUBROUTINE NETRADIATION_BW(shortrad_df, shortrad_dir, coszs, temp_o, &
& temp_o_bw, temp_u, temp_u_bw, temp_g, lai_o, lai_o_bw, lai_u, lai_u_bw&
& , lai_os, lai_os_bw, lai_us, lai_us_bw, lai_o_sunlit, lai_o_shaded, &
& lai_u_sunlit, lai_u_shaded, clumping, temp_air, rh, albedo_snow_v, &
& albedo_snow_v_bw, albedo_snow_n, albedo_snow_n_bw, percentarea_snow_o&
& , percentarea_snow_o_bw, percentarea_snow_u, percentarea_snow_u_bw, &
& percent_snow_g, percent_snow_g_bw, albedo_v_o, albedo_n_o, albedo_v_u&
& , albedo_n_u, albedo_v_g, albedo_v_g_bw, albedo_n_g, albedo_n_g_bw, &
& netrad_o, netrad_u, netrad_g, netrad_g_bw, netradleaf_o_sunlit, &
& netradleaf_o_sunlit_bw, netradleaf_o_shaded, netradleaf_o_shaded_bw, &
& netradleaf_u_sunlit, netradleaf_u_sunlit_bw, netradleaf_u_shaded, &
& netradleaf_u_shaded_bw, netshortradleaf_o_sunlit, &
& netshortradleaf_o_sunlit_bw, netshortradleaf_o_shaded, &
& netshortradleaf_o_shaded_bw, netshortradleaf_u_sunlit, &
& netshortradleaf_u_sunlit_bw, netshortradleaf_u_shaded, &
& netshortradleaf_u_shaded_bw)
  USE METEOMOD_DIFF
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE BEPS_CON, ONLY : zero, sb_constant => sigma
  IMPLICIT NONE
  REAL(r8), INTENT(IN) :: shortrad_df, shortrad_dir, coszs, temp_o, &
& temp_u, temp_g
  REAL(r8) :: temp_o_bw, temp_u_bw
! LAI of over/understorey with or without stem
  REAL(r8), INTENT(IN) :: lai_o, lai_u, lai_os, lai_us
  REAL(r8) :: lai_o_bw, lai_u_bw, lai_os_bw, lai_us_bw
! sunlit/shaded leaves with consideration of stem
  REAL(r8), INTENT(IN) :: lai_o_sunlit, lai_o_shaded, lai_u_sunlit, &
& lai_u_shaded
  REAL(r8), INTENT(IN) :: clumping
  REAL(r8), INTENT(IN) :: temp_air, rh
! albedo of snow in this step
  REAL(r8), INTENT(IN) :: albedo_snow_v, albedo_snow_n
  REAL(r8) :: albedo_snow_v_bw, albedo_snow_n_bw
  REAL(r8), INTENT(IN) :: percentarea_snow_o, percentarea_snow_u, &
& percent_snow_g
  REAL(r8) :: percentarea_snow_o_bw, percentarea_snow_u_bw, &
& percent_snow_g_bw
  REAL(r8), INTENT(IN) :: albedo_v_o, albedo_n_o, albedo_v_u, albedo_n_u&
& , albedo_v_g, albedo_n_g
  REAL(r8) :: albedo_v_g_bw, albedo_n_g_bw
! net Radiation on over/understorey and ground
  REAL(r8) :: netrad_o, netrad_u, netrad_g
  REAL(r8) :: netrad_g_bw
!leaf levels for ET
  REAL(r8) :: netradleaf_o_sunlit, netradleaf_o_shaded, &
& netradleaf_u_sunlit, netradleaf_u_shaded
  REAL(r8) :: netradleaf_o_sunlit_bw, netradleaf_o_shaded_bw, &
& netradleaf_u_sunlit_bw, netradleaf_u_shaded_bw
  REAL(r8) :: netshortradleaf_o_sunlit, netshortradleaf_o_shaded, &
& netshortradleaf_u_sunlit, netshortradleaf_u_shaded
  REAL(r8) :: netshortradleaf_o_sunlit_bw, netshortradleaf_o_shaded_bw, &
& netshortradleaf_u_sunlit_bw, netshortradleaf_u_shaded_bw
!! net shortwave radiation at leaf level for GPP. 
! net short wave radiation
  REAL(r8) :: shortrad_global, netshortrad_o, netshortrad_u, &
& netshortrad_g
  REAL(r8) :: netshortrad_g_bw
  REAL(r8) :: netshortrad_o_dir, netshortrad_o_df, netshortrad_u_dir, &
& netshortrad_u_df, netshortrad_g_dir, netshortrad_g_df
  REAL(r8) :: netshortrad_g_dir_bw, netshortrad_g_df_bw
!real(r8) :: shortRad_dir,shortRad_df
  REAL(r8) :: netlongradleaf_o_sunlit, netlongradleaf_o_shaded, &
& netlongradleaf_u_sunlit, netlongradleaf_u_shaded
  REAL(r8) :: netlongradleaf_o_sunlit_bw, netlongradleaf_o_shaded_bw, &
& netlongradleaf_u_sunlit_bw, netlongradleaf_u_shaded_bw
  REAL(r8) :: netlongrad_o, netlongrad_u, netlongrad_g
  REAL(r8) :: netlongrad_o_bw, netlongrad_u_bw, netlongrad_g_bw
  REAL(r8) :: shortradleaf_o_dir, shortradleaf_u_dir, shortradleaf_o_df&
& , shortradleaf_u_df
  REAL(r8) :: shortradleaf_o_df_bw, shortradleaf_u_df_bw
!albedo of overstorey/understorey/groudn(considering snow)
  REAL(r8) :: albedo_o, albedo_u, albedo_g
  REAL(r8) :: albedo_o_bw, albedo_u_bw, albedo_g_bw
! albedo of three parts in visible and NIR band (considering snow)
  REAL(r8) :: albedo_v_os, albedo_n_os, albedo_v_us, albedo_n_us, &
& albedo_v_gs, albedo_n_gs
  REAL(r8) :: albedo_v_os_bw, albedo_n_os_bw, albedo_v_us_bw, &
& albedo_n_us_bw, albedo_v_gs_bw, albedo_n_gs_bw
!emissivity of air,over/understorey, and ground
  REAL(r8) :: emissivity_air, emissivity_o, emissivity_u, emissivity_g
! longwave radiation emissted by different parts
  REAL(r8) :: longrad_air, longrad_o, longrad_u, longrad_g
  REAL(r8) :: longrad_o_bw, longrad_u_bw
! indicators to describe leaf distribution angles in canopy. slightly related with LAI
  REAL(r8) :: cosq_o, cosq_u
  REAL(r8) :: cosq_o_bw, cosq_u_bw
!gap fraction of direct and diffuse radiation for over/unerstory (diffuse used for diffuse solar radiation and longwave radiation
  REAL(r8) :: gap_o_dir, gap_u_dir, gap_o_df, gap_u_df
  REAL(r8) :: gap_o_dir_bw, gap_u_dir_bw, gap_o_df_bw, gap_u_df_bw
! considering stem
  REAL(r8) :: gap_os_dir, gap_us_dir, gap_os_df, gap_us_df
  REAL(r8) :: gap_os_df_bw, gap_us_df_bw
  INTRINSIC EXP
  INTRINSIC MIN
  INTRINSIC MAX
  REAL(r8) :: temp_bw
  REAL(r8) :: temp_bw0
  REAL(r8) :: temp_bw1
  REAL(r8) :: temp_bw2
  REAL(r8) :: temp_bw3
  INTEGER*4 :: branch
!calculate albedo of canopy in this step
  albedo_v_os = albedo_v_o*(1.-percentarea_snow_o) + albedo_snow_v*&
&   percentarea_snow_o
  albedo_n_os = albedo_n_o*(1.-percentarea_snow_o) + albedo_snow_n*&
&   percentarea_snow_o
  albedo_v_us = albedo_v_u*(1.-percentarea_snow_u) + albedo_snow_v*&
&   percentarea_snow_u
  albedo_n_us = albedo_n_u*(1.-percentarea_snow_u) + albedo_snow_n*&
&   percentarea_snow_u
  albedo_o = 0.5*(albedo_v_os+albedo_n_os)
  albedo_u = 0.5*(albedo_v_us+albedo_n_us)
! calculate albedo of ground 
  albedo_v_gs = albedo_v_g*(1.-percent_snow_g) + albedo_snow_v*&
&   percent_snow_g
  albedo_n_gs = albedo_n_g*(1.-percent_snow_g) + albedo_snow_n*&
&   percent_snow_g
  albedo_g = 0.5*(albedo_v_gs+albedo_n_gs)
! separate global solar radiation into df and dir  @orgin
!      Here we input df/dir directly               @J.Wang
! @J.Wang
  shortrad_global = shortrad_df + shortrad_dir
! fraction at each layer of canopy,df/dir, use LAI here
  IF (coszs .GT. zero) THEN
    IF (-(0.5*clumping*lai_o/coszs) .LT. -10.) THEN
      CALL PUSHCONTROL1B(0)
      gap_o_dir = 0.
    ELSE
      gap_o_dir = EXP(-(0.5*clumping*lai_o/coszs))
      CALL PUSHCONTROL1B(1)
    END IF
    IF (-(0.5*clumping*lai_u/coszs) .LT. -10.) THEN
      CALL PUSHCONTROL2B(1)
      gap_u_dir = 0.
    ELSE
      gap_u_dir = EXP(-(0.5*clumping*lai_u/coszs))
      CALL PUSHCONTROL2B(2)
    END IF
  ELSE
    CALL PUSHCONTROL2B(0)
  END IF
!leaf distribution angles
  cosq_o = 0.537 + 0.025*lai_o
  cosq_u = 0.537 + 0.025*lai_u
  gap_o_df = EXP(-(0.5*clumping*lai_o/cosq_o))
  gap_u_df = EXP(-(0.5*clumping*lai_u/cosq_u))
  gap_os_df = EXP(-(0.5*clumping*lai_os/cosq_o))
  gap_us_df = EXP(-(0.5*clumping*lai_us/cosq_u))
!emissivity of each part
  CALL METEO_PACK(temp_air, rh)
  emissivity_air = 1. - EXP(-((e_actual*10.0)**((temp_air+273.15)/1200.0&
&   )))
  IF (1. .GT. emissivity_air) THEN
    emissivity_air = emissivity_air
  ELSE
    emissivity_air = 1.
  END IF
  IF (0.7 .LT. emissivity_air) THEN
    emissivity_air = emissivity_air
  ELSE
    emissivity_air = 0.7
  END IF
  emissivity_o = 0.98
  emissivity_u = 0.98
  emissivity_g = 0.96
!net short direct radiation on canopy and ground
  IF (shortrad_global .GT. zero .AND. coszs .GT. zero) THEN
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
!net short diffuse radiation on canopy and ground
  IF (shortrad_global .GT. zero .AND. coszs .GT. zero) THEN
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
!total net shortwave radiation at canopy level
!net longwave radiation on canopy and ground
  longrad_air = emissivity_air*sb_constant*(temp_air+273.15)**4
  longrad_o = emissivity_o*sb_constant*(temp_o+273.15)**4
  longrad_u = emissivity_u*sb_constant*(temp_u+273.15)**4
  longrad_g = emissivity_g*sb_constant*(temp_g+273.15)**4
  netlongrad_o = (emissivity_o*(longrad_air+longrad_u*(1.-gap_u_df)+&
&   longrad_g*gap_u_df)-2.*longrad_o)*(1.-gap_o_df) + emissivity_o*(1.-&
&   emissivity_u)*(1.-gap_u_df)*(longrad_air*gap_o_df+longrad_o*(1.-&
&   gap_o_df))
  netlongrad_u = (emissivity_u*(longrad_air*gap_o_df+longrad_o*(1.-&
&   gap_o_df)+longrad_g)-2.*longrad_u)*(1.-gap_u_df) + (1.-emissivity_g)&
&   *((longrad_air*gap_o_df+longrad_o*(1.-gap_o_df))*gap_u_df+longrad_u*&
&   (1.-gap_u_df)) + emissivity_u*(1.-emissivity_o)*(longrad_u*(1.-&
&   gap_u_df)+longrad_g*gap_u_df)*(1.-gap_o_df)
!total net radiation for overstorey/understorey/ground
!leaf level net radiation updated way
! reference Chen2012 clumping index paper
  IF (shortrad_global .GT. zero .AND. coszs .GT. zero) THEN
    shortradleaf_o_dir = 0.5*shortrad_dir/coszs
    IF (shortradleaf_o_dir .GT. 0.7*1362.) THEN
      shortradleaf_o_dir = 0.7*1362.
    ELSE
      shortradleaf_o_dir = shortradleaf_o_dir
    END IF
    shortradleaf_u_dir = shortradleaf_o_dir
    shortradleaf_o_df = (shortrad_df-shortrad_df*gap_os_df)/lai_os + &
&     0.07*shortrad_dir*(1.1-0.1*lai_os)*EXP(-coszs)
    shortradleaf_u_df = (shortrad_df*gap_o_df-shortrad_df*gap_o_df*&
&     gap_us_df)/lai_us + 0.05*shortrad_dir*gap_o_dir*(1.1-0.1*lai_us)*&
&     EXP(-coszs)
    CALL PUSHCONTROL1B(0)
  ELSE
    shortradleaf_o_dir = 0.
    shortradleaf_u_dir = 0.
    shortradleaf_o_df = 0.
    shortradleaf_u_df = 0.
    CALL PUSHCONTROL1B(1)
  END IF
!overstorey sunlit leaves
  IF (lai_o_sunlit .GT. 0.) THEN
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
!overstorey shaded leaves
  IF (lai_o_shaded .GT. 0.) THEN
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
!understorey sunlit leaf
  IF (lai_u_sunlit .GT. 0.) THEN
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
!understorey shaded leaf
  IF (lai_u_shaded .GT. 0.) THEN
    netshortradleaf_u_shaded_bw = netshortradleaf_u_shaded_bw + &
&     netradleaf_u_shaded_bw
    netlongradleaf_u_shaded_bw = netradleaf_u_shaded_bw
    netlongrad_u_bw = netlongradleaf_u_shaded_bw/lai_us
    lai_us_bw = -(netlongrad_u*netlongradleaf_u_shaded_bw/lai_us**2)
    shortradleaf_u_df_bw = (1.-albedo_u)*netshortradleaf_u_shaded_bw
    albedo_u_bw = -(shortradleaf_u_df*netshortradleaf_u_shaded_bw)
  ELSE
    netshortradleaf_u_shaded_bw = netshortradleaf_u_shaded_bw + &
&     netradleaf_u_shaded_bw
    netlongradleaf_u_shaded_bw = netradleaf_u_shaded_bw
    netlongrad_u_bw = netlongradleaf_u_shaded_bw
    shortradleaf_u_df_bw = (1.-albedo_u)*netshortradleaf_u_shaded_bw
    albedo_u_bw = -(shortradleaf_u_df*netshortradleaf_u_shaded_bw)
    lai_us_bw = 0.0_8
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    netshortradleaf_u_sunlit_bw = netshortradleaf_u_sunlit_bw + &
&     netradleaf_u_sunlit_bw
    netlongradleaf_u_sunlit_bw = netradleaf_u_sunlit_bw
    netlongrad_u_bw = netlongrad_u_bw + netlongradleaf_u_sunlit_bw/&
&     lai_us
    lai_us_bw = lai_us_bw - netlongrad_u*netlongradleaf_u_sunlit_bw/&
&     lai_us**2
    shortradleaf_u_df_bw = shortradleaf_u_df_bw + (1.-albedo_u)*&
&     netshortradleaf_u_sunlit_bw
    albedo_u_bw = albedo_u_bw - (shortradleaf_u_dir+shortradleaf_u_df)*&
&     netshortradleaf_u_sunlit_bw
  ELSE
    netshortradleaf_u_sunlit_bw = netshortradleaf_u_sunlit_bw + &
&     netradleaf_u_sunlit_bw
    netlongradleaf_u_sunlit_bw = netradleaf_u_sunlit_bw
    netlongrad_u_bw = netlongrad_u_bw + netlongradleaf_u_sunlit_bw
    shortradleaf_u_df_bw = shortradleaf_u_df_bw + (1.-albedo_u)*&
&     netshortradleaf_u_sunlit_bw
    albedo_u_bw = albedo_u_bw - (shortradleaf_u_dir+shortradleaf_u_df)*&
&     netshortradleaf_u_sunlit_bw
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    netshortradleaf_o_shaded_bw = netshortradleaf_o_shaded_bw + &
&     netradleaf_o_shaded_bw
    netlongradleaf_o_shaded_bw = netradleaf_o_shaded_bw
    netlongrad_o_bw = netlongradleaf_o_shaded_bw/lai_os
    lai_os_bw = -(netlongrad_o*netlongradleaf_o_shaded_bw/lai_os**2)
    shortradleaf_o_df_bw = (1.-albedo_o)*netshortradleaf_o_shaded_bw
    albedo_o_bw = -(shortradleaf_o_df*netshortradleaf_o_shaded_bw)
  ELSE
    netshortradleaf_o_shaded_bw = netshortradleaf_o_shaded_bw + &
&     netradleaf_o_shaded_bw
    netlongradleaf_o_shaded_bw = netradleaf_o_shaded_bw
    netlongrad_o_bw = netlongradleaf_o_shaded_bw
    shortradleaf_o_df_bw = (1.-albedo_o)*netshortradleaf_o_shaded_bw
    albedo_o_bw = -(shortradleaf_o_df*netshortradleaf_o_shaded_bw)
    lai_os_bw = 0.0_8
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    netshortradleaf_o_sunlit_bw = netshortradleaf_o_sunlit_bw + &
&     netradleaf_o_sunlit_bw
    netlongradleaf_o_sunlit_bw = netradleaf_o_sunlit_bw
    netlongrad_o_bw = netlongrad_o_bw + netlongradleaf_o_sunlit_bw/&
&     lai_os
    lai_os_bw = lai_os_bw - netlongrad_o*netlongradleaf_o_sunlit_bw/&
&     lai_os**2
    shortradleaf_o_df_bw = shortradleaf_o_df_bw + (1.-albedo_o)*&
&     netshortradleaf_o_sunlit_bw
    albedo_o_bw = albedo_o_bw - (shortradleaf_o_dir+shortradleaf_o_df)*&
&     netshortradleaf_o_sunlit_bw
  ELSE
    netshortradleaf_o_sunlit_bw = netshortradleaf_o_sunlit_bw + &
&     netradleaf_o_sunlit_bw
    netlongradleaf_o_sunlit_bw = netradleaf_o_sunlit_bw
    netlongrad_o_bw = netlongrad_o_bw + netlongradleaf_o_sunlit_bw
    shortradleaf_o_df_bw = shortradleaf_o_df_bw + (1.-albedo_o)*&
&     netshortradleaf_o_sunlit_bw
    albedo_o_bw = albedo_o_bw - (shortradleaf_o_dir+shortradleaf_o_df)*&
&     netshortradleaf_o_sunlit_bw
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    temp_bw3 = shortradleaf_u_df_bw/lai_us
    temp_bw2 = shortrad_dir*0.05*EXP(-coszs)*shortradleaf_u_df_bw
    gap_o_dir_bw = (1.1-0.1*lai_us)*temp_bw2
    lai_us_bw = lai_us_bw - 0.1*gap_o_dir*temp_bw2 - (shortrad_df*&
&     gap_o_df-shortrad_df*(gap_o_df*gap_us_df))*temp_bw3/lai_us
    gap_o_df_bw = (shortrad_df-gap_us_df*shortrad_df)*temp_bw3
    gap_us_df_bw = -(gap_o_df*shortrad_df*temp_bw3)
    gap_os_df_bw = -(shortrad_df*shortradleaf_o_df_bw/lai_os)
    lai_os_bw = lai_os_bw - ((shortrad_df-shortrad_df*gap_os_df)/lai_os&
&     **2+0.1*shortrad_dir*0.07*EXP(-coszs))*shortradleaf_o_df_bw
  ELSE
    gap_o_df_bw = 0.0_8
    gap_us_df_bw = 0.0_8
    gap_o_dir_bw = 0.0_8
    gap_os_df_bw = 0.0_8
  END IF
  temp_bw0 = (1.-emissivity_g)*netlongrad_u_bw
  temp_bw = gap_u_df*temp_bw0
  temp_bw1 = emissivity_u*(1.-gap_u_df)*netlongrad_u_bw
  netshortrad_g_bw = netrad_g_bw
  netlongrad_g_bw = netrad_g_bw
  temp_bw3 = emissivity_g*netlongrad_g_bw
  gap_u_df_bw = (longrad_air*gap_o_df+longrad_o*(1.-gap_o_df)-longrad_u)&
&   *temp_bw3 - (1.-emissivity_u)*longrad_g*netlongrad_g_bw
  temp_bw2 = gap_u_df*temp_bw3
  longrad_u_bw = (1.-gap_u_df)*temp_bw3
  gap_o_df_bw = gap_o_df_bw + (longrad_air-longrad_o)*temp_bw2
  longrad_o_bw = (1.-gap_o_df)*temp_bw2 + (1.-gap_o_df)*temp_bw + (1.-&
&   gap_o_df)*temp_bw1
  temp_bw2 = emissivity_u*(1.-emissivity_o)*netlongrad_u_bw
  temp_bw3 = (1.-gap_o_df)*temp_bw2
  gap_u_df_bw = gap_u_df_bw + (longrad_g-longrad_u)*temp_bw3 - (&
&   emissivity_u*(longrad_g+longrad_air*gap_o_df+longrad_o*(1.-gap_o_df)&
&   )-2.*longrad_u)*netlongrad_u_bw + (longrad_air*gap_o_df+longrad_o*(&
&   1.-gap_o_df)-longrad_u)*temp_bw0
  gap_o_df_bw = gap_o_df_bw + (longrad_air-longrad_o)*temp_bw - (&
&   longrad_u*(1.-gap_u_df)+longrad_g*gap_u_df)*temp_bw2 + (longrad_air-&
&   longrad_o)*temp_bw1
  temp_bw = emissivity_o*(1.-gap_o_df)*netlongrad_o_bw
  longrad_u_bw = longrad_u_bw + (1.-gap_u_df)*temp_bw3 - 2.*(1.-gap_u_df&
&   )*netlongrad_u_bw + (1.-gap_u_df)*temp_bw0 + (1.-gap_u_df)*temp_bw
  temp_bw0 = emissivity_o*(1.-emissivity_u)*netlongrad_o_bw
  gap_u_df_bw = gap_u_df_bw + (longrad_g-longrad_u)*temp_bw - (&
&   longrad_air*gap_o_df+longrad_o*(1.-gap_o_df))*temp_bw0
  temp_bw1 = (1.-gap_u_df)*temp_bw0
  longrad_o_bw = longrad_o_bw + (1.-gap_o_df)*temp_bw1 - 2.*(1.-gap_o_df&
&   )*netlongrad_o_bw
  gap_o_df_bw = gap_o_df_bw + (longrad_air-longrad_o)*temp_bw1 - (&
&   emissivity_o*(longrad_air+longrad_u*(1.-gap_u_df)+longrad_g*gap_u_df&
&   )-2.*longrad_o)*netlongrad_o_bw
  temp_u_bw = temp_u_bw + 4*(temp_u+273.15)**3*emissivity_u*sb_constant*&
&   longrad_u_bw
  temp_o_bw = 4*(temp_o+273.15)**3*emissivity_o*sb_constant*longrad_o_bw
  netshortrad_g_dir_bw = netshortrad_g_bw
  netshortrad_g_df_bw = netshortrad_g_bw
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    temp_bw = (1.-albedo_g)*shortrad_df*netshortrad_g_df_bw
    albedo_g_bw = -(gap_o_df*gap_u_df*shortrad_df*netshortrad_g_df_bw)
    gap_o_df_bw = gap_o_df_bw + gap_u_df*temp_bw
    gap_u_df_bw = gap_u_df_bw + gap_o_df*temp_bw
  ELSE
    albedo_g_bw = 0.0_8
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    temp_bw = (1.-albedo_g)*shortrad_dir*netshortrad_g_dir_bw
    albedo_g_bw = albedo_g_bw - gap_o_dir*gap_u_dir*shortrad_dir*&
&     netshortrad_g_dir_bw
    gap_o_dir_bw = gap_o_dir_bw + gap_u_dir*temp_bw
    gap_u_dir_bw = gap_o_dir*temp_bw
  ELSE
    gap_u_dir_bw = 0.0_8
  END IF
  temp_bw = -(clumping*0.5*EXP(-(clumping*0.5*(lai_us/cosq_u)))*&
&   gap_us_df_bw/cosq_u)
  lai_us_bw = lai_us_bw + temp_bw
  cosq_u_bw = -(lai_us*temp_bw/cosq_u)
  temp_bw = -(clumping*0.5*EXP(-(clumping*0.5*(lai_os/cosq_o)))*&
&   gap_os_df_bw/cosq_o)
  lai_os_bw = lai_os_bw + temp_bw
  cosq_o_bw = -(lai_os*temp_bw/cosq_o)
  temp_bw = -(clumping*0.5*EXP(-(clumping*0.5*(lai_u/cosq_u)))*&
&   gap_u_df_bw/cosq_u)
  cosq_u_bw = cosq_u_bw - lai_u*temp_bw/cosq_u
  lai_u_bw = lai_u_bw + temp_bw + 0.025*cosq_u_bw
  temp_bw = -(clumping*0.5*EXP(-(clumping*0.5*(lai_o/cosq_o)))*&
&   gap_o_df_bw/cosq_o)
  cosq_o_bw = cosq_o_bw - lai_o*temp_bw/cosq_o
  lai_o_bw = lai_o_bw + temp_bw + 0.025*cosq_o_bw
  CALL POPCONTROL2B(branch)
  IF (branch .NE. 0) THEN
    IF (branch .EQ. 1) THEN
      gap_u_dir_bw = 0.0_8
    ELSE
      lai_u_bw = lai_u_bw - clumping*0.5*EXP(-(clumping*0.5*(lai_u/coszs&
&       )))*gap_u_dir_bw/coszs
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) lai_o_bw = lai_o_bw - clumping*0.5*EXP(-(clumping&
&       *0.5*(lai_o/coszs)))*gap_o_dir_bw/coszs
  END IF
  albedo_n_os_bw = 0.5*albedo_o_bw
  albedo_v_os_bw = 0.5*albedo_o_bw
  albedo_n_us_bw = 0.5*albedo_u_bw
  albedo_v_us_bw = 0.5*albedo_u_bw
  albedo_v_gs_bw = 0.5*albedo_g_bw
  albedo_n_gs_bw = 0.5*albedo_g_bw
  albedo_n_g_bw = albedo_n_g_bw + (1.-percent_snow_g)*albedo_n_gs_bw
  percent_snow_g_bw = percent_snow_g_bw + (albedo_snow_n-albedo_n_g)*&
&   albedo_n_gs_bw + (albedo_snow_v-albedo_v_g)*albedo_v_gs_bw
  albedo_snow_n_bw = albedo_snow_n_bw + percent_snow_g*albedo_n_gs_bw + &
&   percentarea_snow_u*albedo_n_us_bw + percentarea_snow_o*&
&   albedo_n_os_bw
  albedo_v_g_bw = albedo_v_g_bw + (1.-percent_snow_g)*albedo_v_gs_bw
  albedo_snow_v_bw = albedo_snow_v_bw + percent_snow_g*albedo_v_gs_bw + &
&   percentarea_snow_u*albedo_v_us_bw + percentarea_snow_o*&
&   albedo_v_os_bw
  percentarea_snow_u_bw = percentarea_snow_u_bw + (albedo_snow_n-&
&   albedo_n_u)*albedo_n_us_bw + (albedo_snow_v-albedo_v_u)*&
&   albedo_v_us_bw
  percentarea_snow_o_bw = percentarea_snow_o_bw + (albedo_snow_n-&
&   albedo_n_o)*albedo_n_os_bw + (albedo_snow_v-albedo_v_o)*&
&   albedo_v_os_bw
END SUBROUTINE NETRADIATION_BW

!  Differentiation of sensibleheat in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: lai_o_sunlit templ_o_sunlit
!                lai_o_shaded templ_o_shaded gheat_o_sunlit sh_o
!                gheat_o_shaded
!   with respect to varying inputs: lai_o_sunlit templ_o_sunlit
!                lai_o_shaded templ_o_shaded gheat_o_sunlit gheat_o_shaded
! this module will calculate sensible heat from overstorey,understorey, and ground editted by XZ Luo, May23,2015
! inputs: 
! temperature of sunlit and shaded leaves from other storey (leaf temperature module)
! temperature of air,relative humidity
! temperature of ground (soil heat flux module)
! aerodynamic heat conductance of sunlit shaded leaves from over/understorey
! aerodynamic heat conductance of ground
! lAI sunlit and shaded, over/understorey (LAI module)
! Outputs:
! sensible heat from over/understorey and ground
SUBROUTINE SENSIBLEHEAT_BW(templ_o_sunlit, templ_o_sunlit_bw, &
& templ_o_shaded, templ_o_shaded_bw, templ_u_sunlit, templ_u_shaded, &
& temp_g, temp_air, rh_air, gheat_o_sunlit, gheat_o_sunlit_bw, &
& gheat_o_shaded, gheat_o_shaded_bw, gheat_u_sunlit, gheat_u_shaded, &
& gheat_g, lai_o_sunlit, lai_o_sunlit_bw, lai_o_shaded, lai_o_shaded_bw&
& , lai_u_sunlit, lai_u_shaded, sh_o, sh_o_bw, sh_u, sh_g)
  USE METEOMOD_DIFF
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  IMPLICIT NONE
  REAL(r8), INTENT(IN) :: templ_o_sunlit, templ_o_shaded, templ_u_sunlit&
& , templ_u_shaded, temp_g, temp_air, rh_air
  REAL(r8) :: templ_o_sunlit_bw, templ_o_shaded_bw
  REAL(r8), INTENT(IN) :: gheat_o_sunlit, gheat_o_shaded, gheat_u_sunlit&
& , gheat_u_shaded, gheat_g
  REAL(r8) :: gheat_o_sunlit_bw, gheat_o_shaded_bw
  REAL(r8), INTENT(IN) :: lai_o_sunlit, lai_o_shaded, lai_u_sunlit, &
& lai_u_shaded
  REAL(r8) :: lai_o_sunlit_bw, lai_o_shaded_bw
  REAL(r8) :: sh_o, sh_u, sh_g
  REAL(r8) :: sh_o_bw
  REAL(r8) :: sh_o_sunlit, sh_o_shaded, sh_u_sunlit, sh_u_shaded
  REAL(r8) :: sh_o_sunlit_bw, sh_o_shaded_bw
  INTRINSIC MAX
  REAL(r8) :: temp_bw
  CALL METEO_PACK(temp_air, rh_air)
  sh_o_sunlit = (templ_o_sunlit-temp_air)*density_air*cp_air*&
&   gheat_o_sunlit
  sh_o_shaded = (templ_o_shaded-temp_air)*density_air*cp_air*&
&   gheat_o_shaded
  sh_o = sh_o_sunlit*lai_o_sunlit + sh_o_shaded*lai_o_shaded
  IF (-200. .GE. sh_o) sh_o_bw = 0.0_8
  sh_o_sunlit_bw = lai_o_sunlit*sh_o_bw
  lai_o_sunlit_bw = lai_o_sunlit_bw + sh_o_sunlit*sh_o_bw
  sh_o_shaded_bw = lai_o_shaded*sh_o_bw
  lai_o_shaded_bw = lai_o_shaded_bw + sh_o_shaded*sh_o_bw
  temp_bw = density_air*cp_air*sh_o_shaded_bw
  templ_o_shaded_bw = templ_o_shaded_bw + gheat_o_shaded*temp_bw
  gheat_o_shaded_bw = gheat_o_shaded_bw + (templ_o_shaded-temp_air)*&
&   temp_bw
  temp_bw = density_air*cp_air*sh_o_sunlit_bw
  templ_o_sunlit_bw = templ_o_sunlit_bw + gheat_o_sunlit*temp_bw
  gheat_o_sunlit_bw = gheat_o_sunlit_bw + (templ_o_sunlit-temp_air)*&
&   temp_bw
END SUBROUTINE SENSIBLEHEAT_BW

!  Differentiation of retrive_soilp in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: *(soilstat.dt) *(soilstat.ksat)
!                *(soilstat.b) *(soilstat.ice_ratio) *(soilstat.thetam)
!                *(soilstat.thetam_prev) *(soilstat.temp_soil_p)
!                *(soilstat.temp_soil_c) *(soilstat.f_ice) *(soilstat.psim)
!                *(soilstat.thetab) *(soilstat.psib) *(soilstat.r_waterflow)
!                *(soilstat.km) *(soilstat.kb) *(soilstat.kk) *(soilstat.cs)
!                *(soilstat.lambda) *(soilstat.ett) *(soilstat.g)
!                soilp.dt soilp.ksat soilp.b soilp.ice_ratio soilp.thetam
!                soilp.thetam_prev soilp.temp_soil_p soilp.temp_soil_c
!                soilp.f_ice soilp.psim soilp.thetab soilp.psib
!                soilp.r_waterflow soilp.km soilp.kb soilp.kk soilp.cs
!                soilp.lambda soilp.ett soilp.g
!   with respect to varying inputs: *(soilstat.dt) *(soilstat.ksat)
!                *(soilstat.b) *(soilstat.ice_ratio) *(soilstat.thetam)
!                *(soilstat.thetam_prev) *(soilstat.temp_soil_p)
!                *(soilstat.temp_soil_c) *(soilstat.f_ice) *(soilstat.psim)
!                *(soilstat.thetab) *(soilstat.psib) *(soilstat.r_waterflow)
!                *(soilstat.km) *(soilstat.kb) *(soilstat.kk) *(soilstat.cs)
!                *(soilstat.lambda) *(soilstat.ett) *(soilstat.g)
!                soilp.dt soilp.ksat soilp.b soilp.ice_ratio soilp.thetam
!                soilp.thetam_prev soilp.temp_soil_p soilp.temp_soil_c
!                soilp.f_ice soilp.psim soilp.thetab soilp.psib
!                soilp.r_waterflow soilp.km soilp.kb soilp.kk soilp.cs
!                soilp.lambda soilp.ett soilp.g
!   Plus diff mem management of: soilstat.zp:in soilstat.zsp:in
!                soilstat.r_rain_g:in soilstat.r_drainage:in soilstat.r_root_decay:in
!                soilstat.psi_min:in soilstat.alpha:in soilstat.f_soilwater:in
!                soilstat.d_soil:in soilstat.f_root:in soilstat.dt:in
!                soilstat.thermal_cond:in soilstat.theta_vfc:in
!                soilstat.theta_vwp:in soilstat.fei:in soilstat.ksat:in
!                soilstat.psi_sat:in soilstat.b:in soilstat.density_soil:in
!                soilstat.f_org:in soilstat.ice_ratio:in soilstat.thetam:in
!                soilstat.thetam_prev:in soilstat.temp_soil_p:in
!                soilstat.temp_soil_c:in soilstat.f_ice:in soilstat.psim:in
!                soilstat.thetab:in soilstat.psib:in soilstat.r_waterflow:in
!                soilstat.km:in soilstat.kb:in soilstat.kk:in soilstat.cs:in
!                soilstat.lambda:in soilstat.ett:in soilstat.g:in
!!*******************************************
!! This module is used to get/put soilp data at single point
!! from global datasets
!! flag =0: get from ; flag=1: put into
!! Created by J.Wang
!!*******************************************
SUBROUTINE RETRIVE_SOILP_BW(soilp, soilp_bw, i, j, flag)
  USE BEPSTYPE_DIFF
  USE BEPS_SOILMOD_DIFF
  IMPLICIT NONE
  TYPE(SOIL) :: soilp
  TYPE(SOIL_DIFF) :: soilp_bw
  INTEGER :: i, j, flag
  TYPE(SOILS), POINTER :: p
  TYPE(SOILS), POINTER :: p_bw
  INTERFACE 
      SUBROUTINE ENDRUN(msg)
        IMPLICIT NONE
        CHARACTER(len=*), INTENT(IN), OPTIONAL :: msg
      END SUBROUTINE ENDRUN
  END INTERFACE

  p_bw => soilstat_bw
  IF (flag .EQ. 0) THEN
    p_bw%g(i, :, j) = p_bw%g(i, :, j) + soilp_bw%g
    p_bw%ett(i, :, j) = p_bw%ett(i, :, j) + soilp_bw%ett
    p_bw%lambda(i, :, j) = p_bw%lambda(i, :, j) + soilp_bw%lambda
    p_bw%cs(i, :, j) = p_bw%cs(i, :, j) + soilp_bw%cs
    p_bw%kk(i, :, j) = p_bw%kk(i, :, j) + soilp_bw%kk
    p_bw%kb(i, :, j) = p_bw%kb(i, :, j) + soilp_bw%kb
    p_bw%km(i, :, j) = p_bw%km(i, :, j) + soilp_bw%km
    p_bw%r_waterflow(i, :, j) = p_bw%r_waterflow(i, :, j) + soilp_bw%&
&     r_waterflow
    p_bw%psib(i, :, j) = p_bw%psib(i, :, j) + soilp_bw%psib
    p_bw%thetab(i, :, j) = p_bw%thetab(i, :, j) + soilp_bw%thetab
    p_bw%psim(i, :, j) = p_bw%psim(i, :, j) + soilp_bw%psim
    p_bw%f_ice(i, :, j) = p_bw%f_ice(i, :, j) + soilp_bw%f_ice
    p_bw%temp_soil_c(i, :, j) = p_bw%temp_soil_c(i, :, j) + soilp_bw%&
&     temp_soil_c
    p_bw%temp_soil_p(i, :, j) = p_bw%temp_soil_p(i, :, j) + soilp_bw%&
&     temp_soil_p
    p_bw%thetam_prev(i, :, j) = p_bw%thetam_prev(i, :, j) + soilp_bw%&
&     thetam_prev
    p_bw%thetam(i, :, j) = p_bw%thetam(i, :, j) + soilp_bw%thetam
    p_bw%ice_ratio(i, :, j) = p_bw%ice_ratio(i, :, j) + soilp_bw%&
&     ice_ratio
    p_bw%b(i, :, j) = p_bw%b(i, :, j) + soilp_bw%b
    p_bw%ksat(i, :, j) = p_bw%ksat(i, :, j) + soilp_bw%ksat
    p_bw%dt(i, :, j) = p_bw%dt(i, :, j) + soilp_bw%dt
    soilp_bw%dt = 0.0_8
    soilp_bw%ksat = 0.0_8
    soilp_bw%b = 0.0_8
    soilp_bw%ice_ratio = 0.0_8
    soilp_bw%thetam = 0.0_8
    soilp_bw%thetam_prev = 0.0_8
    soilp_bw%temp_soil_p = 0.0_8
    soilp_bw%temp_soil_c = 0.0_8
    soilp_bw%f_ice = 0.0_8
    soilp_bw%psim = 0.0_8
    soilp_bw%thetab = 0.0_8
    soilp_bw%psib = 0.0_8
    soilp_bw%r_waterflow = 0.0_8
    soilp_bw%km = 0.0_8
    soilp_bw%kb = 0.0_8
    soilp_bw%kk = 0.0_8
    soilp_bw%cs = 0.0_8
    soilp_bw%lambda = 0.0_8
    soilp_bw%ett = 0.0_8
    soilp_bw%g = 0.0_8
  ELSE IF (flag .EQ. 1) THEN
    soilp_bw%g = soilp_bw%g + p_bw%g(i, :, j)
    p_bw%g(i, :, j) = 0.0_8
    soilp_bw%ett = soilp_bw%ett + p_bw%ett(i, :, j)
    p_bw%ett(i, :, j) = 0.0_8
    soilp_bw%lambda = soilp_bw%lambda + p_bw%lambda(i, :, j)
    p_bw%lambda(i, :, j) = 0.0_8
    soilp_bw%cs = soilp_bw%cs + p_bw%cs(i, :, j)
    p_bw%cs(i, :, j) = 0.0_8
    soilp_bw%kk = soilp_bw%kk + p_bw%kk(i, :, j)
    p_bw%kk(i, :, j) = 0.0_8
    soilp_bw%kb = soilp_bw%kb + p_bw%kb(i, :, j)
    p_bw%kb(i, :, j) = 0.0_8
    soilp_bw%km = soilp_bw%km + p_bw%km(i, :, j)
    p_bw%km(i, :, j) = 0.0_8
    soilp_bw%r_waterflow = soilp_bw%r_waterflow + p_bw%r_waterflow(i, :&
&     , j)
    p_bw%r_waterflow(i, :, j) = 0.0_8
    soilp_bw%psib = soilp_bw%psib + p_bw%psib(i, :, j)
    p_bw%psib(i, :, j) = 0.0_8
    soilp_bw%thetab = soilp_bw%thetab + p_bw%thetab(i, :, j)
    p_bw%thetab(i, :, j) = 0.0_8
    soilp_bw%psim = soilp_bw%psim + p_bw%psim(i, :, j)
    p_bw%psim(i, :, j) = 0.0_8
    soilp_bw%f_ice = soilp_bw%f_ice + p_bw%f_ice(i, :, j)
    p_bw%f_ice(i, :, j) = 0.0_8
    soilp_bw%temp_soil_c = soilp_bw%temp_soil_c + p_bw%temp_soil_c(i, :&
&     , j)
    p_bw%temp_soil_c(i, :, j) = 0.0_8
    soilp_bw%temp_soil_p = soilp_bw%temp_soil_p + p_bw%temp_soil_p(i, :&
&     , j)
    p_bw%temp_soil_p(i, :, j) = 0.0_8
    soilp_bw%thetam_prev = soilp_bw%thetam_prev + p_bw%thetam_prev(i, :&
&     , j)
    p_bw%thetam_prev(i, :, j) = 0.0_8
    soilp_bw%thetam = soilp_bw%thetam + p_bw%thetam(i, :, j)
    p_bw%thetam(i, :, j) = 0.0_8
    soilp_bw%ice_ratio = soilp_bw%ice_ratio + p_bw%ice_ratio(i, :, j)
    p_bw%ice_ratio(i, :, j) = 0.0_8
    soilp_bw%b = soilp_bw%b + p_bw%b(i, :, j)
    p_bw%b(i, :, j) = 0.0_8
    soilp_bw%ksat = soilp_bw%ksat + p_bw%ksat(i, :, j)
    p_bw%ksat(i, :, j) = 0.0_8
    soilp_bw%dt = soilp_bw%dt + p_bw%dt(i, :, j)
    p_bw%dt(i, :, j) = 0.0_8
  END IF
END SUBROUTINE RETRIVE_SOILP_BW

!  Differentiation of x2beps in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: *(assim.p_vcmax) *(assim.p_vj_slope)
!                *(assim.p_sif_alpha) *(assim.p_sif_beta) *(assim.p_ksat_scalar)
!                *(assim.p_b_scalar) *(assim.p_f_leaf) x
!   with respect to varying inputs: x
!   Plus diff mem management of: assim.p_vcmax:in assim.p_vj_slope:in
!                assim.p_sif_alpha:in assim.p_sif_beta:in assim.p_ksat_scalar:in
!                assim.p_b_scalar:in assim.p_f_leaf:in
!***********************************************************
!     x2beps
!
!> @brief maps one-dimensional (normalised) control vector
!>        to the respective physical BEPS parameter(s)
!>
!> @param[in]   n   length of control vector
!> @param[in]   x   control vector (in normalised units)
!
!> \authors Michael Vossbeck, The Inversion Lab
!> \date    February 2020
!>
SUBROUTINE X2BEPS_BW(n, x, x_bw)
  USE MO_PRIOR
  USE BEPSTYPE_DIFF, ONLY : assim, assim_bw
  USE BEPS_PAR, ONLY : pft, texture
  IMPLICIT NONE
!-- iLab::CHANGED 06/2022: D0,TAWEFF not required since VOD is not assimilated
! !-- agb2vod
! !   (...)
! i1 = i1+1
! assim%p_agb2vod = xphys(i1)
! arguments
  INTEGER, INTENT(IN) :: n
  REAL(kind=8), INTENT(IN) :: x(n)
  REAL(kind=8) :: x_bw(n)
! local declarations
  REAL(kind=8) :: xphys(n)
  REAL(kind=8) :: xphys_bw(n)
  INTEGER :: i1, i2
!-- convert to phyiscal units
!-- Vcmax
!   (for the 'Vcmax' parameter)
  i1 = 1
  i2 = i1 + pft - 1
!-- VJ_slope
!   (...)
  i1 = i2 + 1
  CALL PUSHINTEGER4(i2)
  i2 = i1 + pft - 1
!-- Q10
!   (parameter to adjust 'q10' in calculation plant respiration)
  CALL PUSHINTEGER4(i1)
  i1 = i2 + 1
  CALL PUSHINTEGER4(i2)
  i2 = i1 + pft - 1
!-- SIF alpha
!   (...)
  i1 = i2 + 1
  i2 = i1 + pft - 1
!-- SIF beta
!   (...)
  CALL PUSHINTEGER4(i1)
  i1 = i2 + 1
  CALL PUSHINTEGER4(i2)
  i2 = i1 + pft - 1
!-- iLab::CHANGED 06/2022: D0,TAWEFF not required since VOD is not assimilated
! !-- D0
! !   (...)
! i1 = i2+1
! i2 = i1+PFT-1
! assim%p_D0     = xphys(i1:i2)
! !-- taueff
! !   (...)
! i1 = i2+1
! i2 = i1+PFT-1
! assim%p_taweff = xphys(i1:i2)
!-- Ksat
!   (parameter to adjust 'Ksat', the saturated hydraulic conductivity, in beps_soilMod.F90)
  CALL PUSHINTEGER4(i1)
  i1 = i2 + 1
  CALL PUSHINTEGER4(i2)
  i2 = i1 + texture - 1
!-- b
!   (parameter to adjust 'b', the parameters for calculating soil water characteristic, in beps_soilMode.F90)
  CALL PUSHINTEGER4(i1)
  i1 = i2 + 1
  CALL PUSHINTEGER4(i2)
  i2 = i1 + texture - 1
!-- f_leaf
!   (...)
  CALL PUSHINTEGER4(i1)
  i1 = i2 + 1
!-- kc25
!   (...)
!-- ko25
!   (...)
!-- tau25
!   (...)
  xphys_bw = 0.0_8
  xphys_bw(i1) = xphys_bw(i1) + assim_bw%p_f_leaf
  CALL POPINTEGER4(i1)
  xphys_bw(i1:i2) = xphys_bw(i1:i2) + assim_bw%p_b_scalar
  CALL POPINTEGER4(i2)
  CALL POPINTEGER4(i1)
  xphys_bw(i1:i2) = xphys_bw(i1:i2) + assim_bw%p_ksat_scalar
  CALL POPINTEGER4(i2)
  CALL POPINTEGER4(i1)
  xphys_bw(i1:i2) = xphys_bw(i1:i2) + assim_bw%p_sif_beta
  CALL POPINTEGER4(i2)
  CALL POPINTEGER4(i1)
  xphys_bw(i1:i2) = xphys_bw(i1:i2) + assim_bw%p_sif_alpha
  CALL POPINTEGER4(i2)
  CALL POPINTEGER4(i1)
  xphys_bw(i1:i2) = xphys_bw(i1:i2) + assim_bw%p_vj_slope
  CALL POPINTEGER4(i2)
  i1 = 1
  xphys_bw(i1:i2) = xphys_bw(i1:i2) + assim_bw%p_vcmax
  x_bw = x_bw + x_sigma*xphys_bw
END SUBROUTINE X2BEPS_BW

!       module to compute model-data misfit
!       ilab march 2021
!       last: 06/2022
SUBROUTINE MISFIT_CD(n, x, m, obsdiff)
  IMPLICIT NONE
! arguments
  INTEGER(kind=4), INTENT(IN) :: n, m
  REAL(kind=8), INTENT(IN) :: x(n)
  REAL(kind=8), INTENT(OUT) :: obsdiff(m)
! local
  REAL(kind=8) :: y(m), yobs(m), syobs(m), obs_missing_value
  EXTERNAL GETOBS
  LOGICAL, DIMENSION(m) :: mask
! read obs
  CALL GETOBS(m, yobs, syobs, obs_missing_value)
! simulate obs
  CALL EVALF_CD(n, x, m, y)
! difference
  mask = yobs .NE. obs_missing_value
  WHERE (mask) 
    obsdiff = (y-yobs)/syobs
  ELSEWHERE
    obsdiff = 0.
  END WHERE
END SUBROUTINE MISFIT_CD

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!> \file bepsfunc.F90
!> \brief defines a functional implementation for running BEPS model,
!>        and defines the interface for using BEPS within
!>        a sensitivity and/or optimisation framework.
!>        It defines the top-level interface 'evalf' that maps
!>        a one-dimensional control vector (normalised coordinates)
!>        to a one-dimensional simulation vector.
!>        Please note, that the implementation core of this routine
!>        was taken/transferrred from the original BEPS driver.
!>
!> \authors The Inversion Lab (Michael Vossbeck, Thomas Kaminski) 
!> \date  January 2020 (with several updates applied thereafter)
!                               
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!***********************************************************
!     evalf
!
!> @brief function like BEPS model evaluation (or simulation)
!>        that maps a given one-dimensional control vector x ("independents")
!>        in normalised units to a one-dimensional simulation vector y ("dependents")
!>        The 1D control vector captures 3 BEPS quantities (SIF, Thetam, COSflux),
!>        ordering in the 1D vector is (varying slowest to fastest)
!>        time (hourly), site, BEPS-quantity.
!>
!> @param[in]   n   length of control vector
!> @param[in]   x   control vector (in normalised units)
!> @param[in]   m   length of simulation vector
!> @param[out]  y   simulation vector
!
!> \authors Michael Vossbeck, The Inversion Lab
!> \date    January 2020
!> \last    June 2022
!>
SUBROUTINE EVALF_CD(n, x, m, y)
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE BEPS_CON, ONLY : pi
  USE CONTROLINPUT_MOD_DIFF, ONLY : lai_input, meteo_input, sim_duration&
& , restart_frq, nscale, read_meteo_site, read_meteo_daily, &
& read_meteo_hourly, read_lai_site, read_lai
! use controlInput_mod
  USE BEPSTYPE_DIFF, ONLY : bound, clim, assim
  USE ECORESPMOD_DIFF, ONLY : plant_resp, soil_resp
  USE MID_RESULTS_DIFF
  USE BEPS_SOILMOD_DIFF, ONLY : soil, init_soil_parameters, &
& init_soil_status
  USE BEPS_PAR
  USE OUTPUTMOD_DIFF, ONLY : output, av_output
  USE RESTART_DIFF, ONLY : v2last, restart_io
  USE MO_BEPSFUNC_CTL
  IMPLICIT NONE
! arguments
  INTEGER, INTENT(IN) :: n, m
  REAL(kind=8), INTENT(IN) :: x(n)
  REAL(kind=8), INTENT(OUT) :: y(m)
! local declarations
  CHARACTER(len=*), PARAMETER :: sub='evalf_cd'
  TYPE(CLIMATEDATA) :: meteo
  TYPE(RESULTS) :: mid_res
!! solar zenith angle, local time, local time arc
  REAL(r8) :: coszs, hr_loc, hr_arc
  INTEGER :: i, j, k, jj, ii, kk
!! at single point
  TYPE(SOIL) :: soilp
  REAL(r8) :: ccd(0:4), cssd(0:4), csmd(0:4), cfsd(0:4), cfmd(0:4), csm(&
& 0:4), cm(0:4), cs(0:4), cp(0:4)
  REAL(r8) :: param(0:49), var_o(0:40), var_n(0:40), coef(0:49)
  REAL(r8) :: lai
  REAL(r8) :: ratio_cloud, shortrad_df, shortrad_dir
!-- iLab::similar changes as in driver.F90 by MSWU@2020-09-21
! real(r8)             :: NPP_yr_acc           !! for storing yearly accumulated NPP, Mh/ha/s
! real(r8)             :: agb2vod
! real(r8)             :: D0(1:9)
! real(r8)             :: taweff(1:9)
  INTEGER :: kount, rst_nstep
  INTEGER :: yr, mn, dy, tod, caldy
  INTEGER :: yr_next, mn_next, dy_next, tod_next
  REAL(r8) :: daylen
! .. Parameters for model-internal use
  REAL(r8), SAVE :: pio180=pi/180.
! variables for daily input, used in climin and getmonth
  REAL(r8) :: spds, cpds
! .. Local Arrays
  REAL(r8) :: atmean, atrange
! .. Local Scalars ..
! real(r8)             :: r
  REAL(r8) :: rdaymid, delta, arg, h0, h1, sd, sd1, dhour, tmin, tmp1
  REAL(r8) :: a, b, sunset_arc
!! for counting the time-step number, i.e. ith step
  INTEGER :: nd
!-- iLab::ported from MSWU changes () in driver.f90
!-- index being passed to read_meteo_site
  INTEGER :: n_meteo
! .. Intrinsic Functions ..
  INTRINSIC ACOS, COS, SIN, MOD, ATAN, REAL
!-- counter for 1D simulation vector
  INTEGER :: jcnt
!-- number of days in (actual) year
  INTEGER :: doys
  LOGICAL :: is_end_curr_year, is_end_curr_month, is_end_curr_day, &
& is_first_step
  LOGICAL, SAVE :: bepsf_debug=.false.
  INTRINSIC MIN
  INTRINSIC MAX
  INTRINSIC SUM
!-- consistency
  IF (nscale .NE. 1) THEN
    WRITE(*, '(a)') ' FATAL::'//sub//&
&   ':setup was *not* set for site-level!'
    STOP
  ELSE IF (meteo_input .LT. 0) THEN
    WRITE(*, '(a)') ' FATAL::'//sub//&
&   ':for site-level only hourly meteorological input'//' is supported.'
    STOP
  ELSE IF (lai_input .LT. 0) THEN
    WRITE(*, '(a)') ' FATAL::'//sub//&
&   ':for site-level LAI is expected to be forcing input.'
    STOP
  ELSE
! parameters used for calculating VOD,@MOUSONG.WU,2019-11
!-- iLab::similar changes as in driver.F90 by MSWU@2020-09-21
! NPP_yr_acc = 0.
! agb2vod = 0.9517
! D0 = (/0.05,0.05,0.05,0.05,0.05,0.05,0.05,0.05,0.05/)
! taweff = (/15.0, 15.0, 0., 0., 0., 15., 0., 0., 15./)
    output%npp_yr_acc = 0._r8
!-- initialise simulation vector
    y = fillval_r8
!-- map actual control vector to model parameter
    CALL X2BEPS_CD(n, x)
    jcnt = 1
!! end time loop
!! start time looping
timeloop:DO nd=1,ntp
      yr = time_points(1, nd)
      mn = time_points(2, nd)
      dy = time_points(3, nd)
      tod = time_points(4, nd)
      caldy = time_points(5, nd)
      doys = time_points(6, nd)
      is_first_step = nd .EQ. 1
!--iLab::equations taken from beps_time_manager
      is_end_curr_year = mn .EQ. 1 .AND. dy .EQ. 1 .AND. tod .EQ. 0
      is_end_curr_month = dy .EQ. 1 .AND. tod .EQ. 0
      is_end_curr_day = tod .EQ. 0
      CALL GET_CO2_CONCENTRATION(yr, co2_air)
      CALL GET_COS_CONCENTRATION(yr, cos_air)
!! change hourly input into daily input for further using model for long-term simulations, @MOUSONG.WU, 201905
      IF (meteo_input .GE. 0) THEN
! call hourly meteo. input
        IF (nscale .EQ. 0) THEN
          CALL READ_METEO_HOURLY(yr, mn, dy, tod)
        ELSE
!-- iLab::adapted index (similar to changes in driver.f90 by MSWU,bepspkg_2020-09-21_essi)
          CALL GET_NMETEO_CD(yr, mn, dy, tod, n_meteo)
          CALL READ_METEO_SITE(n_meteo)
        END IF
      ELSE IF (is_first_step .OR. is_end_curr_day) THEN
        CALL READ_METEO_DAILY(yr, mn, dy, tod)
      END IF
      IF (lai_input .GE. 0) THEN
! print *, 'lai is input!'
        IF (is_first_step .OR. is_end_curr_day) THEN
          IF (nscale .EQ. 0) THEN
            CALL READ_LAI(yr, mn, dy, tod, caldy)
          ELSE
            CALL READ_LAI_SITE(caldy)
          END IF
        END IF
      END IF
! print *, 'lai is simulated with phenology scheme!'
!! end spatial loop
! Reading the Vcmax here for assimilation usage @J.Wang
!if(is_first_step() .or. is_end_curr_month()) then
!   if (nscale == 0) then
!    call read_Vcmax(yr, mn, dy, tod)
!   else
!    call read_Vcmax_site(yr, mn, dy, tod)
!   end if
!end if
!    call mpi_barrier(mpi_comm_world,ierr)
!! spatial iteration
pointloop:DO i=1,npoints
!! calculate the solar zenith
        CALL S_COSZS(yr, mn, dy, tod, caldy, doys, bound%latitude(i), &
&              bound%longitude(i), coszs, hr_loc, hr_arc)
!!if(myid == 0) write(*,*) "hr_loc=",hr_loc
!! retrieve meteo for this point
        meteo%srad = clim%srad(i)
        meteo%wind = clim%wind(i)
        meteo%rainfall = clim%rain(i)
        meteo%snow = clim%snow(i)
        meteo%rh = clim%rh(i)
        IF (meteo_input .LT. 0) THEN
! read daily max and min temperatures instead
          meteo%tempmx = clim%tempmx(i)
          meteo%tempmn = clim%tempmn(i)
        ELSE
          meteo%temp = clim%temp(i)
        END IF
! .. compute daily course of temperature and daylength
        rdaymid = REAL(sim_duration+1)/2.
        delta = -(23.4*COS(2.*pi*(rdaymid+10.)/365.))
        spds = SIN(bound%latitude(i)*pio180)*SIN(delta*pio180)
        cpds = COS(bound%latitude(i)*pio180)*COS(delta*pio180)
        arg = -(spds/cpds)
        IF (arg .GT. 1.) THEN
!        polar night:
          daylen = 0.
        ELSE IF (arg .LT. -1) THEN
!        polar day:
          daylen = 24.
        ELSE
!        normal day / night:
          daylen = ACOS(arg)/pi*24.
        END IF
!###########Compute subdaily temperature based on daily input,@MOUSONG.WU,201905#####################
        IF (meteo_input .LT. 0) THEN
! .. compute average conditions
          atmean = (meteo%tempmx+meteo%tempmn)/2.
          atrange = meteo%tempmx - meteo%tempmn
!  hour angle at sunset, added by MOUSONG.WU, 201905
          sunset_arc = daylen/2.*2.0*pi/24.0
          IF (daylen .GE. 4. .AND. daylen .LE. 20.) THEN
!        sunrise
            h0 = 12. - daylen/2.
!        sundown
            h1 = 12. + daylen/2.
!        at sundown:
            sd1 = SIN(pi*(2.*h1+(daylen-52.)/2.)/(daylen+4.))
!! unroll zum vektorisieren
            IF (hr_loc .GT. h0 .AND. hr_loc .LT. h1) THEN
              sd = SIN(pi*(2.*hr_loc+(daylen-52.)/2.)/(daylen+4.))
              meteo%temp = atmean + atrange/2.*sd
            ELSE
! temperature at sundown
              tmp1 = atmean + atrange/2.*sd1
! hours since sundown
              dhour = MOD(hr_loc - h1 + 24., 24.)
              tmin = atmean - atrange/2.
              meteo%temp = tmp1 - (tmp1-tmin)*(dhour/(24.-daylen))
            END IF
          ELSE IF (daylen .GT. 20.) THEN
            sd = COS(pi*(hr_loc-14.)/(daylen/2.+2.))
            meteo%temp = atmean + atrange/2.*sd
          ELSE
            meteo%temp = atmean
          END IF
          clim%temp(i) = meteo%temp
! convert daily solar radiation into hourly using the method by M. Collares-Pereira and A. Rabl,
! The average distribution of solar radiation-correlations between diffuse and hemispherical
!and between daily and hourly insolation values, Solar Energy,vol. 22, no. 2, pp. 155164, 1979.
          a = 0.409 + 0.5016*SIN(sunset_arc-60.)
          b = 0.6609 - 0.4767*SIN(sunset_arc-60.)
          meteo%srad = meteo%srad*(a+b*COS(hr_arc))*(pi/24.)*(COS(hr_arc&
&           )-COS(sunset_arc))/(SIN(sunset_arc)-2*pi*sunset_arc/360.*COS&
&           (sunset_arc))
        END IF
! Calculate cloud fraction, separate shortwave radiation
        IF (coszs .LT. 0.001) THEN
          ratio_cloud = 0.
        ELSE
          ratio_cloud = meteo%srad/(1367.*coszs)
        END IF
        IF (ratio_cloud .GT. 0.8) THEN
          shortrad_df = 0.13*meteo%srad
        ELSE
          shortrad_df = (0.943+0.734*ratio_cloud-4.9*ratio_cloud**2+&
&           1.796*ratio_cloud**3+2.058*ratio_cloud**4)*meteo%srad
        END IF
        IF (shortrad_df .GT. meteo%srad) THEN
          shortrad_df = meteo%srad
        ELSE
          shortrad_df = shortrad_df
        END IF
        IF (shortrad_df .LT. 0.) THEN
          shortrad_df = 0.
        ELSE
          shortrad_df = shortrad_df
        END IF
        shortrad_dir = meteo%srad - shortrad_df
        meteo%s_dff = shortrad_df
        meteo%s_dir = shortrad_dir
        clim%swdr(i) = shortrad_dir
        clim%swdf(i) = shortrad_df
!! end PFT loop
!! PFT iteration
pftloop:DO j=1,pft
          IF (bound%lcno(i, j) .GT. 0 .AND. bound%sw(i) .GT. 0. .AND. &
&             bound%stext(i) .GT. 0 .AND. bound%clumping(i) .GT. 0.5) &
&         THEN
            CALL READPARAM(bound%lcno(i, j), param)
            IF (lai_input .GE. 0) THEN
              lai = bound%lai(i, j)
            ELSE IF (is_first_step) THEN
              lai = bound%laiyr(i, j)
              mid_res%lai_old = lai
            ELSE
              lai = mid_res%lai_new
            END IF
            lai = lai*param(2)/bound%clumping(i)
            CALL READCOEF(bound%lcno(i, j), bound%stext(i), coef)
            IF (nsrest .EQ. nsrstartup .AND. is_first_step) THEN
              CALL INIT_SOIL_PARAMETERS(bound%lcno(i, j), bound%stext(i)&
&                                 , param(27), soilp)
!-- iLab::applied similar changes as in driver.F90 (MSWU@2020-09-21)
              soilp%r_drainage = param(26)
! soilp%r_drainage = assim%p_drainage(j)            ! read this
!para from NC file,@MOUSONG.WU,2019-11
              ii = bound%stext(i)
! write(*,*) 'p_Ksat = ',assim%p_Ksat(ii) 
! write(*,*) 'Ksat_old = ',soilp%Ksat(0)
              DO kk=0,4
                soilp%ksat(kk) = assim%p_ksat_scalar(ii)*soilp%ksat(kk)
                soilp%b(kk) = assim%p_b_scalar(ii)*soilp%b(kk)
              END DO
! replace these three para. above with values from nc
! file,@MOUSONG.WU,2019-11
              CALL INIT_SOIL_STATUS(soilp, bound%st(i), clim%temp(i), &
&                             bound%sw(i), bound%sdp(i))
              DO k=0,40
                var_o(k) = 0.
              END DO
              DO k=3,8
                var_o(k) = clim%temp(i)
              END DO
              DO k=9,14
                var_o(k) = soilp%temp_soil_p(k-9)
              END DO
              DO k=21,26
                var_o(k) = soilp%thetam_prev(k-21)
              END DO
              DO k=27,32
                var_o(k) = soilp%ice_ratio(k-27)
              END DO
            ELSE IF (nsrest .EQ. nsrcontinue .AND. is_first_step) THEN
              CALL INIT_SOIL_PARAMETERS(bound%lcno(i, j), bound%stext(i)&
&                                 , param(27), soilp)
!-- iLab::applied similar changes as in driver.F90 (MSWU@2020-09-21)
              soilp%r_drainage = param(26)
! soilp%r_drainage = assim%p_drainage(j)  ! read from nc
!                                         ! file,MOUSONG.WU@2019-11
              ii = bound%stext(i)
              DO kk=0,4
                soilp%ksat(kk) = assim%p_ksat_scalar(ii)*soilp%ksat(kk)
                soilp%b(kk) = assim%p_b_scalar(ii)*soilp%b(kk)
              END DO
!Replace with NC values,for optimization
!purpose,@MOUSONG.WU,2019-11
              var_o(:) = v2last(i, :, j)
              DO k=9,14
                soilp%temp_soil_c(k-9) = var_o(k)
              END DO
              DO k=21,26
                soilp%thetam(k-21) = var_o(k)
              END DO
            ELSE
!                 do k = 27,32
!                    soilp%ice_ratio(k-27)   = var_o(k)
!                 end do
              var_o(:) = v2last(i, :, j)
              CALL RETRIVE_SOILP_CD(soilp, i, j, 0)
            END IF
!!! simulating photosynthesis
!              do llll = 0,40
!                 write(*,*)  "DG004: Var_o = ",llll, var_o(llll)
!              end do
            CALL INTER_PRG_CD(yr, mn, dy, tod, lai, lai_input, bound%&
&                       lcno(i, j), bound%clumping(i), assim%p_vcmax(j)&
&                       , assim%p_vj_slope(j), assim%p_f_leaf, assim%&
&                       p_kc25, assim%p_ko25, assim%p_tau25, assim%&
&                       p_sif_alpha(j), assim%p_sif_beta(j), param, &
&                       meteo, coszs, var_o, var_n, soilp, mid_res, &
&                       daylen)
! CHANGE Vcmax read from Vcmax file with the Vcmax read from initial para. NC
! file, for optimization purpose,@MOUSONG.WU,2019-11
!              do llll =0,40
!                write(*,*)  "DG004: Var_n = ",llll,var_n(llll)
!             end do
            v2last(i, :, j) = var_n(:)
            CALL RETRIVE_SOILP_CD(soilp, i, j, 1)
!!! simluating Ra
            CALL PLANT_RESP(assim%p_q10(j), bound%lcno(i, j), mid_res, &
&                     bound%laiyr(i, j), lai, meteo%temp, soilp%&
&                     temp_soil_c(1), coszs)
!USE p_q10 here to adjust q10,p_q10 is read from initial para. NC file, for
!optimization purpose,@MOUSONG.WU,2019-11
!!! simulating Rh
            ccd(0) = bound%ccd(i, j)
            cssd(0) = bound%cssd(i, j)
            csmd(0) = bound%csmd(i, j)
            cfsd(0) = bound%cfsd(i, j)
            cfmd(0) = bound%cfmd(i, j)
            csm(0) = bound%csm(i, j)
            cm(0) = bound%cm(i, j)
            cs(0) = bound%cm(i, j)
            cp(0) = bound%cp(i, j)
! to get soil texture for this point,@MOUSONG.WU,2019-11
            jj = bound%stext(i)
!-- iLab::similar changes as in driver.F90 (MSWU@2020-09-21),
!         'beta' no longer parameter
            CALL SOIL_RESP(ccd, cssd, csmd, cfsd, cfmd, csm, cm, cs, cp&
&                    , bound%nppyr(i, j), coef, bound%stext(i), soilp, &
&                    mid_res)
! call soil_resp(Ccd,Cssd,Csmd,Cfsd,Cfmd,Csm,Cm,Cs,&
!      Cp,bound%nppyr(i,j),coef,bound%stext(i),assim%p_beta(jj),soilp,mid_res)
! !! use p_beta read from initial para. NC file, to adjust slow
! !carbon pool, for optimization purpose,@MOUSONG.WU,2019-11
! mid_res%COS_grnd2 = mid_res%COS_grnd2 * (mid_res%NPP - mid_res%NEP)
! ! COS_flux_buf = mid_res%COS_plant + max(mid_res%COS_grnd1,mid_res%COS_grnd2)
! mid_res%COS_flux  = mid_res%COS_plant + max(mid_res%COS_grnd1,mid_res%COS_grnd2)
!! for output variables
! remove 100. for site since the PCT_PFT is fraction, @MOUSONG.WU,2019-11
            output%gpppft(i, j) = mid_res%gpp*bound%pct_pft(i, j)/100.
            output%sifpft(i, j) = mid_res%sif*bound%pct_pft(i, j)/100.
            output%npppft(i, j) = mid_res%npp*bound%pct_pft(i, j)/100.
            output%neppft(i, j) = mid_res%nep*bound%pct_pft(i, j)/100.
            output%shpft(i, j) = mid_res%sh*bound%pct_pft(i, j)/100.
            output%lhpft(i, j) = mid_res%lh*bound%pct_pft(i, j)/100.
            output%transpft(i, j) = mid_res%trans*bound%pct_pft(i, j)/&
&             100.
            output%evappft(i, j) = mid_res%evap*bound%pct_pft(i, j)/100.
            output%net_radpft(i, j) = mid_res%net_rad*bound%pct_pft(i, j&
&             )/100.
            output%laipft(i, j) = lai*bound%pct_pft(i, j)/100.
            output%thetampft(i, j) = mid_res%thetam_surf*bound%pct_pft(i&
&             , j)/100.
            output%faparpft(i, j) = mid_res%fapar*bound%pct_pft(i, j)/&
&             100.
!-- iLab::COS_flux computation now similar as in driver.F90 (MSWU@2020-09-21)
            output%cos_fluxpft(i, j) = (mid_res%cos_plant+mid_res%&
&             cos_grnd)*bound%pct_pft(i, j)/100.
!-- iLab::annual NPP, VOD computation now similar as in driver.F90 (MSWU@2020-09-21)
! convert NPP to Mg/ha for calculation of VOD
            output%npp_yr_acc(i, j) = output%npp_yr_acc(i, j) + mid_res%&
&             npp*bound%pct_pft(i, j)/100.*1.e-2*step
            IF (is_end_curr_year) THEN
! calculate VOD (vegetation optical depth) with results derived from SMOS-IC product, @Mousong.Wu, 201905,taweff is a PFT specifi
!c parameter
              output%vodpft(i, j) = assim%p_agb2vod*ATAN(assim%p_taweff(&
&               j)*output%npp_yr_acc(i, j)) + assim%p_d0(j)*lai
              output%npp_yr_acc(i, j) = 0.
!                  write(*,*) 'VOD= ',output%VODpft(i,j)
            ELSE
              output%vodpft(i, j) = 0.
            END IF
! write(*,*) 'hr_loc = ', hr_loc
!! calculate the OCO-2 SIF   across at 1:30pm
!write(*,*) 'SIFpft= ',mid_res%SIF*bound%PCT_PFT(i,j)/100. 
            IF (hr_loc .GE. 13. .AND. hr_loc .LT. 14.) THEN
              output%sifpft_sat(i, j) = mid_res%sif*bound%pct_pft(i, j)/&
&               100.
            ELSE
              output%sifpft_sat(i, j) = 0.
            END IF
          END IF
        END DO pftloop
!output%SIFpft_sat(i,j) = max(output%SIFpft_sat(i,j),0.)
!write(*,*) 'SIFpft_sat = ', output%SIFpft_sat(i,j)
        output%gpp(i) = SUM(output%gpppft(i, :))
        output%sif(i) = SUM(output%sifpft(i, :))
        output%sif_sat(i) = SUM(output%sifpft_sat(i, :))
        output%npp(i) = SUM(output%npppft(i, :))
        output%nep(i) = SUM(output%neppft(i, :))
        output%sh(i) = SUM(output%shpft(i, :))
        output%lh(i) = SUM(output%lhpft(i, :))
        output%trans(i) = SUM(output%transpft(i, :))
        output%evap(i) = SUM(output%evappft(i, :))
        output%net_rad(i) = SUM(output%net_radpft(i, :))
        output%lai(i) = SUM(output%laipft(i, :))
        output%thetam(i) = SUM(output%thetampft(i, :))
        output%fapar(i) = SUM(output%faparpft(i, :))
        output%vod(i) = SUM(output%vodpft(i, :))
        output%cos_flux(i) = SUM(output%cos_fluxpft(i, :))
!--iLab::mapping to target vector:SIF/Thetam/COSflux ->per time ->per point
!        (see mo_bepsfunc_ctl.f90 for order of simulated BEPS quantities)
        y(jcnt) = output%sif(i)
        y(jcnt+1) = output%thetam(i)
        y(jcnt+2) = output%cos_flux(i)
        jcnt = jcnt + 3
      END DO pointloop
    END DO timeloop
!          call mpi_barrier(mpi_comm_world,ierr)
!--iLab::target vector should have been written completely (dimension consistency)!
    IF (jcnt - 1 .NE. m) WRITE(*, '(a,2(a,i4,1x))') &
&                   ' FATAL::dimension inconsistency for target mapping'&
&                        , 'expected m=', m, 'got jcnt=', jcnt
  END IF
END SUBROUTINE EVALF_CD

!! Last update: July,2015
!! Fortran version: 3/5/2017 @J.Wang
SUBROUTINE INTER_PRG_CD(yr, mn, dy, tod, lai, lai_input, lc, clumping, &
& vcmax0, vj_slope, f_leaf, p_kc25, p_ko25, p_tau25, sif_alpha, sif_beta&
& , param, meteo, coszs, var_o, var_n, soilp, mid_res, daylen)
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
!--iLab::restrict use of beps_time_manager to required entities  
!--iLab-update::extended arguments to avoid time manager completely
! use beps_time_manager, only:is_end_curr_day, get_curr_date
  USE BEPS_SOILMOD_DIFF
  USE BEPSTYPE_DIFF
  USE MID_RESULTS_DIFF
  USE BEPS_PAR
  USE ANGSMOD_DIFF
  USE RAINSNOWMOD_DIFF
  IMPLICIT NONE
!--iLab::added date-elements as argument to avoid 'call get_curr_date' further below
  INTEGER, INTENT(IN) :: yr, mn, dy, tod
  INTEGER, INTENT(IN) :: lc
!!J.Wang
  REAL(r8), INTENT(IN) :: clumping, vcmax0, vj_slope, f_leaf, p_ko25, &
& p_kc25, p_tau25, sif_alpha, sif_beta, coszs, daylen
  REAL(r8), INTENT(IN) :: param(0:49)
  TYPE(CLIMATEDATA), INTENT(IN) :: meteo
  REAL(r8), INTENT(IN) :: var_o(0:40)
  REAL(r8), INTENT(OUT) :: var_n(0:40)
  REAL(r8), INTENT(INOUT) :: lai
  TYPE(SOIL) :: soilp
  TYPE(RESULTS) :: mid_res
  INTEGER, INTENT(IN) :: lai_input
!real(r8),intent(out) :: gs_h2o,G_o_b
  INTEGER :: num, kkk, i, j
  INTEGER, PARAMETER :: iter_max=20
  INTEGER :: landcover
  REAL(r8) :: lai_o, lai_u, stem_o, stem_u
  REAL(r8) :: d_soil(0:layer)
!the depth of snow on the surface
  REAL(r8) :: zsp
!depth of pounded water on the surface
  REAL(r8) :: zp
  REAL(r8), SAVE :: zp1=0.
  REAL(r8), SAVE :: zp2=0.
!height of the Va measured for calculation of L
  REAL(r8) :: height_wind_sp
!sensible heating
  REAL(r8) :: qhc_o(0:iter_max), qhc_u(0:iter_max), qhg(0:iter_max)
!the heat flux into the canopy of over story --in W/m^2
  REAL(r8) :: g(0:layer+1, 0:iter_max)
!the masses od rain and snow on the canopy
  REAL(r8) :: wcl_o(0:iter_max), wcs_o(0:iter_max)
!the fractoion of canopy coverd by liquid water and snow
  REAL(r8) :: xcl_o(0:iter_max), xcs_o(0:iter_max)
  REAL(r8) :: wcl_u(0:iter_max), wcs_u(0:iter_max)
  REAL(r8) :: xcl_u(0:iter_max), xcs_u(0:iter_max)
!the rainfall rate on ground surface m/s
  REAL(r8) :: r_rain_g(0:iter_max)
!density of snow
  REAL(r8) :: rho_snow(0:iter_max)
!albedo of snow
  REAL(r8) :: alpha_v_sw(0:iter_max), alpha_n_sw(0:iter_max)
! amount of snow on ground
  REAL(r8) :: wg_snow(0:iter_max)
! fraction of the ground surface overed by snow
  REAL(r8) :: xg_snow(0:iter_max)
! area of canopy covered by snow
  REAL(r8) :: ac_snow_o(0:iter_max), ac_snow_u(0:iter_max)
!surface temperature
  REAL(r8) :: ts0(0:iter_max), tsn0(0:iter_max), tsm0(0:iter_max), tsn1(&
& 0:iter_max), tsn2(0:iter_max)
!effective canopy temperature in K
  REAL(r8) :: tc_u(0:iter_max)
!soil temperature at the bottom and middle of each layer
  REAL(r8) :: tm(0:layer+1, 0:iter_max)
!thermal conductivity of each soil layer
  REAL(r8) :: lambda_soil(0:layer+1)
! soil volumetric hear capacity of each soil layer J/m3/K
  REAL(r8) :: cs(0:layer+1, 0:iter_max)
  REAL(r8) :: temp_air, temp_grd
!%,m/s,m/s @J.Wang  make original precipitation into rainfall and snow
  REAL(r8) :: rh_air, wind_sp, snow, rainfall
!the evaporation rate of intercepted water of overstory--in kg/m^2/s
  REAL(r8) :: eil_o(0:iter_max), eis_o(0:iter_max)
  REAL(r8) :: eil_u(0:iter_max), eis_u(0:iter_max)
!transpiration
  REAL(r8) :: trans_o(0:iter_max), trans_u(0:iter_max)
  REAL(r8) :: evap_soil(0:iter_max)
!evaporation from water pond
  REAL(r8) :: evap_sw(0:iter_max)
!evaporation from snow pack
  REAL(r8) :: evap_ss(0:iter_max)
!effective thermal conductivity of snow in m2/s
  REAL(r8) :: lambda_snow(0:iter_max)
! vapour partial pressure of water in kPa
  REAL(r8) :: e_a10
! the latent heat of vaporation from liquid at air temperature=Ta
  REAL(r8) :: lv_liquid
! the latent heat of vaporation from solid (snow/ice) at air temperature
  REAL(r8), SAVE :: lv_solid=2.83*1e6
! instantaneous total short wave radiation (Global radiation)
  REAL(r8) :: ks
  REAL(r8) :: alpha_sat, alpha_dry
!visible albedo of overstory,  o--overstory, u--understory
  REAL(r8) :: alpha_v_o, alpha_v_u
!near_infrared albedo
  REAL(r8) :: alpha_n_o, alpha_n_u
! all-wave ground surface albedo
  REAL(r8) :: alpha_g
  REAL(r8) :: alpha_v_g, alpha_n_g
! specific heat of moist air above the canopy
  REAL(r8) :: cp_ca
! the aerodynamic resistance of overstory, understory and ground surface
  REAL(r8) :: ra_o, ra_u, ra_g
! actural canopy stomatal resistance  --in s/m
  REAL(r8) :: q_ca
  REAL(r8) :: radiation_o, radiation_u, radiation_g
!the cumulative infiltration at the time of ponding   --in m/s
  REAL(r8), SAVE :: ip=0.
  REAL(r8), SAVE :: infil=0.
  REAL(r8), SAVE :: zr=0.8
  REAL(r8), SAVE :: cpd=1004.65
  REAL(r8) :: cs_o_sunlit_old, cs_o_shaded_old, cs_u_sunlit_old, &
& cs_u_shaded_old
! CO2 concentration on the surfaces of leaves
  REAL(r8) :: coss_o_sunlit_old, coss_o_shaded_old, coss_u_sunlit_old, &
& coss_u_shaded_old
! COS concentration on the surfaces of leaves
  REAL(r8) :: tc_o_sunlit_old, tc_o_shaded_old, tc_u_sunlit_old, &
& tc_u_shaded_old
! the effective canopy temperature in K
  REAL(r8) :: gs_o_sunlit_new, gs_o_shaded_new, gs_u_sunlit_new, &
& gs_u_shaded_new
!stomatal conductance of the big leaf     for water
  REAL(r8) :: gs_o_sunlit_old, gs_o_shaded_old, gs_u_sunlit_old, &
& gs_u_shaded_old
! net photosynthesis rate
  REAL(r8) :: ac_o_sunlit, ac_o_shaded, ac_u_sunlit, ac_u_shaded
  REAL(r8) :: cs_o_sunlit_new, cs_o_shaded_new, cs_u_sunlit_new, &
& cs_u_shaded_new
! CO2 concentration on the surfaces of     leaves
  REAL(r8) :: coss_o_sunlit_new, coss_o_shaded_new, coss_u_sunlit_new, &
& coss_u_shaded_new
! COS concentration on the surfaces of     leaves
  REAL(r8) :: ci_o_sunlit_new, ci_o_shaded_new, ci_u_sunlit_new, &
& ci_u_shaded_new
! intercellular CO2 concentration pn th    e leaf
  REAL(r8) :: cosi_o_sunlit_new, cosi_o_shaded_new, cosi_u_sunlit_new, &
& cosi_u_shaded_new
! intercellular COS concentration pn the leaf
  REAL(r8) :: ci_o_sunlit_old, ci_o_shaded_old, ci_u_sunlit_old, &
& ci_u_shaded_old
  REAL(r8) :: cosi_o_sunlit_old, cosi_o_shaded_old, cosi_u_sunlit_old, &
& cosi_u_shaded_old
  REAL(r8) :: cc_o_sunlit_new, cc_o_shaded_new, cc_u_sunlit_new, &
& cc_u_shaded_new
! CO2 concentration in the chloroplast
  REAL(r8) :: cosc_o_sunlit_new, cosc_o_shaded_new, cosc_u_sunlit_new, &
& cosc_u_shaded_new
! COS concentration in the chloroplast
  REAL(r8) :: tc_o_sunlit_new, tc_o_shaded_new, tc_u_sunlit_new, &
& tc_u_shaded_new
! the effective canopy temperature in K
! an emperical parameter describin    g the relative availability of soil water for plants
  REAL(r8) :: f_soilwater
! the total conductance for water from     the intercellular space of the leaves to the reference height above the canopy
  REAL(r8) :: gw_o_sunlit, gw_o_shaded, gw_u_sunlit, gw_u_shaded
! the total conductance for CO2 from th    e intercellular space of the leaves to the reference height above the canopy
  REAL(r8) :: gc_o_sunlit, gc_o_shaded, gc_u_sunlit, gc_u_shaded
! the total conductance for water from     the surface of the leaves to the reference height above the canopy
  REAL(r8) :: gww_o_sunlit, gww_o_shaded, gww_u_sunlit, gww_u_shaded
!total conductance for heat transfer f    rom the leaf surface to the reference height above the canopy
  REAL(r8) :: gh_o_sunlit, gh_o_shaded, gh_u_sunlit, gh_u_shaded
  REAL(r8) :: psychrometer
!solar radiation absorbed by sunlit, s    haded leaves
  REAL(r8) :: r_o_sunlit, r_o_shaded, r_u_sunlit, r_u_shaded
  REAL(r8) :: tco, tcu, slope
!sensible heat flux from leaves
  REAL(r8) :: h_o_sunlit, h_o_shaded
  REAL(r8) :: lai_o_sunlit, lai_o_shaded, lai_u_sunlit, lai_u_shaded
  REAL(r8) :: laio_sunlit, laio_shaded, laiu_sunlit, laiu_shaded
! net radiation of leaves
  REAL(r8) :: radiation_o_sun, radiation_o_shaded, radiation_u_sun, &
& radiation_u_shaded
  REAL(r8) :: gpp_o_sunlit, gpp_o_shaded, gpp_u_sunlit, gpp_u_shaded
!canopy level
  REAL(r8) :: sif_o_sunlit, sif_o_shaded, sif_u_sunlit, sif_u_shaded
!leaf level
  REAL(r8) :: lsif_o_sunlit, lsif_o_shaded, lsif_u_sunlit, lsif_u_shaded
!scat
  REAL(r8) :: stsif_o_sunlit, stsif_o_shaded, stsif_u_sunlit, &
& stsif_u_shaded
  REAL(r8) :: cos_o_sunlit, cos_o_shaded, cos_u_sunlit, cos_u_shaded
  REAL(r8) :: lcos_o_sunlit, lcos_o_shaded, lcos_u_sunlit, lcos_u_shaded
  REAL(r8) :: vps_air
  REAL(r8) :: gs_h2o
  REAL(r8) :: gh_o, g_o_a, g_o_b, g_u_a, g_u_b
  REAL(r8) :: canopyh_o, canopyh_u
  REAL(r8) :: vpd_air
  REAL(r8) :: mass_water_g
  REAL(r8) :: percentarea_snow_o, percentarea_snow_u
  REAL(r8) :: gheat_g
!the intercept term in BWB model (mol H2O m-2 s-1)
  REAL(r8) :: b_h2o
! the slope in BWB model
  REAL(r8) :: m_h2o
!leaf latent heat flux (mol/m2/s)
  REAL(r8) :: leleaf_o_sunlit, leleaf_o_shaded, leleaf_u_sunlit, &
& leleaf_u_shaded
!for the Vcmax-Nitrogen calculation
  REAL(r8), SAVE :: kn=0.3
  REAL(r8), SAVE :: g_theta=0.5
!real(r8)             :: K,Vcmax0,Vcmax_sunlit,Vcmax_shaded,expr1,expr2,expr3
!Vcmax0 as an input from outside
  REAL(r8) :: k, vcmax_sunlit, vcmax_shaded, expr1, expr2, expr3
  REAL(r8) :: slope_vcmax_n, leaf_n, jmax_sunlit, jmax_shaded
! for SIF simulation @JWang
  REAL(r8) :: ffpa
! for storing daily mean temperature
  REAL(r8) :: temp_day
! for storing daily mean surface soil moisture
  REAL(r8) :: theta_day
! for storing daily mean transpiration
  REAL(r8) :: trans_day
  REAL(r8) :: cosa
  REAL(r8) :: cos_soil
!--iLab::introduced to avoid calling is_end_curr_day() from beps_time_manager
  LOGICAL :: is_end_curr_day
  INTRINSIC EXP
  INTRINSIC INT
  INTRINSIC MAX
  INTRINSIC MIN
  INTRINSIC ABS
  REAL(r8) :: abs0
  REAL(r8) :: abs1
  REAL(r8) :: abs2
  REAL(r8) :: abs3
  REAL(r8) :: arg1
  REAL(r8) :: arg2
!--iLab: taken from BEPS time manager
  is_end_curr_day = tod .EQ. 0
  temp_day = 0.
  theta_day = 0.
  trans_day = 0.
  psychrometer = 0.066
  alpha_sat = param(24)
  alpha_dry = param(25)
! to be used for module aerodynamic_conductance
  canopyh_o = param(29)
  canopyh_u = param(30)
  height_wind_sp = param(31)
!height_wind_sp   = 30.
! used for photosynthesis
  m_h2o = param(33)
  b_h2o = param(34)
!-- iLab::g2_h2o is *only* set from other routines in case 'CosZs>0.',
!         so we *must* initialise it and have uncommented the initialiser
!         that was already present.
  gs_h2o = 0.
!gs_h2o      = 0.
! Vcmax-Nitrogen calculations by G,Mo 2011.04
  IF (coszs .GT. 0.) THEN
    k = g_theta*clumping/coszs
!   Vcmax0  = param(36)    !an input from outside @J.Wang
    IF (k .GT. 10.) THEN
!! adjust K range here to get rid of floating-point exceptions,@MOUSONG.WU
      expr1 = 1.
      expr2 = 1.
    ELSE
      expr1 = 1. - EXP(-(k*lai))
      expr2 = 1. - EXP(-(lai*(kn+k)))
    END IF
    expr3 = 1. - EXP(-(kn*lai))
    IF (expr1 .GT. 0.) THEN
      vcmax_sunlit = vcmax0*param(47)*param(46)*k*expr2/(kn+k)/expr1
    ELSE
      vcmax_sunlit = vcmax0
    END IF
    IF (k .GT. 0 .AND. lai .GT. expr1/k) THEN
      vcmax_shaded = vcmax0*param(47)*param(46)*(expr3/kn-expr2/(kn+k))/&
&       (lai-expr1/k)
    ELSE
      vcmax_shaded = vcmax0
    END IF
  END IF
!! LAI calculation module by B.Chen
  lai_o = lai
  IF (lai .LT. 0.1) lai_o = 0.1
  landcover = INT(param(4))
! Calculate ffpa as a function of lai, this makes the ffpa vary with time, instead of being a constant as below,@MOUSONG WU, 2020
!-09-14
  ffpa = 1. - EXP(-(0.45*lai))
  IF (1.e-2 .LT. ffpa) THEN
    ffpa = ffpa
  ELSE
    ffpa = 1.e-2
  END IF
  IF (1.0 .GT. ffpa) THEN
    ffpa = ffpa
  ELSE
    ffpa = 1.0
  END IF
! added for sif simulation @J. Wang
!select case (landcover)
!   case (1)    !conifer evergreen
!    ffpa = 0.6
!   case(2)      !conifer decidous
!    ffpa = 0.6
!   case(6)      !broadleaf decidous
!    ffpa = 0.8
!   case(9)      !broadleaf evergreen
!    ffpa = 0.8
!   case(10)     !mix
!    ffpa = 0.4
!   case(13)     !shrub
!    ffpa = 0.8
!   case(14)     ! grass
!    ffpa = 0.8
!   case(15)     ! crop
!    ffpa = 0.6
!   case(40)     ! c4 grass
!    ffpa = 0.6  
!   case(41)     ! C4 crop
!    ffpa = 0.6
!end select
!if(landcover == 25 .or. landcover ==40) then
  IF (((landcover .EQ. 14 .OR. landcover .EQ. 15) .OR. landcover .EQ. 40&
&     ) .OR. landcover .EQ. 41) THEN
!14->grass 15->crop @JWang
    lai_u = 0.01
  ELSE
    lai_u = 1.18*EXP(-(0.99*lai_o))
  END IF
  IF (lai_u .GT. lai_o) lai_u = 0.01
  stem_o = param(8)*0.2
  stem_u = param(9)*0.2
!Bing Chen
  CALL LAI_CAL(stem_o, stem_u, landcover, coszs, lai_o, clumping, lai_u&
&        , laio_sunlit, laio_shaded, laiu_sunlit, laiu_shaded, &
&        lai_o_sunlit, lai_o_shaded, lai_u_sunlit, lai_u_shaded)
!-------initalization of this time step
  ks = meteo%srad
  rh_air = meteo%rh
  wind_sp = meteo%wind
!m/s   liquid water
  rainfall = meteo%rainfall
!m/s   snow
  snow = meteo%snow
  temp_air = meteo%temp
  IF (ks .LE. 0) THEN
    alpha_v_o = 0.
    alpha_n_o = 0.
    alpha_v_u = 0.
    alpha_n_u = 0.
  ELSE
    alpha_v_o = param(22)
    alpha_n_o = param(23)
    alpha_v_u = param(22)
    alpha_n_u = param(23)
  END IF
  qhc_o(0) = var_o(1)
  ts0(0) = var_o(3)
  IF (ts0(0) - temp_air .GT. 2.0) ts0(0) = temp_air + 2.0
  IF (ts0(0) - temp_air .LT. -2.0) ts0(0) = temp_air - 2.0
  tsn0(0) = var_o(4)
  IF (tsn0(0) - temp_air .GT. 2.0) tsn0(0) = temp_air + 2.0
  IF (tsn0(0) - temp_air .LT. -2.0) tsn0(0) = temp_air - 2.0
  tsm0(0) = var_o(5)
  IF (tsm0(0) - temp_air .GT. 2.) tsm0(0) = temp_air + 2.0
  IF (tsm0(0) - temp_air .LT. -2.) tsm0(0) = temp_air - 2.0
  tsn1(0) = var_o(6)
  IF (tsn1(0) - temp_air .GT. 2.0) tsn1(0) = temp_air + 2.0
  IF (tsn1(0) - temp_air .LT. -2.) tsn1(0) = temp_air - 2.0
  tsn2(0) = var_o(7)
  IF (tsn2(0) - temp_air .GT. 2.0) tsn2(0) = temp_air + 2.0
  IF (tsn2(0) - temp_air .LT. -2.) tsn2(0) = temp_air - 2.0
!the mass of intercepted liquid water and snow, overstory
  wcl_o(0) = var_o(15)
  wcs_o(0) = var_o(16)
  wcl_u(0) = var_o(18)
  wcs_u(0) = var_o(19)
!  fraction of ground surface covered by snow and snow mass
  wg_snow(0) = var_o(20)
  soilp%zsp = var_o(33)
  soilp%zp = var_o(34)
  soilp%r_rain_g = var_o(35)
!-- iLab::*must* at least initialise arrays for complete number of iterations
!          (and not only the first element),
!         since elements are input/output(!) arguments to called routines
!         (snowpack_stage1,netRadiation)
  ac_snow_o(0:iter_max) = var_o(36)
  ac_snow_u(0:iter_max) = var_o(37)
  rho_snow(0:iter_max) = var_o(38)
  alpha_v_sw(0:iter_max) = var_o(39)
  alpha_n_sw(0:iter_max) = var_o(40)
! Ac_snow_o(0)    = var_o(36)
! Ac_snow_u(0)    = var_o(37)
! rho_snow(0)     = var_o(38)
! alpha_v_sw(0)   = var_o(39)
! alpha_n_sw(0)   = var_o(40)
  zsp = soilp%zsp
  zp = soilp%zp
  IF (zp .LT. 0.001) zp = 0.
!if(Zp < 1.e-6) Zp = 0.
  DO i=9,14
    soilp%temp_soil_p(i-9) = var_o(i)
  END DO
  DO i=21,26
    soilp%thetam_prev(i-21) = var_o(i)
  END DO
  DO i=27,32
    soilp%ice_ratio(i-27) = var_o(i)
  END DO
! vcmax jmax module  by L. He
  slope_vcmax_n = param(47)
  leaf_n = param(46)
  CALL VCMAX_JMAX(lai_o, clumping, vcmax0, vj_slope, slope_vcmax_n, &
&           leaf_n, coszs, vcmax_sunlit, vcmax_shaded, jmax_sunlit, &
&           jmax_shaded)
! temperatures of overstorey and understorey canopies
  tc_o_sunlit_old = temp_air - 0.5
  tc_o_shaded_old = temp_air - 0.5
  tc_u_sunlit_old = temp_air - 0.5
  tc_u_shaded_old = temp_air - 0.5
!sub-time iteration @J.Wang
  DO kkk=1,kloop
! Snow pack stage 1  by R.Luo
    CALL SNOWPACK_STAGE1(temp_air, snow, wcs_o(kkk-1), wcs_u(kkk-1), &
&                  wg_snow(kkk-1), rho_snow(kkk-1), ac_snow_o(kkk-1), &
&                  ac_snow_u(kkk-1), wcs_o(kkk), wcs_u(kkk), wg_snow(kkk&
&                  ), lai_o, lai_u, clumping, ac_snow_o(kkk), ac_snow_u(&
&                  kkk), xcs_o(kkk), xcs_u(kkk), xg_snow(kkk), rho_snow(&
&                  kkk), zsp, alpha_v_sw(kkk), alpha_n_sw(kkk))
!    write(*,*) "DG01: Ac_snow_o(kkk) =",Ac_snow_o(kkk)
! rainfall stag 1
    CALL RAINFALL_STAGE1(temp_air, rainfall, wcl_o(kkk-1), wcl_u(kkk-1)&
&                  , lai_o, lai_u, clumping, wcl_o(kkk), wcl_u(kkk), &
&                  xcl_o(kkk), xcl_u(kkk), r_rain_g(kkk))
    IF (soilp%thetam_prev(1) .LT. soilp%theta_vwp(1)*0.5) THEN
      alpha_g = alpha_dry
    ELSE
      alpha_g = (soilp%thetam_prev(1)-soilp%theta_vwp(1)*0.5)/(soilp%fei&
&       (1)-soilp%theta_vwp(1)*0.5)*(alpha_sat-alpha_dry) + alpha_dry
    END IF
    alpha_v_g = 2./3.*alpha_g
    alpha_n_g = 4./3.*alpha_g
! soil water factor module
    CALL SOIL_WATER_FACTOR_V2(soilp)
    f_soilwater = soilp%f_soilwater
    IF (f_soilwater .GT. 1.0) f_soilwater = 1.0
!used as the init. for module aerodynamic_conductance
    gh_o = qhc_o(kkk-1)
    vps_air = 0.61078*EXP(17.3*temp_air/(237.3+temp_air))
    e_a10 = vps_air*rh_air/100.
!water vapor deficit at the reference height @J.Wang maybe directly use meteo_pack
    vpd_air = vps_air - e_a10
!g/g  no dimention
    q_ca = 0.622*e_a10/(101.35-0.378*e_a10)
    cp_ca = cpd*(1.+0.84*q_ca)
    slope = 2503.0/(temp_air+237.3)**2*EXP(17.27*temp_air/(temp_air+&
&     237.3))
    gs_o_sunlit_old = 1./200.0
    ci_o_sunlit_old = 0.7*co2_air
    gs_o_shaded_old = 1./200.0
    ci_o_shaded_old = 0.7*co2_air
    gs_u_sunlit_old = 1./300.0
    ci_u_sunlit_old = 0.7*co2_air
    gs_u_shaded_old = 1./300.0
    ci_u_shaded_old = 0.7*co2_air
    cosi_o_sunlit_old = 0.7*cos_air
    cosi_o_shaded_old = 0.7*cos_air
    cosi_u_sunlit_old = 0.7*cos_air
    cosi_u_shaded_old = 0.7*cos_air
    percentarea_snow_o = ac_snow_o(kkk)/lai_o/2.
    percentarea_snow_u = ac_snow_u(kkk)/lai_u/2.
!ground temperature substituted by air temperature
    temp_grd = temp_air
    num = 0
    DO WHILE (.true.)
      num = num + 1
! aerodynamic_conductance module by G.Mo
      arg1 = lai_o + stem_o
      arg2 = lai_u + stem_u
      CALL AERODYNAMIC_CONDUCTANCE(canopyh_o, canopyh_u, height_wind_sp&
&                            , clumping, temp_air, wind_sp, gh_o, arg1, &
&                            arg2, ra_o, ra_u, ra_g, g_o_a, g_o_b, g_u_a&
&                            , g_u_b)
!heat conductance of sunlit leaves of overstorey
      gh_o_sunlit = 1.0/(1.0/g_o_a+0.5/g_o_b)
      gh_o_shaded = 1.0/(1.0/g_o_a+0.5/g_o_b)
      gh_u_sunlit = 1.0/(1.0/g_u_a+0.5/g_u_b)
      gh_u_shaded = 1.0/(1.0/g_u_a+0.5/g_u_b)
! conductance for intercepted water of sunlit leaves of overstorey
      gww_o_sunlit = 1.0/(1.0/g_o_a+1.0/g_o_b+100.)
      gww_o_shaded = 1.0/(1.0/g_o_a+1.0/g_o_b+100.)
      gww_u_sunlit = 1.0/(1.0/g_u_a+1.0/g_u_b+100.)
      gww_u_shaded = 1.0/(1.0/g_u_a+1.0/g_u_b+100.)
! temperatures of overstorey and understorey canopies
      tco = (tc_o_sunlit_old*lai_o_sunlit+tc_o_shaded_old*lai_o_shaded)/&
&       (lai_o_sunlit+lai_o_shaded)
      tcu = (tc_u_sunlit_old*lai_u_sunlit+tc_u_shaded_old*lai_u_shaded)/&
&       (lai_u_sunlit+lai_u_shaded)
! net Radiation at canopy and leaf level module by X.Luo
      arg1 = lai_o + stem_o
      arg2 = lai_u + stem_u
      CALL NETRADIATION_CD(meteo%s_dff, meteo%s_dir, coszs, tco, tcu, &
&                    temp_grd, lai_o, lai_u, arg1, arg2, lai_o_sunlit, &
&                    lai_o_shaded, lai_u_sunlit, lai_u_shaded, clumping&
&                    , temp_air, rh_air, alpha_v_sw(kkk), alpha_n_sw(kkk&
&                    ), percentarea_snow_o, percentarea_snow_u, xg_snow(&
&                    kkk), alpha_v_o, alpha_n_o, alpha_v_u, alpha_n_u, &
&                    alpha_v_g, alpha_n_g, radiation_o, radiation_u, &
&                    radiation_g, radiation_o_sun, radiation_o_shaded, &
&                    radiation_u_sun, radiation_u_shaded, r_o_sunlit, &
&                    r_o_shaded, r_u_sunlit, r_u_shaded)
! photosynthesis module by B. Chen
!conductance of sunlit leaves of overstorey for water
      gw_o_sunlit = 1.0/(1.0/g_o_a+1.0/g_o_b+1.0/gs_o_sunlit_old)
      gw_o_shaded = 1.0/(1.0/g_o_a+1.0/g_o_b+1.0/gs_o_shaded_old)
      gw_u_sunlit = 1.0/(1.0/g_u_a+1.0/g_u_b+1.0/gs_u_sunlit_old)
      gw_u_shaded = 1.0/(1.0/g_u_a+1.0/g_u_b+1.0/gs_u_shaded_old)
      leleaf_o_sunlit = gw_o_sunlit*(vpd_air+slope*(tc_o_sunlit_old-&
&       temp_air))*rho_a*cp_ca/psychrometer
      leleaf_o_shaded = gw_o_shaded*(vpd_air+slope*(tc_o_shaded_old-&
&       temp_air))*rho_a*cp_ca/psychrometer
      leleaf_u_sunlit = gw_u_sunlit*(vpd_air+slope*(tc_u_sunlit_old-&
&       temp_air))*rho_a*cp_ca/psychrometer
      leleaf_u_shaded = gw_u_shaded*(vpd_air+slope*(tc_u_shaded_old-&
&       temp_air))*rho_a*cp_ca/psychrometer
      IF (coszs .GT. 0.) THEN
        CALL PHOTOSYNTHESIS(landcover, tc_o_sunlit_old, f_leaf, p_kc25, &
&                     p_ko25, p_tau25, r_o_sunlit, e_a10, g_o_b, &
&                     vcmax_sunlit, vj_slope, f_soilwater, b_h2o, m_h2o&
&                     , ci_o_sunlit_old, temp_air, leleaf_o_sunlit, &
&                     gs_o_sunlit_new, gs_h2o, ac_o_sunlit, &
&                     ci_o_sunlit_new, ffpa, sif_alpha, sif_beta, &
&                     lsif_o_sunlit, cosi_o_sunlit_old, &
&                     cosi_o_sunlit_new, lcos_o_sunlit)
        CALL PHOTOSYNTHESIS(landcover, tc_o_shaded_old, f_leaf, p_kc25, &
&                     p_ko25, p_tau25, r_o_shaded, e_a10, g_o_b, &
&                     vcmax_shaded, vj_slope, f_soilwater, b_h2o, m_h2o&
&                     , ci_o_shaded_old, temp_air, leleaf_o_shaded, &
&                     gs_o_shaded_new, gs_h2o, ac_o_shaded, &
&                     ci_o_shaded_new, ffpa, sif_alpha, sif_beta, &
&                     lsif_o_shaded, cosi_o_shaded_old, &
&                     cosi_o_shaded_new, lcos_o_shaded)
        CALL PHOTOSYNTHESIS(landcover, tc_u_sunlit_old, f_leaf, p_kc25, &
&                     p_ko25, p_tau25, r_u_sunlit, e_a10, g_u_b, &
&                     vcmax_sunlit, vj_slope, f_soilwater, b_h2o, m_h2o&
&                     , ci_u_sunlit_old, temp_air, leleaf_u_sunlit, &
&                     gs_u_sunlit_new, gs_h2o, ac_u_sunlit, &
&                     ci_u_sunlit_new, ffpa, sif_alpha, sif_beta, &
&                     lsif_u_sunlit, cosi_u_sunlit_old, &
&                     cosi_u_sunlit_new, lcos_u_sunlit)
        CALL PHOTOSYNTHESIS(landcover, tc_u_shaded_old, f_leaf, p_kc25, &
&                     p_ko25, p_tau25, r_u_shaded, e_a10, g_u_b, &
&                     vcmax_shaded, vj_slope, f_soilwater, b_h2o, m_h2o&
&                     , ci_u_shaded_old, temp_air, leleaf_u_shaded, &
&                     gs_u_shaded_new, gs_h2o, ac_u_shaded, &
&                     ci_u_shaded_new, ffpa, sif_alpha, sif_beta, &
&                     lsif_u_shaded, cosi_u_shaded_old, &
&                     cosi_u_shaded_new, lcos_u_shaded)
      ELSE
        gs_o_sunlit_new = 0.0001
        ac_o_sunlit = 0.0
        lsif_o_sunlit = 0.0
        lcos_o_sunlit = 0.0
        ci_o_sunlit_new = co2_air*0.7
        cs_o_sunlit_new = co2_air
        cc_o_sunlit_new = co2_air*0.7*0.8
        cosi_o_sunlit_new = cos_air*0.7
        coss_o_sunlit_new = cos_air
        cosc_o_sunlit_new = cos_air*0.7*0.8
        gs_o_shaded_new = 0.0001
        ac_o_shaded = 0.0
        lsif_o_shaded = 0.0
        lcos_o_shaded = 0.0
        ci_o_shaded_new = co2_air*0.7
        cs_o_shaded_new = co2_air
        cc_o_shaded_new = co2_air*0.7*0.8
        cosi_o_shaded_new = cos_air*0.7
        coss_o_shaded_new = cos_air
        cosc_o_shaded_new = cos_air*0.7*0.8
        gs_u_sunlit_new = 0.0001
        ac_u_sunlit = 0.0
        lsif_u_sunlit = 0.
        lcos_u_sunlit = 0.
        ci_u_sunlit_new = co2_air*0.7
        cs_u_sunlit_new = co2_air
        cc_u_sunlit_new = co2_air*0.7*0.8
        cosi_u_sunlit_new = cos_air*0.7
        coss_u_sunlit_new = cos_air
        cosc_u_sunlit_new = cos_air*0.7*0.8
        gs_u_shaded_new = 0.0001
        ac_u_shaded = 0.0
        lsif_u_shaded = 0.
        lcos_u_shaded = 0.
        ci_u_shaded_new = co2_air*0.7
        cs_u_shaded_new = co2_air
        cc_u_shaded_new = co2_air*0.7*0.8
        cosi_u_shaded_new = cos_air*0.7
        coss_u_shaded_new = cos_air
        cosc_u_shaded_new = cos_air*0.7*0.8
      END IF
!       write(*,*) G_o_b,gs_h2o
      ci_o_sunlit_old = ci_o_sunlit_new
      cs_o_sunlit_old = cs_o_sunlit_new
      cosi_o_sunlit_old = cosi_o_sunlit_new
      coss_o_sunlit_old = coss_o_sunlit_new
      gs_o_sunlit_old = gs_o_sunlit_new
!conductance of sunlit leaves of overstorey for water
      gw_o_sunlit = 1.0/(1.0/g_o_a+1.0/g_o_b+1.0/gs_o_sunlit_new)
!conductance of sunlit leaves of overstorey for CO2
      gc_o_sunlit = 1.0/(1.0/g_o_a+1.4/g_o_b+1.6/gs_o_sunlit_new)
      ci_o_shaded_old = ci_o_shaded_new
      cs_o_shaded_old = cs_o_shaded_new
      cosi_o_shaded_old = cosi_o_shaded_new
      coss_o_shaded_old = coss_o_shaded_new
      gs_o_shaded_old = gs_o_shaded_new
      gw_o_shaded = 1.0/(1.0/g_o_a+1.0/g_o_b+1.0/gs_o_shaded_new)
      gc_o_shaded = 1.0/(1.0/g_o_a+1.4/g_o_b+1.6/gs_o_shaded_new)
      ci_u_sunlit_old = ci_o_sunlit_new
      cs_u_sunlit_old = cs_u_sunlit_new
      cosi_u_sunlit_old = cosi_o_sunlit_new
      coss_u_sunlit_old = coss_u_sunlit_new
      gs_u_sunlit_old = gs_o_sunlit_new
      gw_u_sunlit = 1.0/(1.0/g_u_a+1.0/g_u_b+1.0/gs_u_sunlit_new)
      gc_u_sunlit = 1.0/(1.0/g_u_a+1.4/g_u_b+1.6/gs_u_sunlit_new)
      ci_u_shaded_old = ci_u_shaded_new
      cs_u_shaded_old = cs_u_shaded_new
      cosi_u_shaded_old = cosi_u_shaded_new
      coss_u_shaded_old = coss_u_shaded_new
      gs_u_shaded_old = gs_u_shaded_new
      gw_u_shaded = 1.0/(1.0/g_u_a+1.0/g_u_b+1.0/gs_u_shaded_new)
      gc_u_shaded = 1.0/(1.0/g_u_a+1.4/g_u_b+1.6/gs_u_shaded_new)
! leaf tempratures module by L. He
      CALL LEAF_TEMPERATURES(temp_air, slope, psychrometer, vpd_air, &
&                      cp_ca, gw_o_sunlit, gw_o_shaded, gw_u_sunlit, &
&                      gw_u_shaded, gww_o_sunlit, gww_o_shaded, &
&                      gww_u_sunlit, gww_u_shaded, gh_o_sunlit, &
&                      gh_o_shaded, gh_u_sunlit, gh_u_shaded, xcs_o(kkk)&
&                      , xcl_o(kkk), xcs_u(kkk), xcl_u(kkk), &
&                      radiation_o_sun, radiation_o_shaded, &
&                      radiation_u_sun, radiation_u_shaded, &
&                      tc_o_sunlit_new, tc_o_shaded_new, tc_u_sunlit_new&
&                      , tc_u_shaded_new)
      h_o_sunlit = (tc_o_sunlit_new-temp_air)*rho_a*cp_ca*gh_o_sunlit
      h_o_shaded = (tc_o_shaded_new-temp_air)*rho_a*cp_ca*gh_o_shaded
!for next num aerodynamic conductance calculation
      gh_o = h_o_sunlit*lai_o_sunlit + h_o_shaded*lai_o_shaded
      IF (tc_o_sunlit_new - tc_o_sunlit_old .GE. 0.) THEN
        abs0 = tc_o_sunlit_new - tc_o_sunlit_old
      ELSE
        abs0 = -(tc_o_sunlit_new-tc_o_sunlit_old)
      END IF
      IF (tc_o_shaded_new - tc_o_shaded_old .GE. 0.) THEN
        abs1 = tc_o_shaded_new - tc_o_shaded_old
      ELSE
        abs1 = -(tc_o_shaded_new-tc_o_shaded_old)
      END IF
      IF (tc_u_sunlit_new - tc_u_sunlit_old .GE. 0.) THEN
        abs2 = tc_u_sunlit_new - tc_u_sunlit_old
      ELSE
        abs2 = -(tc_u_sunlit_new-tc_u_sunlit_old)
      END IF
      IF (tc_u_shaded_new - tc_u_shaded_old .GE. 0.) THEN
        abs3 = tc_u_shaded_new - tc_u_shaded_old
      ELSE
        abs3 = -(tc_u_shaded_new-tc_u_shaded_old)
      END IF
      IF (abs0 .LT. 0.02 .AND. abs1 .LT. 0.02 .AND. abs2 .LT. 0.02 .AND.&
&         abs3 .LT. 0.02) THEN
        GOTO 100
      ELSE IF (num .GT. 22) THEN
!iteration does not converge.
        tc_o_sunlit_old = temp_air
        tc_o_shaded_old = temp_air
        tc_u_sunlit_old = temp_air
        tc_u_shaded_old = temp_air
        GOTO 100
      ELSE
        tc_o_sunlit_old = tc_o_sunlit_new
        tc_o_shaded_old = tc_o_shaded_new
        tc_u_sunlit_old = tc_u_sunlit_new
        tc_u_shaded_old = tc_u_shaded_new
      END IF
    END DO
! end do while
!    write(*,*) G_o_b,gs_h2o
 100 gpp_o_sunlit = ac_o_sunlit*laio_sunlit
    gpp_o_shaded = ac_o_shaded*laio_shaded
    gpp_u_sunlit = ac_u_sunlit*laiu_sunlit
    gpp_u_shaded = ac_u_shaded*laiu_shaded
    cos_o_sunlit = lcos_o_sunlit*laio_sunlit
    cos_o_shaded = lcos_o_shaded*laio_shaded
    cos_u_sunlit = lcos_u_sunlit*laiu_sunlit
    cos_u_shaded = lcos_u_shaded*laiu_shaded
!    stSIF_o_sunlit=lSIF_o_sunlit*0.5*clumping*(1.1-0.1*LAIo_sunlit)*exp(-CosZs)*LAIo_sunlit
!    stSIF_o_shaded=lSIF_o_shaded*0.5*clumping*(1.1-0.1*LAIo_shaded)*exp(-CosZs)*LAIo_shaded
!    stSIF_u_sunlit=lSIF_u_sunlit*0.5*clumping*(1.1-0.1*LAIu_sunlit)*exp(-CosZs)*LAIu_sunlit
!    stSIF_u_shaded=lSIF_u_shaded*0.5*clumping*(1.1-0.1*LAIu_shaded)*exp(-CosZs)*LAIu_shaded
!    SIF_o_sunlit=lSIF_o_sunlit*exp(-0.5*clumping*LAIo_sunlit/CosZs)*LAIo_sunlit+stSIF_o_sunlit
!    SIF_o_shaded=lSIF_o_shaded*exp(-0.5*clumping*LAIo_shaded/CosZs)*LAIo_shaded+stSIF_o_shaded
!    SIF_u_sunlit=lSIF_u_sunlit*exp(-0.5*clumping*LAIu_sunlit/CosZs)*LAIu_sunlit+stSIF_u_sunlit
!    SIF_u_shaded=lSIF_u_shaded*exp(-0.5*clumping*LAIu_shaded/CosZs)*LAIu_shaded+stSIF_u_shaded
    stsif_o_sunlit = lsif_o_sunlit*0.3*clumping*(1.1-0.1*laio_sunlit)*&
&     EXP(-coszs)
    stsif_o_shaded = lsif_o_shaded*0.3*clumping*(1.1-0.1*laio_shaded)*&
&     EXP(-coszs)
    stsif_u_sunlit = lsif_u_sunlit*0.3*clumping*(1.1-0.1*laiu_sunlit)*&
&     EXP(-coszs)
    stsif_u_shaded = lsif_u_shaded*0.3*clumping*(1.1-0.1*laiu_shaded)*&
&     EXP(-coszs)
!    stSIF_o_sunlit = 0.0   !!@JWang  for scattering correction,@MOUSONG,make sure this is correct???
!    stSIF_o_shaded = 0.0
!    stSIF_u_sunlit = 0.0
!    stSIF_u_shaded = 0.0
    sif_o_sunlit = (lsif_o_sunlit+stsif_o_sunlit)*laio_sunlit*0.1
    sif_o_shaded = (lsif_o_shaded+stsif_o_shaded)*laio_shaded*0.1
    sif_u_sunlit = (lsif_u_sunlit+stsif_u_sunlit)*laiu_sunlit*0.1
    sif_u_shaded = (lsif_u_shaded+stsif_u_shaded)*laiu_shaded*0.1
!Transpiration module by X. Luo
    CALL TRANSPIRATION(tc_o_sunlit_new, tc_o_shaded_new, tc_u_sunlit_new&
&                , tc_u_shaded_new, temp_air, rh_air, gw_o_sunlit, &
&                gw_o_shaded, gw_u_sunlit, gw_u_shaded, lai_o_sunlit, &
&                lai_o_shaded, lai_u_sunlit, lai_u_shaded, trans_o(kkk)&
&                , trans_u(kkk))
! Evaporation and sublimation from canopy by X. Luo
    CALL EVAPORATION_CANOPY(tc_o_sunlit_new, tc_o_shaded_new, &
&                     tc_u_sunlit_new, tc_u_shaded_new, temp_air, rh_air&
&                     , gww_o_sunlit, gww_o_shaded, gww_u_sunlit, &
&                     gww_u_shaded, lai_o_sunlit, lai_o_shaded, &
&                     lai_u_sunlit, lai_u_shaded, xcl_o(kkk), xcl_u(kkk)&
&                     , xcs_o(kkk), xcs_u(kkk), eil_o(kkk), eil_u(kkk), &
&                     eis_o(kkk), eis_u(kkk))
! Rainfall stage 2 by X. Luo
    CALL RAINFALL_STAGE2(eil_o(kkk), eil_u(kkk), wcl_o(kkk), wcl_u(kkk))
! Snow pack stage2
    CALL SNOWPACK_STAGE2(eis_o(kkk), eis_u(kkk), wcs_o(kkk), wcs_u(kkk))
! Evaporation from soil module
    gheat_g = 1./ra_g
    mass_water_g = rho_w*zp
    CALL SOIL_EVAPORATION(temp_grd, ts0(kkk-1), rh_air, radiation_g, &
&                   gheat_g, xg_snow(kkk), zp, zsp, mass_water_g, &
&                   wg_snow(kkk), rho_snow(kkk), soilp%thetam_prev(0), &
&                   soilp%fei(0), evap_soil(kkk), evap_sw(kkk), evap_ss(&
&                   kkk))
! update surface ponding after ponding evaporation calculation
    zp = mass_water_g/rho_w
! update snow depth as well after snow evaporation calculation
    zsp = wg_snow(kkk)/rho_snow(kkk)
! to be checked later:  why set these 4 to 0
    eil_o(kkk) = 0.
    eis_o(kkk) = 0.
    eil_u(kkk) = 0.
    eis_u(kkk) = 0.
! soil Thermal Conductivity module by L. He
    CALL UPDATESOILTHERMALCONDUCTIVITY(soilp)
    CALL UPDATE_CS(soilp)
! Surface temperature
    cs(0, kkk) = soilp%cs(0)
    cs(1, kkk) = soilp%cs(0)
    tc_u(kkk) = tcu
    lambda_soil(1) = soilp%lambda(0)
    d_soil(1) = soilp%d_soil(0)
    tm(1, kkk-1) = soilp%temp_soil_p(1)
    tm(0, kkk-1) = soilp%temp_soil_p(0)
    g(1, kkk) = soilp%g(0)
    CALL SURFACETEMPERATURE(temp_air, rh_air, zsp, zp, cs(1, kkk), cs(0&
&                     , kkk), gheat_g, d_soil(1), rho_snow(kkk), tc_u(&
&                     kkk), radiation_g, evap_soil(kkk), evap_sw(kkk), &
&                     evap_ss(kkk), lambda_soil(1), xg_snow(kkk), g(1, &
&                     kkk), ts0(kkk-1), tm(1, kkk-1), tm(0, kkk-1), tsn0&
&                     (kkk-1), tsm0(kkk-1), tsn1(kkk-1), tsn2(kkk-1), &
&                     ts0(kkk), tm(0, kkk), tsn0(kkk), tsm0(kkk), tsn1(&
&                     kkk), tsn2(kkk), g(0, kkk))
    soilp%temp_soil_c(0) = tm(0, kkk)
! Snow pack stage3 module
    CALL SNOWPACK_STAGE3(temp_air, tsn0(kkk), tsn0(kkk-1), rho_snow(kkk)&
&                  , zsp, zp, wg_snow(kkk))
    CALL SENSIBLEHEAT_CD(tc_o_sunlit_new, tc_o_shaded_new, &
&                  tc_u_sunlit_new, tc_u_shaded_new, ts0(kkk), temp_air&
&                  , rh_air, gh_o_sunlit, gh_o_shaded, gh_u_sunlit, &
&                  gh_u_shaded, gheat_g, lai_o_sunlit, lai_o_shaded, &
&                  lai_u_sunlit, lai_u_shaded, qhc_o(kkk), qhc_u(kkk), &
&                  qhg(kkk))
! soil water module
    soilp%zsp = zsp
    soilp%g(0) = g(0, kkk)
    CALL UPDATEHEATFLUX(soilp, xg_snow(kkk), lambda_snow(kkk), tsn0(kkk)&
&                 , temp_air, kstep)
    CALL SOIL_WATER_UPTAKE(soilp, trans_o(kkk), trans_u(kkk), evap_soil(&
&                    kkk))
    soilp%r_rain_g = r_rain_g(kkk)
    soilp%zp = zp
    CALL UPDATESOILMOISTURE(soilp)
    zp = soilp%zp
  END DO
!END kkk iteration
!    write(*,*) G_o_b,gs_h2o
  kkk = kloop
!True? or Tsn1 @J.Wang
  IF (tsn1(kkk) .GT. 40.) tsn2(kkk) = 40.
  IF (tsn1(kkk) .LT. -40.) tsn2(kkk) = -40.
  IF (tsn2(kkk) .GT. 40.) tsn2(kkk) = 40.
  IF (tsn2(kkk) .LT. -40.) tsn2(kkk) = -40.
! SH
  var_n(1) = qhc_o(kkk)
! The temperature of ground surface
  var_n(3) = ts0(kkk)
!The temperature of ground surface
  var_n(4) = tsn0(kkk)
  var_n(5) = tsm0(kkk)
  var_n(6) = tsn1(kkk)
  var_n(7) = tsn2(kkk)
  DO i=9,14
    var_n(i) = soilp%temp_soil_c(i-9)
  END DO
  DO i=21,26
    var_n(i) = soilp%thetam(i-21)
  END DO
  DO i=27,32
    var_n(i) = soilp%ice_ratio(i-27)
  END DO
  var_n(15) = wcl_o(kkk)
!the mass of intercepted liquid water and snow, overstory
  var_n(16) = wcs_o(kkk)
  var_n(18) = wcl_u(kkk)
  var_n(19) = wcs_u(kkk)
! fraction of ground surface covered by snow and snow mass
  var_n(20) = wg_snow(kkk)
  var_n(33) = soilp%zsp
  var_n(34) = soilp%zp
  var_n(35) = soilp%r_rain_g
  var_n(36) = ac_snow_o(kkk)
  var_n(37) = ac_snow_u(kkk)
  var_n(38) = rho_snow(kkk)
  var_n(39) = alpha_v_sw(kkk)
  var_n(40) = alpha_n_sw(kkk)
!laten heat of water vaporization in j/kg
  lv_liquid = (2.501-0.00237*temp_air)*1000000.
!for output
  mid_res%net_rad = radiation_o + radiation_u + radiation_g
  mid_res%lh = lv_liquid*(trans_o(kkk)+eil_o(kkk)+trans_u(kkk)+eil_u(kkk&
&   )+evap_soil(kkk)+evap_sw(kkk)) + lv_solid*(eis_o(kkk)+eis_u(kkk)+&
&   evap_ss(kkk))
  mid_res%sh = qhc_o(kkk) + qhc_u(kkk) + qhg(kkk)
  mid_res%trans = (trans_o(kkk)+trans_u(kkk))/rho_w
  mid_res%evap = (eil_o(kkk)+eil_u(kkk)+evap_soil(kkk)+evap_sw(kkk))/&
&   rho_w + (eis_o(kkk)+eis_u(kkk)+evap_ss(kkk))/rho_snow(kkk)
!J.Wang kg/m2/s// umol C/m2/s
  mid_res%gpp_o_sunlit = gpp_o_sunlit*12.*1.e-6*1.e-3
  mid_res%gpp_u_sunlit = gpp_u_sunlit*12.*1.e-6*1.e-3
  mid_res%gpp_o_shaded = gpp_o_shaded*12.*1.e-6*1.e-3
  mid_res%gpp_u_shaded = gpp_u_shaded*12.*1.e-6*1.e-3
  mid_res%gpp = mid_res%gpp_o_sunlit + mid_res%gpp_u_sunlit + mid_res%&
&   gpp_o_shaded + mid_res%gpp_u_shaded
  mid_res%sif = sif_o_sunlit + sif_o_shaded + sif_u_sunlit + &
&   sif_u_shaded
  mid_res%thetam_surf = soilp%thetam(0)
! pmol/m2/s
  mid_res%cos_plant = cos_o_sunlit + cos_o_shaded + cos_u_sunlit + &
&   cos_u_shaded
!    write(*,*) "thetam_surf = ", mid_res%thetam_surf
  IF (lai_input .LT. 0) THEN
    temp_day = temp_day + meteo%temp
    theta_day = theta_day + (soilp%theta_vfc(0)-soilp%theta_vwp(0))
    trans_day = trans_day + mid_res%trans
    IF (is_end_curr_day) THEN
      temp_day = temp_day/24.
      theta_day = theta_day/24.
      trans_day = trans_day/24.
! use the method in BETHY to calculate phenology, with a little modification, @Mousong.Wu,201905
      CALL BEPS_PHENOLOGY_CD(lc, daylen, temp_day, theta_day, trans_day&
&                      , mid_res%lai_old)
      temp_day = 0.
      theta_day = 0.
      trans_day = 0.
      mid_res%lai_new = mid_res%lai_old
    ELSE
      mid_res%lai_new = mid_res%lai_old
    END IF
    lai = mid_res%lai_new
!mid_res%fAPAR = 1. - exp(-0.45*lai)    ! calculate fAPAR using the Lambert-Beer law, Benjamin Smith et al., 2008, &
! & Forest Ecology and Management, @Mousong.Wu, 201905
!          write(*,*) 'lai = ', mid_res%lai_old
!          write(*,*) 'fAPAR = ', mid_res%fAPAR
  END IF
!lai = mid_res%lai_new 
! calculate fAPAR using the Lambert-Beer law, Benjamin Smith et al., 2008, &
  mid_res%fapar = 1. - EXP(-(0.45*lai))
! & Forest Ecology and Management, @Mousong.Wu, 201905
  CALL COS_GRND_CD(soilp, cos_soil)
! pmol/m2/s
  mid_res%cos_grnd = cos_soil
  RETURN
END SUBROUTINE INTER_PRG_CD

SUBROUTINE COS_GRND_CD(soilp, cos_soil)
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE BEPS_SOILMOD_DIFF
  IMPLICIT NONE
!Input Variables
  TYPE(SOIL), INTENT(IN) :: soilp
!Local Variables
! local ground COS flux (pmol/m2/sec)
  REAL(r8) :: cos_soil
  REAL(r8) :: f_opt, s_opt, f_g, s_g, a
  REAL(r8), PARAMETER :: k_cos_soil=1.2e-4
!Misc Variables
  INTEGER :: j
  REAL(r8) :: soil_t, soil_s, dsoil, soil_ice
  REAL(r8) :: cos_soil_abiotic, cos_soil_biotic
  INTRINSIC LOG, DBLE, EXP
  soil_t = 0.
  soil_s = 0.
  soil_ice = 0.
  dsoil = 0.
!...ground uptake of COS, calculated from Whelan et al., 2016, ACP. calculate the abiotic and biotic part of ground uptake separa
!tely.
  DO j=1,3
    soil_t = soil_t + soilp%temp_soil_c(j-1)*soilp%d_soil(j-1)
    soil_s = soil_s + soilp%thetam(j-1)*soilp%d_soil(j-1)
    soil_ice = soil_ice + soilp%ice_ratio(j-1)*soilp%d_soil(j-1)
    dsoil = dsoil + soilp%d_soil(j-1)
  END DO
  soil_t = soil_t/dsoil
  soil_ice = soil_ice/dsoil
  cos_soil_abiotic = 0.437*EXP(0.0984*soil_t)
  f_opt = -(0.00986*soil_t*soil_t) + 0.197*soil_t - 9.32
  s_opt = 0.28*soil_t + 14.5
  f_g = -(0.0119*soil_t*soil_t) + 0.110*soil_t - 1.18
  s_g = 35.0
  a = LOG(f_opt/f_g)*(LOG(s_opt/s_g)+(s_g/s_opt-1.))**(-1)
  cos_soil_biotic = f_opt*(soil_s/s_opt)**a*EXP(-(a*(soil_s/s_opt-1.)))
  cos_soil = cos_soil_abiotic + cos_soil_biotic
END SUBROUTINE COS_GRND_CD

SUBROUTINE BEPS_PHENOLOGY_CD(lc, daylen, dt, theta, trans, lai)
!***********************************************************
!* WOK, 2008-07-30
!* IMPLIFIED PHENOLOGY MODEL
!* simplified phenology model
!***********************************************************
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE MO_HELPER_DIFF, ONLY : errf, mins, maxs, minx, maxx, fominef_ss, &
& fomaxef_ss
  IMPLICIT NONE
!  REAL, ALLOCATABLE, DIMENSION (:,:,:) :: mlai ! monthly LAI fields from external data
  INTEGER, INTENT(IN) :: lc
  REAL, INTENT(IN) :: daylen
  REAL, INTENT(IN) :: dt
  REAL, INTENT(IN) :: theta
  REAL, INTENT(IN) :: trans
  REAL, INTENT(INOUT) :: lai
! air-temperature memory [deg C]
  REAL :: tmpm
! water limited LAI memory
  REAL :: laim
! highest recorded LAI (with a decay rate, for setting 'zfc')
  REAL :: laihi
! WOK-ADD-070723 litter production to be calculated directly in phenology (not in cbalance indirectly)
! auxiliary fields
  REAL :: tmpmmult, laimmult
! output field
  REAL :: leafshed
  REAL :: laihimult
! memory time for updating fractional cover
  REAL, PARAMETER :: taulaihi=5.0
!  REAL, PARAMETER :: laimin = 1e-6            ! minimum LAI for pot. transpiration per LAI estimates
! curvature parameter for mins/maxs
  REAL, PARAMETER :: eta=0.99999
! WOK-ADD-070723 the list of controlling parameters
! FREE PARAMETERS
! maximum LAI
  REAL :: plaimax(10)
! rootdepth
  REAL :: rootdepth(10)
! leaf onset temperature [deg C]
  REAL :: ptphen(10)
! range of leaf onset temperature [1/deg C]
  REAL :: ptphenr(10)
! leaf shedding daylength [hours]
  REAL :: pdphen
! range of leaf shedding daylength [hours]
  REAL :: pdphenr
!  REAL, ALLOCATABLE, DIMENSION (:) :: PTSHD   ! leaf shedding temperature [deg C]
!  REAL, ALLOCATABLE, DIMENSION (:) :: PTSHDS  ! spread of leaf shedding temperature [1/deg C]
! leaf growth factor [1/days]
  REAL :: plgr
! inverse leaf longevity from start of senescense [1/days]
  REAL :: pkl(10)
! target survival time at current soil moisture [days]
  REAL :: ptauw(10)
! PARAMETERS LEFT FIXED
! inverse memory time for soil moisture-limited LAI [1/days]
  REAL :: pks
! inverse memory time for air temperature [1/days]
  REAL :: pkm
  REAL :: pasm
  REAL :: zfc, zlai
  REAL :: fcmax0, lailim0, cdrm
  REAL :: xdtmp, lait, laiw, fx, t0, ts, ft, fd, fg
  REAL :: lailast
  REAL :: laimaxw, laimax, r, lailim, wai
  REAL :: dptrp
  INTEGER :: plt
! WOK-090309 'ph' is now only used in nscale
! xph     1: warm-evergreen; 2: cold-evergreen; 3: summergreen; 4: raingreen; 5: grass; 6: annual crop;
! INTEGER, DIMENSION (0:13), PARAMETER :: xph= &
!PFT:0  1  2  3  4  5  6  7  8  9 10 11 12 13
!  (/5, 1, 4, 1, 3, 2, 3, 1, 4, 5, 5, 2, 5, 6/)
  REAL :: sla(10)
  INTRINSIC EXP
  REAL :: result1
  REAL :: arg1
  REAL :: arg2
  SELECT CASE  (lc) 
  CASE (1) 
!conifer evergreen
    plt = 1
  CASE (2) 
!conifer decidous
    plt = 2
  CASE (6) 
!broadleaf decidous
    plt = 3
  CASE (9) 
!broadleaf evergreen
    plt = 4
  CASE (10) 
!mix
    plt = 5
  CASE (13) 
!shrub
    plt = 6
  CASE (14) 
! grass
    plt = 7
  CASE (15) 
! crop
    plt = 8
  CASE (40) 
! C4 grass
    plt = 9
  CASE (41) 
! C4 crop
    plt = 10
  END SELECT
  sla = (/4.1, 11.3, 12.8, 7.8, 9.0, 9.2, 16.9, 25.3, 16.9, 16.9/)
!sla(0:13)=(/0., 9.9, 14.1, 5.7, 11.5, 4.1, 11.3, 6.9, &
!		& 11.5, 16.9, 16.9, 6.9, 16.9, 25.3/)
  ptphen = (/10.0, 10.0, 5.0, 0., 5., 4.0, 2.0, 15.0, 2.0, 2.0/)
!  ptphen(0:13)=(/0.,0.,0., 0., 10.0, 10.0, 10.0, 0., 8.0, &
!       & 2.0, 2.0, 2.0, 2.0, 15.0/)
  ptphenr = (/2.0, 2.0, 2., 2., 2., 2.0, 2., 2., 2., 2./)
!  ptphenr(0:13)=(/0.,0., 0., 0., 2.0, 2.0, 2.0, 0., 2.0, &
!        & 2.0, 2.0, 2.0, 2.0, 2.0/)
  pdphen = 10.5
  pdphenr = 0.5
  plgr = 0.5
  pkl = (/0.1, 0., 5.e-3, 0.1, 0.1, 0.1, 5.e-3, 0.1, 5.e-3, 5.e-3/)
! pkl(0:13) = (/0.,0.1, 0., 0.1, 5.e-3, 0.1, 0., 0.1, &
!       & 0.1, 0.1, 5.e-3, 0.1, 0.1, 0.1/)
  ptauw = (/30., 30., 30., 30., 30., 30., 30., 30., 30., 30./)
!  ptauw(1:13) = (/0., 30., 30., 30., 30., 30., 30., &
!        & 30., 30., 30., 30., 30., 30./)
!  LIST OF PFTs in BETHY:
!  1:  tropical broadleaf evergreen tree
!  2:  tropical broadleaf deciduous tree
!  3:  temperate broadleaf evergreen tree
!  4:  temperate broadleaf deciduous tree
!  5:  evergreen coniferous tree
!  6:  deciduous coniferous tree
!  7:  evergreen shrub
!  8:  deciduous shrub
!  9:  C3 grass
! 10:  C4 grass
! 11:  tundra
! 12:  swamp
! 13:  arable crop
  rootdepth = (/0.6, 0.6, 0.8, 0.8, 0.7, 0.5, 0.3, 0.3, 0.3, 0.3/)
  plaimax = (/4.5, 4.5, 4.5, 4.5, 4.5, 3.3, 3.0, 4.5, 3.0, 3.0/)
  fcmax0 = 1.0
  lailim0 = 3.0
  cdrm = 0.45
  pkm = 1./30.
  pks = 1./30.
!   multiplier for advancing temperature memory by one day
  tmpmmult = EXP(-pkm)
!   multiplier for advancing soil-water limited LAI memory by one day
  laimmult = EXP(-pks)
!   decay multiplier for evergreen LAI
!    laimult = exp (-pkl)
!   the air-temperature memory
  tmpm = 0.
!   the water stress index memory
  laim = 0.
  lai = plaimax(plt)
!   decay multiplier for maximum LAI used to set fractional cover
  laihimult = EXP(-(1./(taulaihi*365.)))
!   control for fractional cover 'zfc'
  laihi = 0.
  zfc = fcmax0
!   output field
  leafshed = 0.
!   spin-up of temperature memory
  tmpm = dt*(1.-tmpmmult) + tmpm*tmpmmult
!   calculate plant available soil moisture and daily potential transpiration, @MOUSONG.WU, 201905
! convert from m3/m3 to mm
  pasm = theta*rootdepth(plt)*1000.
! convert from m/s to mm
  dptrp = trans*86400.*1000.
  lailast = lai
!------------------------------------------------------------------
! advances LAI and fractional cover by one day
! from its current state to the state at day 'iday'
!------------------------------------------------------------------
  DO plt=1,9
!      IF (ph(k)==1.or.ph(k)==4) THEN ! warm-evergreen and warm-deciduous phenology
    IF (((plt .EQ. 3 .OR. plt .EQ. 4) .OR. plt .EQ. 5) .OR. plt .EQ. 6) &
&   THEN
! warm-evergreen and warm-deciduous phenology
! effective maximum LAI, taking into account structural limiations
!        laimax = plaimax(k) * (1. - exp(-laimaxw/plaimax(k)))
!   initialize LAI
      result1 = MAXX(dptrp, 1.e-3, 2.e-2)
      laimax = pasm*lailast/ptauw(plt)/result1
!        laimax = mins (laimax, plaimax(k), 0.9)
!snb, test
      result1 = FOMINEF_SS(laimax, plaimax(plt), 2.e-1)
      laimax = result1 + 1.e-1
! update water limited LAI memory
      laim = laimax*(1.-laimmult) + laim*laimmult
! rate of change of LAI towards limit
      r = plgr
! limit LAI
      lailim = laim
! update LAI
!        lai(k) = lailim - (lailim - lai(k)) * exp (-r)
!      ELSE IF (ph(k)==2.or.ph(k)==3) THEN ! cold-evergreen and cold-deciduous phenology
    ELSE IF (plt .EQ. 1 .OR. plt .EQ. 2) THEN
! cold-evergreen and cold-deciduous phenology
! update memory of daily mean temperature
      tmpm = dt*(1.-tmpmmult) + tmpm*tmpmmult
! fraction of vegetation above temperature threshold
      arg1 = (tmpm-ptphen(plt))/ptphenr(plt)
      ft = ERRF(arg1)
! fraction of vegetation above daylength threshold
      arg1 = (daylen-pdphen)/pdphenr
      fd = ERRF(arg1)
      r = ft*fd*plgr + (1.-ft*fd)*pkl(plt) + 1.e-9
      arg1 = ft*fd*plgr*plaimax(plt)/r
      lailim = MAXX(arg1, 1.e-9, 5.e-3)
!        lai(k) = plaimax(k) - (plaimax(k) - lai(k)) * exp (-r)
!        lai(k) = lailim - (lailim - lai(k)) * exp (-r)
    ELSE
! grass and annual crop phenology
      tmpm = dt*(1.-tmpmmult) + tmpm*tmpmmult
      arg1 = (tmpm-ptphen(plt))/ptphenr(plt)
      ft = ERRF(arg1)
      result1 = MAXX(dptrp, 1.e-3, 2.e-2)
      laimax = pasm*lailast/ptauw(plt)/result1
!        laimax = mins (laimax, plaimax(k), 0.9)
!        if(pft(k)==9) print '(a,8g30.14)','PFT9-a: iday,tmpm(k),ft,laimax,pasm(k),zlai(k),dptrp(k),lai(k)',iday,tmpm(k),ft,laima
!x,pasm(k),zlai(k),dptrp(k),lai(k)
!snb, test
      result1 = FOMINEF_SS(laimax, plaimax(plt), 2.e-1)
      laimax = result1 + 1.e-1
      laim = laimax*(1.-laimmult) + laim*laimmult
      r = ft*plgr + (1.-ft)*pkl(plt) + 1.e-9
      arg1 = ft*plgr*laim/r
      lailim = MAXX(arg1, 1.e-9, 5.e-3)
!        lai(k) = lailim - (lailim - lai(k)) * exp (-r)
    END IF
!      leafshed(k) = maxx (lailast - lai(k), 0., 1e-3) / sla(k) * 1000. * cdrm
    arg1 = (lailim-lai)*(1.-EXP(-r))
    result1 = MAXX(arg1, 0., 1.e-3)
    leafshed = result1/sla(plt)*1000.*cdrm
    lai = lailim - (lailim-lai)*EXP(-r)
  END DO
!      if(pft(k)==9) print '(a,8g30.14)','PFT9-b: lai(k),r,lailim',lai(k),r,lailim
! set fractional cover
!      laihi(k) = maxs (lai(k), laihi(k), eta) * laihimult
  result1 = FOMAXEF_SS(lai, laihi, 2.e-6)
  laihi = result1*laihimult
!      zfc(k) = maxs (laihi(k) / lailim0, lai(k) / lailim0, eta)
  arg1 = laihi/lailim0
  arg2 = lai/lailim0
  zfc = FOMAXEF_SS(arg1, arg2, 2.e-6)
!      zfc(k) = mins ( zfc(k), 1., eta) * fcmax0
! snb, test
  result1 = MINX(zfc, 1., 2.e-6)
  zfc = result1*fcmax0
END SUBROUTINE BEPS_PHENOLOGY_CD

! This module calculate net radiation at both canopy level and leaf level XZ luo may23 2015
! output: net radiation for canopy,over/under storey and ground
!         ............. on sunlit/shaded leaves of over/understorey
!
! inputs: global solar radiation,cosine value for solar zenith angle,albedo of leaves
!         albedo of snow,percentage of snow cover
!         leaf area index 
!         temperature of over/under storey and ground
!         temperature of air/rh
SUBROUTINE NETRADIATION_CD(shortrad_df, shortrad_dir, coszs, temp_o, &
& temp_u, temp_g, lai_o, lai_u, lai_os, lai_us, lai_o_sunlit, &
& lai_o_shaded, lai_u_sunlit, lai_u_shaded, clumping, temp_air, rh, &
& albedo_snow_v, albedo_snow_n, percentarea_snow_o, percentarea_snow_u, &
& percent_snow_g, albedo_v_o, albedo_n_o, albedo_v_u, albedo_n_u, &
& albedo_v_g, albedo_n_g, netrad_o, netrad_u, netrad_g, &
& netradleaf_o_sunlit, netradleaf_o_shaded, netradleaf_u_sunlit, &
& netradleaf_u_shaded, netshortradleaf_o_sunlit, &
& netshortradleaf_o_shaded, netshortradleaf_u_sunlit, &
& netshortradleaf_u_shaded)
  USE METEOMOD_DIFF
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE BEPS_CON, ONLY : zero, sb_constant => sigma
  IMPLICIT NONE
  REAL(r8), INTENT(IN) :: shortrad_df, shortrad_dir, coszs, temp_o, &
& temp_u, temp_g
! LAI of over/understorey with or without stem
  REAL(r8), INTENT(IN) :: lai_o, lai_u, lai_os, lai_us
! sunlit/shaded leaves with consideration of stem
  REAL(r8), INTENT(IN) :: lai_o_sunlit, lai_o_shaded, lai_u_sunlit, &
& lai_u_shaded
  REAL(r8), INTENT(IN) :: clumping
  REAL(r8), INTENT(IN) :: temp_air, rh
! albedo of snow in this step
  REAL(r8), INTENT(IN) :: albedo_snow_v, albedo_snow_n
  REAL(r8), INTENT(IN) :: percentarea_snow_o, percentarea_snow_u, &
& percent_snow_g
  REAL(r8), INTENT(IN) :: albedo_v_o, albedo_n_o, albedo_v_u, albedo_n_u&
& , albedo_v_g, albedo_n_g
! net Radiation on over/understorey and ground
  REAL(r8), INTENT(OUT) :: netrad_o, netrad_u, netrad_g
!leaf levels for ET
  REAL(r8), INTENT(OUT) :: netradleaf_o_sunlit, netradleaf_o_shaded, &
& netradleaf_u_sunlit, netradleaf_u_shaded
  REAL(r8), INTENT(OUT) :: netshortradleaf_o_sunlit, &
& netshortradleaf_o_shaded, netshortradleaf_u_sunlit, &
& netshortradleaf_u_shaded
!! net shortwave radiation at leaf level for GPP. 
! net short wave radiation
  REAL(r8) :: shortrad_global, netshortrad_o, netshortrad_u, &
& netshortrad_g
  REAL(r8) :: netshortrad_o_dir, netshortrad_o_df, netshortrad_u_dir, &
& netshortrad_u_df, netshortrad_g_dir, netshortrad_g_df
!real(r8) :: shortRad_dir,shortRad_df
  REAL(r8) :: netlongradleaf_o_sunlit, netlongradleaf_o_shaded, &
& netlongradleaf_u_sunlit, netlongradleaf_u_shaded
  REAL(r8) :: netlongrad_o, netlongrad_u, netlongrad_g
  REAL(r8) :: shortradleaf_o_dir, shortradleaf_u_dir, shortradleaf_o_df&
& , shortradleaf_u_df
!albedo of overstorey/understorey/groudn(considering snow)
  REAL(r8) :: albedo_o, albedo_u, albedo_g
! albedo of three parts in visible and NIR band (considering snow)
  REAL(r8) :: albedo_v_os, albedo_n_os, albedo_v_us, albedo_n_us, &
& albedo_v_gs, albedo_n_gs
!emissivity of air,over/understorey, and ground
  REAL(r8) :: emissivity_air, emissivity_o, emissivity_u, emissivity_g
! longwave radiation emissted by different parts
  REAL(r8) :: longrad_air, longrad_o, longrad_u, longrad_g
! indicators to describe leaf distribution angles in canopy. slightly related with LAI
  REAL(r8) :: cosq_o, cosq_u
!gap fraction of direct and diffuse radiation for over/unerstory (diffuse used for diffuse solar radiation and longwave radiation
  REAL(r8) :: gap_o_dir, gap_u_dir, gap_o_df, gap_u_df
! considering stem
  REAL(r8) :: gap_os_dir, gap_us_dir, gap_os_df, gap_us_df
  INTRINSIC EXP
  INTRINSIC MIN
  INTRINSIC MAX
!calculate albedo of canopy in this step
  albedo_v_os = albedo_v_o*(1.-percentarea_snow_o) + albedo_snow_v*&
&   percentarea_snow_o
  albedo_n_os = albedo_n_o*(1.-percentarea_snow_o) + albedo_snow_n*&
&   percentarea_snow_o
  albedo_v_us = albedo_v_u*(1.-percentarea_snow_u) + albedo_snow_v*&
&   percentarea_snow_u
  albedo_n_us = albedo_n_u*(1.-percentarea_snow_u) + albedo_snow_n*&
&   percentarea_snow_u
  albedo_o = 0.5*(albedo_v_os+albedo_n_os)
  albedo_u = 0.5*(albedo_v_us+albedo_n_us)
! calculate albedo of ground 
  albedo_v_gs = albedo_v_g*(1.-percent_snow_g) + albedo_snow_v*&
&   percent_snow_g
  albedo_n_gs = albedo_n_g*(1.-percent_snow_g) + albedo_snow_n*&
&   percent_snow_g
  albedo_g = 0.5*(albedo_v_gs+albedo_n_gs)
! separate global solar radiation into df and dir  @orgin
!      Here we input df/dir directly               @J.Wang
! @J.Wang
  shortrad_global = shortrad_df + shortrad_dir
! fraction at each layer of canopy,df/dir, use LAI here
  IF (coszs .GT. zero) THEN
    IF (-(0.5*clumping*lai_o/coszs) .LT. -10.) THEN
      gap_o_dir = 0.
    ELSE
      gap_o_dir = EXP(-(0.5*clumping*lai_o/coszs))
    END IF
    IF (-(0.5*clumping*lai_u/coszs) .LT. -10.) THEN
      gap_u_dir = 0.
    ELSE
      gap_u_dir = EXP(-(0.5*clumping*lai_u/coszs))
    END IF
    IF (-(0.5*clumping*lai_os/coszs) .LT. -10.) THEN
      gap_os_dir = 0.
    ELSE
!considering stem
      gap_os_dir = EXP(-(0.5*clumping*lai_os/coszs))
    END IF
    IF (-(0.5*clumping*lai_us/coszs) .LT. -10.) THEN
      gap_us_dir = 0.
    ELSE
      gap_us_dir = EXP(-(0.5*clumping*lai_us/coszs))
    END IF
  END IF
!leaf distribution angles
  cosq_o = 0.537 + 0.025*lai_o
  cosq_u = 0.537 + 0.025*lai_u
  gap_o_df = EXP(-(0.5*clumping*lai_o/cosq_o))
  gap_u_df = EXP(-(0.5*clumping*lai_u/cosq_u))
  gap_os_df = EXP(-(0.5*clumping*lai_os/cosq_o))
  gap_us_df = EXP(-(0.5*clumping*lai_us/cosq_u))
!emissivity of each part
  CALL METEO_PACK(temp_air, rh)
  emissivity_air = 1. - EXP(-((e_actual*10.0)**((temp_air+273.15)/1200.0&
&   )))
  IF (1. .GT. emissivity_air) THEN
    emissivity_air = emissivity_air
  ELSE
    emissivity_air = 1.
  END IF
  IF (0.7 .LT. emissivity_air) THEN
    emissivity_air = emissivity_air
  ELSE
    emissivity_air = 0.7
  END IF
  emissivity_o = 0.98
  emissivity_u = 0.98
  emissivity_g = 0.96
!net short direct radiation on canopy and ground
  IF (shortrad_global .GT. zero .AND. coszs .GT. zero) THEN
! day time
    netshortrad_o_dir = shortrad_dir*(1.-albedo_o-(1.-albedo_u)*&
&     gap_o_dir)
    netshortrad_u_dir = shortrad_dir*gap_o_dir*(1.-albedo_u-(1.-albedo_g&
&     )*gap_u_dir)
    netshortrad_g_dir = shortrad_dir*gap_o_dir*gap_u_dir*(1.-albedo_g)
  ELSE
    netshortrad_o_dir = 0.
    netshortrad_u_dir = 0
    netshortrad_g_dir = 0
  END IF
!net short diffuse radiation on canopy and ground
  IF (shortrad_global .GT. zero .AND. coszs .GT. zero) THEN
! day time
    netshortrad_o_df = shortrad_df*(1.-albedo_o-(1.-albedo_u)*gap_o_df) &
&     + 0.21*clumping*shortrad_dir*(1.1-0.1*lai_o)*EXP(-(1.*coszs))
    netshortrad_u_df = shortrad_df*gap_o_df*(1.-albedo_u-(1.-albedo_g)*&
&     gap_u_df) + 0.21*clumping*shortrad_dir*gap_o_dir*(1.1-0.1*lai_u)*&
&     EXP(-(1.*coszs))
    netshortrad_g_df = shortrad_df*gap_o_df*gap_u_df*(1.-albedo_g)
  ELSE
    netshortrad_o_df = 0.
    netshortrad_u_df = 0.
    netshortrad_g_df = 0.
  END IF
!total net shortwave radiation at canopy level
  netshortrad_o = netshortrad_o_dir + netshortrad_o_df
  netshortrad_u = netshortrad_u_dir + netshortrad_u_df
  netshortrad_g = netshortrad_g_dir + netshortrad_g_df
!net longwave radiation on canopy and ground
  longrad_air = emissivity_air*sb_constant*(temp_air+273.15)**4
  longrad_o = emissivity_o*sb_constant*(temp_o+273.15)**4
  longrad_u = emissivity_u*sb_constant*(temp_u+273.15)**4
  longrad_g = emissivity_g*sb_constant*(temp_g+273.15)**4
  netlongrad_o = (emissivity_o*(longrad_air+longrad_u*(1.-gap_u_df)+&
&   longrad_g*gap_u_df)-2.*longrad_o)*(1.-gap_o_df) + emissivity_o*(1.-&
&   emissivity_u)*(1.-gap_u_df)*(longrad_air*gap_o_df+longrad_o*(1.-&
&   gap_o_df))
  netlongrad_u = (emissivity_u*(longrad_air*gap_o_df+longrad_o*(1.-&
&   gap_o_df)+longrad_g)-2.*longrad_u)*(1.-gap_u_df) + (1.-emissivity_g)&
&   *((longrad_air*gap_o_df+longrad_o*(1.-gap_o_df))*gap_u_df+longrad_u*&
&   (1.-gap_u_df)) + emissivity_u*(1.-emissivity_o)*(longrad_u*(1.-&
&   gap_u_df)+longrad_g*gap_u_df)*(1.-gap_o_df)
  netlongrad_g = emissivity_g*((longrad_air*gap_o_df+longrad_o*(1.-&
&   gap_o_df))*gap_u_df+longrad_u*(1.-gap_u_df)) - longrad_g + (1.-&
&   emissivity_u)*longrad_g*(1.-gap_u_df)
!total net radiation for overstorey/understorey/ground
  netrad_o = netshortrad_o + netlongrad_o
  netrad_u = netshortrad_u + netlongrad_u
  netrad_g = netshortrad_g + netlongrad_g
!leaf level net radiation updated way
! reference Chen2012 clumping index paper
  IF (shortrad_global .GT. zero .AND. coszs .GT. zero) THEN
    shortradleaf_o_dir = 0.5*shortrad_dir/coszs
    IF (shortradleaf_o_dir .GT. 0.7*1362.) THEN
      shortradleaf_o_dir = 0.7*1362.
    ELSE
      shortradleaf_o_dir = shortradleaf_o_dir
    END IF
    shortradleaf_u_dir = shortradleaf_o_dir
    shortradleaf_o_df = (shortrad_df-shortrad_df*gap_os_df)/lai_os + &
&     0.07*shortrad_dir*(1.1-0.1*lai_os)*EXP(-coszs)
    shortradleaf_u_df = (shortrad_df*gap_o_df-shortrad_df*gap_o_df*&
&     gap_us_df)/lai_us + 0.05*shortrad_dir*gap_o_dir*(1.1-0.1*lai_us)*&
&     EXP(-coszs)
  ELSE
    shortradleaf_o_dir = 0.
    shortradleaf_u_dir = 0.
    shortradleaf_o_df = 0.
    shortradleaf_u_df = 0.
  END IF
!overstorey sunlit leaves
  IF (lai_o_sunlit .GT. 0.) THEN
    netshortradleaf_o_sunlit = (shortradleaf_o_dir+shortradleaf_o_df)*(&
&     1.-albedo_o)
!leaf level net long
    netlongradleaf_o_sunlit = netlongrad_o/lai_os
    netradleaf_o_sunlit = netshortradleaf_o_sunlit + &
&     netlongradleaf_o_sunlit
  ELSE
    netshortradleaf_o_sunlit = (shortradleaf_o_dir+shortradleaf_o_df)*(&
&     1.-albedo_o)
    netlongradleaf_o_sunlit = netlongrad_o
    netradleaf_o_sunlit = netshortradleaf_o_sunlit + &
&     netlongradleaf_o_sunlit
  END IF
!overstorey shaded leaves
  IF (lai_o_shaded .GT. 0.) THEN
    netshortradleaf_o_shaded = shortradleaf_o_df*(1.-albedo_o)
    netlongradleaf_o_shaded = netlongrad_o/lai_os
    netradleaf_o_shaded = netshortradleaf_o_shaded + &
&     netlongradleaf_o_shaded
  ELSE
    netshortradleaf_o_shaded = shortradleaf_o_df*(1.-albedo_o)
    netlongradleaf_o_shaded = netlongrad_o
    netradleaf_o_shaded = netshortradleaf_o_shaded + &
&     netlongradleaf_o_shaded
  END IF
!understorey sunlit leaf
  IF (lai_u_sunlit .GT. 0.) THEN
    netshortradleaf_u_sunlit = (shortradleaf_u_dir+shortradleaf_u_df)*(&
&     1.-albedo_u)
    netlongradleaf_u_sunlit = netlongrad_u/lai_us
    netradleaf_u_sunlit = netshortradleaf_u_sunlit + &
&     netlongradleaf_u_sunlit
  ELSE
    netshortradleaf_u_sunlit = (shortradleaf_u_dir+shortradleaf_u_df)*(&
&     1.-albedo_u)
    netlongradleaf_u_sunlit = netlongrad_u
    netradleaf_u_sunlit = netshortradleaf_u_sunlit + &
&     netlongradleaf_u_sunlit
  END IF
!understorey shaded leaf
  IF (lai_u_shaded .GT. 0.) THEN
    netshortradleaf_u_shaded = shortradleaf_u_df*(1.-albedo_u)
    netlongradleaf_u_shaded = netlongrad_u/lai_us
    netradleaf_u_shaded = netshortradleaf_u_shaded + &
&     netlongradleaf_u_shaded
  ELSE
    netshortradleaf_u_shaded = shortradleaf_u_df*(1.-albedo_u)
    netlongradleaf_u_shaded = netlongrad_u
    netradleaf_u_shaded = netshortradleaf_u_shaded + &
&     netlongradleaf_u_shaded
  END IF
END SUBROUTINE NETRADIATION_CD

! this module will calculate sensible heat from overstorey,understorey, and ground editted by XZ Luo, May23,2015
! inputs: 
! temperature of sunlit and shaded leaves from other storey (leaf temperature module)
! temperature of air,relative humidity
! temperature of ground (soil heat flux module)
! aerodynamic heat conductance of sunlit shaded leaves from over/understorey
! aerodynamic heat conductance of ground
! lAI sunlit and shaded, over/understorey (LAI module)
! Outputs:
! sensible heat from over/understorey and ground
SUBROUTINE SENSIBLEHEAT_CD(templ_o_sunlit, templ_o_shaded, &
& templ_u_sunlit, templ_u_shaded, temp_g, temp_air, rh_air, &
& gheat_o_sunlit, gheat_o_shaded, gheat_u_sunlit, gheat_u_shaded, &
& gheat_g, lai_o_sunlit, lai_o_shaded, lai_u_sunlit, lai_u_shaded, sh_o&
& , sh_u, sh_g)
  USE METEOMOD_DIFF
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  IMPLICIT NONE
  REAL(r8), INTENT(IN) :: templ_o_sunlit, templ_o_shaded, templ_u_sunlit&
& , templ_u_shaded, temp_g, temp_air, rh_air
  REAL(r8), INTENT(IN) :: gheat_o_sunlit, gheat_o_shaded, gheat_u_sunlit&
& , gheat_u_shaded, gheat_g
  REAL(r8), INTENT(IN) :: lai_o_sunlit, lai_o_shaded, lai_u_sunlit, &
& lai_u_shaded
  REAL(r8), INTENT(OUT) :: sh_o, sh_u, sh_g
  REAL(r8) :: sh_o_sunlit, sh_o_shaded, sh_u_sunlit, sh_u_shaded
  INTRINSIC MAX
  CALL METEO_PACK(temp_air, rh_air)
  sh_o_sunlit = (templ_o_sunlit-temp_air)*density_air*cp_air*&
&   gheat_o_sunlit
  sh_o_shaded = (templ_o_shaded-temp_air)*density_air*cp_air*&
&   gheat_o_shaded
  sh_u_sunlit = (templ_u_sunlit-temp_air)*density_air*cp_air*&
&   gheat_u_sunlit
  sh_u_shaded = (templ_u_shaded-temp_air)*density_air*cp_air*&
&   gheat_u_shaded
  sh_o = sh_o_sunlit*lai_o_sunlit + sh_o_shaded*lai_o_shaded
  sh_u = sh_u_sunlit*lai_u_sunlit + sh_u_shaded*lai_u_shaded
  IF (-200. .LT. sh_o) THEN
    sh_o = sh_o
  ELSE
    sh_o = -200.
  END IF
  IF (-200. .LT. sh_u) THEN
    sh_u = sh_u
  ELSE
    sh_u = -200.
  END IF
  sh_g = (temp_g-temp_air)*density_air*cp_air*gheat_g
  RETURN
END SUBROUTINE SENSIBLEHEAT_CD

!!*******************************************
!! This module is used to get/put soilp data at single point
!! from global datasets
!! flag =0: get from ; flag=1: put into
!! Created by J.Wang
!!*******************************************
SUBROUTINE RETRIVE_SOILP_CD(soilp, i, j, flag)
  USE BEPSTYPE_DIFF
  USE BEPS_SOILMOD_DIFF
  IMPLICIT NONE
  TYPE(SOIL) :: soilp
  INTEGER :: i, j, flag
  TYPE(SOILS), POINTER :: p
  INTERFACE 
      SUBROUTINE ENDRUN(msg)
        IMPLICIT NONE
        CHARACTER(len=*), INTENT(IN), OPTIONAL :: msg
      END SUBROUTINE ENDRUN
  END INTERFACE

  p => soilstat
  IF (i .GT. npoints .OR. j .GT. pft) CALL ENDRUN(&
&                           'out of the range of spatial points or PFTs'&
&                                          )
  IF (flag .EQ. 0) THEN
! getting data
    soilp%n_layer = p%n_layer(i)
    soilp%zp = p%zp(i, j)
    soilp%zsp = p%zsp(i, j)
    soilp%r_rain_g = p%r_rain_g(i, j)
    soilp%r_drainage = p%r_drainage(i, j)
    soilp%r_root_decay = p%r_root_decay(i, j)
    soilp%psi_min = p%psi_min(i, j)
    soilp%alpha = p%alpha(i, j)
    soilp%f_soilwater = p%f_soilwater(i, j)
    soilp%d_soil(:) = p%d_soil(i, :)
    soilp%f_root(:) = p%f_root(i, :, j)
    soilp%dt(:) = p%dt(i, :, j)
    soilp%thermal_cond(:) = p%thermal_cond(i, :, j)
    soilp%theta_vfc(:) = p%theta_vfc(i, :, j)
    soilp%theta_vwp(:) = p%theta_vwp(i, :, j)
    soilp%fei(:) = p%fei(i, :, j)
    soilp%ksat(:) = p%ksat(i, :, j)
    soilp%psi_sat(:) = p%psi_sat(i, :, j)
    soilp%b(:) = p%b(i, :, j)
    soilp%density_soil(:) = p%density_soil(i, :)
    soilp%f_org(:) = p%f_org(i, :, j)
    soilp%ice_ratio(:) = p%ice_ratio(i, :, j)
    soilp%thetam(:) = p%thetam(i, :, j)
    soilp%thetam_prev(:) = p%thetam_prev(i, :, j)
    soilp%temp_soil_p(:) = p%temp_soil_p(i, :, j)
    soilp%temp_soil_c(:) = p%temp_soil_c(i, :, j)
    soilp%f_ice(:) = p%f_ice(i, :, j)
    soilp%psim(:) = p%psim(i, :, j)
    soilp%thetab(:) = p%thetab(i, :, j)
    soilp%psib(:) = p%psib(i, :, j)
    soilp%r_waterflow(:) = p%r_waterflow(i, :, j)
    soilp%km(:) = p%km(i, :, j)
    soilp%kb(:) = p%kb(i, :, j)
    soilp%kk(:) = p%kk(i, :, j)
    soilp%cs(:) = p%cs(i, :, j)
    soilp%lambda(:) = p%lambda(i, :, j)
    soilp%ett(:) = p%ett(i, :, j)
    soilp%g(:) = p%g(i, :, j)
  ELSE IF (flag .EQ. 1) THEN
!! storing data
    p%n_layer(i) = soilp%n_layer
    p%zp(i, j) = soilp%zp
    p%zsp(i, j) = soilp%zsp
    p%r_rain_g(i, j) = soilp%r_rain_g
    p%r_drainage(i, j) = soilp%r_drainage
    p%r_root_decay(i, j) = soilp%r_root_decay
    p%psi_min(i, j) = soilp%psi_min
    p%alpha(i, j) = soilp%alpha
    p%f_soilwater(i, j) = soilp%f_soilwater
    p%d_soil(i, :) = soilp%d_soil(:)
    p%f_root(i, :, j) = soilp%f_root(:)
    p%dt(i, :, j) = soilp%dt(:)
    p%thermal_cond(i, :, j) = soilp%thermal_cond(:)
    p%theta_vfc(i, :, j) = soilp%theta_vfc(:)
    p%theta_vwp(i, :, j) = soilp%theta_vwp(:)
    p%fei(i, :, j) = soilp%fei(:)
    p%ksat(i, :, j) = soilp%ksat(:)
    p%psi_sat(i, :, j) = soilp%psi_sat(:)
    p%b(i, :, j) = soilp%b(:)
    p%density_soil(i, :) = soilp%density_soil(:)
    p%f_org(i, :, j) = soilp%f_org(:)
    p%ice_ratio(i, :, j) = soilp%ice_ratio(:)
    p%thetam(i, :, j) = soilp%thetam(:)
    p%thetam_prev(i, :, j) = soilp%thetam_prev(:)
    p%temp_soil_p(i, :, j) = soilp%temp_soil_p(:)
    p%temp_soil_c(i, :, j) = soilp%temp_soil_c(:)
    p%f_ice(i, :, j) = soilp%f_ice(:)
    p%psim(i, :, j) = soilp%psim(:)
    p%thetab(i, :, j) = soilp%thetab(:)
    p%psib(i, :, j) = soilp%psib(:)
    p%r_waterflow(i, :, j) = soilp%r_waterflow(:)
    p%km(i, :, j) = soilp%km(:)
    p%kb(i, :, j) = soilp%kb(:)
    p%kk(i, :, j) = soilp%kk(:)
    p%cs(i, :, j) = soilp%cs(:)
    p%lambda(i, :, j) = soilp%lambda(:)
    p%ett(i, :, j) = soilp%ett(:)
    p%g(i, :, j) = soilp%g(:)
  END IF
END SUBROUTINE RETRIVE_SOILP_CD

!***********************************************************
!     x2beps
!
!> @brief maps one-dimensional (normalised) control vector
!>        to the respective physical BEPS parameter(s)
!>
!> @param[in]   n   length of control vector
!> @param[in]   x   control vector (in normalised units)
!
!> \authors Michael Vossbeck, The Inversion Lab
!> \date    February 2020
!>
SUBROUTINE X2BEPS_CD(n, x)
  USE MO_PRIOR
  USE BEPSTYPE_DIFF, ONLY : assim
  USE BEPS_PAR, ONLY : pft, texture
  IMPLICIT NONE
!-- iLab::CHANGED 06/2022: D0,TAWEFF not required since VOD is not assimilated
! !-- agb2vod
! !   (...)
! i1 = i1+1
! assim%p_agb2vod = xphys(i1)
! arguments
  INTEGER, INTENT(IN) :: n
  REAL(kind=8), INTENT(IN) :: x(n)
! local declarations
  REAL(kind=8) :: xphys(n)
  INTEGER :: i1, i2
!-- convert to phyiscal units
  xphys = x*x_sigma
!-- Vcmax
!   (for the 'Vcmax' parameter)
  i1 = 1
  i2 = i1 + pft - 1
  assim%p_vcmax = xphys(i1:i2)
!-- VJ_slope
!   (...)
  i1 = i2 + 1
  i2 = i1 + pft - 1
  assim%p_vj_slope = xphys(i1:i2)
!-- Q10
!   (parameter to adjust 'q10' in calculation plant respiration)
  i1 = i2 + 1
  i2 = i1 + pft - 1
  assim%p_q10 = xphys(i1:i2)
!-- SIF alpha
!   (...)
  i1 = i2 + 1
  i2 = i1 + pft - 1
  assim%p_sif_alpha = xphys(i1:i2)
!-- SIF beta
!   (...)
  i1 = i2 + 1
  i2 = i1 + pft - 1
  assim%p_sif_beta = xphys(i1:i2)
!-- iLab::CHANGED 06/2022: D0,TAWEFF not required since VOD is not assimilated
! !-- D0
! !   (...)
! i1 = i2+1
! i2 = i1+PFT-1
! assim%p_D0     = xphys(i1:i2)
! !-- taueff
! !   (...)
! i1 = i2+1
! i2 = i1+PFT-1
! assim%p_taweff = xphys(i1:i2)
!-- Ksat
!   (parameter to adjust 'Ksat', the saturated hydraulic conductivity, in beps_soilMod.F90)
  i1 = i2 + 1
  i2 = i1 + texture - 1
  assim%p_ksat_scalar = xphys(i1:i2)
!-- b
!   (parameter to adjust 'b', the parameters for calculating soil water characteristic, in beps_soilMode.F90)
  i1 = i2 + 1
  i2 = i1 + texture - 1
  assim%p_b_scalar = xphys(i1:i2)
!-- f_leaf
!   (...)
  i1 = i2 + 1
  assim%p_f_leaf = xphys(i1)
!-- kc25
!   (...)
  i1 = i1 + 1
  assim%p_kc25 = xphys(i1)
!-- ko25
!   (...)
  i1 = i1 + 1
  assim%p_ko25 = xphys(i1)
!-- tau25
!   (...)
  i1 = i1 + 1
  assim%p_tau25 = xphys(i1)
END SUBROUTINE X2BEPS_CD

!  Differentiation of devprior in reverse (adjoint) mode (with options noISIZE r8):
!   gradient     of useful results: priordiff
!   with respect to varying inputs: x
!       simple function
!       iLab
SUBROUTINE DEVPRIOR_BW(n, x, x_bw, priordiff, priordiff_bw)
  IMPLICIT NONE
! arguments
  INTEGER(kind=4), INTENT(IN) :: n
  REAL(kind=8), INTENT(IN) :: x(n)
  REAL(kind=8) :: x_bw(n)
  REAL(kind=8) :: priordiff(n)
  REAL(kind=8) :: priordiff_bw(n)
! local
  REAL(kind=8) :: sx(n), x0(n)
  LOGICAL :: mask(n)
! get prior
  CALL GETPRIOR(n, x0, sx, mask)
! x and x0 already normalised by sx
  WHERE (.NOT.mask) priordiff_bw = 0.0_8
  x_bw = 0.0_8
  WHERE (mask) x_bw = priordiff_bw
END SUBROUTINE DEVPRIOR_BW

SUBROUTINE INITF_BW(n, m)
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE CONTROLINPUT_MOD_DIFF
  USE BEPS_TIME_MANAGER, ONLY : set_timemgr_init, timemgr_init, &
& get_curr_date, advance_timestep, is_last_step, get_doys, &
& get_curr_calday, get_nstep, get_start_date, timemgr_diff_secs
  USE BEPSTYPE_DIFF
  USE BEPSTYPEINIT_DIFF
  USE RESTART_DIFF
  USE ESMF, ONLY : esmf_initialize
  USE MO_BEPSFUNC_CTL
  IMPLICIT NONE
!- arguments
  INTEGER, INTENT(OUT) :: n, m
!-local variables
  CHARACTER(len=*), PARAMETER :: sub='initf_bw::'
  LOGICAL :: ldebug
  CHARACTER(len=32) :: fmt
  INTRINSIC TRIM
  EXTERNAL NCREADOBS
  CHARACTER(len=4) :: result1
!-- init
  ldebug = .false.
  n = -1
  m = -1
!! setting up MPI enviroments with the namelists
!   call Initmpi()
  CALL RDNAMELIST()
  IF (nscale .EQ. 1) THEN
    nlp = n_site
    npoints = nlp
    WRITE(*, '(a,2(a,i3,1x))') ' INFO::'//sub, 'nlp=', nlp, 'npoints=', &
&   npoints
    WRITE(*, *) 'site points check', npoints
  END IF
!! Initialize the beps types
  CALL INITBEPSTYPE_BW()
!! Initialize output
  CALL INIT_OUTPUT()
!--------------------------------------------------------------------------
! Initialize ESMF.  This is done outside of the ESMF_INTERFACE ifdef
! because it is needed for the time manager, even if the ESMF_INTERFACE
! is not used.
!--------------------------------------------------------------------------
  CALL ESMF_INITIALIZE()
!! setting time manager
  IF (nsrest .EQ. nsrstartup) THEN
!!! calling time_manager set init
    CALL SET_TIMEMGR_INIT(calendar_in=calendar, start_ymd_in=icdate, &
&                   start_tod_in=icsec, nelapse_in=sim_duration, &
&                   dtime_in=step)
  ELSE IF (nsrest .EQ. nsrcontinue) THEN
    CALL RESTART_IO('read')
    CALL SET_TIMEMGR_INIT(calendar_in=calendar, start_ymd_in=rst_icdate&
&                   , start_tod_in=rst_icsec, nelapse_in=sim_duration, &
&                   dtime_in=step)
  END IF
  CALL TIMEMGR_INIT()
  IF (nscale .EQ. 0) THEN
! nscale = 0 for global simulation, 1 for site simulation
    WRITE(*, '(a)') ' INFO::'//sub//'BEPS run at global scale!'
!! Reading boundary fields, yearly data,and soil Cpools for BEPS @J.Wang (note: if yearly and C pools data fields will change yea
!r by year, these datasets should be read in the time looping
    CALL READ_BOUNDARY()
    CALL READ_YRDATA()
    CALL READ_CPOOLS()
  ELSE
    WRITE(*, '(a)') ' INFO::'//sub//&
&   'BEPS run at site / multiple-point scale!'
! read site data, including yrdata, boundary data, and carbon pools
    CALL READ_BOUNDARY_SITE()
  END IF
!-- get number of time steps
  CALL BEPS_TIME_SETUP(ntp)
!-- iLab::we do have 'nsimvar' simulated variables,
!         'ntp' timesteps and 'nlp' land points (i.e. sites)
!         toplevel function 'bepsf_timesum' (see bepsfunc.F90) build temporal sum over
!         variables:
  m = ntp*nlp*nsimvar
!
  result1 = IFMT(ntp)
  fmt = '(a,'//TRIM(result1)//')'
  WRITE(*, fmt) ' INFO::'//sub//' ntp=', ntp
  result1 = IFMT(nlp)
  fmt = '(a,'//TRIM(result1)//')'
  WRITE(*, fmt) ' INFO::'//sub//' nlp=', nlp
  result1 = IFMT(nsimvar)
  fmt = '(a,'//TRIM(result1)//')'
  WRITE(*, fmt) ' INFO::'//sub//' nsimvar=', nsimvar
  result1 = IFMT(m)
  fmt = '(a,1(a,'//TRIM(result1)//'),a)'
  WRITE(*, fmt) ' INFO::'//sub//' ...dependents DONE. (', 'm=', m, ')'
!MOUSONG WU,2020-09-21
! 1. the parameters to be optimized have been modified, thes parameters include p_Ksat,p_b,these two are soil texture differentia
!ted, in total 2*11,
! p_Vcmax,p_VJ_slope,sif_alpha,sif_beta,p_q10,p_D0,p_taueff, these are PFT differentiated, in total 7*9
! p_f_leaf,p_kc25,p_ko25,p_tau25,p_agbvod, in total 5*1
! Totally, 90 parameters are optimized in this new version. In practice, when we only focus on carbon fluxes, there might not be 
!so many parameters to be optimized, for example,
! the parameters related to SIF, VOD will not be optimized. this means that we have a maximum of 90 parameters to be optimized in
! this model.
! these parameters have been assigned with prior values and uncertainties.
!-- iLab::**7** PFT differentiated parameter (Vcmax,VJ_slope,Q10,sif_alpha,sif_beta,D0,taueff)
!         **2** texture differentiated parameter (Ksat, b)
!         **5** global parameter (f_leaf,kc25,ko25,tau25,agb2vod)
!-- CHANGED 06/2022: since VOD will not be assimilated, we can skip the respective parameters
!                    D0, taueff, agb2vod
!-- iLab::**5** PFT differentiated parameter (Vcmax,VJ_slope,Q10,sif_alpha,sif_beta)
!         **2** texture differentiated parameter (Ksat, b)
!         **4** global parameter (f_leaf,kc25,ko25,tau25)
  WRITE(*, '(a)') ' INFO::'//sub//&
& ' start determining number of parameter...'
  n = 5*pft + 2*texture + 4
!
  result1 = IFMT(n)
  fmt = '(a,1(a,'//TRIM(result1)//'),a)'
  WRITE(*, fmt) ' INFO::'//sub//' ...parameter DONE. (', 'n=', n, ')'
  CALL NCREADOBS(m, 'obs.nc')

CONTAINS
  FUNCTION IFMT(n) RESULT (fmt)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: n
    CHARACTER(len=4) :: fmt
    IF (n .LT. 10) THEN
      fmt = 'i1'
    ELSE IF (n .LT. 100) THEN
      fmt = 'i2'
    ELSE IF (n .LT. 1000) THEN
      fmt = 'i3'
    ELSE IF (n .LT. 10000) THEN
      fmt = 'i4'
    ELSE IF (n .LT. 100000) THEN
      fmt = 'i5'
    ELSE IF (n .LT. 1000000) THEN
      fmt = 'i6'
    ELSE IF (n .LT. 10000000) THEN
      fmt = 'i7'
    ELSE
      fmt = 'i15'
    END IF
  END FUNCTION IFMT

  SUBROUTINE BEPS_TIME_SETUP(nt)
    IMPLICIT NONE
! local declarations
    INTEGER, INTENT(OUT) :: nt
    INTEGER :: yr, mn, dy, tod
    INTEGER :: yr_ref, mn_ref, dy_ref, tod_ref
    INTEGER, ALLOCATABLE :: ymds(:, :)
    INTEGER :: it
    INTEGER :: caldy, doys, kount
    CHARACTER(len=*), PARAMETER :: sub='beps_time_setup'
!-- set timer to startup (very likely not necessary here)
    CALL TIMEMGR_INIT()
    IF (ldebug) OPEN(1, file='beps_times_1.asc', form='formatted', &
&              action='write') 
!-- take the first
!-- determine number of time-steps
    nt = 0
!! end time loop
timeloop:DO 
      nt = nt + 1
      CALL GET_CURR_DATE(yr, mn, dy, tod)
!-- take the first date as reference time/date
      IF (nt .EQ. 1) THEN
        IF (tod .NE. 0) THEN
          WRITE(*, '(1x,a)') 'FATAL::'//sub//&
&         'tod was expected to be zero for reference date!'
          STOP
        ELSE
          yr_ref = yr
          mn_ref = mn
          dy_ref = dy
          tod_ref = tod
          WRITE(ref_date(1:4), '(i4.4)') yr_ref
          WRITE(ref_date(5:5), '(a)') '-'
          WRITE(ref_date(6:7), '(i2.2)') mn_ref
          WRITE(ref_date(8:8), '(a)') '-'
          WRITE(ref_date(9:10), '(i2.2)') dy_ref
          WRITE(ref_date(11:19), '(a)') 'T00:00:00'
        END IF
      END IF
      IF (ldebug) THEN
        caldy = GET_CURR_CALDAY()
        doys = GET_DOYS(yr)
        kount = GET_NSTEP()
        WRITE(1, '(a,i3,1x,a,i4,1x,2(a,i2,1x),a,i5,1x,2(a,i3,1x),a,i3)')&
&       'nt=', nt, 'yr=', yr, 'mn=', mn, 'dy=', dy, 'tod=', tod, &
&       'caldy=', caldy, 'doys=', doys, 'kount=', kount
      END IF
!! advance time
      CALL ADVANCE_TIMESTEP()
      IF (IS_LAST_STEP()) THEN
        IF (ldebug) CLOSE(1) 
!-- allocate time-point array
!   NOTE:we store one time-point more for restart purpose
        ALLOCATE(time_points(6, nt+1))
        ALLOCATE(seconds_since_ref(nt))
!-- reset timer to first time-step
        CALL TIMEMGR_INIT()
        IF (ldebug) OPEN(1, file='beps_times_2.asc', form='formatted', &
&                  action='write') 
        it = 0
 ttloop:DO 
          it = it + 1
          CALL GET_CURR_DATE(yr, mn, dy, tod)
          IF (ldebug) THEN
            caldy = GET_CURR_CALDAY()
            doys = GET_DOYS(yr)
            kount = GET_NSTEP()
            WRITE(1, &
&           '(a,i3,1x,a,i4,1x,2(a,i2,1x),a,i5,1x,2(a,i3,1x),a,i3)') &
&           'nt=', it, 'yr=', yr, 'mn=', mn, 'dy=', dy, 'tod=', tod, &
&           'caldy=', caldy, 'doys=', doys, 'kount=', kount
          END IF
          time_points(1, it) = yr
          time_points(2, it) = mn
          time_points(3, it) = dy
          time_points(4, it) = tod
          time_points(5, it) = GET_CURR_CALDAY()
          time_points(6, it) = GET_DOYS(yr)
!-- seconds elapsed since reference date/time
          CALL TIMEMGR_DIFF_SECS(yr_ref*10000 + mn_ref*100 + dy_ref, &
&                          tod_ref, yr*10000 + mn*100 + dy, tod, &
&                          seconds_since_ref(it))
!! advance time
          CALL ADVANCE_TIMESTEP()
          IF (IS_LAST_STEP()) THEN
!-- save first time-point *after* simulation period (restart)
            CALL GET_CURR_DATE(yr, mn, dy, tod)
            time_points(1, it+1) = yr
            time_points(2, it+1) = mn
            time_points(3, it+1) = dy
            time_points(4, it+1) = tod
            time_points(5, it+1) = GET_CURR_CALDAY()
            time_points(6, it+1) = GET_DOYS(yr)
            IF (ldebug) CLOSE(1) 
!-- reset timer to first time-step
            CALL TIMEMGR_INIT()
            GOTO 100
          END IF
        END DO ttloop
      END IF
    END DO timeloop
 100 CONTINUE
  END SUBROUTINE BEPS_TIME_SETUP

END SUBROUTINE INITF_BW
SUBROUTINE INITF_CD(n, m)
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE CONTROLINPUT_MOD_DIFF
  USE BEPS_TIME_MANAGER, ONLY : set_timemgr_init, timemgr_init, &
& get_curr_date, advance_timestep, is_last_step, get_doys, &
& get_curr_calday, get_nstep, get_start_date, timemgr_diff_secs
  USE BEPSTYPE_DIFF
  USE BEPSTYPEINIT_DIFF
  USE RESTART_DIFF
  USE ESMF, ONLY : esmf_initialize
  USE MO_BEPSFUNC_CTL
  IMPLICIT NONE
!- arguments
  INTEGER, INTENT(OUT) :: n, m
!-local variables
  CHARACTER(len=*), PARAMETER :: sub='initf_cd::'
  LOGICAL :: ldebug
  CHARACTER(len=32) :: fmt
  INTRINSIC TRIM
  EXTERNAL NCREADOBS
  CHARACTER(len=4) :: result1
!-- init
  ldebug = .false.
  n = -1
  m = -1
!! setting up MPI enviroments with the namelists
!   call Initmpi()
  CALL RDNAMELIST()
  IF (nscale .EQ. 1) THEN
    nlp = n_site
    npoints = nlp
    WRITE(*, '(a,2(a,i3,1x))') ' INFO::'//sub, 'nlp=', nlp, 'npoints=', &
&   npoints
    WRITE(*, *) 'site points check', npoints
  END IF
!! Initialize the beps types
  CALL INITBEPSTYPE()
!! Initialize output
  CALL INIT_OUTPUT()
!--------------------------------------------------------------------------
! Initialize ESMF.  This is done outside of the ESMF_INTERFACE ifdef
! because it is needed for the time manager, even if the ESMF_INTERFACE
! is not used.
!--------------------------------------------------------------------------
  CALL ESMF_INITIALIZE()
!! setting time manager
  IF (nsrest .EQ. nsrstartup) THEN
!!! calling time_manager set init
    CALL SET_TIMEMGR_INIT(calendar_in=calendar, start_ymd_in=icdate, &
&                   start_tod_in=icsec, nelapse_in=sim_duration, &
&                   dtime_in=step)
  ELSE IF (nsrest .EQ. nsrcontinue) THEN
    CALL RESTART_IO('read')
    CALL SET_TIMEMGR_INIT(calendar_in=calendar, start_ymd_in=rst_icdate&
&                   , start_tod_in=rst_icsec, nelapse_in=sim_duration, &
&                   dtime_in=step)
  END IF
  CALL TIMEMGR_INIT()
  IF (nscale .EQ. 0) THEN
! nscale = 0 for global simulation, 1 for site simulation
    WRITE(*, '(a)') ' INFO::'//sub//'BEPS run at global scale!'
!! Reading boundary fields, yearly data,and soil Cpools for BEPS @J.Wang (note: if yearly and C pools data fields will change yea
!r by year, these datasets should be read in the time looping
    CALL READ_BOUNDARY()
    CALL READ_YRDATA()
    CALL READ_CPOOLS()
  ELSE
    WRITE(*, '(a)') ' INFO::'//sub//&
&   'BEPS run at site / multiple-point scale!'
! read site data, including yrdata, boundary data, and carbon pools
    CALL READ_BOUNDARY_SITE()
  END IF
!-- get number of time steps
  CALL BEPS_TIME_SETUP(ntp)
!-- iLab::we do have 'nsimvar' simulated variables,
!         'ntp' timesteps and 'nlp' land points (i.e. sites)
!         toplevel function 'bepsf_timesum' (see bepsfunc.F90) build temporal sum over
!         variables:
  m = ntp*nlp*nsimvar
!
  result1 = IFMT(ntp)
  fmt = '(a,'//TRIM(result1)//')'
  WRITE(*, fmt) ' INFO::'//sub//' ntp=', ntp
  result1 = IFMT(nlp)
  fmt = '(a,'//TRIM(result1)//')'
  WRITE(*, fmt) ' INFO::'//sub//' nlp=', nlp
  result1 = IFMT(nsimvar)
  fmt = '(a,'//TRIM(result1)//')'
  WRITE(*, fmt) ' INFO::'//sub//' nsimvar=', nsimvar
  result1 = IFMT(m)
  fmt = '(a,1(a,'//TRIM(result1)//'),a)'
  WRITE(*, fmt) ' INFO::'//sub//' ...dependents DONE. (', 'm=', m, ')'
!MOUSONG WU,2020-09-21
! 1. the parameters to be optimized have been modified, thes parameters include p_Ksat,p_b,these two are soil texture differentia
!ted, in total 2*11,
! p_Vcmax,p_VJ_slope,sif_alpha,sif_beta,p_q10,p_D0,p_taueff, these are PFT differentiated, in total 7*9
! p_f_leaf,p_kc25,p_ko25,p_tau25,p_agbvod, in total 5*1
! Totally, 90 parameters are optimized in this new version. In practice, when we only focus on carbon fluxes, there might not be 
!so many parameters to be optimized, for example,
! the parameters related to SIF, VOD will not be optimized. this means that we have a maximum of 90 parameters to be optimized in
! this model.
! these parameters have been assigned with prior values and uncertainties.
!-- iLab::**7** PFT differentiated parameter (Vcmax,VJ_slope,Q10,sif_alpha,sif_beta,D0,taueff)
!         **2** texture differentiated parameter (Ksat, b)
!         **5** global parameter (f_leaf,kc25,ko25,tau25,agb2vod)
!-- CHANGED 06/2022: since VOD will not be assimilated, we can skip the respective parameters
!                    D0, taueff, agb2vod
!-- iLab::**5** PFT differentiated parameter (Vcmax,VJ_slope,Q10,sif_alpha,sif_beta)
!         **2** texture differentiated parameter (Ksat, b)
!         **4** global parameter (f_leaf,kc25,ko25,tau25)
  WRITE(*, '(a)') ' INFO::'//sub//&
& ' start determining number of parameter...'
  n = 5*pft + 2*texture + 4
!
  result1 = IFMT(n)
  fmt = '(a,1(a,'//TRIM(result1)//'),a)'
  WRITE(*, fmt) ' INFO::'//sub//' ...parameter DONE. (', 'n=', n, ')'
  CALL NCREADOBS(m, 'obs.nc')

CONTAINS
  FUNCTION IFMT(n) RESULT (fmt)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: n
    CHARACTER(len=4) :: fmt
    IF (n .LT. 10) THEN
      fmt = 'i1'
    ELSE IF (n .LT. 100) THEN
      fmt = 'i2'
    ELSE IF (n .LT. 1000) THEN
      fmt = 'i3'
    ELSE IF (n .LT. 10000) THEN
      fmt = 'i4'
    ELSE IF (n .LT. 100000) THEN
      fmt = 'i5'
    ELSE IF (n .LT. 1000000) THEN
      fmt = 'i6'
    ELSE IF (n .LT. 10000000) THEN
      fmt = 'i7'
    ELSE
      fmt = 'i15'
    END IF
  END FUNCTION IFMT

  SUBROUTINE BEPS_TIME_SETUP(nt)
    IMPLICIT NONE
! local declarations
    INTEGER, INTENT(OUT) :: nt
    INTEGER :: yr, mn, dy, tod
    INTEGER :: yr_ref, mn_ref, dy_ref, tod_ref
    INTEGER, ALLOCATABLE :: ymds(:, :)
    INTEGER :: it
    INTEGER :: caldy, doys, kount
    CHARACTER(len=*), PARAMETER :: sub='beps_time_setup'
!-- set timer to startup (very likely not necessary here)
    CALL TIMEMGR_INIT()
    IF (ldebug) OPEN(1, file='beps_times_1.asc', form='formatted', &
&              action='write') 
!-- take the first
!-- determine number of time-steps
    nt = 0
!! end time loop
timeloop:DO 
      nt = nt + 1
      CALL GET_CURR_DATE(yr, mn, dy, tod)
!-- take the first date as reference time/date
      IF (nt .EQ. 1) THEN
        IF (tod .NE. 0) THEN
          WRITE(*, '(1x,a)') 'FATAL::'//sub//&
&         'tod was expected to be zero for reference date!'
          STOP
        ELSE
          yr_ref = yr
          mn_ref = mn
          dy_ref = dy
          tod_ref = tod
          WRITE(ref_date(1:4), '(i4.4)') yr_ref
          WRITE(ref_date(5:5), '(a)') '-'
          WRITE(ref_date(6:7), '(i2.2)') mn_ref
          WRITE(ref_date(8:8), '(a)') '-'
          WRITE(ref_date(9:10), '(i2.2)') dy_ref
          WRITE(ref_date(11:19), '(a)') 'T00:00:00'
        END IF
      END IF
      IF (ldebug) THEN
        caldy = GET_CURR_CALDAY()
        doys = GET_DOYS(yr)
        kount = GET_NSTEP()
        WRITE(1, '(a,i3,1x,a,i4,1x,2(a,i2,1x),a,i5,1x,2(a,i3,1x),a,i3)')&
&       'nt=', nt, 'yr=', yr, 'mn=', mn, 'dy=', dy, 'tod=', tod, &
&       'caldy=', caldy, 'doys=', doys, 'kount=', kount
      END IF
!! advance time
      CALL ADVANCE_TIMESTEP()
      IF (IS_LAST_STEP()) THEN
        IF (ldebug) CLOSE(1) 
!-- allocate time-point array
!   NOTE:we store one time-point more for restart purpose
        ALLOCATE(time_points(6, nt+1))
        ALLOCATE(seconds_since_ref(nt))
!-- reset timer to first time-step
        CALL TIMEMGR_INIT()
        IF (ldebug) OPEN(1, file='beps_times_2.asc', form='formatted', &
&                  action='write') 
        it = 0
 ttloop:DO 
          it = it + 1
          CALL GET_CURR_DATE(yr, mn, dy, tod)
          IF (ldebug) THEN
            caldy = GET_CURR_CALDAY()
            doys = GET_DOYS(yr)
            kount = GET_NSTEP()
            WRITE(1, &
&           '(a,i3,1x,a,i4,1x,2(a,i2,1x),a,i5,1x,2(a,i3,1x),a,i3)') &
&           'nt=', it, 'yr=', yr, 'mn=', mn, 'dy=', dy, 'tod=', tod, &
&           'caldy=', caldy, 'doys=', doys, 'kount=', kount
          END IF
          time_points(1, it) = yr
          time_points(2, it) = mn
          time_points(3, it) = dy
          time_points(4, it) = tod
          time_points(5, it) = GET_CURR_CALDAY()
          time_points(6, it) = GET_DOYS(yr)
!-- seconds elapsed since reference date/time
          CALL TIMEMGR_DIFF_SECS(yr_ref*10000 + mn_ref*100 + dy_ref, &
&                          tod_ref, yr*10000 + mn*100 + dy, tod, &
&                          seconds_since_ref(it))
!! advance time
          CALL ADVANCE_TIMESTEP()
          IF (IS_LAST_STEP()) THEN
!-- save first time-point *after* simulation period (restart)
            CALL GET_CURR_DATE(yr, mn, dy, tod)
            time_points(1, it+1) = yr
            time_points(2, it+1) = mn
            time_points(3, it+1) = dy
            time_points(4, it+1) = tod
            time_points(5, it+1) = GET_CURR_CALDAY()
            time_points(6, it+1) = GET_DOYS(yr)
            IF (ldebug) CLOSE(1) 
!-- reset timer to first time-step
            CALL TIMEMGR_INIT()
            GOTO 100
          END IF
        END DO ttloop
      END IF
    END DO timeloop
 100 CONTINUE
  END SUBROUTINE BEPS_TIME_SETUP

END SUBROUTINE INITF_CD
SUBROUTINE INITX_CD(n, x, sx)
  USE MO_PRIOR
  USE BEPSTYPE_DIFF, ONLY : assim
  USE BEPS_PAR, ONLY : pft, texture
  USE CONTROLINPUT_MOD_DIFF, ONLY : read_prior_para
  IMPLICIT NONE
! arguments
  INTEGER, INTENT(IN) :: n
  REAL(kind=8), INTENT(OUT) :: x(n), sx(n)
! local variables
  REAL(kind=8) :: xphys(n)
  INTEGER :: i1, i2, ii
  CHARACTER(len=2) :: str2
  INTRINSIC TRIM
!-- allocate prior module
  ALLOCATE(x_pr(n))
  ALLOCATE(x_sigma(n))
  ALLOCATE(x_mask(n))
  ALLOCATE(x_prname(n))
! put the parameters to be optimized in a NETCDF
  CALL READ_PRIOR_PARA()
!file and read them as well their
!uncertainties,@MOUSONG.WU,2019-11
!-- assign/mapping
!-- Vcmax
  i1 = 1
  i2 = i1 + pft - 1
  xphys(i1:i2) = assim%p_vcmax
  x_sigma(i1:i2) = assim%u_vcmax
  DO ii=i1,i2
    WRITE(str2, '(i2.2)') ii - i1 + 1
    x_prname(ii) = 'Vcmax_PFT'//str2
  END DO
!-- VJ_slope
  i1 = i2 + 1
  i2 = i1 + pft - 1
  xphys(i1:i2) = assim%p_vj_slope
  x_sigma(i1:i2) = assim%u_vj_slope
  DO ii=i1,i2
    WRITE(str2, '(i2.2)') ii - i1 + 1
    x_prname(ii) = 'VJ_slope_PFT'//str2
  END DO
!-- Q10
!   (parameter to adjust 'q10' in calculation plant respiration)
  i1 = i2 + 1
  i2 = i1 + pft - 1
  xphys(i1:i2) = assim%p_q10
  x_sigma(i1:i2) = assim%u_q10
  DO ii=i1,i2
    WRITE(str2, '(i2.2)') ii - i1 + 1
    x_prname(ii) = 'Q10_PFT'//str2
  END DO
!-- sif_alpha
!   (...)
  i1 = i2 + 1
  i2 = i1 + pft - 1
  xphys(i1:i2) = assim%p_sif_alpha
  x_sigma(i1:i2) = assim%u_sif_alpha
  DO ii=i1,i2
    WRITE(str2, '(i2.2)') ii - i1 + 1
    x_prname(ii) = 'sif_alpha_PFT'//str2
  END DO
!-- sif_beta
!   (...)
  i1 = i2 + 1
  i2 = i1 + pft - 1
  xphys(i1:i2) = assim%p_sif_beta
  x_sigma(i1:i2) = assim%u_sif_beta
  DO ii=i1,i2
    WRITE(str2, '(i2.2)') ii - i1 + 1
    x_prname(ii) = 'sif_beta_PFT'//str2
  END DO
!-- iLab::CHANGED 06/2022: D0,TAWEFF not required since VOD is not assimilated
! !-- D0
! !   (...)
! i1 = i2+1
! i2 = i1+PFT-1
! xphys(i1:i2)   = assim%p_D0
! x_sigma(i1:i2) = assim%u_D0
! do ii=i1,i2
!    write(str2, '(i2.2)') ii-i1+1
!    x_prname(ii) = 'D0_PFT'//str2
! enddo
! !-- TAWEFF
! !   (...)
! i1 = i2+1
! i2 = i1+PFT-1
! xphys(i1:i2)   = assim%p_taweff
! x_sigma(i1:i2) = assim%u_taweff
! do ii=i1,i2
!    write(str2, '(i2.2)') ii-i1+1
!    x_prname(ii) = 'taweff_PFT'//str2
! enddo
!-- Ksat
!   (parameter to adjust 'Ksat', the saturated hydraulic conductivity, in beps_soilMod.F90)
  i1 = i2 + 1
  i2 = i1 + texture - 1
  xphys(i1:i2) = assim%p_ksat_scalar
  x_sigma(i1:i2) = assim%u_ksat_scalar
  DO ii=i1,i2
    WRITE(str2, '(i2.2)') ii - i1 + 1
    x_prname(ii) = 'Ksat_Txt'//str2
  END DO
!-- u
!   (parameter to adjust 'b', the parameters for calculating soil water characteristic, in beps_soilMode.F90)
  i1 = i2 + 1
  i2 = i1 + texture - 1
  xphys(i1:i2) = assim%p_b_scalar
  x_sigma(i1:i2) = assim%u_b_scalar
  DO ii=i1,i2
    WRITE(str2, '(i2.2)') ii - i1 + 1
    x_prname(ii) = 'b_Txt'//str2
  END DO
!-- f_leaf
  i1 = i2 + 1
  xphys(i1) = assim%p_f_leaf
  x_sigma(i1) = assim%u_f_leaf
  x_prname(i1) = 'f_leaf'
!-- kc25
  i1 = i1 + 1
  xphys(i1) = assim%p_kc25
  x_sigma(i1) = assim%u_kc25
  x_prname(i1) = 'kc25'
!-- ko25
  i1 = i1 + 1
  xphys(i1) = assim%p_ko25
  x_sigma(i1) = assim%u_ko25
  x_prname(i1) = 'ko25'
!-- tau25
  i1 = i1 + 1
  xphys(i1) = assim%p_tau25
  x_sigma(i1) = assim%u_tau25
  x_prname(i1) = 'tau25'
!-- iLab::CHANGED 06/2022: D0,TAWEFF not required since VOD is not assimilated
! !-- agb2vod
! i1 = i1+1
! xphys(i1)    = assim%p_agb2vod
! x_sigma(i1)  = assim%u_agb2vod
! x_prname(i1) = 'agb2vod'
!-- save normalised prior module
  x_pr = xphys/x_sigma
!-- by default deviation from prior is activated
  x_mask = .true.
!-- assign to output arguments
  x = x_pr
  sx = x_sigma
!-- write list of parameter names (to ease consistency of post-processing)
  OPEN(18, file='ctlvec_scaled.txt', form='formatted') 
  WRITE(str2, '(i2.2)') pft
  WRITE(18, '(a)') '#npft='//str2
  WRITE(str2, '(i2.2)') texture
  WRITE(18, '(a)') '#ntexture='//str2
  WRITE(18, '(a,a31,a20,a20)') '#', 'name', 'scaled prior', &
& 'prior uncertainty'
  DO ii=1,n
    WRITE(18, '(a32,e20.6,e20.6)') TRIM(x_prname(ii)), x_pr(ii), x_sigma&
&   (ii)
  END DO
  CLOSE(18) 
END SUBROUTINE INITX_CD
SUBROUTINE GET_NMETEO_CD(yr, mn, dy, tod, n_meteo)
  USE SHR_KIND_MOD, ONLY : r8 => shr_kind_r8
  USE BEPS_TIME_MANAGER, ONLY : timemgr_diff_secs
  USE CONTROLINPUT_MOD_DIFF, ONLY : read_meteo_site_reftime
  USE BEPSTYPE_DIFF, ONLY : clim
  IMPLICIT NONE
!-- arguments
  INTEGER, INTENT(IN) :: yr, mn, dy, tod
  INTEGER, INTENT(OUT) :: n_meteo
!-- local
  REAL(r8) :: secs_meteo
  INTEGER :: metyr, metmn, metdy
  INTEGER :: iostat
  INTRINSIC INT
!-- ensure reference time of meteorological forcing is available
  CALL READ_METEO_SITE_REFTIME()
!-- get year/month/day from reference date
  CALL STR2INT(clim%meteo_ref_yyyymmdd(1:4), metyr, iostat)
  CALL STR2INT(clim%meteo_ref_yyyymmdd(6:7), metmn, iostat)
  CALL STR2INT(clim%meteo_ref_yyyymmdd(9:10), metdy, iostat)
  CALL TIMEMGR_DIFF_SECS(metyr*10000 + metmn*100 + metdy, 0, yr*10000 + &
&                  mn*100 + dy, tod, secs_meteo)
  n_meteo = INT(secs_meteo/3600 + 1)

CONTAINS
  ELEMENTAL SUBROUTINE STR2INT(str, int, iostat)
    IMPLICIT NONE
!-- arguments
    CHARACTER(len=*), INTENT(IN) :: str
    INTEGER, INTENT(OUT) :: int
    INTEGER, INTENT(OUT) :: iostat
    READ(str, *, iostat=iostat) int
  END SUBROUTINE STR2INT

END SUBROUTINE GET_NMETEO_CD
!       module to compute cost_cd function
!       ilab march 2021
subroutine cost_cd ( n, x, m, f)
  implicit none
  ! arguments
  integer(kind=4), intent(in) :: n, m
  real(kind=8), intent(in) :: x(n)
  real(kind=8), intent(out) :: f
  ! local
  real(kind=8) :: obsdiff(m), priordiff(n)
  
  call misfit_cd(n,x,m,obsdiff)
  call devprior(n,x,priordiff)
  f = 0.5 * (sum(obsdiff**2) + sum(priordiff**2))
end subroutine cost_cd
